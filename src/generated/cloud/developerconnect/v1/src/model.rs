// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message for requesting a list of Users
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersRequest {
    /// Required. Parent value for ListUsersRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUsersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListUsersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListUsersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing Users
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersResponse {
    /// The list of Users
    pub users: std::vec::Vec<crate::model::User>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [users][crate::model::ListUsersResponse::users].
    pub fn set_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>,
    {
        use std::iter::Iterator;
        self.users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsersResponse {
    type PageItem = crate::model::User;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __users,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "users" => Ok(__FieldTag::__users),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__users => {
                            if !fields.insert(__FieldTag::__users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for users",
                                ));
                            }
                            result.users = map.next_value::<std::option::Option<std::vec::Vec<crate::model::User>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.users.is_empty() {
            state.serialize_entry("users", &self.users)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing Connection object
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Connection {
    /// Identifier. The resource name of the connection, in the format
    /// `projects/{project}/locations/{location}/connections/{connection_id}`.
    pub name: std::string::String,

    /// Output only. [Output only] Create timestamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Delete timestamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Installation state of the Connection.
    pub installation_state: std::option::Option<crate::model::InstallationState>,

    /// Optional. If disabled is set to true, functionality is disabled for this
    /// connection. Repository based API methods and webhooks processing for
    /// repositories in this connection will be disabled.
    pub disabled: bool,

    /// Output only. Set to true when the connection is being set up or updated in
    /// the background.
    pub reconciling: bool,

    /// Optional. Allows clients to store small amounts of arbitrary data.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. A system-assigned unique identifier for the Connection.
    pub uid: std::string::String,

    /// Optional. The crypto key configuration. This field is used by the
    /// Customer-Managed Encryption Keys (CMEK) feature.
    pub crypto_key_config: std::option::Option<crate::model::CryptoKeyConfig>,

    /// Optional. Configuration for the git proxy feature. Enabling the git proxy
    /// allows clients to perform git operations on the repositories linked in the
    /// connection.
    pub git_proxy_config: std::option::Option<crate::model::GitProxyConfig>,

    /// Configuration for the connection depending on the type of provider.
    pub connection_config: std::option::Option<crate::model::connection::ConnectionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Connection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Connection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Connection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Connection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Connection::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Connection::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Connection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [installation_state][crate::model::Connection::installation_state].
    pub fn set_installation_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstallationState>,
    {
        self.installation_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [installation_state][crate::model::Connection::installation_state].
    pub fn set_or_clear_installation_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstallationState>,
    {
        self.installation_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::Connection::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Connection::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Connection::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Connection::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Connection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [crypto_key_config][crate::model::Connection::crypto_key_config].
    pub fn set_crypto_key_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyConfig>,
    {
        self.crypto_key_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key_config][crate::model::Connection::crypto_key_config].
    pub fn set_or_clear_crypto_key_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyConfig>,
    {
        self.crypto_key_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_proxy_config][crate::model::Connection::git_proxy_config].
    pub fn set_git_proxy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitProxyConfig>,
    {
        self.git_proxy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_proxy_config][crate::model::Connection::git_proxy_config].
    pub fn set_or_clear_git_proxy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitProxyConfig>,
    {
        self.git_proxy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config].
    ///
    /// Note that all the setters affecting `connection_config` are mutually
    /// exclusive.
    pub fn set_connection_config<
        T: std::convert::Into<std::option::Option<crate::model::connection::ConnectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = v.into();
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GithubConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitHubConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GithubConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GithubConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_github_config<T: std::convert::Into<std::boxed::Box<crate::model::GitHubConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GithubConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_enterprise_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitHubEnterpriseConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GitHubEnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GitlabConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gitlab_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitLabConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GitlabConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GitlabConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_gitlab_config<T: std::convert::Into<std::boxed::Box<crate::model::GitLabConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GitlabConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GitlabEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gitlab_enterprise_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitLabEnterpriseConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GitlabEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GitlabEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_gitlab_enterprise_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GitLabEnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GitlabEnterpriseConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `BitbucketDataCenterConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bitbucket_data_center_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BitbucketDataCenterConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::BitbucketDataCenterConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `BitbucketDataCenterConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_bitbucket_data_center_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BitbucketDataCenterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::BitbucketDataCenterConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `BitbucketCloudConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bitbucket_cloud_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BitbucketCloudConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::BitbucketCloudConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `BitbucketCloudConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_bitbucket_cloud_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BitbucketCloudConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::BitbucketCloudConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.Connection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Connection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __github_config,
            __github_enterprise_config,
            __gitlab_config,
            __gitlab_enterprise_config,
            __bitbucket_data_center_config,
            __bitbucket_cloud_config,
            __name,
            __create_time,
            __update_time,
            __delete_time,
            __labels,
            __installation_state,
            __disabled,
            __reconciling,
            __annotations,
            __etag,
            __uid,
            __crypto_key_config,
            __git_proxy_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "githubConfig" => Ok(__FieldTag::__github_config),
                            "github_config" => Ok(__FieldTag::__github_config),
                            "githubEnterpriseConfig" => Ok(__FieldTag::__github_enterprise_config),
                            "github_enterprise_config" => {
                                Ok(__FieldTag::__github_enterprise_config)
                            }
                            "gitlabConfig" => Ok(__FieldTag::__gitlab_config),
                            "gitlab_config" => Ok(__FieldTag::__gitlab_config),
                            "gitlabEnterpriseConfig" => Ok(__FieldTag::__gitlab_enterprise_config),
                            "gitlab_enterprise_config" => {
                                Ok(__FieldTag::__gitlab_enterprise_config)
                            }
                            "bitbucketDataCenterConfig" => {
                                Ok(__FieldTag::__bitbucket_data_center_config)
                            }
                            "bitbucket_data_center_config" => {
                                Ok(__FieldTag::__bitbucket_data_center_config)
                            }
                            "bitbucketCloudConfig" => Ok(__FieldTag::__bitbucket_cloud_config),
                            "bitbucket_cloud_config" => Ok(__FieldTag::__bitbucket_cloud_config),
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "installationState" => Ok(__FieldTag::__installation_state),
                            "installation_state" => Ok(__FieldTag::__installation_state),
                            "disabled" => Ok(__FieldTag::__disabled),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "etag" => Ok(__FieldTag::__etag),
                            "uid" => Ok(__FieldTag::__uid),
                            "cryptoKeyConfig" => Ok(__FieldTag::__crypto_key_config),
                            "crypto_key_config" => Ok(__FieldTag::__crypto_key_config),
                            "gitProxyConfig" => Ok(__FieldTag::__git_proxy_config),
                            "git_proxy_config" => Ok(__FieldTag::__git_proxy_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Connection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__github_config => {
                            if !fields.insert(__FieldTag::__github_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github_config",
                                ));
                            }
                            if result.connection_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_config`, a oneof with full ID .google.cloud.developerconnect.v1.Connection.github_config, latest field was githubConfig",
                                ));
                            }
                            result.connection_config = std::option::Option::Some(
                                crate::model::connection::ConnectionConfig::GithubConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitHubConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__github_enterprise_config => {
                            if !fields.insert(__FieldTag::__github_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github_enterprise_config",
                                ));
                            }
                            if result.connection_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_config`, a oneof with full ID .google.cloud.developerconnect.v1.Connection.github_enterprise_config, latest field was githubEnterpriseConfig",
                                ));
                            }
                            result.connection_config = std::option::Option::Some(
                                crate::model::connection::ConnectionConfig::GithubEnterpriseConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitHubEnterpriseConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gitlab_config => {
                            if !fields.insert(__FieldTag::__gitlab_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gitlab_config",
                                ));
                            }
                            if result.connection_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_config`, a oneof with full ID .google.cloud.developerconnect.v1.Connection.gitlab_config, latest field was gitlabConfig",
                                ));
                            }
                            result.connection_config = std::option::Option::Some(
                                crate::model::connection::ConnectionConfig::GitlabConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitLabConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gitlab_enterprise_config => {
                            if !fields.insert(__FieldTag::__gitlab_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gitlab_enterprise_config",
                                ));
                            }
                            if result.connection_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_config`, a oneof with full ID .google.cloud.developerconnect.v1.Connection.gitlab_enterprise_config, latest field was gitlabEnterpriseConfig",
                                ));
                            }
                            result.connection_config = std::option::Option::Some(
                                crate::model::connection::ConnectionConfig::GitlabEnterpriseConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GitLabEnterpriseConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bitbucket_data_center_config => {
                            if !fields.insert(__FieldTag::__bitbucket_data_center_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bitbucket_data_center_config",
                                ));
                            }
                            if result.connection_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_config`, a oneof with full ID .google.cloud.developerconnect.v1.Connection.bitbucket_data_center_config, latest field was bitbucketDataCenterConfig",
                                ));
                            }
                            result.connection_config = std::option::Option::Some(
                                crate::model::connection::ConnectionConfig::BitbucketDataCenterConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::BitbucketDataCenterConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__bitbucket_cloud_config => {
                            if !fields.insert(__FieldTag::__bitbucket_cloud_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bitbucket_cloud_config",
                                ));
                            }
                            if result.connection_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_config`, a oneof with full ID .google.cloud.developerconnect.v1.Connection.bitbucket_cloud_config, latest field was bitbucketCloudConfig",
                                ));
                            }
                            result.connection_config = std::option::Option::Some(
                                crate::model::connection::ConnectionConfig::BitbucketCloudConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BitbucketCloudConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__installation_state => {
                            if !fields.insert(__FieldTag::__installation_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installation_state",
                                ));
                            }
                            result.installation_state = map
                                .next_value::<std::option::Option<crate::model::InstallationState>>(
                                )?;
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crypto_key_config => {
                            if !fields.insert(__FieldTag::__crypto_key_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crypto_key_config",
                                ));
                            }
                            result.crypto_key_config = map
                                .next_value::<std::option::Option<crate::model::CryptoKeyConfig>>(
                                )?;
                        }
                        __FieldTag::__git_proxy_config => {
                            if !fields.insert(__FieldTag::__git_proxy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_proxy_config",
                                ));
                            }
                            result.git_proxy_config = map
                                .next_value::<std::option::Option<crate::model::GitProxyConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Connection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.github_config() {
            state.serialize_entry("githubConfig", value)?;
        }
        if let Some(value) = self.github_enterprise_config() {
            state.serialize_entry("githubEnterpriseConfig", value)?;
        }
        if let Some(value) = self.gitlab_config() {
            state.serialize_entry("gitlabConfig", value)?;
        }
        if let Some(value) = self.gitlab_enterprise_config() {
            state.serialize_entry("gitlabEnterpriseConfig", value)?;
        }
        if let Some(value) = self.bitbucket_data_center_config() {
            state.serialize_entry("bitbucketDataCenterConfig", value)?;
        }
        if let Some(value) = self.bitbucket_cloud_config() {
            state.serialize_entry("bitbucketCloudConfig", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.installation_state.is_some() {
            state.serialize_entry("installationState", &self.installation_state)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.crypto_key_config.is_some() {
            state.serialize_entry("cryptoKeyConfig", &self.crypto_key_config)?;
        }
        if self.git_proxy_config.is_some() {
            state.serialize_entry("gitProxyConfig", &self.git_proxy_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the connection depending on the type of provider.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionConfig {
        /// Configuration for connections to github.com.
        GithubConfig(std::boxed::Box<crate::model::GitHubConfig>),
        /// Configuration for connections to an instance of GitHub Enterprise.
        GithubEnterpriseConfig(std::boxed::Box<crate::model::GitHubEnterpriseConfig>),
        /// Configuration for connections to gitlab.com.
        GitlabConfig(std::boxed::Box<crate::model::GitLabConfig>),
        /// Configuration for connections to an instance of GitLab Enterprise.
        GitlabEnterpriseConfig(std::boxed::Box<crate::model::GitLabEnterpriseConfig>),
        /// Configuration for connections to an instance of Bitbucket Data Center.
        BitbucketDataCenterConfig(std::boxed::Box<crate::model::BitbucketDataCenterConfig>),
        /// Configuration for connections to an instance of Bitbucket Clouds.
        BitbucketCloudConfig(std::boxed::Box<crate::model::BitbucketCloudConfig>),
    }
}

/// The crypto key configuration. This field is used by the Customer-managed
/// encryption keys (CMEK) feature.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CryptoKeyConfig {
    /// Required. The name of the key which is used to encrypt/decrypt customer
    /// data. For key in Cloud KMS, the key should be in the format of
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    pub key_reference: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoKeyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_reference][crate::model::CryptoKeyConfig::key_reference].
    pub fn set_key_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_reference = v.into();
        self
    }
}

impl wkt::message::Message for CryptoKeyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CryptoKeyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CryptoKeyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_reference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CryptoKeyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyReference" => Ok(__FieldTag::__key_reference),
                            "key_reference" => Ok(__FieldTag::__key_reference),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CryptoKeyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CryptoKeyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_reference => {
                            if !fields.insert(__FieldTag::__key_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_reference",
                                ));
                            }
                            result.key_reference = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CryptoKeyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_reference.is_empty() {
            state.serialize_entry("keyReference", &self.key_reference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The git proxy configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GitProxyConfig {
    /// Optional. Setting this to true allows the git proxy to be used for
    /// performing git operations on the repositories linked in the connection.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitProxyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GitProxyConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GitProxyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitProxyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitProxyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitProxyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitProxyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitProxyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitProxyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes stage and necessary actions to be taken by the
/// user to complete the installation. Used for GitHub and GitHub Enterprise
/// based connections.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstallationState {
    /// Output only. Current step of the installation process.
    pub stage: crate::model::installation_state::Stage,

    /// Output only. Message of what the user should do next to continue the
    /// installation. Empty string if the installation is already complete.
    pub message: std::string::String,

    /// Output only. Link to follow for next action. Empty string if the
    /// installation is already complete.
    pub action_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstallationState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stage][crate::model::InstallationState::stage].
    pub fn set_stage<T: std::convert::Into<crate::model::installation_state::Stage>>(
        mut self,
        v: T,
    ) -> Self {
        self.stage = v.into();
        self
    }

    /// Sets the value of [message][crate::model::InstallationState::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [action_uri][crate::model::InstallationState::action_uri].
    pub fn set_action_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_uri = v.into();
        self
    }
}

impl wkt::message::Message for InstallationState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.InstallationState"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstallationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stage,
            __message,
            __action_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstallationState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stage" => Ok(__FieldTag::__stage),
                            "message" => Ok(__FieldTag::__message),
                            "actionUri" => Ok(__FieldTag::__action_uri),
                            "action_uri" => Ok(__FieldTag::__action_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstallationState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstallationState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stage => {
                            if !fields.insert(__FieldTag::__stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stage",
                                ));
                            }
                            result.stage = map.next_value::<std::option::Option<crate::model::installation_state::Stage>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_uri => {
                            if !fields.insert(__FieldTag::__action_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_uri",
                                ));
                            }
                            result.action_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstallationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.stage) {
            state.serialize_entry("stage", &self.stage)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.action_uri.is_empty() {
            state.serialize_entry("actionUri", &self.action_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InstallationState].
pub mod installation_state {
    #[allow(unused_imports)]
    use super::*;

    /// Stage of the installation process.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Stage {
        /// No stage specified.
        Unspecified,
        /// Only for GitHub Enterprise. An App creation has been requested.
        /// The user needs to confirm the creation in their GitHub enterprise host.
        PendingCreateApp,
        /// User needs to authorize the GitHub (or Enterprise) App via OAuth.
        PendingUserOauth,
        /// User needs to follow the link to install the GitHub (or Enterprise) App.
        PendingInstallApp,
        /// Installation process has been completed.
        Complete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Stage::value] or
        /// [Stage::name].
        UnknownValue(stage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Stage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PendingCreateApp => std::option::Option::Some(1),
                Self::PendingUserOauth => std::option::Option::Some(2),
                Self::PendingInstallApp => std::option::Option::Some(3),
                Self::Complete => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STAGE_UNSPECIFIED"),
                Self::PendingCreateApp => std::option::Option::Some("PENDING_CREATE_APP"),
                Self::PendingUserOauth => std::option::Option::Some("PENDING_USER_OAUTH"),
                Self::PendingInstallApp => std::option::Option::Some("PENDING_INSTALL_APP"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Stage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Stage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Stage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PendingCreateApp,
                2 => Self::PendingUserOauth,
                3 => Self::PendingInstallApp,
                10 => Self::Complete,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Stage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STAGE_UNSPECIFIED" => Self::Unspecified,
                "PENDING_CREATE_APP" => Self::PendingCreateApp,
                "PENDING_USER_OAUTH" => Self::PendingUserOauth,
                "PENDING_INSTALL_APP" => Self::PendingInstallApp,
                "COMPLETE" => Self::Complete,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Stage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PendingCreateApp => serializer.serialize_i32(1),
                Self::PendingUserOauth => serializer.serialize_i32(2),
                Self::PendingInstallApp => serializer.serialize_i32(3),
                Self::Complete => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Stage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Stage>::new(
                ".google.cloud.developerconnect.v1.InstallationState.Stage",
            ))
        }
    }
}

/// Configuration for connections to github.com.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GitHubConfig {
    /// Required. Immutable. The GitHub Application that was installed to the
    /// GitHub user or organization.
    pub github_app: crate::model::git_hub_config::GitHubApp,

    /// Optional. OAuth credential of the account that authorized the GitHub App.
    /// It is recommended to use a robot account instead of a human user account.
    /// The OAuth token must be tied to the GitHub App of this config.
    pub authorizer_credential: std::option::Option<crate::model::OAuthCredential>,

    /// Optional. GitHub App installation id.
    pub app_installation_id: i64,

    /// Output only. The URI to navigate to in order to manage the installation
    /// associated with this GitHubConfig.
    pub installation_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [github_app][crate::model::GitHubConfig::github_app].
    pub fn set_github_app<T: std::convert::Into<crate::model::git_hub_config::GitHubApp>>(
        mut self,
        v: T,
    ) -> Self {
        self.github_app = v.into();
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::GitHubConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OAuthCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::GitHubConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OAuthCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [app_installation_id][crate::model::GitHubConfig::app_installation_id].
    pub fn set_app_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_installation_id = v.into();
        self
    }

    /// Sets the value of [installation_uri][crate::model::GitHubConfig::installation_uri].
    pub fn set_installation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.installation_uri = v.into();
        self
    }
}

impl wkt::message::Message for GitHubConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitHubConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitHubConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __github_app,
            __authorizer_credential,
            __app_installation_id,
            __installation_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "githubApp" => Ok(__FieldTag::__github_app),
                            "github_app" => Ok(__FieldTag::__github_app),
                            "authorizerCredential" => Ok(__FieldTag::__authorizer_credential),
                            "authorizer_credential" => Ok(__FieldTag::__authorizer_credential),
                            "appInstallationId" => Ok(__FieldTag::__app_installation_id),
                            "app_installation_id" => Ok(__FieldTag::__app_installation_id),
                            "installationUri" => Ok(__FieldTag::__installation_uri),
                            "installation_uri" => Ok(__FieldTag::__installation_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitHubConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__github_app => {
                            if !fields.insert(__FieldTag::__github_app) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for github_app",
                                ));
                            }
                            result.github_app = map.next_value::<std::option::Option<crate::model::git_hub_config::GitHubApp>>()?.unwrap_or_default();
                        }
                        __FieldTag::__authorizer_credential => {
                            if !fields.insert(__FieldTag::__authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorizer_credential",
                                ));
                            }
                            result.authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::OAuthCredential>>(
                                )?;
                        }
                        __FieldTag::__app_installation_id => {
                            if !fields.insert(__FieldTag::__app_installation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_installation_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.app_installation_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__installation_uri => {
                            if !fields.insert(__FieldTag::__installation_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installation_uri",
                                ));
                            }
                            result.installation_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitHubConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.github_app) {
            state.serialize_entry("githubApp", &self.github_app)?;
        }
        if self.authorizer_credential.is_some() {
            state.serialize_entry("authorizerCredential", &self.authorizer_credential)?;
        }
        if !wkt::internal::is_default(&self.app_installation_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("appInstallationId", &__With(&self.app_installation_id))?;
        }
        if !self.installation_uri.is_empty() {
            state.serialize_entry("installationUri", &self.installation_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GitHubConfig].
pub mod git_hub_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the various GitHub Applications that can be installed to a
    /// GitHub user or organization and used with Developer Connect.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GitHubApp {
        /// GitHub App not specified.
        Unspecified,
        /// The Developer Connect GitHub Application.
        DeveloperConnect,
        /// The Firebase GitHub Application.
        Firebase,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GitHubApp::value] or
        /// [GitHubApp::name].
        UnknownValue(git_hub_app::UnknownValue),
    }

    #[doc(hidden)]
    pub mod git_hub_app {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GitHubApp {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DeveloperConnect => std::option::Option::Some(1),
                Self::Firebase => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GIT_HUB_APP_UNSPECIFIED"),
                Self::DeveloperConnect => std::option::Option::Some("DEVELOPER_CONNECT"),
                Self::Firebase => std::option::Option::Some("FIREBASE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GitHubApp {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GitHubApp {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GitHubApp {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DeveloperConnect,
                2 => Self::Firebase,
                _ => Self::UnknownValue(git_hub_app::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GitHubApp {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GIT_HUB_APP_UNSPECIFIED" => Self::Unspecified,
                "DEVELOPER_CONNECT" => Self::DeveloperConnect,
                "FIREBASE" => Self::Firebase,
                _ => Self::UnknownValue(git_hub_app::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GitHubApp {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DeveloperConnect => serializer.serialize_i32(1),
                Self::Firebase => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GitHubApp {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GitHubApp>::new(
                ".google.cloud.developerconnect.v1.GitHubConfig.GitHubApp",
            ))
        }
    }
}

/// Configuration for connections to an instance of GitHub Enterprise.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GitHubEnterpriseConfig {
    /// Required. The URI of the GitHub Enterprise host this connection is for.
    pub host_uri: std::string::String,

    /// Optional. ID of the GitHub App created from the manifest.
    pub app_id: i64,

    /// Output only. The URL-friendly name of the GitHub App.
    pub app_slug: std::string::String,

    /// Optional. SecretManager resource containing the private key of the GitHub
    /// App, formatted as `projects/*/secrets/*/versions/*`.
    pub private_key_secret_version: std::string::String,

    /// Optional. SecretManager resource containing the webhook secret of the
    /// GitHub App, formatted as `projects/*/secrets/*/versions/*`.
    pub webhook_secret_secret_version: std::string::String,

    /// Optional. ID of the installation of the GitHub App.
    pub app_installation_id: i64,

    /// Output only. The URI to navigate to in order to manage the installation
    /// associated with this GitHubEnterpriseConfig.
    pub installation_uri: std::string::String,

    /// Optional. Configuration for using Service Directory to privately connect to
    /// a GitHub Enterprise server. This should only be set if the GitHub
    /// Enterprise server is hosted on-premises and not reachable by public
    /// internet. If this field is left empty, calls to the GitHub Enterprise
    /// server will be made over the public internet.
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// Output only. GitHub Enterprise version installed at the host_uri.
    pub server_version: std::string::String,

    /// Optional. SSL certificate to use for requests to GitHub Enterprise.
    pub ssl_ca_certificate: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GitHubEnterpriseConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [app_id][crate::model::GitHubEnterpriseConfig::app_id].
    pub fn set_app_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_id = v.into();
        self
    }

    /// Sets the value of [app_slug][crate::model::GitHubEnterpriseConfig::app_slug].
    pub fn set_app_slug<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_slug = v.into();
        self
    }

    /// Sets the value of [private_key_secret_version][crate::model::GitHubEnterpriseConfig::private_key_secret_version].
    pub fn set_private_key_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_key_secret_version = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitHubEnterpriseConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [app_installation_id][crate::model::GitHubEnterpriseConfig::app_installation_id].
    pub fn set_app_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_installation_id = v.into();
        self
    }

    /// Sets the value of [installation_uri][crate::model::GitHubEnterpriseConfig::installation_uri].
    pub fn set_installation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.installation_uri = v.into();
        self
    }

    /// Sets the value of [service_directory_config][crate::model::GitHubEnterpriseConfig::service_directory_config].
    pub fn set_service_directory_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_directory_config][crate::model::GitHubEnterpriseConfig::service_directory_config].
    pub fn set_or_clear_service_directory_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [server_version][crate::model::GitHubEnterpriseConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }

    /// Sets the value of [ssl_ca_certificate][crate::model::GitHubEnterpriseConfig::ssl_ca_certificate].
    pub fn set_ssl_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitHubEnterpriseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitHubEnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_uri,
            __app_id,
            __app_slug,
            __private_key_secret_version,
            __webhook_secret_secret_version,
            __app_installation_id,
            __installation_uri,
            __service_directory_config,
            __server_version,
            __ssl_ca_certificate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitHubEnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostUri" => Ok(__FieldTag::__host_uri),
                            "host_uri" => Ok(__FieldTag::__host_uri),
                            "appId" => Ok(__FieldTag::__app_id),
                            "app_id" => Ok(__FieldTag::__app_id),
                            "appSlug" => Ok(__FieldTag::__app_slug),
                            "app_slug" => Ok(__FieldTag::__app_slug),
                            "privateKeySecretVersion" => {
                                Ok(__FieldTag::__private_key_secret_version)
                            }
                            "private_key_secret_version" => {
                                Ok(__FieldTag::__private_key_secret_version)
                            }
                            "webhookSecretSecretVersion" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "webhook_secret_secret_version" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "appInstallationId" => Ok(__FieldTag::__app_installation_id),
                            "app_installation_id" => Ok(__FieldTag::__app_installation_id),
                            "installationUri" => Ok(__FieldTag::__installation_uri),
                            "installation_uri" => Ok(__FieldTag::__installation_uri),
                            "serviceDirectoryConfig" => Ok(__FieldTag::__service_directory_config),
                            "service_directory_config" => {
                                Ok(__FieldTag::__service_directory_config)
                            }
                            "serverVersion" => Ok(__FieldTag::__server_version),
                            "server_version" => Ok(__FieldTag::__server_version),
                            "sslCaCertificate" => Ok(__FieldTag::__ssl_ca_certificate),
                            "ssl_ca_certificate" => Ok(__FieldTag::__ssl_ca_certificate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitHubEnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitHubEnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_uri => {
                            if !fields.insert(__FieldTag::__host_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_uri",
                                ));
                            }
                            result.host_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_id => {
                            if !fields.insert(__FieldTag::__app_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.app_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__app_slug => {
                            if !fields.insert(__FieldTag::__app_slug) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_slug",
                                ));
                            }
                            result.app_slug = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_key_secret_version => {
                            if !fields.insert(__FieldTag::__private_key_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key_secret_version",
                                ));
                            }
                            result.private_key_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_secret_secret_version => {
                            if !fields.insert(__FieldTag::__webhook_secret_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_secret_secret_version",
                                ));
                            }
                            result.webhook_secret_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_installation_id => {
                            if !fields.insert(__FieldTag::__app_installation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_installation_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.app_installation_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__installation_uri => {
                            if !fields.insert(__FieldTag::__installation_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installation_uri",
                                ));
                            }
                            result.installation_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_directory_config => {
                            if !fields.insert(__FieldTag::__service_directory_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_directory_config",
                                ));
                            }
                            result.service_directory_config = map.next_value::<std::option::Option<crate::model::ServiceDirectoryConfig>>()?
                                ;
                        }
                        __FieldTag::__server_version => {
                            if !fields.insert(__FieldTag::__server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_version",
                                ));
                            }
                            result.server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl_ca_certificate => {
                            if !fields.insert(__FieldTag::__ssl_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_ca_certificate",
                                ));
                            }
                            result.ssl_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitHubEnterpriseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host_uri.is_empty() {
            state.serialize_entry("hostUri", &self.host_uri)?;
        }
        if !wkt::internal::is_default(&self.app_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("appId", &__With(&self.app_id))?;
        }
        if !self.app_slug.is_empty() {
            state.serialize_entry("appSlug", &self.app_slug)?;
        }
        if !self.private_key_secret_version.is_empty() {
            state.serialize_entry("privateKeySecretVersion", &self.private_key_secret_version)?;
        }
        if !self.webhook_secret_secret_version.is_empty() {
            state.serialize_entry(
                "webhookSecretSecretVersion",
                &self.webhook_secret_secret_version,
            )?;
        }
        if !wkt::internal::is_default(&self.app_installation_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("appInstallationId", &__With(&self.app_installation_id))?;
        }
        if !self.installation_uri.is_empty() {
            state.serialize_entry("installationUri", &self.installation_uri)?;
        }
        if self.service_directory_config.is_some() {
            state.serialize_entry("serviceDirectoryConfig", &self.service_directory_config)?;
        }
        if !self.server_version.is_empty() {
            state.serialize_entry("serverVersion", &self.server_version)?;
        }
        if !self.ssl_ca_certificate.is_empty() {
            state.serialize_entry("sslCaCertificate", &self.ssl_ca_certificate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ServiceDirectoryConfig represents Service Directory configuration for a
/// connection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceDirectoryConfig {
    /// Required. The Service Directory service name.
    /// Format:
    /// projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
    pub service: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceDirectoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::ServiceDirectoryConfig::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for ServiceDirectoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ServiceDirectoryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceDirectoryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceDirectoryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceDirectoryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceDirectoryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceDirectoryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents an OAuth token of the account that authorized the Connection,
/// and associated metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OAuthCredential {
    /// Required. A SecretManager resource containing the OAuth token that
    /// authorizes the connection. Format: `projects/*/secrets/*/versions/*`.
    pub oauth_token_secret_version: std::string::String,

    /// Output only. The username associated with this token.
    pub username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OAuthCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oauth_token_secret_version][crate::model::OAuthCredential::oauth_token_secret_version].
    pub fn set_oauth_token_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_token_secret_version = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OAuthCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for OAuthCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.OAuthCredential"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OAuthCredential {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oauth_token_secret_version,
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OAuthCredential")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oauthTokenSecretVersion" => {
                                Ok(__FieldTag::__oauth_token_secret_version)
                            }
                            "oauth_token_secret_version" => {
                                Ok(__FieldTag::__oauth_token_secret_version)
                            }
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OAuthCredential;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OAuthCredential")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oauth_token_secret_version => {
                            if !fields.insert(__FieldTag::__oauth_token_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_token_secret_version",
                                ));
                            }
                            result.oauth_token_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OAuthCredential {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.oauth_token_secret_version.is_empty() {
            state.serialize_entry("oauthTokenSecretVersion", &self.oauth_token_secret_version)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for connections to gitlab.com.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GitLabConfig {
    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// of a GitLab project, formatted as `projects/*/secrets/*/versions/*`. This
    /// is used to validate webhooks.
    pub webhook_secret_secret_version: std::string::String,

    /// Required. A GitLab personal access token with the minimum `read_api` scope
    /// access and a minimum role of `reporter`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. A GitLab personal access token with the minimum `api` scope
    /// access and a minimum role of `maintainer`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitLabConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitLabConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::GitLabConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_authorizer_credential][crate::model::GitLabConfig::read_authorizer_credential].
    pub fn set_or_clear_read_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::GitLabConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::GitLabConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GitLabConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitLabConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitLabConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __webhook_secret_secret_version,
            __read_authorizer_credential,
            __authorizer_credential,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitLabConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "webhookSecretSecretVersion" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "webhook_secret_secret_version" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "readAuthorizerCredential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "read_authorizer_credential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "authorizerCredential" => Ok(__FieldTag::__authorizer_credential),
                            "authorizer_credential" => Ok(__FieldTag::__authorizer_credential),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitLabConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitLabConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__webhook_secret_secret_version => {
                            if !fields.insert(__FieldTag::__webhook_secret_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_secret_secret_version",
                                ));
                            }
                            result.webhook_secret_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_authorizer_credential => {
                            if !fields.insert(__FieldTag::__read_authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_authorizer_credential",
                                ));
                            }
                            result.read_authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::__authorizer_credential => {
                            if !fields.insert(__FieldTag::__authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorizer_credential",
                                ));
                            }
                            result.authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitLabConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.webhook_secret_secret_version.is_empty() {
            state.serialize_entry(
                "webhookSecretSecretVersion",
                &self.webhook_secret_secret_version,
            )?;
        }
        if self.read_authorizer_credential.is_some() {
            state.serialize_entry("readAuthorizerCredential", &self.read_authorizer_credential)?;
        }
        if self.authorizer_credential.is_some() {
            state.serialize_entry("authorizerCredential", &self.authorizer_credential)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a personal access token that authorized the Connection,
/// and associated metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UserCredential {
    /// Required. A SecretManager resource containing the user token that
    /// authorizes the Developer Connect connection. Format:
    /// `projects/*/secrets/*/versions/*`.
    pub user_token_secret_version: std::string::String,

    /// Output only. The username associated with this token.
    pub username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_token_secret_version][crate::model::UserCredential::user_token_secret_version].
    pub fn set_user_token_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_token_secret_version = v.into();
        self
    }

    /// Sets the value of [username][crate::model::UserCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for UserCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.UserCredential"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserCredential {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_token_secret_version,
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserCredential")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userTokenSecretVersion" => Ok(__FieldTag::__user_token_secret_version),
                            "user_token_secret_version" => {
                                Ok(__FieldTag::__user_token_secret_version)
                            }
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserCredential;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserCredential")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_token_secret_version => {
                            if !fields.insert(__FieldTag::__user_token_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_token_secret_version",
                                ));
                            }
                            result.user_token_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserCredential {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_token_secret_version.is_empty() {
            state.serialize_entry("userTokenSecretVersion", &self.user_token_secret_version)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for connections to an instance of GitLab Enterprise.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GitLabEnterpriseConfig {
    /// Required. The URI of the GitLab Enterprise host this connection is for.
    pub host_uri: std::string::String,

    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// of a GitLab project, formatted as `projects/*/secrets/*/versions/*`. This
    /// is used to validate webhooks.
    pub webhook_secret_secret_version: std::string::String,

    /// Required. A GitLab personal access token with the minimum `read_api` scope
    /// access and a minimum role of `reporter`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. A GitLab personal access token with the minimum `api` scope
    /// access and a minimum role of `maintainer`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Optional. Configuration for using Service Directory to privately connect to
    /// a GitLab Enterprise instance. This should only be set if the GitLab
    /// Enterprise server is hosted on-premises and not reachable by public
    /// internet. If this field is left empty, calls to the GitLab Enterprise
    /// server will be made over the public internet.
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// Optional. SSL Certificate Authority certificate to use for requests to
    /// GitLab Enterprise instance.
    pub ssl_ca_certificate: std::string::String,

    /// Output only. Version of the GitLab Enterprise server running on the
    /// `host_uri`.
    pub server_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitLabEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GitLabEnterpriseConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitLabEnterpriseConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::GitLabEnterpriseConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_authorizer_credential][crate::model::GitLabEnterpriseConfig::read_authorizer_credential].
    pub fn set_or_clear_read_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::GitLabEnterpriseConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::GitLabEnterpriseConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_directory_config][crate::model::GitLabEnterpriseConfig::service_directory_config].
    pub fn set_service_directory_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_directory_config][crate::model::GitLabEnterpriseConfig::service_directory_config].
    pub fn set_or_clear_service_directory_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_ca_certificate][crate::model::GitLabEnterpriseConfig::ssl_ca_certificate].
    pub fn set_ssl_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_ca_certificate = v.into();
        self
    }

    /// Sets the value of [server_version][crate::model::GitLabEnterpriseConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }
}

impl wkt::message::Message for GitLabEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitLabEnterpriseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitLabEnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_uri,
            __webhook_secret_secret_version,
            __read_authorizer_credential,
            __authorizer_credential,
            __service_directory_config,
            __ssl_ca_certificate,
            __server_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitLabEnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostUri" => Ok(__FieldTag::__host_uri),
                            "host_uri" => Ok(__FieldTag::__host_uri),
                            "webhookSecretSecretVersion" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "webhook_secret_secret_version" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "readAuthorizerCredential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "read_authorizer_credential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "authorizerCredential" => Ok(__FieldTag::__authorizer_credential),
                            "authorizer_credential" => Ok(__FieldTag::__authorizer_credential),
                            "serviceDirectoryConfig" => Ok(__FieldTag::__service_directory_config),
                            "service_directory_config" => {
                                Ok(__FieldTag::__service_directory_config)
                            }
                            "sslCaCertificate" => Ok(__FieldTag::__ssl_ca_certificate),
                            "ssl_ca_certificate" => Ok(__FieldTag::__ssl_ca_certificate),
                            "serverVersion" => Ok(__FieldTag::__server_version),
                            "server_version" => Ok(__FieldTag::__server_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitLabEnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitLabEnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_uri => {
                            if !fields.insert(__FieldTag::__host_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_uri",
                                ));
                            }
                            result.host_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_secret_secret_version => {
                            if !fields.insert(__FieldTag::__webhook_secret_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_secret_secret_version",
                                ));
                            }
                            result.webhook_secret_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_authorizer_credential => {
                            if !fields.insert(__FieldTag::__read_authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_authorizer_credential",
                                ));
                            }
                            result.read_authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::__authorizer_credential => {
                            if !fields.insert(__FieldTag::__authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorizer_credential",
                                ));
                            }
                            result.authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::__service_directory_config => {
                            if !fields.insert(__FieldTag::__service_directory_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_directory_config",
                                ));
                            }
                            result.service_directory_config = map.next_value::<std::option::Option<crate::model::ServiceDirectoryConfig>>()?
                                ;
                        }
                        __FieldTag::__ssl_ca_certificate => {
                            if !fields.insert(__FieldTag::__ssl_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_ca_certificate",
                                ));
                            }
                            result.ssl_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_version => {
                            if !fields.insert(__FieldTag::__server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_version",
                                ));
                            }
                            result.server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitLabEnterpriseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host_uri.is_empty() {
            state.serialize_entry("hostUri", &self.host_uri)?;
        }
        if !self.webhook_secret_secret_version.is_empty() {
            state.serialize_entry(
                "webhookSecretSecretVersion",
                &self.webhook_secret_secret_version,
            )?;
        }
        if self.read_authorizer_credential.is_some() {
            state.serialize_entry("readAuthorizerCredential", &self.read_authorizer_credential)?;
        }
        if self.authorizer_credential.is_some() {
            state.serialize_entry("authorizerCredential", &self.authorizer_credential)?;
        }
        if self.service_directory_config.is_some() {
            state.serialize_entry("serviceDirectoryConfig", &self.service_directory_config)?;
        }
        if !self.ssl_ca_certificate.is_empty() {
            state.serialize_entry("sslCaCertificate", &self.ssl_ca_certificate)?;
        }
        if !self.server_version.is_empty() {
            state.serialize_entry("serverVersion", &self.server_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for connections to an instance of Bitbucket Data Center.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BitbucketDataCenterConfig {
    /// Required. The URI of the Bitbucket Data Center host this connection is for.
    pub host_uri: std::string::String,

    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// used to verify webhook events, formatted as
    /// `projects/*/secrets/*/versions/*`. This is used to validate webhooks.
    pub webhook_secret_secret_version: std::string::String,

    /// Required. An http access token with the minimum `Repository read` access.
    /// It's recommended to use a system account to generate the credentials.
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. An http access token with the minimum `Repository admin` scope
    /// access. This is needed to create webhooks. It's recommended to use a system
    /// account to generate these credentials.
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Optional. Configuration for using Service Directory to privately connect to
    /// a Bitbucket Data Center instance. This should only be set if the Bitbucket
    /// Data Center is hosted on-premises and not reachable by public internet. If
    /// this field is left empty, calls to the Bitbucket Data Center will be made
    /// over the public internet.
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// Optional. SSL certificate authority to trust when making requests to
    /// Bitbucket Data Center.
    pub ssl_ca_certificate: std::string::String,

    /// Output only. Version of the Bitbucket Data Center server running on the
    /// `host_uri`.
    pub server_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BitbucketDataCenterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::BitbucketDataCenterConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::BitbucketDataCenterConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::BitbucketDataCenterConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_authorizer_credential][crate::model::BitbucketDataCenterConfig::read_authorizer_credential].
    pub fn set_or_clear_read_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::BitbucketDataCenterConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::BitbucketDataCenterConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_directory_config][crate::model::BitbucketDataCenterConfig::service_directory_config].
    pub fn set_service_directory_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_directory_config][crate::model::BitbucketDataCenterConfig::service_directory_config].
    pub fn set_or_clear_service_directory_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_ca_certificate][crate::model::BitbucketDataCenterConfig::ssl_ca_certificate].
    pub fn set_ssl_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_ca_certificate = v.into();
        self
    }

    /// Sets the value of [server_version][crate::model::BitbucketDataCenterConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }
}

impl wkt::message::Message for BitbucketDataCenterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.BitbucketDataCenterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BitbucketDataCenterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_uri,
            __webhook_secret_secret_version,
            __read_authorizer_credential,
            __authorizer_credential,
            __service_directory_config,
            __ssl_ca_certificate,
            __server_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BitbucketDataCenterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostUri" => Ok(__FieldTag::__host_uri),
                            "host_uri" => Ok(__FieldTag::__host_uri),
                            "webhookSecretSecretVersion" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "webhook_secret_secret_version" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "readAuthorizerCredential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "read_authorizer_credential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "authorizerCredential" => Ok(__FieldTag::__authorizer_credential),
                            "authorizer_credential" => Ok(__FieldTag::__authorizer_credential),
                            "serviceDirectoryConfig" => Ok(__FieldTag::__service_directory_config),
                            "service_directory_config" => {
                                Ok(__FieldTag::__service_directory_config)
                            }
                            "sslCaCertificate" => Ok(__FieldTag::__ssl_ca_certificate),
                            "ssl_ca_certificate" => Ok(__FieldTag::__ssl_ca_certificate),
                            "serverVersion" => Ok(__FieldTag::__server_version),
                            "server_version" => Ok(__FieldTag::__server_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BitbucketDataCenterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BitbucketDataCenterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_uri => {
                            if !fields.insert(__FieldTag::__host_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_uri",
                                ));
                            }
                            result.host_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_secret_secret_version => {
                            if !fields.insert(__FieldTag::__webhook_secret_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_secret_secret_version",
                                ));
                            }
                            result.webhook_secret_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_authorizer_credential => {
                            if !fields.insert(__FieldTag::__read_authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_authorizer_credential",
                                ));
                            }
                            result.read_authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::__authorizer_credential => {
                            if !fields.insert(__FieldTag::__authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorizer_credential",
                                ));
                            }
                            result.authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::__service_directory_config => {
                            if !fields.insert(__FieldTag::__service_directory_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_directory_config",
                                ));
                            }
                            result.service_directory_config = map.next_value::<std::option::Option<crate::model::ServiceDirectoryConfig>>()?
                                ;
                        }
                        __FieldTag::__ssl_ca_certificate => {
                            if !fields.insert(__FieldTag::__ssl_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_ca_certificate",
                                ));
                            }
                            result.ssl_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_version => {
                            if !fields.insert(__FieldTag::__server_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_version",
                                ));
                            }
                            result.server_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BitbucketDataCenterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host_uri.is_empty() {
            state.serialize_entry("hostUri", &self.host_uri)?;
        }
        if !self.webhook_secret_secret_version.is_empty() {
            state.serialize_entry(
                "webhookSecretSecretVersion",
                &self.webhook_secret_secret_version,
            )?;
        }
        if self.read_authorizer_credential.is_some() {
            state.serialize_entry("readAuthorizerCredential", &self.read_authorizer_credential)?;
        }
        if self.authorizer_credential.is_some() {
            state.serialize_entry("authorizerCredential", &self.authorizer_credential)?;
        }
        if self.service_directory_config.is_some() {
            state.serialize_entry("serviceDirectoryConfig", &self.service_directory_config)?;
        }
        if !self.ssl_ca_certificate.is_empty() {
            state.serialize_entry("sslCaCertificate", &self.ssl_ca_certificate)?;
        }
        if !self.server_version.is_empty() {
            state.serialize_entry("serverVersion", &self.server_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for connections to an instance of Bitbucket Cloud.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BitbucketCloudConfig {
    /// Required. The Bitbucket Cloud Workspace ID to be connected to Google Cloud
    /// Platform.
    pub workspace: std::string::String,

    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// used to verify webhook events, formatted as
    /// `projects/*/secrets/*/versions/*`. This is used to validate and create
    /// webhooks.
    pub webhook_secret_secret_version: std::string::String,

    /// Required. An access token with the minimum `repository` access.
    /// It can either be a workspace, project or repository access token.
    /// It's recommended to use a system account to generate the credentials.
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. An access token with the minimum `repository`, `pullrequest` and
    /// `webhook` scope access. It can either be a workspace, project or repository
    /// access token. This is needed to create webhooks. It's recommended to use a
    /// system account to generate these credentials.
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BitbucketCloudConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::BitbucketCloudConfig::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::BitbucketCloudConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::BitbucketCloudConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_authorizer_credential][crate::model::BitbucketCloudConfig::read_authorizer_credential].
    pub fn set_or_clear_read_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::BitbucketCloudConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::BitbucketCloudConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BitbucketCloudConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.BitbucketCloudConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BitbucketCloudConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __webhook_secret_secret_version,
            __read_authorizer_credential,
            __authorizer_credential,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BitbucketCloudConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "webhookSecretSecretVersion" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "webhook_secret_secret_version" => {
                                Ok(__FieldTag::__webhook_secret_secret_version)
                            }
                            "readAuthorizerCredential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "read_authorizer_credential" => {
                                Ok(__FieldTag::__read_authorizer_credential)
                            }
                            "authorizerCredential" => Ok(__FieldTag::__authorizer_credential),
                            "authorizer_credential" => Ok(__FieldTag::__authorizer_credential),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BitbucketCloudConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BitbucketCloudConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_secret_secret_version => {
                            if !fields.insert(__FieldTag::__webhook_secret_secret_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_secret_secret_version",
                                ));
                            }
                            result.webhook_secret_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_authorizer_credential => {
                            if !fields.insert(__FieldTag::__read_authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_authorizer_credential",
                                ));
                            }
                            result.read_authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::__authorizer_credential => {
                            if !fields.insert(__FieldTag::__authorizer_credential) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorizer_credential",
                                ));
                            }
                            result.authorizer_credential = map
                                .next_value::<std::option::Option<crate::model::UserCredential>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BitbucketCloudConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.webhook_secret_secret_version.is_empty() {
            state.serialize_entry(
                "webhookSecretSecretVersion",
                &self.webhook_secret_secret_version,
            )?;
        }
        if self.read_authorizer_credential.is_some() {
            state.serialize_entry("readAuthorizerCredential", &self.read_authorizer_credential)?;
        }
        if self.authorizer_credential.is_some() {
            state.serialize_entry("authorizerCredential", &self.authorizer_credential)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting list of Connections
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent value for ListConnectionsRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing Connections
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// The list of Connection
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connections,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connections" => Ok(__FieldTag::__connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a Connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GetConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a Connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// connection_id from the method_signature of Create RPC
    pub connection_id: std::string::String,

    /// Required. The resource being created
    pub connection: std::option::Option<crate::model::Connection>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::CreateConnectionRequest::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateConnectionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CreateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __connection_id,
            __connection,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "connectionId" => Ok(__FieldTag::__connection_id),
                            "connection_id" => Ok(__FieldTag::__connection_id),
                            "connection" => Ok(__FieldTag::__connection),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_id => {
                            if !fields.insert(__FieldTag::__connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_id",
                                ));
                            }
                            result.connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.connection_id.is_empty() {
            state.serialize_entry("connectionId", &self.connection_id)?;
        }
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a Connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Connection resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub connection: std::option::Option<crate::model::Connection>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, and the connection is not found a new connection
    /// will be created. In this situation `update_mask` is ignored.
    /// The creation will succeed only if the input connection has all the
    /// necessary information (e.g a github_config with both  user_oauth_token and
    /// installation_id properties).
    pub allow_missing: bool,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateConnectionRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateConnectionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.UpdateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __connection,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "connection" => Ok(__FieldTag::__connection),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection =
                                map.next_value::<std::option::Option<crate::model::Connection>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.connection.is_some() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a Connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    /// Optional. The current etag of the Connection.
    /// If an etag is provided and does not match the current etag of the
    /// Connection, deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteConnectionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteConnectionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting list of AccountConnectors
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAccountConnectorsRequest {
    /// Required. Parent value for ListAccountConnectorsRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAccountConnectorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAccountConnectorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAccountConnectorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAccountConnectorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAccountConnectorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAccountConnectorsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAccountConnectorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListAccountConnectorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAccountConnectorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAccountConnectorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAccountConnectorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAccountConnectorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAccountConnectorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing AccountConnectors
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAccountConnectorsResponse {
    /// The list of AccountConnectors
    pub account_connectors: std::vec::Vec<crate::model::AccountConnector>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAccountConnectorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_connectors][crate::model::ListAccountConnectorsResponse::account_connectors].
    pub fn set_account_connectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccountConnector>,
    {
        use std::iter::Iterator;
        self.account_connectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAccountConnectorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAccountConnectorsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAccountConnectorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListAccountConnectorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAccountConnectorsResponse {
    type PageItem = crate::model::AccountConnector;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.account_connectors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAccountConnectorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __account_connectors,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAccountConnectorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accountConnectors" => Ok(__FieldTag::__account_connectors),
                            "account_connectors" => Ok(__FieldTag::__account_connectors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAccountConnectorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAccountConnectorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__account_connectors => {
                            if !fields.insert(__FieldTag::__account_connectors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_connectors",
                                ));
                            }
                            result.account_connectors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AccountConnector>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAccountConnectorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.account_connectors.is_empty() {
            state.serialize_entry("accountConnectors", &self.account_connectors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a AccountConnector
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAccountConnectorRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAccountConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAccountConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAccountConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GetAccountConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAccountConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAccountConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAccountConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAccountConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAccountConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAccountConnectorRequest {
    /// Required. Location resource name as the account_connectors parent.
    pub parent: std::string::String,

    /// Required. The ID to use for the AccountConnector, which will become the
    /// final component of the AccountConnector's resource name. Its format should
    /// adhere to <https://google.aip.dev/122#resource-id-segments> Names must be
    /// unique per-project per-location.
    pub account_connector_id: std::string::String,

    /// Required. The AccountConnector to create.
    pub account_connector: std::option::Option<crate::model::AccountConnector>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAccountConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAccountConnectorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [account_connector_id][crate::model::CreateAccountConnectorRequest::account_connector_id].
    pub fn set_account_connector_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.account_connector_id = v.into();
        self
    }

    /// Sets the value of [account_connector][crate::model::CreateAccountConnectorRequest::account_connector].
    pub fn set_account_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccountConnector>,
    {
        self.account_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_connector][crate::model::CreateAccountConnectorRequest::account_connector].
    pub fn set_or_clear_account_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccountConnector>,
    {
        self.account_connector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateAccountConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAccountConnectorRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAccountConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CreateAccountConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAccountConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __account_connector_id,
            __account_connector,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAccountConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "accountConnectorId" => Ok(__FieldTag::__account_connector_id),
                            "account_connector_id" => Ok(__FieldTag::__account_connector_id),
                            "accountConnector" => Ok(__FieldTag::__account_connector),
                            "account_connector" => Ok(__FieldTag::__account_connector),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAccountConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAccountConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account_connector_id => {
                            if !fields.insert(__FieldTag::__account_connector_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_connector_id",
                                ));
                            }
                            result.account_connector_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account_connector => {
                            if !fields.insert(__FieldTag::__account_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_connector",
                                ));
                            }
                            result.account_connector = map
                                .next_value::<std::option::Option<crate::model::AccountConnector>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAccountConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.account_connector_id.is_empty() {
            state.serialize_entry("accountConnectorId", &self.account_connector_id)?;
        }
        if self.account_connector.is_some() {
            state.serialize_entry("accountConnector", &self.account_connector)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a AccountConnector
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAccountConnectorRequest {
    /// Optional. The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The AccountConnector to update.
    pub account_connector: std::option::Option<crate::model::AccountConnector>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, and the accountConnector is not found a new
    /// accountConnector will be created. In this situation `update_mask` is
    /// ignored. The creation will succeed only if the input accountConnector has
    /// all the necessary
    pub allow_missing: bool,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAccountConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAccountConnectorRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAccountConnectorRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [account_connector][crate::model::UpdateAccountConnectorRequest::account_connector].
    pub fn set_account_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccountConnector>,
    {
        self.account_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account_connector][crate::model::UpdateAccountConnectorRequest::account_connector].
    pub fn set_or_clear_account_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccountConnector>,
    {
        self.account_connector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateAccountConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateAccountConnectorRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAccountConnectorRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAccountConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.UpdateAccountConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAccountConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __account_connector,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAccountConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "accountConnector" => Ok(__FieldTag::__account_connector),
                            "account_connector" => Ok(__FieldTag::__account_connector),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAccountConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAccountConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__account_connector => {
                            if !fields.insert(__FieldTag::__account_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_connector",
                                ));
                            }
                            result.account_connector = map
                                .next_value::<std::option::Option<crate::model::AccountConnector>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAccountConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.account_connector.is_some() {
            state.serialize_entry("accountConnector", &self.account_connector)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a AccountConnector
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAccountConnectorRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    /// Optional. The current etag of the AccountConnectorn.
    /// If an etag is provided and does not match the current etag of the
    /// AccountConnector, deletion will be blocked and an ABORTED error will be
    /// returned.
    pub etag: std::string::String,

    /// Optional. If set to true, any Users from this AccountConnector will also
    /// be deleted. (Otherwise, the request will only work if the AccountConnector
    /// has no Users.)
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAccountConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAccountConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteAccountConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteAccountConnectorRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAccountConnectorRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteAccountConnectorRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAccountConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteAccountConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAccountConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            __etag,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAccountConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAccountConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAccountConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAccountConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a User
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUserRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteUserRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteUserRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteUserRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for fetching a User of the user themselves.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchSelfRequest {
    /// Required. Name of the AccountConnector resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchSelfRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchSelfRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FetchSelfRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchSelfRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchSelfRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchSelfRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchSelfRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchSelfRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchSelfRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a User of the user themselves.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSelfRequest {
    /// Required. Name of the AccountConnector resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSelfRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSelfRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSelfRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteSelfRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSelfRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSelfRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSelfRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSelfRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSelfRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for fetching an OAuth access token.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchAccessTokenRequest {
    /// Required. The resource name of the AccountConnector in the format
    /// `projects/*/locations/*/accountConnectors/*`.
    pub account_connector: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [account_connector][crate::model::FetchAccessTokenRequest::account_connector].
    pub fn set_account_connector<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.account_connector = v.into();
        self
    }
}

impl wkt::message::Message for FetchAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchAccessTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchAccessTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __account_connector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchAccessTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accountConnector" => Ok(__FieldTag::__account_connector),
                            "account_connector" => Ok(__FieldTag::__account_connector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchAccessTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchAccessTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__account_connector => {
                            if !fields.insert(__FieldTag::__account_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_connector",
                                ));
                            }
                            result.account_connector = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchAccessTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.account_connector.is_empty() {
            state.serialize_entry("accountConnector", &self.account_connector)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for responding to getting an OAuth access token.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchAccessTokenResponse {
    /// The token content.
    pub token: std::string::String,

    /// Expiration timestamp. Can be empty if unknown or non-expiring.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The scopes of the access token.
    pub scopes: std::vec::Vec<std::string::String>,

    /// The error resulted from exchanging OAuth tokens from the service provider.
    pub exchange_error: std::option::Option<crate::model::ExchangeError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::FetchAccessTokenResponse::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::FetchAccessTokenResponse::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::FetchAccessTokenResponse::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scopes][crate::model::FetchAccessTokenResponse::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exchange_error][crate::model::FetchAccessTokenResponse::exchange_error].
    pub fn set_exchange_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExchangeError>,
    {
        self.exchange_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exchange_error][crate::model::FetchAccessTokenResponse::exchange_error].
    pub fn set_or_clear_exchange_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExchangeError>,
    {
        self.exchange_error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FetchAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchAccessTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchAccessTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __token,
            __expiration_time,
            __scopes,
            __exchange_error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchAccessTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "token" => Ok(__FieldTag::__token),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "scopes" => Ok(__FieldTag::__scopes),
                            "exchangeError" => Ok(__FieldTag::__exchange_error),
                            "exchange_error" => Ok(__FieldTag::__exchange_error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchAccessTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchAccessTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__token => {
                            if !fields.insert(__FieldTag::__token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token",
                                ));
                            }
                            result.token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scopes",
                                ));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exchange_error => {
                            if !fields.insert(__FieldTag::__exchange_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exchange_error",
                                ));
                            }
                            result.exchange_error = map
                                .next_value::<std::option::Option<crate::model::ExchangeError>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchAccessTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.token.is_empty() {
            state.serialize_entry("token", &self.token)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if self.exchange_error.is_some() {
            state.serialize_entry("exchangeError", &self.exchange_error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for representing an error from exchanging OAuth tokens.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExchangeError {
    /// <https://datatracker.ietf.org/doc/html/rfc6749#section-5.2> - error
    pub code: std::string::String,

    /// <https://datatracker.ietf.org/doc/html/rfc6749#section-5.2> -
    /// error_description
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExchangeError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::ExchangeError::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ExchangeError::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for ExchangeError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ExchangeError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExchangeError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExchangeError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExchangeError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExchangeError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExchangeError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing the GitRepositoryLink object
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GitRepositoryLink {
    /// Identifier. Resource name of the repository, in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    pub name: std::string::String,

    /// Required. Git Clone URI.
    pub clone_uri: std::string::String,

    /// Output only. [Output only] Create timestamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Delete timestamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. Set to true when the connection is being set up or updated in
    /// the background.
    pub reconciling: bool,

    /// Optional. Allows clients to store small amounts of arbitrary data.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. A system-assigned unique identifier for the GitRepositoryLink.
    pub uid: std::string::String,

    /// Output only. External ID of the webhook created for the repository.
    pub webhook_id: std::string::String,

    /// Output only. URI to access the linked repository through the Git Proxy.
    /// This field is only populated if the git proxy is enabled for the
    /// connection.
    pub git_proxy_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitRepositoryLink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GitRepositoryLink::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [clone_uri][crate::model::GitRepositoryLink::clone_uri].
    pub fn set_clone_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clone_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GitRepositoryLink::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::GitRepositoryLink::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::GitRepositoryLink::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::GitRepositoryLink::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::GitRepositoryLink::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::GitRepositoryLink::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::GitRepositoryLink::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::GitRepositoryLink::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::GitRepositoryLink::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::GitRepositoryLink::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uid][crate::model::GitRepositoryLink::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [webhook_id][crate::model::GitRepositoryLink::webhook_id].
    pub fn set_webhook_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_id = v.into();
        self
    }

    /// Sets the value of [git_proxy_uri][crate::model::GitRepositoryLink::git_proxy_uri].
    pub fn set_git_proxy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_proxy_uri = v.into();
        self
    }
}

impl wkt::message::Message for GitRepositoryLink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitRepositoryLink"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GitRepositoryLink {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __clone_uri,
            __create_time,
            __update_time,
            __delete_time,
            __labels,
            __etag,
            __reconciling,
            __annotations,
            __uid,
            __webhook_id,
            __git_proxy_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitRepositoryLink")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cloneUri" => Ok(__FieldTag::__clone_uri),
                            "clone_uri" => Ok(__FieldTag::__clone_uri),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "uid" => Ok(__FieldTag::__uid),
                            "webhookId" => Ok(__FieldTag::__webhook_id),
                            "webhook_id" => Ok(__FieldTag::__webhook_id),
                            "gitProxyUri" => Ok(__FieldTag::__git_proxy_uri),
                            "git_proxy_uri" => Ok(__FieldTag::__git_proxy_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GitRepositoryLink;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitRepositoryLink")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clone_uri => {
                            if !fields.insert(__FieldTag::__clone_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_uri",
                                ));
                            }
                            result.clone_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_id => {
                            if !fields.insert(__FieldTag::__webhook_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_id",
                                ));
                            }
                            result.webhook_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_proxy_uri => {
                            if !fields.insert(__FieldTag::__git_proxy_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_proxy_uri",
                                ));
                            }
                            result.git_proxy_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GitRepositoryLink {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.clone_uri.is_empty() {
            state.serialize_entry("cloneUri", &self.clone_uri)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.webhook_id.is_empty() {
            state.serialize_entry("webhookId", &self.webhook_id)?;
        }
        if !self.git_proxy_uri.is_empty() {
            state.serialize_entry("gitProxyUri", &self.git_proxy_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a GitRepositoryLink
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGitRepositoryLinkRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. The resource being created
    pub git_repository_link: std::option::Option<crate::model::GitRepositoryLink>,

    /// Required. The ID to use for the repository, which will become the final
    /// component of the repository's resource name. This ID should be unique in
    /// the connection. Allows alphanumeric characters and any of
    /// -._~%!$&'()*+,;=@.
    pub git_repository_link_id: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGitRepositoryLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGitRepositoryLinkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [git_repository_link][crate::model::CreateGitRepositoryLinkRequest::git_repository_link].
    pub fn set_git_repository_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitRepositoryLink>,
    {
        self.git_repository_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_repository_link][crate::model::CreateGitRepositoryLinkRequest::git_repository_link].
    pub fn set_or_clear_git_repository_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitRepositoryLink>,
    {
        self.git_repository_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_repository_link_id][crate::model::CreateGitRepositoryLinkRequest::git_repository_link_id].
    pub fn set_git_repository_link_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGitRepositoryLinkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateGitRepositoryLinkRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateGitRepositoryLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CreateGitRepositoryLinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGitRepositoryLinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __git_repository_link,
            __git_repository_link_id,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGitRepositoryLinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "gitRepositoryLink" => Ok(__FieldTag::__git_repository_link),
                            "git_repository_link" => Ok(__FieldTag::__git_repository_link),
                            "gitRepositoryLinkId" => Ok(__FieldTag::__git_repository_link_id),
                            "git_repository_link_id" => Ok(__FieldTag::__git_repository_link_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGitRepositoryLinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGitRepositoryLinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_repository_link => {
                            if !fields.insert(__FieldTag::__git_repository_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_repository_link",
                                ));
                            }
                            result.git_repository_link = map
                                .next_value::<std::option::Option<crate::model::GitRepositoryLink>>(
                                )?;
                        }
                        __FieldTag::__git_repository_link_id => {
                            if !fields.insert(__FieldTag::__git_repository_link_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_repository_link_id",
                                ));
                            }
                            result.git_repository_link_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGitRepositoryLinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.git_repository_link.is_some() {
            state.serialize_entry("gitRepositoryLink", &self.git_repository_link)?;
        }
        if !self.git_repository_link_id.is_empty() {
            state.serialize_entry("gitRepositoryLinkId", &self.git_repository_link_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a GitRepositoryLink
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGitRepositoryLinkRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGitRepositoryLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGitRepositoryLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteGitRepositoryLinkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteGitRepositoryLinkRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteGitRepositoryLinkRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGitRepositoryLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteGitRepositoryLinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGitRepositoryLinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGitRepositoryLinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGitRepositoryLinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGitRepositoryLinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGitRepositoryLinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting a list of GitRepositoryLinks
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGitRepositoryLinksRequest {
    /// Required. Parent value for ListGitRepositoryLinksRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGitRepositoryLinksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGitRepositoryLinksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGitRepositoryLinksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGitRepositoryLinksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGitRepositoryLinksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGitRepositoryLinksRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGitRepositoryLinksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListGitRepositoryLinksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGitRepositoryLinksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGitRepositoryLinksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGitRepositoryLinksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGitRepositoryLinksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGitRepositoryLinksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing GitRepositoryLinks
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGitRepositoryLinksResponse {
    /// The list of GitRepositoryLinks
    pub git_repository_links: std::vec::Vec<crate::model::GitRepositoryLink>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGitRepositoryLinksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_links][crate::model::ListGitRepositoryLinksResponse::git_repository_links].
    pub fn set_git_repository_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GitRepositoryLink>,
    {
        use std::iter::Iterator;
        self.git_repository_links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGitRepositoryLinksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGitRepositoryLinksResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGitRepositoryLinksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListGitRepositoryLinksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGitRepositoryLinksResponse {
    type PageItem = crate::model::GitRepositoryLink;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.git_repository_links
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGitRepositoryLinksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __git_repository_links,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGitRepositoryLinksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gitRepositoryLinks" => Ok(__FieldTag::__git_repository_links),
                            "git_repository_links" => Ok(__FieldTag::__git_repository_links),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGitRepositoryLinksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGitRepositoryLinksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__git_repository_links => {
                            if !fields.insert(__FieldTag::__git_repository_links) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_repository_links",
                                ));
                            }
                            result.git_repository_links =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GitRepositoryLink>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGitRepositoryLinksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.git_repository_links.is_empty() {
            state.serialize_entry("gitRepositoryLinks", &self.git_repository_links)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a GitRepositoryLink
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGitRepositoryLinkRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGitRepositoryLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGitRepositoryLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGitRepositoryLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GetGitRepositoryLinkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGitRepositoryLinkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGitRepositoryLinkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGitRepositoryLinkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGitRepositoryLinkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGitRepositoryLinkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for fetching SCM read/write token.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchReadWriteTokenRequest {
    /// Required. The resource name of the gitRepositoryLink in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    pub git_repository_link: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadWriteTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_link][crate::model::FetchReadWriteTokenRequest::git_repository_link].
    pub fn set_git_repository_link<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadWriteTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadWriteTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchReadWriteTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __git_repository_link,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchReadWriteTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gitRepositoryLink" => Ok(__FieldTag::__git_repository_link),
                            "git_repository_link" => Ok(__FieldTag::__git_repository_link),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchReadWriteTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchReadWriteTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__git_repository_link => {
                            if !fields.insert(__FieldTag::__git_repository_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_repository_link",
                                ));
                            }
                            result.git_repository_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchReadWriteTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.git_repository_link.is_empty() {
            state.serialize_entry("gitRepositoryLink", &self.git_repository_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for fetching SCM read token.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchReadTokenRequest {
    /// Required. The resource name of the gitRepositoryLink in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    pub git_repository_link: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_link][crate::model::FetchReadTokenRequest::git_repository_link].
    pub fn set_git_repository_link<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchReadTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __git_repository_link,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchReadTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gitRepositoryLink" => Ok(__FieldTag::__git_repository_link),
                            "git_repository_link" => Ok(__FieldTag::__git_repository_link),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchReadTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchReadTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__git_repository_link => {
                            if !fields.insert(__FieldTag::__git_repository_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_repository_link",
                                ));
                            }
                            result.git_repository_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchReadTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.git_repository_link.is_empty() {
            state.serialize_entry("gitRepositoryLink", &self.git_repository_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for responding to get read token.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchReadTokenResponse {
    /// The token content.
    pub token: std::string::String,

    /// Expiration timestamp. Can be empty if unknown or non-expiring.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The git_username to specify when making a git clone with the
    /// token. For example, for GitHub GitRepositoryLinks, this would be
    /// "x-access-token"
    pub git_username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::FetchReadTokenResponse::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::FetchReadTokenResponse::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::FetchReadTokenResponse::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_username][crate::model::FetchReadTokenResponse::git_username].
    pub fn set_git_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_username = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchReadTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __token,
            __expiration_time,
            __git_username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchReadTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "token" => Ok(__FieldTag::__token),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "gitUsername" => Ok(__FieldTag::__git_username),
                            "git_username" => Ok(__FieldTag::__git_username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchReadTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchReadTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__token => {
                            if !fields.insert(__FieldTag::__token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token",
                                ));
                            }
                            result.token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__git_username => {
                            if !fields.insert(__FieldTag::__git_username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_username",
                                ));
                            }
                            result.git_username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchReadTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.token.is_empty() {
            state.serialize_entry("token", &self.token)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !self.git_username.is_empty() {
            state.serialize_entry("gitUsername", &self.git_username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for responding to get read/write token.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchReadWriteTokenResponse {
    /// The token content.
    pub token: std::string::String,

    /// Expiration timestamp. Can be empty if unknown or non-expiring.
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The git_username to specify when making a git clone with the
    /// token. For example, for GitHub GitRepositoryLinks, this would be
    /// "x-access-token"
    pub git_username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadWriteTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::FetchReadWriteTokenResponse::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::FetchReadWriteTokenResponse::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::FetchReadWriteTokenResponse::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_username][crate::model::FetchReadWriteTokenResponse::git_username].
    pub fn set_git_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_username = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadWriteTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadWriteTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchReadWriteTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __token,
            __expiration_time,
            __git_username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchReadWriteTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "token" => Ok(__FieldTag::__token),
                            "expirationTime" => Ok(__FieldTag::__expiration_time),
                            "expiration_time" => Ok(__FieldTag::__expiration_time),
                            "gitUsername" => Ok(__FieldTag::__git_username),
                            "git_username" => Ok(__FieldTag::__git_username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchReadWriteTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchReadWriteTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__token => {
                            if !fields.insert(__FieldTag::__token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token",
                                ));
                            }
                            result.token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expiration_time => {
                            if !fields.insert(__FieldTag::__expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration_time",
                                ));
                            }
                            result.expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__git_username => {
                            if !fields.insert(__FieldTag::__git_username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_username",
                                ));
                            }
                            result.git_username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchReadWriteTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.token.is_empty() {
            state.serialize_entry("token", &self.token)?;
        }
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if !self.git_username.is_empty() {
            state.serialize_entry("gitUsername", &self.git_username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for FetchLinkableGitRepositoriesRequest.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchLinkableGitRepositoriesRequest {
    /// Required. The name of the Connection.
    /// Format: `projects/*/locations/*/connections/*`.
    pub connection: std::string::String,

    /// Optional. Number of results to return in the list. Defaults to 20.
    pub page_size: i32,

    /// Optional. Page start.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchLinkableGitRepositoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::FetchLinkableGitRepositoriesRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchLinkableGitRepositoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchLinkableGitRepositoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchLinkableGitRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchLinkableGitRepositoriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchLinkableGitRepositoriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchLinkableGitRepositoriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connection" => Ok(__FieldTag::__connection),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchLinkableGitRepositoriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchLinkableGitRepositoriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchLinkableGitRepositoriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection.is_empty() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for FetchLinkableGitRepositories.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchLinkableGitRepositoriesResponse {
    /// The git repositories that can be linked to the connection.
    pub linkable_git_repositories: std::vec::Vec<crate::model::LinkableGitRepository>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchLinkableGitRepositoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [linkable_git_repositories][crate::model::FetchLinkableGitRepositoriesResponse::linkable_git_repositories].
    pub fn set_linkable_git_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LinkableGitRepository>,
    {
        use std::iter::Iterator;
        self.linkable_git_repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchLinkableGitRepositoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchLinkableGitRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchLinkableGitRepositoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchLinkableGitRepositoriesResponse {
    type PageItem = crate::model::LinkableGitRepository;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.linkable_git_repositories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchLinkableGitRepositoriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __linkable_git_repositories,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchLinkableGitRepositoriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "linkableGitRepositories" => {
                                Ok(__FieldTag::__linkable_git_repositories)
                            }
                            "linkable_git_repositories" => {
                                Ok(__FieldTag::__linkable_git_repositories)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchLinkableGitRepositoriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchLinkableGitRepositoriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__linkable_git_repositories => {
                            if !fields.insert(__FieldTag::__linkable_git_repositories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linkable_git_repositories",
                                ));
                            }
                            result.linkable_git_repositories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LinkableGitRepository>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchLinkableGitRepositoriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.linkable_git_repositories.is_empty() {
            state.serialize_entry("linkableGitRepositories", &self.linkable_git_repositories)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// LinkableGitRepository represents a git repository that can be linked to a
/// connection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LinkableGitRepository {
    /// The clone uri of the repository.
    pub clone_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkableGitRepository {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_uri][crate::model::LinkableGitRepository::clone_uri].
    pub fn set_clone_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clone_uri = v.into();
        self
    }
}

impl wkt::message::Message for LinkableGitRepository {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.LinkableGitRepository"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LinkableGitRepository {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clone_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkableGitRepository")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloneUri" => Ok(__FieldTag::__clone_uri),
                            "clone_uri" => Ok(__FieldTag::__clone_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LinkableGitRepository;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkableGitRepository")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clone_uri => {
                            if !fields.insert(__FieldTag::__clone_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_uri",
                                ));
                            }
                            result.clone_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LinkableGitRepository {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clone_uri.is_empty() {
            state.serialize_entry("cloneUri", &self.clone_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for fetching github installations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchGitHubInstallationsRequest {
    /// Required. The resource name of the connection in the format
    /// `projects/*/locations/*/connections/*`.
    pub connection: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitHubInstallationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::FetchGitHubInstallationsRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitHubInstallationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitHubInstallationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchGitHubInstallationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchGitHubInstallationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connection" => Ok(__FieldTag::__connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchGitHubInstallationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchGitHubInstallationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection => {
                            if !fields.insert(__FieldTag::__connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection",
                                ));
                            }
                            result.connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchGitHubInstallationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection.is_empty() {
            state.serialize_entry("connection", &self.connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response of fetching github installations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchGitHubInstallationsResponse {
    /// List of installations available to the OAuth user (for github.com)
    /// or all the installations (for GitHub enterprise).
    pub installations:
        std::vec::Vec<crate::model::fetch_git_hub_installations_response::Installation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitHubInstallationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [installations][crate::model::FetchGitHubInstallationsResponse::installations].
    pub fn set_installations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::fetch_git_hub_installations_response::Installation>,
    {
        use std::iter::Iterator;
        self.installations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchGitHubInstallationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitHubInstallationsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchGitHubInstallationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __installations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchGitHubInstallationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "installations" => Ok(__FieldTag::__installations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchGitHubInstallationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchGitHubInstallationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__installations => {
                            if !fields.insert(__FieldTag::__installations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for installations",
                                ));
                            }
                            result.installations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::fetch_git_hub_installations_response::Installation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchGitHubInstallationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.installations.is_empty() {
            state.serialize_entry("installations", &self.installations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FetchGitHubInstallationsResponse].
pub mod fetch_git_hub_installations_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an installation of the GitHub App.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Installation {
        /// ID of the installation in GitHub.
        pub id: i64,

        /// Name of the GitHub user or organization that owns this installation.
        pub name: std::string::String,

        /// Either "user" or "organization".
        pub r#type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Installation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::fetch_git_hub_installations_response::Installation::id].
        pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::fetch_git_hub_installations_response::Installation::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::fetch_git_hub_installations_response::Installation::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Installation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitHubInstallationsResponse.Installation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Installation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __name,
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Installation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Installation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Installation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Installation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.id) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("id", &__With(&self.id))?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Request for fetching git refs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchGitRefsRequest {
    /// Required. The resource name of GitRepositoryLink in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    pub git_repository_link: std::string::String,

    /// Required. Type of refs to fetch.
    pub ref_type: crate::model::fetch_git_refs_request::RefType,

    /// Optional. Number of results to return in the list. Default to 20.
    pub page_size: i32,

    /// Optional. Page start.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitRefsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_link][crate::model::FetchGitRefsRequest::git_repository_link].
    pub fn set_git_repository_link<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link = v.into();
        self
    }

    /// Sets the value of [ref_type][crate::model::FetchGitRefsRequest::ref_type].
    pub fn set_ref_type<T: std::convert::Into<crate::model::fetch_git_refs_request::RefType>>(
        mut self,
        v: T,
    ) -> Self {
        self.ref_type = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchGitRefsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchGitRefsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitRefsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitRefsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchGitRefsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __git_repository_link,
            __ref_type,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchGitRefsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gitRepositoryLink" => Ok(__FieldTag::__git_repository_link),
                            "git_repository_link" => Ok(__FieldTag::__git_repository_link),
                            "refType" => Ok(__FieldTag::__ref_type),
                            "ref_type" => Ok(__FieldTag::__ref_type),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchGitRefsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchGitRefsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__git_repository_link => {
                            if !fields.insert(__FieldTag::__git_repository_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_repository_link",
                                ));
                            }
                            result.git_repository_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ref_type => {
                            if !fields.insert(__FieldTag::__ref_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ref_type",
                                ));
                            }
                            result.ref_type =
                                map.next_value::<std::option::Option<
                                    crate::model::fetch_git_refs_request::RefType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchGitRefsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.git_repository_link.is_empty() {
            state.serialize_entry("gitRepositoryLink", &self.git_repository_link)?;
        }
        if !wkt::internal::is_default(&self.ref_type) {
            state.serialize_entry("refType", &self.ref_type)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FetchGitRefsRequest].
pub mod fetch_git_refs_request {
    #[allow(unused_imports)]
    use super::*;

    /// Type of refs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefType {
        /// No type specified.
        Unspecified,
        /// To fetch tags.
        Tag,
        /// To fetch branches.
        Branch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefType::value] or
        /// [RefType::name].
        UnknownValue(ref_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ref_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tag => std::option::Option::Some(1),
                Self::Branch => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REF_TYPE_UNSPECIFIED"),
                Self::Tag => std::option::Option::Some("TAG"),
                Self::Branch => std::option::Option::Some("BRANCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tag,
                2 => Self::Branch,
                _ => Self::UnknownValue(ref_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REF_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TAG" => Self::Tag,
                "BRANCH" => Self::Branch,
                _ => Self::UnknownValue(ref_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tag => serializer.serialize_i32(1),
                Self::Branch => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefType>::new(
                ".google.cloud.developerconnect.v1.FetchGitRefsRequest.RefType",
            ))
        }
    }
}

/// Response for fetching git refs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchGitRefsResponse {
    /// Name of the refs fetched.
    pub ref_names: std::vec::Vec<std::string::String>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitRefsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ref_names][crate::model::FetchGitRefsResponse::ref_names].
    pub fn set_ref_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ref_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchGitRefsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitRefsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitRefsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchGitRefsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ref_names,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchGitRefsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "refNames" => Ok(__FieldTag::__ref_names),
                            "ref_names" => Ok(__FieldTag::__ref_names),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchGitRefsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchGitRefsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ref_names => {
                            if !fields.insert(__FieldTag::__ref_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ref_names",
                                ));
                            }
                            result.ref_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchGitRefsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ref_names.is_empty() {
            state.serialize_entry("refNames", &self.ref_names)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AccountConnector encapsulates what a platform administrator needs to
/// configure for users to connect to the service providers, which includes,
/// among other fields, the OAuth client ID, client secret, and authorization and
/// token endpoints.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccountConnector {
    /// Identifier. The resource name of the accountConnector, in the format
    /// `projects/{project}/locations/{location}/accountConnectors/{account_connector_id}`.
    pub name: std::string::String,

    /// Output only. The timestamp when the accountConnector was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the accountConnector was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Allows users to store small amounts of arbitrary data.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Optional. Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Start OAuth flow by clicking on this URL.
    pub oauth_start_uri: std::string::String,

    /// The AccountConnector config.
    pub account_connector_config:
        std::option::Option<crate::model::account_connector::AccountConnectorConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccountConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccountConnector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AccountConnector::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AccountConnector::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AccountConnector::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AccountConnector::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::AccountConnector::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::AccountConnector::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AccountConnector::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [oauth_start_uri][crate::model::AccountConnector::oauth_start_uri].
    pub fn set_oauth_start_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.oauth_start_uri = v.into();
        self
    }

    /// Sets the value of [account_connector_config][crate::model::AccountConnector::account_connector_config].
    ///
    /// Note that all the setters affecting `account_connector_config` are mutually
    /// exclusive.
    pub fn set_account_connector_config<
        T: std::convert::Into<
                std::option::Option<crate::model::account_connector::AccountConnectorConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.account_connector_config = v.into();
        self
    }

    /// The value of [account_connector_config][crate::model::AccountConnector::account_connector_config]
    /// if it holds a `ProviderOauthConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn provider_oauth_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProviderOAuthConfig>> {
        #[allow(unreachable_patterns)]
        self.account_connector_config
            .as_ref()
            .and_then(|v| match v {
                crate::model::account_connector::AccountConnectorConfig::ProviderOauthConfig(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
    }

    /// Sets the value of [account_connector_config][crate::model::AccountConnector::account_connector_config]
    /// to hold a `ProviderOauthConfig`.
    ///
    /// Note that all the setters affecting `account_connector_config` are
    /// mutually exclusive.
    pub fn set_provider_oauth_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ProviderOAuthConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.account_connector_config = std::option::Option::Some(
            crate::model::account_connector::AccountConnectorConfig::ProviderOauthConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AccountConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.AccountConnector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccountConnector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provider_oauth_config,
            __name,
            __create_time,
            __update_time,
            __annotations,
            __etag,
            __labels,
            __oauth_start_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccountConnector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "providerOauthConfig" => Ok(__FieldTag::__provider_oauth_config),
                            "provider_oauth_config" => Ok(__FieldTag::__provider_oauth_config),
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "etag" => Ok(__FieldTag::__etag),
                            "labels" => Ok(__FieldTag::__labels),
                            "oauthStartUri" => Ok(__FieldTag::__oauth_start_uri),
                            "oauth_start_uri" => Ok(__FieldTag::__oauth_start_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccountConnector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccountConnector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provider_oauth_config => {
                            if !fields.insert(__FieldTag::__provider_oauth_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provider_oauth_config",
                                ));
                            }
                            if result.account_connector_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `account_connector_config`, a oneof with full ID .google.cloud.developerconnect.v1.AccountConnector.provider_oauth_config, latest field was providerOauthConfig",
                                ));
                            }
                            result.account_connector_config = std::option::Option::Some(
                                crate::model::account_connector::AccountConnectorConfig::ProviderOauthConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ProviderOAuthConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oauth_start_uri => {
                            if !fields.insert(__FieldTag::__oauth_start_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_start_uri",
                                ));
                            }
                            result.oauth_start_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccountConnector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.provider_oauth_config() {
            state.serialize_entry("providerOauthConfig", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.oauth_start_uri.is_empty() {
            state.serialize_entry("oauthStartUri", &self.oauth_start_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccountConnector].
pub mod account_connector {
    #[allow(unused_imports)]
    use super::*;

    /// The AccountConnector config.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccountConnectorConfig {
        /// Provider OAuth config.
        ProviderOauthConfig(std::boxed::Box<crate::model::ProviderOAuthConfig>),
    }
}

/// User represents a user connected to the service providers through
/// a AccountConnector.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct User {
    /// Identifier. Resource name of the user, in the format
    /// `projects/*/locations/*/accountConnectors/*/users/*`.
    pub name: std::string::String,

    /// Output only. Developer Connect automatically converts user identity
    /// to some human readable description, e.g., email address.
    pub display_name: std::string::String,

    /// Output only. The timestamp when the user was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the token was last requested.
    pub last_token_request_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::User::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::User::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::User::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_token_request_time][crate::model::User::last_token_request_time].
    pub fn set_last_token_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_token_request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_token_request_time][crate::model::User::last_token_request_time].
    pub fn set_or_clear_last_token_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_token_request_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.User"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for User {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __last_token_request_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for User")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "lastTokenRequestTime" => Ok(__FieldTag::__last_token_request_time),
                            "last_token_request_time" => Ok(__FieldTag::__last_token_request_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = User;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct User")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_token_request_time => {
                            if !fields.insert(__FieldTag::__last_token_request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_token_request_time",
                                ));
                            }
                            result.last_token_request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for User {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.last_token_request_time.is_some() {
            state.serialize_entry("lastTokenRequestTime", &self.last_token_request_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ProviderOAuthConfig is the OAuth config for a provider.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProviderOAuthConfig {
    /// Required. User selected scopes to apply to the Oauth config
    /// In the event of changing scopes, user records under AccountConnector will
    /// be deleted and users will re-auth again.
    pub scopes: std::vec::Vec<std::string::String>,

    /// OAuth Provider ID. It could be Developer Connect owned or providers
    /// provided.
    pub oauth_provider_id:
        std::option::Option<crate::model::provider_o_auth_config::OauthProviderId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProviderOAuthConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scopes][crate::model::ProviderOAuthConfig::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [oauth_provider_id][crate::model::ProviderOAuthConfig::oauth_provider_id].
    ///
    /// Note that all the setters affecting `oauth_provider_id` are mutually
    /// exclusive.
    pub fn set_oauth_provider_id<
        T: std::convert::Into<
                std::option::Option<crate::model::provider_o_auth_config::OauthProviderId>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_provider_id = v.into();
        self
    }

    /// The value of [oauth_provider_id][crate::model::ProviderOAuthConfig::oauth_provider_id]
    /// if it holds a `SystemProviderId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn system_provider_id(&self) -> std::option::Option<&crate::model::SystemProvider> {
        #[allow(unreachable_patterns)]
        self.oauth_provider_id.as_ref().and_then(|v| match v {
            crate::model::provider_o_auth_config::OauthProviderId::SystemProviderId(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [oauth_provider_id][crate::model::ProviderOAuthConfig::oauth_provider_id]
    /// to hold a `SystemProviderId`.
    ///
    /// Note that all the setters affecting `oauth_provider_id` are
    /// mutually exclusive.
    pub fn set_system_provider_id<T: std::convert::Into<crate::model::SystemProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_provider_id = std::option::Option::Some(
            crate::model::provider_o_auth_config::OauthProviderId::SystemProviderId(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ProviderOAuthConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ProviderOAuthConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProviderOAuthConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __system_provider_id,
            __scopes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProviderOAuthConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "systemProviderId" => Ok(__FieldTag::__system_provider_id),
                            "system_provider_id" => Ok(__FieldTag::__system_provider_id),
                            "scopes" => Ok(__FieldTag::__scopes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProviderOAuthConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProviderOAuthConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__system_provider_id => {
                            if !fields.insert(__FieldTag::__system_provider_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system_provider_id",
                                ));
                            }
                            if result.oauth_provider_id.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `oauth_provider_id`, a oneof with full ID .google.cloud.developerconnect.v1.ProviderOAuthConfig.system_provider_id, latest field was systemProviderId",
                                ));
                            }
                            result.oauth_provider_id = std::option::Option::Some(
                                crate::model::provider_o_auth_config::OauthProviderId::SystemProviderId(
                                    map.next_value::<std::option::Option<crate::model::SystemProvider>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scopes",
                                ));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProviderOAuthConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.system_provider_id() {
            state.serialize_entry("systemProviderId", value)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ProviderOAuthConfig].
pub mod provider_o_auth_config {
    #[allow(unused_imports)]
    use super::*;

    /// OAuth Provider ID. It could be Developer Connect owned or providers
    /// provided.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OauthProviderId {
        /// Immutable. Developer Connect provided OAuth.
        SystemProviderId(crate::model::SystemProvider),
    }
}

/// The InsightsConfig resource is the core configuration object to capture
/// events from your Software Development Lifecycle. It acts as the central hub
/// for managing how Developer connect understands your application, its runtime
/// environments, and the artifacts deployed within them.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InsightsConfig {
    /// Identifier. The name of the InsightsConfig.
    /// Format:
    /// projects/{project}/locations/{location}/insightsConfigs/{insightsConfig}
    pub name: std::string::String,

    /// Output only. [Output only] Create timestamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The runtime configurations where the application is deployed.
    pub runtime_configs: std::vec::Vec<crate::model::RuntimeConfig>,

    /// Optional. The artifact configurations of the artifacts that are deployed.
    pub artifact_configs: std::vec::Vec<crate::model::ArtifactConfig>,

    /// Optional. Output only. The state of the InsightsConfig.
    pub state: crate::model::insights_config::State,

    /// Optional. User specified annotations. See
    /// <https://google.aip.dev/148#annotations> for more details such as format and
    /// size limitations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Set of labels associated with an InsightsConfig.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of InsightsConfig does not match the
    /// user's intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    pub reconciling: bool,

    /// Output only. Any errors that occurred while setting up the InsightsConfig.
    /// Each error will be in the format: `field_name: error_message`, e.g.
    /// GetAppHubApplication: Permission denied while getting App Hub
    /// application. Please grant permissions to the P4SA.
    pub errors: std::vec::Vec<rpc::model::Status>,

    /// The context of the InsightsConfig.
    pub insights_config_context:
        std::option::Option<crate::model::insights_config::InsightsConfigContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InsightsConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::InsightsConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::InsightsConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::InsightsConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::InsightsConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [runtime_configs][crate::model::InsightsConfig::runtime_configs].
    pub fn set_runtime_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuntimeConfig>,
    {
        use std::iter::Iterator;
        self.runtime_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [artifact_configs][crate::model::InsightsConfig::artifact_configs].
    pub fn set_artifact_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ArtifactConfig>,
    {
        use std::iter::Iterator;
        self.artifact_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::InsightsConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::insights_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::InsightsConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::InsightsConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [reconciling][crate::model::InsightsConfig::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::InsightsConfig::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [insights_config_context][crate::model::InsightsConfig::insights_config_context].
    ///
    /// Note that all the setters affecting `insights_config_context` are mutually
    /// exclusive.
    pub fn set_insights_config_context<
        T: std::convert::Into<
                std::option::Option<crate::model::insights_config::InsightsConfigContext>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.insights_config_context = v.into();
        self
    }

    /// The value of [insights_config_context][crate::model::InsightsConfig::insights_config_context]
    /// if it holds a `AppHubApplication`, `None` if the field is not set or
    /// holds a different branch.
    pub fn app_hub_application(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.insights_config_context.as_ref().and_then(|v| match v {
            crate::model::insights_config::InsightsConfigContext::AppHubApplication(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [insights_config_context][crate::model::InsightsConfig::insights_config_context]
    /// to hold a `AppHubApplication`.
    ///
    /// Note that all the setters affecting `insights_config_context` are
    /// mutually exclusive.
    pub fn set_app_hub_application<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.insights_config_context = std::option::Option::Some(
            crate::model::insights_config::InsightsConfigContext::AppHubApplication(v.into()),
        );
        self
    }
}

impl wkt::message::Message for InsightsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.InsightsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsightsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __app_hub_application,
            __name,
            __create_time,
            __update_time,
            __runtime_configs,
            __artifact_configs,
            __state,
            __annotations,
            __labels,
            __reconciling,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsightsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "appHubApplication" => Ok(__FieldTag::__app_hub_application),
                            "app_hub_application" => Ok(__FieldTag::__app_hub_application),
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "runtimeConfigs" => Ok(__FieldTag::__runtime_configs),
                            "runtime_configs" => Ok(__FieldTag::__runtime_configs),
                            "artifactConfigs" => Ok(__FieldTag::__artifact_configs),
                            "artifact_configs" => Ok(__FieldTag::__artifact_configs),
                            "state" => Ok(__FieldTag::__state),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsightsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsightsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__app_hub_application => {
                            if !fields.insert(__FieldTag::__app_hub_application) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_hub_application",
                                ));
                            }
                            if result.insights_config_context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `insights_config_context`, a oneof with full ID .google.cloud.developerconnect.v1.InsightsConfig.app_hub_application, latest field was appHubApplication",
                                ));
                            }
                            result.insights_config_context = std::option::Option::Some(
                                crate::model::insights_config::InsightsConfigContext::AppHubApplication(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__runtime_configs => {
                            if !fields.insert(__FieldTag::__runtime_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_configs",
                                ));
                            }
                            result.runtime_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RuntimeConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__artifact_configs => {
                            if !fields.insert(__FieldTag::__artifact_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_configs",
                                ));
                            }
                            result.artifact_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ArtifactConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::insights_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsightsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.app_hub_application() {
            state.serialize_entry("appHubApplication", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.runtime_configs.is_empty() {
            state.serialize_entry("runtimeConfigs", &self.runtime_configs)?;
        }
        if !self.artifact_configs.is_empty() {
            state.serialize_entry("artifactConfigs", &self.artifact_configs)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InsightsConfig].
pub mod insights_config {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the InsightsConfig.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// No state specified.
        Unspecified,
        /// The InsightsConfig is pending application discovery/runtime discovery.
        Pending,
        /// The initial discovery process is complete.
        Complete,
        /// The InsightsConfig is in an error state.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(5),
                Self::Complete => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                3 => Self::Complete,
                4 => Self::Error,
                5 => Self::Pending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "COMPLETE" => Self::Complete,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(5),
                Self::Complete => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.developerconnect.v1.InsightsConfig.State",
            ))
        }
    }

    /// The context of the InsightsConfig.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InsightsConfigContext {
        /// Optional. The name of the App Hub Application.
        /// Format:
        /// projects/{project}/locations/{location}/applications/{application}
        AppHubApplication(std::string::String),
    }
}

/// RuntimeConfig represents the runtimes where the application is
/// deployed.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeConfig {
    /// Required. Immutable. The URI of the runtime configuration.
    /// For GKE, this is the cluster name.
    /// For Cloud Run, this is the service name.
    pub uri: std::string::String,

    /// Output only. The state of the Runtime.
    pub state: crate::model::runtime_config::State,

    /// The type of the runtime.
    pub runtime: std::option::Option<crate::model::runtime_config::Runtime>,

    /// Where the runtime is derived from.
    pub derived_from: std::option::Option<crate::model::runtime_config::DerivedFrom>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::RuntimeConfig::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RuntimeConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::runtime_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [runtime][crate::model::RuntimeConfig::runtime].
    ///
    /// Note that all the setters affecting `runtime` are mutually
    /// exclusive.
    pub fn set_runtime<
        T: std::convert::Into<std::option::Option<crate::model::runtime_config::Runtime>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime = v.into();
        self
    }

    /// The value of [runtime][crate::model::RuntimeConfig::runtime]
    /// if it holds a `GkeWorkload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke_workload(&self) -> std::option::Option<&std::boxed::Box<crate::model::GKEWorkload>> {
        #[allow(unreachable_patterns)]
        self.runtime.as_ref().and_then(|v| match v {
            crate::model::runtime_config::Runtime::GkeWorkload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [runtime][crate::model::RuntimeConfig::runtime]
    /// to hold a `GkeWorkload`.
    ///
    /// Note that all the setters affecting `runtime` are
    /// mutually exclusive.
    pub fn set_gke_workload<T: std::convert::Into<std::boxed::Box<crate::model::GKEWorkload>>>(
        mut self,
        v: T,
    ) -> Self {
        self.runtime =
            std::option::Option::Some(crate::model::runtime_config::Runtime::GkeWorkload(v.into()));
        self
    }

    /// Sets the value of [derived_from][crate::model::RuntimeConfig::derived_from].
    ///
    /// Note that all the setters affecting `derived_from` are mutually
    /// exclusive.
    pub fn set_derived_from<
        T: std::convert::Into<std::option::Option<crate::model::runtime_config::DerivedFrom>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.derived_from = v.into();
        self
    }

    /// The value of [derived_from][crate::model::RuntimeConfig::derived_from]
    /// if it holds a `AppHubWorkload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn app_hub_workload(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AppHubWorkload>> {
        #[allow(unreachable_patterns)]
        self.derived_from.as_ref().and_then(|v| match v {
            crate::model::runtime_config::DerivedFrom::AppHubWorkload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [derived_from][crate::model::RuntimeConfig::derived_from]
    /// to hold a `AppHubWorkload`.
    ///
    /// Note that all the setters affecting `derived_from` are
    /// mutually exclusive.
    pub fn set_app_hub_workload<
        T: std::convert::Into<std::boxed::Box<crate::model::AppHubWorkload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.derived_from = std::option::Option::Some(
            crate::model::runtime_config::DerivedFrom::AppHubWorkload(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RuntimeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.RuntimeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gke_workload,
            __app_hub_workload,
            __uri,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gkeWorkload" => Ok(__FieldTag::__gke_workload),
                            "gke_workload" => Ok(__FieldTag::__gke_workload),
                            "appHubWorkload" => Ok(__FieldTag::__app_hub_workload),
                            "app_hub_workload" => Ok(__FieldTag::__app_hub_workload),
                            "uri" => Ok(__FieldTag::__uri),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gke_workload => {
                            if !fields.insert(__FieldTag::__gke_workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_workload",
                                ));
                            }
                            if result.runtime.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `runtime`, a oneof with full ID .google.cloud.developerconnect.v1.RuntimeConfig.gke_workload, latest field was gkeWorkload",
                                ));
                            }
                            result.runtime = std::option::Option::Some(
                                crate::model::runtime_config::Runtime::GkeWorkload(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GKEWorkload>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__app_hub_workload => {
                            if !fields.insert(__FieldTag::__app_hub_workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_hub_workload",
                                ));
                            }
                            if result.derived_from.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `derived_from`, a oneof with full ID .google.cloud.developerconnect.v1.RuntimeConfig.app_hub_workload, latest field was appHubWorkload",
                                ));
                            }
                            result.derived_from = std::option::Option::Some(
                                crate::model::runtime_config::DerivedFrom::AppHubWorkload(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AppHubWorkload>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::runtime_config::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gke_workload() {
            state.serialize_entry("gkeWorkload", value)?;
        }
        if let Some(value) = self.app_hub_workload() {
            state.serialize_entry("appHubWorkload", value)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RuntimeConfig].
pub mod runtime_config {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the runtime in the InsightsConfig.
    /// Whether the runtime is linked to the InsightsConfig.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// No state specified.
        Unspecified,
        /// The runtime configuration has been linked to the InsightsConfig.
        Linked,
        /// The runtime configuration has been unlinked to the InsightsConfig.
        Unlinked,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Linked => std::option::Option::Some(1),
                Self::Unlinked => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Linked => std::option::Option::Some("LINKED"),
                Self::Unlinked => std::option::Option::Some("UNLINKED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Linked,
                2 => Self::Unlinked,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "LINKED" => Self::Linked,
                "UNLINKED" => Self::Unlinked,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Linked => serializer.serialize_i32(1),
                Self::Unlinked => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.developerconnect.v1.RuntimeConfig.State",
            ))
        }
    }

    /// The type of the runtime.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Runtime {
        /// Output only. Google Kubernetes Engine runtime.
        GkeWorkload(std::boxed::Box<crate::model::GKEWorkload>),
    }

    /// Where the runtime is derived from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DerivedFrom {
        /// Output only. App Hub Workload.
        AppHubWorkload(std::boxed::Box<crate::model::AppHubWorkload>),
    }
}

/// GKEWorkload represents the Google Kubernetes Engine runtime.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GKEWorkload {
    /// Required. Immutable. The name of the GKE cluster.
    /// Format:
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    pub cluster: std::string::String,

    /// Output only. The name of the GKE deployment.
    /// Format:
    /// `projects/{project}/locations/{location}/clusters/{cluster}/namespaces/{namespace}/deployments/{deployment}`.
    pub deployment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GKEWorkload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GKEWorkload::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [deployment][crate::model::GKEWorkload::deployment].
    pub fn set_deployment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deployment = v.into();
        self
    }
}

impl wkt::message::Message for GKEWorkload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GKEWorkload"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GKEWorkload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            __deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GKEWorkload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            "deployment" => Ok(__FieldTag::__deployment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GKEWorkload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GKEWorkload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            result.deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GKEWorkload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.deployment.is_empty() {
            state.serialize_entry("deployment", &self.deployment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// AppHubWorkload represents the App Hub Workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AppHubWorkload {
    /// Required. Output only. Immutable. The name of the App Hub Workload.
    /// Format:
    /// `projects/{project}/locations/{location}/applications/{application}/workloads/{workload}`.
    pub workload: std::string::String,

    /// Output only. The criticality of the App Hub Workload.
    pub criticality: std::string::String,

    /// Output only. The environment of the App Hub Workload.
    pub environment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppHubWorkload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workload][crate::model::AppHubWorkload::workload].
    pub fn set_workload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload = v.into();
        self
    }

    /// Sets the value of [criticality][crate::model::AppHubWorkload::criticality].
    pub fn set_criticality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.criticality = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::AppHubWorkload::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

impl wkt::message::Message for AppHubWorkload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.AppHubWorkload"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppHubWorkload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workload,
            __criticality,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppHubWorkload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workload" => Ok(__FieldTag::__workload),
                            "criticality" => Ok(__FieldTag::__criticality),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppHubWorkload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppHubWorkload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workload => {
                            if !fields.insert(__FieldTag::__workload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload",
                                ));
                            }
                            result.workload = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__criticality => {
                            if !fields.insert(__FieldTag::__criticality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for criticality",
                                ));
                            }
                            result.criticality = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppHubWorkload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workload.is_empty() {
            state.serialize_entry("workload", &self.workload)?;
        }
        if !self.criticality.is_empty() {
            state.serialize_entry("criticality", &self.criticality)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The artifact config of the artifact that is deployed.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ArtifactConfig {
    /// Required. Immutable. The URI of the artifact that is deployed.
    /// e.g. `us-docker.pkg.dev/my-project/my-repo/image`.
    /// The URI does not include the tag / digest because it captures a lineage of
    /// artifacts.
    pub uri: std::string::String,

    /// The storage location of the artifact.
    pub artifact_storage: std::option::Option<crate::model::artifact_config::ArtifactStorage>,

    /// The storage location of the artifact metadata.
    pub artifact_metadata_storage:
        std::option::Option<crate::model::artifact_config::ArtifactMetadataStorage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ArtifactConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ArtifactConfig::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [artifact_storage][crate::model::ArtifactConfig::artifact_storage].
    ///
    /// Note that all the setters affecting `artifact_storage` are mutually
    /// exclusive.
    pub fn set_artifact_storage<
        T: std::convert::Into<std::option::Option<crate::model::artifact_config::ArtifactStorage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = v.into();
        self
    }

    /// The value of [artifact_storage][crate::model::ArtifactConfig::artifact_storage]
    /// if it holds a `GoogleArtifactRegistry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_artifact_registry(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleArtifactRegistry>> {
        #[allow(unreachable_patterns)]
        self.artifact_storage.as_ref().and_then(|v| match v {
            crate::model::artifact_config::ArtifactStorage::GoogleArtifactRegistry(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [artifact_storage][crate::model::ArtifactConfig::artifact_storage]
    /// to hold a `GoogleArtifactRegistry`.
    ///
    /// Note that all the setters affecting `artifact_storage` are
    /// mutually exclusive.
    pub fn set_google_artifact_registry<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleArtifactRegistry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_storage = std::option::Option::Some(
            crate::model::artifact_config::ArtifactStorage::GoogleArtifactRegistry(v.into()),
        );
        self
    }

    /// Sets the value of [artifact_metadata_storage][crate::model::ArtifactConfig::artifact_metadata_storage].
    ///
    /// Note that all the setters affecting `artifact_metadata_storage` are mutually
    /// exclusive.
    pub fn set_artifact_metadata_storage<
        T: std::convert::Into<
                std::option::Option<crate::model::artifact_config::ArtifactMetadataStorage>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_metadata_storage = v.into();
        self
    }

    /// The value of [artifact_metadata_storage][crate::model::ArtifactConfig::artifact_metadata_storage]
    /// if it holds a `GoogleArtifactAnalysis`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_artifact_analysis(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GoogleArtifactAnalysis>> {
        #[allow(unreachable_patterns)]
        self.artifact_metadata_storage
            .as_ref()
            .and_then(|v| match v {
                crate::model::artifact_config::ArtifactMetadataStorage::GoogleArtifactAnalysis(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
    }

    /// Sets the value of [artifact_metadata_storage][crate::model::ArtifactConfig::artifact_metadata_storage]
    /// to hold a `GoogleArtifactAnalysis`.
    ///
    /// Note that all the setters affecting `artifact_metadata_storage` are
    /// mutually exclusive.
    pub fn set_google_artifact_analysis<
        T: std::convert::Into<std::boxed::Box<crate::model::GoogleArtifactAnalysis>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_metadata_storage = std::option::Option::Some(
            crate::model::artifact_config::ArtifactMetadataStorage::GoogleArtifactAnalysis(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ArtifactConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ArtifactConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ArtifactConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __google_artifact_registry,
            __google_artifact_analysis,
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArtifactConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "googleArtifactRegistry" => Ok(__FieldTag::__google_artifact_registry),
                            "google_artifact_registry" => {
                                Ok(__FieldTag::__google_artifact_registry)
                            }
                            "googleArtifactAnalysis" => Ok(__FieldTag::__google_artifact_analysis),
                            "google_artifact_analysis" => {
                                Ok(__FieldTag::__google_artifact_analysis)
                            }
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ArtifactConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArtifactConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__google_artifact_registry => {
                            if !fields.insert(__FieldTag::__google_artifact_registry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_artifact_registry",
                                ));
                            }
                            if result.artifact_storage.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `artifact_storage`, a oneof with full ID .google.cloud.developerconnect.v1.ArtifactConfig.google_artifact_registry, latest field was googleArtifactRegistry",
                                ));
                            }
                            result.artifact_storage = std::option::Option::Some(
                                crate::model::artifact_config::ArtifactStorage::GoogleArtifactRegistry(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GoogleArtifactRegistry>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__google_artifact_analysis => {
                            if !fields.insert(__FieldTag::__google_artifact_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_artifact_analysis",
                                ));
                            }
                            if result.artifact_metadata_storage.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `artifact_metadata_storage`, a oneof with full ID .google.cloud.developerconnect.v1.ArtifactConfig.google_artifact_analysis, latest field was googleArtifactAnalysis",
                                ));
                            }
                            result.artifact_metadata_storage = std::option::Option::Some(
                                crate::model::artifact_config::ArtifactMetadataStorage::GoogleArtifactAnalysis(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GoogleArtifactAnalysis>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ArtifactConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.google_artifact_registry() {
            state.serialize_entry("googleArtifactRegistry", value)?;
        }
        if let Some(value) = self.google_artifact_analysis() {
            state.serialize_entry("googleArtifactAnalysis", value)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ArtifactConfig].
pub mod artifact_config {
    #[allow(unused_imports)]
    use super::*;

    /// The storage location of the artifact.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ArtifactStorage {
        /// Optional. Set if the artifact is stored in Artifact registry.
        GoogleArtifactRegistry(std::boxed::Box<crate::model::GoogleArtifactRegistry>),
    }

    /// The storage location of the artifact metadata.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ArtifactMetadataStorage {
        /// Optional. Set if the artifact metadata is stored in Artifact analysis.
        GoogleArtifactAnalysis(std::boxed::Box<crate::model::GoogleArtifactAnalysis>),
    }
}

/// Google Artifact Analysis configurations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleArtifactAnalysis {
    /// Required. The project id of the project where the provenance is stored.
    pub project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleArtifactAnalysis {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GoogleArtifactAnalysis::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }
}

impl wkt::message::Message for GoogleArtifactAnalysis {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GoogleArtifactAnalysis"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleArtifactAnalysis {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleArtifactAnalysis")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleArtifactAnalysis;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleArtifactAnalysis")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleArtifactAnalysis {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Google Artifact Registry configurations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GoogleArtifactRegistry {
    /// Required. The host project of Artifact Registry.
    pub project_id: std::string::String,

    /// Required. Immutable. The name of the artifact registry package.
    pub artifact_registry_package: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GoogleArtifactRegistry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GoogleArtifactRegistry::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [artifact_registry_package][crate::model::GoogleArtifactRegistry::artifact_registry_package].
    pub fn set_artifact_registry_package<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.artifact_registry_package = v.into();
        self
    }
}

impl wkt::message::Message for GoogleArtifactRegistry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GoogleArtifactRegistry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GoogleArtifactRegistry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __artifact_registry_package,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GoogleArtifactRegistry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "artifactRegistryPackage" => {
                                Ok(__FieldTag::__artifact_registry_package)
                            }
                            "artifact_registry_package" => {
                                Ok(__FieldTag::__artifact_registry_package)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GoogleArtifactRegistry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GoogleArtifactRegistry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__artifact_registry_package => {
                            if !fields.insert(__FieldTag::__artifact_registry_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for artifact_registry_package",
                                ));
                            }
                            result.artifact_registry_package = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GoogleArtifactRegistry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.artifact_registry_package.is_empty() {
            state.serialize_entry("artifactRegistryPackage", &self.artifact_registry_package)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for creating an InsightsConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInsightsConfigRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the requesting InsightsConfig.
    pub insights_config_id: std::string::String,

    /// Required. The resource being created.
    pub insights_config: std::option::Option<crate::model::InsightsConfig>,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInsightsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInsightsConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [insights_config_id][crate::model::CreateInsightsConfigRequest::insights_config_id].
    pub fn set_insights_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.insights_config_id = v.into();
        self
    }

    /// Sets the value of [insights_config][crate::model::CreateInsightsConfigRequest::insights_config].
    pub fn set_insights_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightsConfig>,
    {
        self.insights_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insights_config][crate::model::CreateInsightsConfigRequest::insights_config].
    pub fn set_or_clear_insights_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightsConfig>,
    {
        self.insights_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateInsightsConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateInsightsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CreateInsightsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInsightsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __insights_config_id,
            __insights_config,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInsightsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "insightsConfigId" => Ok(__FieldTag::__insights_config_id),
                            "insights_config_id" => Ok(__FieldTag::__insights_config_id),
                            "insightsConfig" => Ok(__FieldTag::__insights_config),
                            "insights_config" => Ok(__FieldTag::__insights_config),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInsightsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInsightsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insights_config_id => {
                            if !fields.insert(__FieldTag::__insights_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights_config_id",
                                ));
                            }
                            result.insights_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insights_config => {
                            if !fields.insert(__FieldTag::__insights_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights_config",
                                ));
                            }
                            result.insights_config = map
                                .next_value::<std::option::Option<crate::model::InsightsConfig>>(
                                )?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInsightsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.insights_config_id.is_empty() {
            state.serialize_entry("insightsConfigId", &self.insights_config_id)?;
        }
        if self.insights_config.is_some() {
            state.serialize_entry("insightsConfig", &self.insights_config)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for getting an InsightsConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInsightsConfigRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInsightsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInsightsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInsightsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GetInsightsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInsightsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInsightsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInsightsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInsightsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInsightsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for requesting list of InsightsConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInsightsConfigsRequest {
    /// Required. Parent value for ListInsightsConfigsRequest.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results. See <https://google.aip.dev/160> for more
    /// details. Filter string, adhering to the rules in
    /// <https://google.aip.dev/160>. List only InsightsConfigs matching the filter.
    /// If filter is empty, all InsightsConfigs are listed.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInsightsConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInsightsConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInsightsConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInsightsConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInsightsConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInsightsConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInsightsConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListInsightsConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInsightsConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInsightsConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInsightsConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInsightsConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInsightsConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for response to listing InsightsConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInsightsConfigsResponse {
    /// The list of InsightsConfigs.
    pub insights_configs: std::vec::Vec<crate::model::InsightsConfig>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInsightsConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insights_configs][crate::model::ListInsightsConfigsResponse::insights_configs].
    pub fn set_insights_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InsightsConfig>,
    {
        use std::iter::Iterator;
        self.insights_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInsightsConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInsightsConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInsightsConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListInsightsConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInsightsConfigsResponse {
    type PageItem = crate::model::InsightsConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.insights_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInsightsConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __insights_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInsightsConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insightsConfigs" => Ok(__FieldTag::__insights_configs),
                            "insights_configs" => Ok(__FieldTag::__insights_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInsightsConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInsightsConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__insights_configs => {
                            if !fields.insert(__FieldTag::__insights_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights_configs",
                                ));
                            }
                            result.insights_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InsightsConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInsightsConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.insights_configs.is_empty() {
            state.serialize_entry("insightsConfigs", &self.insights_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for deleting an InsightsConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInsightsConfigRequest {
    /// Required. Value for parent.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInsightsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInsightsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInsightsConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteInsightsConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInsightsConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInsightsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteInsightsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInsightsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInsightsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInsightsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInsightsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInsightsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for updating an InsightsConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInsightsConfigRequest {
    /// Required. The resource being updated.
    pub insights_config: std::option::Option<crate::model::InsightsConfig>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, and the insightsConfig is not found a new
    /// insightsConfig will be created. In this situation `update_mask` is ignored.
    /// The creation will succeed only if the input insightsConfig has all the
    /// necessary information (e.g a github_config with both  user_oauth_token and
    /// installation_id properties).
    pub allow_missing: bool,

    /// Optional. If set, validate the request, but do not actually post it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInsightsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insights_config][crate::model::UpdateInsightsConfigRequest::insights_config].
    pub fn set_insights_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightsConfig>,
    {
        self.insights_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insights_config][crate::model::UpdateInsightsConfigRequest::insights_config].
    pub fn set_or_clear_insights_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightsConfig>,
    {
        self.insights_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInsightsConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateInsightsConfigRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInsightsConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInsightsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.UpdateInsightsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInsightsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __insights_config,
            __request_id,
            __allow_missing,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInsightsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insightsConfig" => Ok(__FieldTag::__insights_config),
                            "insights_config" => Ok(__FieldTag::__insights_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInsightsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInsightsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__insights_config => {
                            if !fields.insert(__FieldTag::__insights_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights_config",
                                ));
                            }
                            result.insights_config = map
                                .next_value::<std::option::Option<crate::model::InsightsConfig>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInsightsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.insights_config.is_some() {
            state.serialize_entry("insightsConfig", &self.insights_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SystemProvider is a list of providers that are owned by Developer Connect.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SystemProvider {
    /// No system provider specified.
    Unspecified,
    /// GitHub provider.
    /// Scopes can be found at
    /// <https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps#available-scopes>
    Github,
    /// GitLab provider.
    /// Scopes can be found at
    /// <https://docs.gitlab.com/user/profile/personal_access_tokens/#personal-access-token-scopes>
    Gitlab,
    /// Google provider.
    /// Recommended scopes:
    /// `https://www.googleapis.com/auth/drive.readonly`,
    /// `https://www.googleapis.com/auth/documents.readonly`
    Google,
    /// Sentry provider.
    /// Scopes can be found at
    /// <https://docs.sentry.io/api/permissions/>
    Sentry,
    /// Rovo provider.
    /// Must select the "rovo" scope.
    Rovo,
    /// New Relic provider.
    /// No scopes are allowed.
    NewRelic,
    /// Datastax provider.
    /// No scopes are allowed.
    Datastax,
    /// Dynatrace provider.
    Dynatrace,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SystemProvider::value] or
    /// [SystemProvider::name].
    UnknownValue(system_provider::UnknownValue),
}

#[doc(hidden)]
pub mod system_provider {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SystemProvider {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Github => std::option::Option::Some(1),
            Self::Gitlab => std::option::Option::Some(2),
            Self::Google => std::option::Option::Some(3),
            Self::Sentry => std::option::Option::Some(4),
            Self::Rovo => std::option::Option::Some(5),
            Self::NewRelic => std::option::Option::Some(6),
            Self::Datastax => std::option::Option::Some(7),
            Self::Dynatrace => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SYSTEM_PROVIDER_UNSPECIFIED"),
            Self::Github => std::option::Option::Some("GITHUB"),
            Self::Gitlab => std::option::Option::Some("GITLAB"),
            Self::Google => std::option::Option::Some("GOOGLE"),
            Self::Sentry => std::option::Option::Some("SENTRY"),
            Self::Rovo => std::option::Option::Some("ROVO"),
            Self::NewRelic => std::option::Option::Some("NEW_RELIC"),
            Self::Datastax => std::option::Option::Some("DATASTAX"),
            Self::Dynatrace => std::option::Option::Some("DYNATRACE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SystemProvider {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SystemProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SystemProvider {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Github,
            2 => Self::Gitlab,
            3 => Self::Google,
            4 => Self::Sentry,
            5 => Self::Rovo,
            6 => Self::NewRelic,
            7 => Self::Datastax,
            8 => Self::Dynatrace,
            _ => Self::UnknownValue(system_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SystemProvider {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SYSTEM_PROVIDER_UNSPECIFIED" => Self::Unspecified,
            "GITHUB" => Self::Github,
            "GITLAB" => Self::Gitlab,
            "GOOGLE" => Self::Google,
            "SENTRY" => Self::Sentry,
            "ROVO" => Self::Rovo,
            "NEW_RELIC" => Self::NewRelic,
            "DATASTAX" => Self::Datastax,
            "DYNATRACE" => Self::Dynatrace,
            _ => Self::UnknownValue(system_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SystemProvider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Github => serializer.serialize_i32(1),
            Self::Gitlab => serializer.serialize_i32(2),
            Self::Google => serializer.serialize_i32(3),
            Self::Sentry => serializer.serialize_i32(4),
            Self::Rovo => serializer.serialize_i32(5),
            Self::NewRelic => serializer.serialize_i32(6),
            Self::Datastax => serializer.serialize_i32(7),
            Self::Dynatrace => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SystemProvider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SystemProvider>::new(
            ".google.cloud.developerconnect.v1.SystemProvider",
        ))
    }
}
