// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents an access event.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Access {
    /// Associated email, such as "foo@google.com".
    ///
    /// The email address of the authenticated user or a service account acting on
    /// behalf of a third party principal making the request. For third party
    /// identity callers, the `principal_subject` field is populated instead of
    /// this field. For privacy reasons, the principal email address is sometimes
    /// redacted. For more information, see [Caller identities in audit
    /// logs](https://cloud.google.com/logging/docs/audit#user-id).
    pub principal_email: std::string::String,

    /// Caller's IP address, such as "1.1.1.1".
    pub caller_ip: std::string::String,

    /// The caller IP's geolocation, which identifies where the call came from.
    pub caller_ip_geo: std::option::Option<crate::model::Geolocation>,

    /// Type of user agent associated with the finding. For example, an operating
    /// system shell or an embedded or standalone application.
    pub user_agent_family: std::string::String,

    /// The caller's user agent string associated with the finding.
    pub user_agent: std::string::String,

    /// This is the API service that the service account made a call to, e.g.
    /// "iam.googleapis.com"
    pub service_name: std::string::String,

    /// The method that the service account called, e.g. "SetIamPolicy".
    pub method_name: std::string::String,

    /// A string that represents the principal_subject that is associated with the
    /// identity. Unlike `principal_email`, `principal_subject` supports principals
    /// that aren't associated with email addresses, such as third party
    /// principals. For most identities, the format is
    /// `principal://iam.googleapis.com/{identity pool name}/subject/{subject}`.
    /// Some GKE identities, such as GKE_WORKLOAD, FREEFORM, and GKE_HUB_WORKLOAD,
    /// still use the legacy format `serviceAccount:{identity pool
    /// name}[{subject}]`.
    pub principal_subject: std::string::String,

    /// The name of the service account key that was used to create or exchange
    /// credentials when authenticating the service account that made the request.
    /// This is a scheme-less URI full resource name. For example:
    ///
    /// "//iam.googleapis.com/projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}".
    pub service_account_key_name: std::string::String,

    /// The identity delegation history of an authenticated service account that
    /// made the request. The `serviceAccountDelegationInfo[]` object contains
    /// information about the real authorities that try to access Google Cloud
    /// resources by delegating on a service account. When multiple authorities are
    /// present, they are guaranteed to be sorted based on the original ordering of
    /// the identity delegation events.
    pub service_account_delegation_info: std::vec::Vec<crate::model::ServiceAccountDelegationInfo>,

    /// A string that represents a username. The username provided depends on the
    /// type of the finding and is likely not an IAM principal. For example, this
    /// can be a system username if the finding is related to a virtual machine, or
    /// it can be an application login username.
    pub user_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Access {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal_email][crate::model::Access::principal_email].
    pub fn set_principal_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal_email = v.into();
        self
    }

    /// Sets the value of [caller_ip][crate::model::Access::caller_ip].
    pub fn set_caller_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.caller_ip = v.into();
        self
    }

    /// Sets the value of [caller_ip_geo][crate::model::Access::caller_ip_geo].
    pub fn set_caller_ip_geo<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Geolocation>,
    {
        self.caller_ip_geo = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [caller_ip_geo][crate::model::Access::caller_ip_geo].
    pub fn set_or_clear_caller_ip_geo<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Geolocation>,
    {
        self.caller_ip_geo = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_agent_family][crate::model::Access::user_agent_family].
    pub fn set_user_agent_family<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_agent_family = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::Access::user_agent].
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [service_name][crate::model::Access::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::Access::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [principal_subject][crate::model::Access::principal_subject].
    pub fn set_principal_subject<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal_subject = v.into();
        self
    }

    /// Sets the value of [service_account_key_name][crate::model::Access::service_account_key_name].
    pub fn set_service_account_key_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_key_name = v.into();
        self
    }

    /// Sets the value of [service_account_delegation_info][crate::model::Access::service_account_delegation_info].
    pub fn set_service_account_delegation_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccountDelegationInfo>,
    {
        use std::iter::Iterator;
        self.service_account_delegation_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_name][crate::model::Access::user_name].
    pub fn set_user_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_name = v.into();
        self
    }
}

impl wkt::message::Message for Access {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Access"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Access {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __principal_email,
            __caller_ip,
            __caller_ip_geo,
            __user_agent_family,
            __user_agent,
            __service_name,
            __method_name,
            __principal_subject,
            __service_account_key_name,
            __service_account_delegation_info,
            __user_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Access")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "principalEmail" => Ok(__FieldTag::__principal_email),
                            "principal_email" => Ok(__FieldTag::__principal_email),
                            "callerIp" => Ok(__FieldTag::__caller_ip),
                            "caller_ip" => Ok(__FieldTag::__caller_ip),
                            "callerIpGeo" => Ok(__FieldTag::__caller_ip_geo),
                            "caller_ip_geo" => Ok(__FieldTag::__caller_ip_geo),
                            "userAgentFamily" => Ok(__FieldTag::__user_agent_family),
                            "user_agent_family" => Ok(__FieldTag::__user_agent_family),
                            "userAgent" => Ok(__FieldTag::__user_agent),
                            "user_agent" => Ok(__FieldTag::__user_agent),
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "methodName" => Ok(__FieldTag::__method_name),
                            "method_name" => Ok(__FieldTag::__method_name),
                            "principalSubject" => Ok(__FieldTag::__principal_subject),
                            "principal_subject" => Ok(__FieldTag::__principal_subject),
                            "serviceAccountKeyName" => Ok(__FieldTag::__service_account_key_name),
                            "service_account_key_name" => {
                                Ok(__FieldTag::__service_account_key_name)
                            }
                            "serviceAccountDelegationInfo" => {
                                Ok(__FieldTag::__service_account_delegation_info)
                            }
                            "service_account_delegation_info" => {
                                Ok(__FieldTag::__service_account_delegation_info)
                            }
                            "userName" => Ok(__FieldTag::__user_name),
                            "user_name" => Ok(__FieldTag::__user_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Access;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Access")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__principal_email => {
                            if !fields.insert(__FieldTag::__principal_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_email",
                                ));
                            }
                            result.principal_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__caller_ip => {
                            if !fields.insert(__FieldTag::__caller_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for caller_ip",
                                ));
                            }
                            result.caller_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__caller_ip_geo => {
                            if !fields.insert(__FieldTag::__caller_ip_geo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for caller_ip_geo",
                                ));
                            }
                            result.caller_ip_geo =
                                map.next_value::<std::option::Option<crate::model::Geolocation>>()?;
                        }
                        __FieldTag::__user_agent_family => {
                            if !fields.insert(__FieldTag::__user_agent_family) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_agent_family",
                                ));
                            }
                            result.user_agent_family = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_agent => {
                            if !fields.insert(__FieldTag::__user_agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_agent",
                                ));
                            }
                            result.user_agent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__method_name => {
                            if !fields.insert(__FieldTag::__method_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method_name",
                                ));
                            }
                            result.method_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__principal_subject => {
                            if !fields.insert(__FieldTag::__principal_subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_subject",
                                ));
                            }
                            result.principal_subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_key_name => {
                            if !fields.insert(__FieldTag::__service_account_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_key_name",
                                ));
                            }
                            result.service_account_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_delegation_info => {
                            if !fields.insert(__FieldTag::__service_account_delegation_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_delegation_info",
                                ));
                            }
                            result.service_account_delegation_info = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ServiceAccountDelegationInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_name => {
                            if !fields.insert(__FieldTag::__user_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_name",
                                ));
                            }
                            result.user_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Access {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.principal_email.is_empty() {
            state.serialize_entry("principalEmail", &self.principal_email)?;
        }
        if !self.caller_ip.is_empty() {
            state.serialize_entry("callerIp", &self.caller_ip)?;
        }
        if self.caller_ip_geo.is_some() {
            state.serialize_entry("callerIpGeo", &self.caller_ip_geo)?;
        }
        if !self.user_agent_family.is_empty() {
            state.serialize_entry("userAgentFamily", &self.user_agent_family)?;
        }
        if !self.user_agent.is_empty() {
            state.serialize_entry("userAgent", &self.user_agent)?;
        }
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.method_name.is_empty() {
            state.serialize_entry("methodName", &self.method_name)?;
        }
        if !self.principal_subject.is_empty() {
            state.serialize_entry("principalSubject", &self.principal_subject)?;
        }
        if !self.service_account_key_name.is_empty() {
            state.serialize_entry("serviceAccountKeyName", &self.service_account_key_name)?;
        }
        if !self.service_account_delegation_info.is_empty() {
            state.serialize_entry(
                "serviceAccountDelegationInfo",
                &self.service_account_delegation_info,
            )?;
        }
        if !self.user_name.is_empty() {
            state.serialize_entry("userName", &self.user_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Access {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Access");
        debug_struct.field("principal_email", &self.principal_email);
        debug_struct.field("caller_ip", &self.caller_ip);
        debug_struct.field("caller_ip_geo", &self.caller_ip_geo);
        debug_struct.field("user_agent_family", &self.user_agent_family);
        debug_struct.field("user_agent", &self.user_agent);
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("method_name", &self.method_name);
        debug_struct.field("principal_subject", &self.principal_subject);
        debug_struct.field("service_account_key_name", &self.service_account_key_name);
        debug_struct.field(
            "service_account_delegation_info",
            &self.service_account_delegation_info,
        );
        debug_struct.field("user_name", &self.user_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Identity delegation history of an authenticated service account.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceAccountDelegationInfo {
    /// The email address of a Google account.
    pub principal_email: std::string::String,

    /// A string representing the principal_subject associated with the identity.
    /// As compared to `principal_email`, supports principals that aren't
    /// associated with email addresses, such as third party principals. For most
    /// identities, the format will be `principal://iam.googleapis.com/{identity
    /// pool name}/subjects/{subject}` except for some GKE identities
    /// (GKE_WORKLOAD, FREEFORM, GKE_HUB_WORKLOAD) that are still in the legacy
    /// format `serviceAccount:{identity pool name}[{subject}]`
    pub principal_subject: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceAccountDelegationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal_email][crate::model::ServiceAccountDelegationInfo::principal_email].
    pub fn set_principal_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal_email = v.into();
        self
    }

    /// Sets the value of [principal_subject][crate::model::ServiceAccountDelegationInfo::principal_subject].
    pub fn set_principal_subject<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal_subject = v.into();
        self
    }
}

impl wkt::message::Message for ServiceAccountDelegationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ServiceAccountDelegationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceAccountDelegationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __principal_email,
            __principal_subject,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceAccountDelegationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "principalEmail" => Ok(__FieldTag::__principal_email),
                            "principal_email" => Ok(__FieldTag::__principal_email),
                            "principalSubject" => Ok(__FieldTag::__principal_subject),
                            "principal_subject" => Ok(__FieldTag::__principal_subject),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceAccountDelegationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceAccountDelegationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__principal_email => {
                            if !fields.insert(__FieldTag::__principal_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_email",
                                ));
                            }
                            result.principal_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__principal_subject => {
                            if !fields.insert(__FieldTag::__principal_subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_subject",
                                ));
                            }
                            result.principal_subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceAccountDelegationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.principal_email.is_empty() {
            state.serialize_entry("principalEmail", &self.principal_email)?;
        }
        if !self.principal_subject.is_empty() {
            state.serialize_entry("principalSubject", &self.principal_subject)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServiceAccountDelegationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceAccountDelegationInfo");
        debug_struct.field("principal_email", &self.principal_email);
        debug_struct.field("principal_subject", &self.principal_subject);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a geographical location for a given access.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Geolocation {
    /// A CLDR.
    pub region_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Geolocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [region_code][crate::model::Geolocation::region_code].
    pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region_code = v.into();
        self
    }
}

impl wkt::message::Message for Geolocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Geolocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Geolocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __region_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Geolocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "regionCode" => Ok(__FieldTag::__region_code),
                            "region_code" => Ok(__FieldTag::__region_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Geolocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Geolocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__region_code => {
                            if !fields.insert(__FieldTag::__region_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region_code",
                                ));
                            }
                            result.region_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Geolocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.region_code.is_empty() {
            state.serialize_entry("regionCode", &self.region_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Geolocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Geolocation");
        debug_struct.field("region_code", &self.region_code);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details about resources affected by this finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AffectedResources {
    /// The count of resources affected by the finding.
    pub count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AffectedResources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [count][crate::model::AffectedResources::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for AffectedResources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.AffectedResources"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AffectedResources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AffectedResources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "count" => Ok(__FieldTag::__count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AffectedResources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AffectedResources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AffectedResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AffectedResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AffectedResources");
        debug_struct.field("count", &self.count);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information about the AI model associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AiModel {
    /// The name of the AI model, for example, "gemini:1.0.0".
    pub name: std::string::String,

    /// The domain of the model, for example, “image-classification”.
    pub domain: std::string::String,

    /// The name of the model library, for example, “transformers”.
    pub library: std::string::String,

    /// The region in which the model is used, for example, “us-central1”.
    pub location: std::string::String,

    /// The publisher of the model, for example, “google” or “nvidia”.
    pub publisher: std::string::String,

    /// The platform on which the model is deployed.
    pub deployment_platform: crate::model::ai_model::DeploymentPlatform,

    /// The user defined display name of model. Ex. baseline-classification-model
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AiModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AiModel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::AiModel::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [library][crate::model::AiModel::library].
    pub fn set_library<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.library = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AiModel::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [publisher][crate::model::AiModel::publisher].
    pub fn set_publisher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.publisher = v.into();
        self
    }

    /// Sets the value of [deployment_platform][crate::model::AiModel::deployment_platform].
    pub fn set_deployment_platform<
        T: std::convert::Into<crate::model::ai_model::DeploymentPlatform>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_platform = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AiModel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for AiModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.AiModel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AiModel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __domain,
            __library,
            __location,
            __publisher,
            __deployment_platform,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AiModel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "domain" => Ok(__FieldTag::__domain),
                            "library" => Ok(__FieldTag::__library),
                            "location" => Ok(__FieldTag::__location),
                            "publisher" => Ok(__FieldTag::__publisher),
                            "deploymentPlatform" => Ok(__FieldTag::__deployment_platform),
                            "deployment_platform" => Ok(__FieldTag::__deployment_platform),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AiModel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AiModel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__library => {
                            if !fields.insert(__FieldTag::__library) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for library",
                                ));
                            }
                            result.library = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__publisher => {
                            if !fields.insert(__FieldTag::__publisher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publisher",
                                ));
                            }
                            result.publisher = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment_platform => {
                            if !fields.insert(__FieldTag::__deployment_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_platform",
                                ));
                            }
                            result.deployment_platform = map.next_value::<std::option::Option<crate::model::ai_model::DeploymentPlatform>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AiModel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.library.is_empty() {
            state.serialize_entry("library", &self.library)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.publisher.is_empty() {
            state.serialize_entry("publisher", &self.publisher)?;
        }
        if !wkt::internal::is_default(&self.deployment_platform) {
            state.serialize_entry("deploymentPlatform", &self.deployment_platform)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AiModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AiModel");
        debug_struct.field("name", &self.name);
        debug_struct.field("domain", &self.domain);
        debug_struct.field("library", &self.library);
        debug_struct.field("location", &self.location);
        debug_struct.field("publisher", &self.publisher);
        debug_struct.field("deployment_platform", &self.deployment_platform);
        debug_struct.field("display_name", &self.display_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AiModel].
pub mod ai_model {
    #[allow(unused_imports)]
    use super::*;

    /// The platform on which the model is deployed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeploymentPlatform {
        /// Unspecified deployment platform.
        Unspecified,
        /// Vertex AI.
        VertexAi,
        /// Google Kubernetes Engine.
        Gke,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DeploymentPlatform::value] or
        /// [DeploymentPlatform::name].
        UnknownValue(deployment_platform::UnknownValue),
    }

    #[doc(hidden)]
    pub mod deployment_platform {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DeploymentPlatform {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VertexAi => std::option::Option::Some(1),
                Self::Gke => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DEPLOYMENT_PLATFORM_UNSPECIFIED"),
                Self::VertexAi => std::option::Option::Some("VERTEX_AI"),
                Self::Gke => std::option::Option::Some("GKE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DeploymentPlatform {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DeploymentPlatform {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DeploymentPlatform {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VertexAi,
                2 => Self::Gke,
                _ => Self::UnknownValue(deployment_platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DeploymentPlatform {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEPLOYMENT_PLATFORM_UNSPECIFIED" => Self::Unspecified,
                "VERTEX_AI" => Self::VertexAi,
                "GKE" => Self::Gke,
                _ => Self::UnknownValue(deployment_platform::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DeploymentPlatform {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VertexAi => serializer.serialize_i32(1),
                Self::Gke => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DeploymentPlatform {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeploymentPlatform>::new(
                ".google.cloud.securitycenter.v2.AiModel.DeploymentPlatform",
            ))
        }
    }
}

/// Represents an application associated with a finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Application {
    /// The base URI that identifies the network location of the application in
    /// which the vulnerability was detected. For example, `<http://example.com>`.
    pub base_uri: std::string::String,

    /// The full URI with payload that could be used to reproduce the
    /// vulnerability. For example, `<http://example.com>?p=aMmYgI6H`.
    pub full_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Application {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_uri][crate::model::Application::base_uri].
    pub fn set_base_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_uri = v.into();
        self
    }

    /// Sets the value of [full_uri][crate::model::Application::full_uri].
    pub fn set_full_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.full_uri = v.into();
        self
    }
}

impl wkt::message::Message for Application {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Application"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Application {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_uri,
            __full_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Application")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseUri" => Ok(__FieldTag::__base_uri),
                            "base_uri" => Ok(__FieldTag::__base_uri),
                            "fullUri" => Ok(__FieldTag::__full_uri),
                            "full_uri" => Ok(__FieldTag::__full_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Application;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Application")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_uri => {
                            if !fields.insert(__FieldTag::__base_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_uri",
                                ));
                            }
                            result.base_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_uri => {
                            if !fields.insert(__FieldTag::__full_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_uri",
                                ));
                            }
                            result.full_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Application {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.base_uri.is_empty() {
            state.serialize_entry("baseUri", &self.base_uri)?;
        }
        if !self.full_uri.is_empty() {
            state.serialize_entry("fullUri", &self.full_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Application {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Application");
        debug_struct.field("base_uri", &self.base_uri);
        debug_struct.field("full_uri", &self.full_uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An attack exposure contains the results of an attack path simulation run.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttackExposure {
    /// A number between 0 (inclusive) and infinity that represents how important
    /// this finding is to remediate. The higher the score, the more important it
    /// is to remediate.
    pub score: f64,

    /// The most recent time the attack exposure was updated on this finding.
    pub latest_calculation_time: std::option::Option<wkt::Timestamp>,

    /// The resource name of the attack path simulation result that contains the
    /// details regarding this attack exposure score.
    /// Example: `organizations/123/simulations/456/attackExposureResults/789`
    pub attack_exposure_result: std::string::String,

    /// Output only. What state this AttackExposure is in. This captures whether or
    /// not an attack exposure has been calculated or not.
    pub state: crate::model::attack_exposure::State,

    /// The number of high value resources that are exposed as a result of this
    /// finding.
    pub exposed_high_value_resources_count: i32,

    /// The number of medium value resources that are exposed as a result of this
    /// finding.
    pub exposed_medium_value_resources_count: i32,

    /// The number of high value resources that are exposed as a result of this
    /// finding.
    pub exposed_low_value_resources_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttackExposure {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::AttackExposure::score].
    pub fn set_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [latest_calculation_time][crate::model::AttackExposure::latest_calculation_time].
    pub fn set_latest_calculation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.latest_calculation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_calculation_time][crate::model::AttackExposure::latest_calculation_time].
    pub fn set_or_clear_latest_calculation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.latest_calculation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attack_exposure_result][crate::model::AttackExposure::attack_exposure_result].
    pub fn set_attack_exposure_result<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_exposure_result = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AttackExposure::state].
    pub fn set_state<T: std::convert::Into<crate::model::attack_exposure::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [exposed_high_value_resources_count][crate::model::AttackExposure::exposed_high_value_resources_count].
    pub fn set_exposed_high_value_resources_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.exposed_high_value_resources_count = v.into();
        self
    }

    /// Sets the value of [exposed_medium_value_resources_count][crate::model::AttackExposure::exposed_medium_value_resources_count].
    pub fn set_exposed_medium_value_resources_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.exposed_medium_value_resources_count = v.into();
        self
    }

    /// Sets the value of [exposed_low_value_resources_count][crate::model::AttackExposure::exposed_low_value_resources_count].
    pub fn set_exposed_low_value_resources_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.exposed_low_value_resources_count = v.into();
        self
    }
}

impl wkt::message::Message for AttackExposure {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.AttackExposure"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttackExposure {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score,
            __latest_calculation_time,
            __attack_exposure_result,
            __state,
            __exposed_high_value_resources_count,
            __exposed_medium_value_resources_count,
            __exposed_low_value_resources_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttackExposure")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "score" => Ok(__FieldTag::__score),
                            "latestCalculationTime" => Ok(__FieldTag::__latest_calculation_time),
                            "latest_calculation_time" => Ok(__FieldTag::__latest_calculation_time),
                            "attackExposureResult" => Ok(__FieldTag::__attack_exposure_result),
                            "attack_exposure_result" => Ok(__FieldTag::__attack_exposure_result),
                            "state" => Ok(__FieldTag::__state),
                            "exposedHighValueResourcesCount" => {
                                Ok(__FieldTag::__exposed_high_value_resources_count)
                            }
                            "exposed_high_value_resources_count" => {
                                Ok(__FieldTag::__exposed_high_value_resources_count)
                            }
                            "exposedMediumValueResourcesCount" => {
                                Ok(__FieldTag::__exposed_medium_value_resources_count)
                            }
                            "exposed_medium_value_resources_count" => {
                                Ok(__FieldTag::__exposed_medium_value_resources_count)
                            }
                            "exposedLowValueResourcesCount" => {
                                Ok(__FieldTag::__exposed_low_value_resources_count)
                            }
                            "exposed_low_value_resources_count" => {
                                Ok(__FieldTag::__exposed_low_value_resources_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttackExposure;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttackExposure")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__latest_calculation_time => {
                            if !fields.insert(__FieldTag::__latest_calculation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_calculation_time",
                                ));
                            }
                            result.latest_calculation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__attack_exposure_result => {
                            if !fields.insert(__FieldTag::__attack_exposure_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_exposure_result",
                                ));
                            }
                            result.attack_exposure_result = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::attack_exposure::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exposed_high_value_resources_count => {
                            if !fields.insert(__FieldTag::__exposed_high_value_resources_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exposed_high_value_resources_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exposed_high_value_resources_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exposed_medium_value_resources_count => {
                            if !fields.insert(__FieldTag::__exposed_medium_value_resources_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exposed_medium_value_resources_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exposed_medium_value_resources_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exposed_low_value_resources_count => {
                            if !fields.insert(__FieldTag::__exposed_low_value_resources_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exposed_low_value_resources_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exposed_low_value_resources_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttackExposure {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if self.latest_calculation_time.is_some() {
            state.serialize_entry("latestCalculationTime", &self.latest_calculation_time)?;
        }
        if !self.attack_exposure_result.is_empty() {
            state.serialize_entry("attackExposureResult", &self.attack_exposure_result)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.exposed_high_value_resources_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "exposedHighValueResourcesCount",
                &__With(&self.exposed_high_value_resources_count),
            )?;
        }
        if !wkt::internal::is_default(&self.exposed_medium_value_resources_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "exposedMediumValueResourcesCount",
                &__With(&self.exposed_medium_value_resources_count),
            )?;
        }
        if !wkt::internal::is_default(&self.exposed_low_value_resources_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "exposedLowValueResourcesCount",
                &__With(&self.exposed_low_value_resources_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AttackExposure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttackExposure");
        debug_struct.field("score", &self.score);
        debug_struct.field("latest_calculation_time", &self.latest_calculation_time);
        debug_struct.field("attack_exposure_result", &self.attack_exposure_result);
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "exposed_high_value_resources_count",
            &self.exposed_high_value_resources_count,
        );
        debug_struct.field(
            "exposed_medium_value_resources_count",
            &self.exposed_medium_value_resources_count,
        );
        debug_struct.field(
            "exposed_low_value_resources_count",
            &self.exposed_low_value_resources_count,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AttackExposure].
pub mod attack_exposure {
    #[allow(unused_imports)]
    use super::*;

    /// This enum defines the various states an AttackExposure can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is not specified.
        Unspecified,
        /// The attack exposure has been calculated.
        Calculated,
        /// The attack exposure has not been calculated.
        NotCalculated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Calculated => std::option::Option::Some(1),
                Self::NotCalculated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Calculated => std::option::Option::Some("CALCULATED"),
                Self::NotCalculated => std::option::Option::Some("NOT_CALCULATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Calculated,
                2 => Self::NotCalculated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CALCULATED" => Self::Calculated,
                "NOT_CALCULATED" => Self::NotCalculated,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Calculated => serializer.serialize_i32(1),
                Self::NotCalculated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.securitycenter.v2.AttackExposure.State",
            ))
        }
    }
}

/// A path that an attacker could take to reach an exposed resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttackPath {
    /// The attack path name, for example,
    /// `organizations/12/simulations/34/valuedResources/56/attackPaths/78`
    pub name: std::string::String,

    /// A list of nodes that exist in this attack path.
    pub path_nodes: std::vec::Vec<crate::model::attack_path::AttackPathNode>,

    /// A list of the edges between nodes in this attack path.
    pub edges: std::vec::Vec<crate::model::attack_path::AttackPathEdge>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttackPath {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttackPath::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [path_nodes][crate::model::AttackPath::path_nodes].
    pub fn set_path_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::attack_path::AttackPathNode>,
    {
        use std::iter::Iterator;
        self.path_nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [edges][crate::model::AttackPath::edges].
    pub fn set_edges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::attack_path::AttackPathEdge>,
    {
        use std::iter::Iterator;
        self.edges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AttackPath {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.AttackPath"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttackPath {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __path_nodes,
            __edges,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttackPath")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pathNodes" => Ok(__FieldTag::__path_nodes),
                            "path_nodes" => Ok(__FieldTag::__path_nodes),
                            "edges" => Ok(__FieldTag::__edges),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttackPath;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttackPath")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path_nodes => {
                            if !fields.insert(__FieldTag::__path_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path_nodes",
                                ));
                            }
                            result.path_nodes = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::attack_path::AttackPathNode>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__edges => {
                            if !fields.insert(__FieldTag::__edges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for edges",
                                ));
                            }
                            result.edges = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::attack_path::AttackPathEdge>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttackPath {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.path_nodes.is_empty() {
            state.serialize_entry("pathNodes", &self.path_nodes)?;
        }
        if !self.edges.is_empty() {
            state.serialize_entry("edges", &self.edges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AttackPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttackPath");
        debug_struct.field("name", &self.name);
        debug_struct.field("path_nodes", &self.path_nodes);
        debug_struct.field("edges", &self.edges);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AttackPath].
pub mod attack_path {
    #[allow(unused_imports)]
    use super::*;

    /// Represents one point that an attacker passes through in this attack path.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AttackPathNode {
        /// The name of the resource at this point in the attack path.
        /// The format of the name follows the Cloud Asset Inventory [resource
        /// name
        /// format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
        pub resource: std::string::String,

        /// The [supported resource
        /// type](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
        pub resource_type: std::string::String,

        /// Human-readable name of this resource.
        pub display_name: std::string::String,

        /// The findings associated with this node in the attack path.
        pub associated_findings:
            std::vec::Vec<crate::model::attack_path::attack_path_node::PathNodeAssociatedFinding>,

        /// Unique id of the attack path node.
        pub uuid: std::string::String,

        /// A list of attack step nodes that exist in this attack path node.
        pub attack_steps:
            std::vec::Vec<crate::model::attack_path::attack_path_node::AttackStepNode>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AttackPathNode {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource][crate::model::attack_path::AttackPathNode::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [resource_type][crate::model::attack_path::AttackPathNode::resource_type].
        pub fn set_resource_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::attack_path::AttackPathNode::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [associated_findings][crate::model::attack_path::AttackPathNode::associated_findings].
        pub fn set_associated_findings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::attack_path::attack_path_node::PathNodeAssociatedFinding,
                >,
        {
            use std::iter::Iterator;
            self.associated_findings = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [uuid][crate::model::attack_path::AttackPathNode::uuid].
        pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uuid = v.into();
            self
        }

        /// Sets the value of [attack_steps][crate::model::attack_path::AttackPathNode::attack_steps].
        pub fn set_attack_steps<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::attack_path::attack_path_node::AttackStepNode>,
        {
            use std::iter::Iterator;
            self.attack_steps = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AttackPathNode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AttackPath.AttackPathNode"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AttackPathNode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __resource,
                __resource_type,
                __display_name,
                __associated_findings,
                __uuid,
                __attack_steps,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AttackPathNode")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "resource" => Ok(__FieldTag::__resource),
                                "resourceType" => Ok(__FieldTag::__resource_type),
                                "resource_type" => Ok(__FieldTag::__resource_type),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "associatedFindings" => Ok(__FieldTag::__associated_findings),
                                "associated_findings" => Ok(__FieldTag::__associated_findings),
                                "uuid" => Ok(__FieldTag::__uuid),
                                "attackSteps" => Ok(__FieldTag::__attack_steps),
                                "attack_steps" => Ok(__FieldTag::__attack_steps),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AttackPathNode;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AttackPathNode")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__resource => {
                                if !fields.insert(__FieldTag::__resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource",
                                    ));
                                }
                                result.resource = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource_type => {
                                if !fields.insert(__FieldTag::__resource_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_type",
                                    ));
                                }
                                result.resource_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__associated_findings => {
                                if !fields.insert(__FieldTag::__associated_findings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for associated_findings",
                                    ));
                                }
                                result.associated_findings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::attack_path::attack_path_node::PathNodeAssociatedFinding>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__uuid => {
                                if !fields.insert(__FieldTag::__uuid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uuid",
                                    ));
                                }
                                result.uuid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__attack_steps => {
                                if !fields.insert(__FieldTag::__attack_steps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attack_steps",
                                    ));
                                }
                                result.attack_steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::attack_path::attack_path_node::AttackStepNode>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AttackPathNode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.resource.is_empty() {
                state.serialize_entry("resource", &self.resource)?;
            }
            if !self.resource_type.is_empty() {
                state.serialize_entry("resourceType", &self.resource_type)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.associated_findings.is_empty() {
                state.serialize_entry("associatedFindings", &self.associated_findings)?;
            }
            if !self.uuid.is_empty() {
                state.serialize_entry("uuid", &self.uuid)?;
            }
            if !self.attack_steps.is_empty() {
                state.serialize_entry("attackSteps", &self.attack_steps)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AttackPathNode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AttackPathNode");
            debug_struct.field("resource", &self.resource);
            debug_struct.field("resource_type", &self.resource_type);
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("associated_findings", &self.associated_findings);
            debug_struct.field("uuid", &self.uuid);
            debug_struct.field("attack_steps", &self.attack_steps);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AttackPathNode].
    pub mod attack_path_node {
        #[allow(unused_imports)]
        use super::*;

        /// A finding that is associated with this node in the attack path.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PathNodeAssociatedFinding {
            /// Canonical name of the associated findings. Example:
            /// `organizations/123/sources/456/findings/789`
            pub canonical_finding: std::string::String,

            /// The additional taxonomy group within findings from a given source.
            pub finding_category: std::string::String,

            /// Full resource name of the finding.
            pub name: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PathNodeAssociatedFinding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [canonical_finding][crate::model::attack_path::attack_path_node::PathNodeAssociatedFinding::canonical_finding].
            pub fn set_canonical_finding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.canonical_finding = v.into();
                self
            }

            /// Sets the value of [finding_category][crate::model::attack_path::attack_path_node::PathNodeAssociatedFinding::finding_category].
            pub fn set_finding_category<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.finding_category = v.into();
                self
            }

            /// Sets the value of [name][crate::model::attack_path::attack_path_node::PathNodeAssociatedFinding::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }
        }

        impl wkt::message::Message for PathNodeAssociatedFinding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.securitycenter.v2.AttackPath.AttackPathNode.PathNodeAssociatedFinding"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PathNodeAssociatedFinding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __canonical_finding,
                    __finding_category,
                    __name,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PathNodeAssociatedFinding")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "canonicalFinding" => Ok(__FieldTag::__canonical_finding),
                                    "canonical_finding" => Ok(__FieldTag::__canonical_finding),
                                    "findingCategory" => Ok(__FieldTag::__finding_category),
                                    "finding_category" => Ok(__FieldTag::__finding_category),
                                    "name" => Ok(__FieldTag::__name),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PathNodeAssociatedFinding;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PathNodeAssociatedFinding")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__canonical_finding => {
                                    if !fields.insert(__FieldTag::__canonical_finding) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for canonical_finding",
                                            ),
                                        );
                                    }
                                    result.canonical_finding = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__finding_category => {
                                    if !fields.insert(__FieldTag::__finding_category) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for finding_category",
                                            ),
                                        );
                                    }
                                    result.finding_category = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PathNodeAssociatedFinding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.canonical_finding.is_empty() {
                    state.serialize_entry("canonicalFinding", &self.canonical_finding)?;
                }
                if !self.finding_category.is_empty() {
                    state.serialize_entry("findingCategory", &self.finding_category)?;
                }
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for PathNodeAssociatedFinding {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("PathNodeAssociatedFinding");
                debug_struct.field("canonical_finding", &self.canonical_finding);
                debug_struct.field("finding_category", &self.finding_category);
                debug_struct.field("name", &self.name);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Detailed steps the attack can take between path nodes.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AttackStepNode {
            /// Unique ID for one Node
            pub uuid: std::string::String,

            /// Attack step type. Can be either AND, OR or DEFENSE
            pub r#type: crate::model::attack_path::attack_path_node::NodeType,

            /// User friendly name of the attack step
            pub display_name: std::string::String,

            /// Attack step labels for metadata
            pub labels: std::collections::HashMap<std::string::String, std::string::String>,

            /// Attack step description
            pub description: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AttackStepNode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [uuid][crate::model::attack_path::attack_path_node::AttackStepNode::uuid].
            pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uuid = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::attack_path::attack_path_node::AttackStepNode::type].
            pub fn set_type<
                T: std::convert::Into<crate::model::attack_path::attack_path_node::NodeType>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [display_name][crate::model::attack_path::attack_path_node::AttackStepNode::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [labels][crate::model::attack_path::attack_path_node::AttackStepNode::labels].
            pub fn set_labels<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }

            /// Sets the value of [description][crate::model::attack_path::attack_path_node::AttackStepNode::description].
            pub fn set_description<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.description = v.into();
                self
            }
        }

        impl wkt::message::Message for AttackStepNode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.securitycenter.v2.AttackPath.AttackPathNode.AttackStepNode"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AttackStepNode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __uuid,
                    __type,
                    __display_name,
                    __labels,
                    __description,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AttackStepNode")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "uuid" => Ok(__FieldTag::__uuid),
                                    "type" => Ok(__FieldTag::__type),
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "labels" => Ok(__FieldTag::__labels),
                                    "description" => Ok(__FieldTag::__description),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AttackStepNode;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AttackStepNode")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__uuid => {
                                    if !fields.insert(__FieldTag::__uuid) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for uuid"),
                                        );
                                    }
                                    result.uuid = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map
                                        .next_value::<std::option::Option<
                                            crate::model::attack_path::attack_path_node::NodeType,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__labels => {
                                    if !fields.insert(__FieldTag::__labels) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for labels"),
                                        );
                                    }
                                    result.labels = map
                                        .next_value::<std::option::Option<
                                            std::collections::HashMap<
                                                std::string::String,
                                                std::string::String,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__description => {
                                    if !fields.insert(__FieldTag::__description) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for description",
                                            ),
                                        );
                                    }
                                    result.description = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AttackStepNode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.uuid.is_empty() {
                    state.serialize_entry("uuid", &self.uuid)?;
                }
                if !wkt::internal::is_default(&self.r#type) {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.labels.is_empty() {
                    state.serialize_entry("labels", &self.labels)?;
                }
                if !self.description.is_empty() {
                    state.serialize_entry("description", &self.description)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for AttackStepNode {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("AttackStepNode");
                debug_struct.field("uuid", &self.uuid);
                debug_struct.field("r#type", &self.r#type);
                debug_struct.field("display_name", &self.display_name);
                debug_struct.field("labels", &self.labels);
                debug_struct.field("description", &self.description);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// The type of the incoming attack step node.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum NodeType {
            /// Type not specified
            Unspecified,
            /// Incoming edge joined with AND
            And,
            /// Incoming edge joined with OR
            Or,
            /// Incoming edge is defense
            Defense,
            /// Incoming edge is attacker
            Attacker,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [NodeType::value] or
            /// [NodeType::name].
            UnknownValue(node_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod node_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl NodeType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::And => std::option::Option::Some(1),
                    Self::Or => std::option::Option::Some(2),
                    Self::Defense => std::option::Option::Some(3),
                    Self::Attacker => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("NODE_TYPE_UNSPECIFIED"),
                    Self::And => std::option::Option::Some("NODE_TYPE_AND"),
                    Self::Or => std::option::Option::Some("NODE_TYPE_OR"),
                    Self::Defense => std::option::Option::Some("NODE_TYPE_DEFENSE"),
                    Self::Attacker => std::option::Option::Some("NODE_TYPE_ATTACKER"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for NodeType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for NodeType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for NodeType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::And,
                    2 => Self::Or,
                    3 => Self::Defense,
                    4 => Self::Attacker,
                    _ => Self::UnknownValue(node_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for NodeType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "NODE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "NODE_TYPE_AND" => Self::And,
                    "NODE_TYPE_OR" => Self::Or,
                    "NODE_TYPE_DEFENSE" => Self::Defense,
                    "NODE_TYPE_ATTACKER" => Self::Attacker,
                    _ => Self::UnknownValue(node_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for NodeType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::And => serializer.serialize_i32(1),
                    Self::Or => serializer.serialize_i32(2),
                    Self::Defense => serializer.serialize_i32(3),
                    Self::Attacker => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for NodeType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeType>::new(
                    ".google.cloud.securitycenter.v2.AttackPath.AttackPathNode.NodeType",
                ))
            }
        }
    }

    /// Represents a connection between a source node and a destination node in
    /// this attack path.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AttackPathEdge {
        /// The attack node uuid of the source node.
        pub source: std::string::String,

        /// The attack node uuid of the destination node.
        pub destination: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AttackPathEdge {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::attack_path::AttackPathEdge::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [destination][crate::model::attack_path::AttackPathEdge::destination].
        pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.destination = v.into();
            self
        }
    }

    impl wkt::message::Message for AttackPathEdge {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AttackPath.AttackPathEdge"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AttackPathEdge {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source,
                __destination,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AttackPathEdge")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "source" => Ok(__FieldTag::__source),
                                "destination" => Ok(__FieldTag::__destination),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AttackPathEdge;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AttackPathEdge")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source => {
                                if !fields.insert(__FieldTag::__source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source",
                                    ));
                                }
                                result.source = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__destination => {
                                if !fields.insert(__FieldTag::__destination) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for destination",
                                    ));
                                }
                                result.destination = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AttackPathEdge {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source.is_empty() {
                state.serialize_entry("source", &self.source)?;
            }
            if !self.destination.is_empty() {
                state.serialize_entry("destination", &self.destination)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AttackPathEdge {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AttackPathEdge");
            debug_struct.field("source", &self.source);
            debug_struct.field("destination", &self.destination);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Information related to Google Cloud Backup and DR Service findings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupDisasterRecovery {
    /// The name of a Backup and DR template which comprises one or more backup
    /// policies. See the [Backup and DR
    /// documentation](https://cloud.google.com/backup-disaster-recovery/docs/concepts/backup-plan#temp)
    /// for more information. For example, `snap-ov`.
    pub backup_template: std::string::String,

    /// The names of Backup and DR policies that are associated with a template
    /// and that define when to run a backup, how frequently to run a backup, and
    /// how long to retain the backup image. For example, `onvaults`.
    pub policies: std::vec::Vec<std::string::String>,

    /// The name of a Backup and DR host, which is managed by the backup and
    /// recovery appliance and known to the management console. The host can be of
    /// type Generic (for example, Compute Engine, SQL Server, Oracle DB, SMB file
    /// system, etc.), vCenter, or an ESX server. See the [Backup and DR
    /// documentation on
    /// hosts](https://cloud.google.com/backup-disaster-recovery/docs/configuration/manage-hosts-and-their-applications)
    /// for more information. For example, `centos7-01`.
    pub host: std::string::String,

    /// The names of Backup and DR applications. An application is a VM, database,
    /// or file system on a managed host monitored by a backup and recovery
    /// appliance. For example, `centos7-01-vol00`, `centos7-01-vol01`,
    /// `centos7-01-vol02`.
    pub applications: std::vec::Vec<std::string::String>,

    /// The name of the Backup and DR storage pool that the backup and recovery
    /// appliance is storing data in. The storage pool could be of type Cloud,
    /// Primary, Snapshot, or OnVault. See the [Backup and DR documentation on
    /// storage
    /// pools](https://cloud.google.com/backup-disaster-recovery/docs/concepts/storage-pools).
    /// For example, `DiskPoolOne`.
    pub storage_pool: std::string::String,

    /// The names of Backup and DR advanced policy options of a policy applying to
    /// an application. See the [Backup and DR documentation on policy
    /// options](https://cloud.google.com/backup-disaster-recovery/docs/create-plan/policy-settings).
    /// For example, `skipofflineappsincongrp, nounmap`.
    pub policy_options: std::vec::Vec<std::string::String>,

    /// The name of the Backup and DR resource profile that specifies the storage
    /// media for backups of application and VM data. See the [Backup and DR
    /// documentation on
    /// profiles](https://cloud.google.com/backup-disaster-recovery/docs/concepts/backup-plan#profile).
    /// For example, `GCP`.
    pub profile: std::string::String,

    /// The name of the Backup and DR appliance that captures, moves, and manages
    /// the lifecycle of backup data. For example, `backup-server-57137`.
    pub appliance: std::string::String,

    /// The backup type of the Backup and DR image.
    /// For example, `Snapshot`, `Remote Snapshot`, `OnVault`.
    pub backup_type: std::string::String,

    /// The timestamp at which the Backup and DR backup was created.
    pub backup_create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupDisasterRecovery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_template][crate::model::BackupDisasterRecovery::backup_template].
    pub fn set_backup_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_template = v.into();
        self
    }

    /// Sets the value of [policies][crate::model::BackupDisasterRecovery::policies].
    pub fn set_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [host][crate::model::BackupDisasterRecovery::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [applications][crate::model::BackupDisasterRecovery::applications].
    pub fn set_applications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [storage_pool][crate::model::BackupDisasterRecovery::storage_pool].
    pub fn set_storage_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.storage_pool = v.into();
        self
    }

    /// Sets the value of [policy_options][crate::model::BackupDisasterRecovery::policy_options].
    pub fn set_policy_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.policy_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [profile][crate::model::BackupDisasterRecovery::profile].
    pub fn set_profile<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.profile = v.into();
        self
    }

    /// Sets the value of [appliance][crate::model::BackupDisasterRecovery::appliance].
    pub fn set_appliance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.appliance = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::BackupDisasterRecovery::backup_type].
    pub fn set_backup_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [backup_create_time][crate::model::BackupDisasterRecovery::backup_create_time].
    pub fn set_backup_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.backup_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_create_time][crate::model::BackupDisasterRecovery::backup_create_time].
    pub fn set_or_clear_backup_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.backup_create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupDisasterRecovery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.BackupDisasterRecovery"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupDisasterRecovery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_template,
            __policies,
            __host,
            __applications,
            __storage_pool,
            __policy_options,
            __profile,
            __appliance,
            __backup_type,
            __backup_create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupDisasterRecovery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupTemplate" => Ok(__FieldTag::__backup_template),
                            "backup_template" => Ok(__FieldTag::__backup_template),
                            "policies" => Ok(__FieldTag::__policies),
                            "host" => Ok(__FieldTag::__host),
                            "applications" => Ok(__FieldTag::__applications),
                            "storagePool" => Ok(__FieldTag::__storage_pool),
                            "storage_pool" => Ok(__FieldTag::__storage_pool),
                            "policyOptions" => Ok(__FieldTag::__policy_options),
                            "policy_options" => Ok(__FieldTag::__policy_options),
                            "profile" => Ok(__FieldTag::__profile),
                            "appliance" => Ok(__FieldTag::__appliance),
                            "backupType" => Ok(__FieldTag::__backup_type),
                            "backup_type" => Ok(__FieldTag::__backup_type),
                            "backupCreateTime" => Ok(__FieldTag::__backup_create_time),
                            "backup_create_time" => Ok(__FieldTag::__backup_create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupDisasterRecovery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupDisasterRecovery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_template => {
                            if !fields.insert(__FieldTag::__backup_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_template",
                                ));
                            }
                            result.backup_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policies => {
                            if !fields.insert(__FieldTag::__policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policies",
                                ));
                            }
                            result.policies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__applications => {
                            if !fields.insert(__FieldTag::__applications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applications",
                                ));
                            }
                            result.applications = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_pool => {
                            if !fields.insert(__FieldTag::__storage_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pool",
                                ));
                            }
                            result.storage_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_options => {
                            if !fields.insert(__FieldTag::__policy_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_options",
                                ));
                            }
                            result.policy_options = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__profile => {
                            if !fields.insert(__FieldTag::__profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profile",
                                ));
                            }
                            result.profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__appliance => {
                            if !fields.insert(__FieldTag::__appliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for appliance",
                                ));
                            }
                            result.appliance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_type => {
                            if !fields.insert(__FieldTag::__backup_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_type",
                                ));
                            }
                            result.backup_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_create_time => {
                            if !fields.insert(__FieldTag::__backup_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_create_time",
                                ));
                            }
                            result.backup_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupDisasterRecovery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_template.is_empty() {
            state.serialize_entry("backupTemplate", &self.backup_template)?;
        }
        if !self.policies.is_empty() {
            state.serialize_entry("policies", &self.policies)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self.applications.is_empty() {
            state.serialize_entry("applications", &self.applications)?;
        }
        if !self.storage_pool.is_empty() {
            state.serialize_entry("storagePool", &self.storage_pool)?;
        }
        if !self.policy_options.is_empty() {
            state.serialize_entry("policyOptions", &self.policy_options)?;
        }
        if !self.profile.is_empty() {
            state.serialize_entry("profile", &self.profile)?;
        }
        if !self.appliance.is_empty() {
            state.serialize_entry("appliance", &self.appliance)?;
        }
        if !self.backup_type.is_empty() {
            state.serialize_entry("backupType", &self.backup_type)?;
        }
        if self.backup_create_time.is_some() {
            state.serialize_entry("backupCreateTime", &self.backup_create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackupDisasterRecovery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupDisasterRecovery");
        debug_struct.field("backup_template", &self.backup_template);
        debug_struct.field("policies", &self.policies);
        debug_struct.field("host", &self.host);
        debug_struct.field("applications", &self.applications);
        debug_struct.field("storage_pool", &self.storage_pool);
        debug_struct.field("policy_options", &self.policy_options);
        debug_struct.field("profile", &self.profile);
        debug_struct.field("appliance", &self.appliance);
        debug_struct.field("backup_type", &self.backup_type);
        debug_struct.field("backup_create_time", &self.backup_create_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configures how to deliver Findings to BigQuery Instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryExport {
    /// Identifier. The relative resource name of this export. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>.
    /// The following list shows some examples:
    ///
    ///
    /// `organizations/{organization_id}/locations/{location_id}/bigQueryExports/{export_id}`
    ///
    /// + `folders/{folder_id}/locations/{location_id}/bigQueryExports/{export_id}`
    ///
    /// `projects/{project_id}/locations/{location_id}/bigQueryExports/{export_id}`
    ///
    /// This field is provided in responses, and is ignored when provided in create
    /// requests.
    pub name: std::string::String,

    /// The description of the export (max of 1024 characters).
    pub description: std::string::String,

    /// Expression that defines the filter to apply across create/update events
    /// of findings. The expression is a list of zero or more restrictions combined
    /// via logical operators `AND` and `OR`. Parentheses are supported, and `OR`
    /// has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a
    /// `-` character in front of them to indicate negation. The fields map to
    /// those defined in the corresponding resource.
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    pub filter: std::string::String,

    /// The dataset to write findings' updates to. Its format is
    /// "projects/[project_id]/datasets/[bigquery_dataset_id]".
    /// BigQuery dataset unique ID  must contain only letters (a-z, A-Z), numbers
    /// (0-9), or underscores (_).
    pub dataset: std::string::String,

    /// Output only. The time at which the BigQuery export was created.
    /// This field is set by the server and will be ignored if provided on export
    /// on creation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the BigQuery export was updated.
    /// This field is set by the server and will be ignored if provided on export
    /// creation or update.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Email address of the user who last edited the BigQuery export.
    /// This field is set by the server and will be ignored if provided on export
    /// creation or update.
    pub most_recent_editor: std::string::String,

    /// Output only. The service account that needs permission to create table and
    /// upload data to the BigQuery dataset.
    pub principal: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryExport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BigQueryExport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BigQueryExport::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BigQueryExport::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::BigQueryExport::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BigQueryExport::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BigQueryExport::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BigQueryExport::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BigQueryExport::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [most_recent_editor][crate::model::BigQueryExport::most_recent_editor].
    pub fn set_most_recent_editor<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.most_recent_editor = v.into();
        self
    }

    /// Sets the value of [principal][crate::model::BigQueryExport::principal].
    pub fn set_principal<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryExport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.BigQueryExport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryExport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __filter,
            __dataset,
            __create_time,
            __update_time,
            __most_recent_editor,
            __principal,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryExport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "filter" => Ok(__FieldTag::__filter),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "mostRecentEditor" => Ok(__FieldTag::__most_recent_editor),
                            "most_recent_editor" => Ok(__FieldTag::__most_recent_editor),
                            "principal" => Ok(__FieldTag::__principal),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryExport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryExport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__most_recent_editor => {
                            if !fields.insert(__FieldTag::__most_recent_editor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for most_recent_editor",
                                ));
                            }
                            result.most_recent_editor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__principal => {
                            if !fields.insert(__FieldTag::__principal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal",
                                ));
                            }
                            result.principal = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryExport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.most_recent_editor.is_empty() {
            state.serialize_entry("mostRecentEditor", &self.most_recent_editor)?;
        }
        if !self.principal.is_empty() {
            state.serialize_entry("principal", &self.principal)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQueryExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryExport");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("dataset", &self.dataset);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("most_recent_editor", &self.most_recent_editor);
        debug_struct.field("principal", &self.principal);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains details about a chokepoint, which is a resource or resource group
/// where high-risk attack paths converge, based on [attack path simulations]
/// (<https://cloud.google.com/security-command-center/docs/attack-exposure-learn#attack_path_simulations>).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Chokepoint {
    /// List of resource names of findings associated with this chokepoint.
    /// For example, organizations/123/sources/456/findings/789.
    /// This list will have at most 100 findings.
    pub related_findings: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Chokepoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [related_findings][crate::model::Chokepoint::related_findings].
    pub fn set_related_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Chokepoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Chokepoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Chokepoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __related_findings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Chokepoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relatedFindings" => Ok(__FieldTag::__related_findings),
                            "related_findings" => Ok(__FieldTag::__related_findings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Chokepoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Chokepoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__related_findings => {
                            if !fields.insert(__FieldTag::__related_findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_findings",
                                ));
                            }
                            result.related_findings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Chokepoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.related_findings.is_empty() {
            state.serialize_entry("relatedFindings", &self.related_findings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Chokepoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Chokepoint");
        debug_struct.field("related_findings", &self.related_findings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Fields related to Google Cloud Armor findings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudArmor {
    /// Information about the [Google Cloud Armor security
    /// policy](https://cloud.google.com/armor/docs/security-policy-overview)
    /// relevant to the finding.
    pub security_policy: std::option::Option<crate::model::SecurityPolicy>,

    /// Information about incoming requests evaluated by [Google Cloud Armor
    /// security
    /// policies](https://cloud.google.com/armor/docs/security-policy-overview).
    pub requests: std::option::Option<crate::model::Requests>,

    /// Information about potential Layer 7 DDoS attacks identified by [Google
    /// Cloud Armor Adaptive
    /// Protection](https://cloud.google.com/armor/docs/adaptive-protection-overview).
    pub adaptive_protection: std::option::Option<crate::model::AdaptiveProtection>,

    /// Information about DDoS attack volume and classification.
    pub attack: std::option::Option<crate::model::Attack>,

    /// Distinguish between volumetric & protocol DDoS attack and
    /// application layer attacks. For example, "L3_4" for Layer 3 and Layer 4 DDoS
    /// attacks, or "L_7" for Layer 7 DDoS attacks.
    pub threat_vector: std::string::String,

    /// Duration of attack from the start until the current moment (updated every 5
    /// minutes).
    pub duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudArmor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [security_policy][crate::model::CloudArmor::security_policy].
    pub fn set_security_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPolicy>,
    {
        self.security_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_policy][crate::model::CloudArmor::security_policy].
    pub fn set_or_clear_security_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPolicy>,
    {
        self.security_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requests][crate::model::CloudArmor::requests].
    pub fn set_requests<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Requests>,
    {
        self.requests = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requests][crate::model::CloudArmor::requests].
    pub fn set_or_clear_requests<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Requests>,
    {
        self.requests = v.map(|x| x.into());
        self
    }

    /// Sets the value of [adaptive_protection][crate::model::CloudArmor::adaptive_protection].
    pub fn set_adaptive_protection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdaptiveProtection>,
    {
        self.adaptive_protection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [adaptive_protection][crate::model::CloudArmor::adaptive_protection].
    pub fn set_or_clear_adaptive_protection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdaptiveProtection>,
    {
        self.adaptive_protection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attack][crate::model::CloudArmor::attack].
    pub fn set_attack<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Attack>,
    {
        self.attack = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attack][crate::model::CloudArmor::attack].
    pub fn set_or_clear_attack<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Attack>,
    {
        self.attack = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threat_vector][crate::model::CloudArmor::threat_vector].
    pub fn set_threat_vector<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.threat_vector = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::CloudArmor::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::CloudArmor::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudArmor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CloudArmor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudArmor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __security_policy,
            __requests,
            __adaptive_protection,
            __attack,
            __threat_vector,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudArmor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "securityPolicy" => Ok(__FieldTag::__security_policy),
                            "security_policy" => Ok(__FieldTag::__security_policy),
                            "requests" => Ok(__FieldTag::__requests),
                            "adaptiveProtection" => Ok(__FieldTag::__adaptive_protection),
                            "adaptive_protection" => Ok(__FieldTag::__adaptive_protection),
                            "attack" => Ok(__FieldTag::__attack),
                            "threatVector" => Ok(__FieldTag::__threat_vector),
                            "threat_vector" => Ok(__FieldTag::__threat_vector),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudArmor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudArmor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__security_policy => {
                            if !fields.insert(__FieldTag::__security_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_policy",
                                ));
                            }
                            result.security_policy = map
                                .next_value::<std::option::Option<crate::model::SecurityPolicy>>(
                                )?;
                        }
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests =
                                map.next_value::<std::option::Option<crate::model::Requests>>()?;
                        }
                        __FieldTag::__adaptive_protection => {
                            if !fields.insert(__FieldTag::__adaptive_protection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adaptive_protection",
                                ));
                            }
                            result.adaptive_protection = map.next_value::<std::option::Option<crate::model::AdaptiveProtection>>()?
                                ;
                        }
                        __FieldTag::__attack => {
                            if !fields.insert(__FieldTag::__attack) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack",
                                ));
                            }
                            result.attack =
                                map.next_value::<std::option::Option<crate::model::Attack>>()?;
                        }
                        __FieldTag::__threat_vector => {
                            if !fields.insert(__FieldTag::__threat_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threat_vector",
                                ));
                            }
                            result.threat_vector = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudArmor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if self.requests.is_some() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if self.adaptive_protection.is_some() {
            state.serialize_entry("adaptiveProtection", &self.adaptive_protection)?;
        }
        if self.attack.is_some() {
            state.serialize_entry("attack", &self.attack)?;
        }
        if !self.threat_vector.is_empty() {
            state.serialize_entry("threatVector", &self.threat_vector)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudArmor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudArmor");
        debug_struct.field("security_policy", &self.security_policy);
        debug_struct.field("requests", &self.requests);
        debug_struct.field("adaptive_protection", &self.adaptive_protection);
        debug_struct.field("attack", &self.attack);
        debug_struct.field("threat_vector", &self.threat_vector);
        debug_struct.field("duration", &self.duration);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about the [Google Cloud Armor security
/// policy](https://cloud.google.com/armor/docs/security-policy-overview)
/// relevant to the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityPolicy {
    /// The name of the Google Cloud Armor security policy, for example,
    /// "my-security-policy".
    pub name: std::string::String,

    /// The type of Google Cloud Armor security policy for example, 'backend
    /// security policy', 'edge security policy', 'network edge security policy',
    /// or 'always-on DDoS protection'.
    pub r#type: std::string::String,

    /// Whether or not the associated rule or policy is in preview mode.
    pub preview: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SecurityPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SecurityPolicy::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [preview][crate::model::SecurityPolicy::preview].
    pub fn set_preview<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.preview = v.into();
        self
    }
}

impl wkt::message::Message for SecurityPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.SecurityPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __preview,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "preview" => Ok(__FieldTag::__preview),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preview => {
                            if !fields.insert(__FieldTag::__preview) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preview",
                                ));
                            }
                            result.preview = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.preview) {
            state.serialize_entry("preview", &self.preview)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecurityPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityPolicy");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("preview", &self.preview);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about the requests relevant to the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Requests {
    /// For 'Increasing deny ratio', the ratio is the denied traffic divided by the
    /// allowed traffic. For 'Allowed traffic spike', the ratio is the allowed
    /// traffic in the short term divided by allowed traffic in the long term.
    pub ratio: f64,

    /// Allowed RPS (requests per second) in the short term.
    pub short_term_allowed: i32,

    /// Allowed RPS (requests per second) over the long term.
    pub long_term_allowed: i32,

    /// Denied RPS (requests per second) over the long term.
    pub long_term_denied: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Requests {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ratio][crate::model::Requests::ratio].
    pub fn set_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.ratio = v.into();
        self
    }

    /// Sets the value of [short_term_allowed][crate::model::Requests::short_term_allowed].
    pub fn set_short_term_allowed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.short_term_allowed = v.into();
        self
    }

    /// Sets the value of [long_term_allowed][crate::model::Requests::long_term_allowed].
    pub fn set_long_term_allowed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.long_term_allowed = v.into();
        self
    }

    /// Sets the value of [long_term_denied][crate::model::Requests::long_term_denied].
    pub fn set_long_term_denied<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.long_term_denied = v.into();
        self
    }
}

impl wkt::message::Message for Requests {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Requests"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Requests {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ratio,
            __short_term_allowed,
            __long_term_allowed,
            __long_term_denied,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Requests")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ratio" => Ok(__FieldTag::__ratio),
                            "shortTermAllowed" => Ok(__FieldTag::__short_term_allowed),
                            "short_term_allowed" => Ok(__FieldTag::__short_term_allowed),
                            "longTermAllowed" => Ok(__FieldTag::__long_term_allowed),
                            "long_term_allowed" => Ok(__FieldTag::__long_term_allowed),
                            "longTermDenied" => Ok(__FieldTag::__long_term_denied),
                            "long_term_denied" => Ok(__FieldTag::__long_term_denied),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Requests;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Requests")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ratio => {
                            if !fields.insert(__FieldTag::__ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ratio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__short_term_allowed => {
                            if !fields.insert(__FieldTag::__short_term_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_term_allowed",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.short_term_allowed =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__long_term_allowed => {
                            if !fields.insert(__FieldTag::__long_term_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_term_allowed",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.long_term_allowed =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__long_term_denied => {
                            if !fields.insert(__FieldTag::__long_term_denied) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_term_denied",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.long_term_denied =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Requests {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ratio", &__With(&self.ratio))?;
        }
        if !wkt::internal::is_default(&self.short_term_allowed) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shortTermAllowed", &__With(&self.short_term_allowed))?;
        }
        if !wkt::internal::is_default(&self.long_term_allowed) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("longTermAllowed", &__With(&self.long_term_allowed))?;
        }
        if !wkt::internal::is_default(&self.long_term_denied) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("longTermDenied", &__With(&self.long_term_denied))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Requests {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Requests");
        debug_struct.field("ratio", &self.ratio);
        debug_struct.field("short_term_allowed", &self.short_term_allowed);
        debug_struct.field("long_term_allowed", &self.long_term_allowed);
        debug_struct.field("long_term_denied", &self.long_term_denied);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about [Google Cloud Armor Adaptive
/// Protection](https://cloud.google.com/armor/docs/cloud-armor-overview#google-cloud-armor-adaptive-protection).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptiveProtection {
    /// A score of 0 means that there is low confidence that the detected event is
    /// an actual attack. A score of 1 means that there is high confidence that the
    /// detected event is an attack. See the [Adaptive Protection
    /// documentation](https://cloud.google.com/armor/docs/adaptive-protection-overview#configure-alert-tuning)
    /// for further explanation.
    pub confidence: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptiveProtection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [confidence][crate::model::AdaptiveProtection::confidence].
    pub fn set_confidence<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for AdaptiveProtection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.AdaptiveProtection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptiveProtection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptiveProtection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptiveProtection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptiveProtection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptiveProtection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdaptiveProtection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdaptiveProtection");
        debug_struct.field("confidence", &self.confidence);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information about DDoS attack volume and classification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Attack {
    /// Total PPS (packets per second) volume of attack.
    pub volume_pps_long: i64,

    /// Total BPS (bytes per second) volume of attack.
    pub volume_bps_long: i64,

    /// Type of attack, for example, 'SYN-flood', 'NTP-udp', or 'CHARGEN-udp'.
    pub classification: std::string::String,

    /// Total PPS (packets per second) volume of attack. Deprecated - refer to
    /// volume_pps_long instead.
    #[deprecated]
    pub volume_pps: i32,

    /// Total BPS (bytes per second) volume of attack. Deprecated - refer to
    /// volume_bps_long instead.
    #[deprecated]
    pub volume_bps: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Attack {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_pps_long][crate::model::Attack::volume_pps_long].
    pub fn set_volume_pps_long<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.volume_pps_long = v.into();
        self
    }

    /// Sets the value of [volume_bps_long][crate::model::Attack::volume_bps_long].
    pub fn set_volume_bps_long<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.volume_bps_long = v.into();
        self
    }

    /// Sets the value of [classification][crate::model::Attack::classification].
    pub fn set_classification<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.classification = v.into();
        self
    }

    /// Sets the value of [volume_pps][crate::model::Attack::volume_pps].
    #[deprecated]
    pub fn set_volume_pps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.volume_pps = v.into();
        self
    }

    /// Sets the value of [volume_bps][crate::model::Attack::volume_bps].
    #[deprecated]
    pub fn set_volume_bps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.volume_bps = v.into();
        self
    }
}

impl wkt::message::Message for Attack {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Attack"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Attack {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume_pps_long,
            __volume_bps_long,
            __classification,
            __volume_pps,
            __volume_bps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Attack")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumePpsLong" => Ok(__FieldTag::__volume_pps_long),
                            "volume_pps_long" => Ok(__FieldTag::__volume_pps_long),
                            "volumeBpsLong" => Ok(__FieldTag::__volume_bps_long),
                            "volume_bps_long" => Ok(__FieldTag::__volume_bps_long),
                            "classification" => Ok(__FieldTag::__classification),
                            "volumePps" => Ok(__FieldTag::__volume_pps),
                            "volume_pps" => Ok(__FieldTag::__volume_pps),
                            "volumeBps" => Ok(__FieldTag::__volume_bps),
                            "volume_bps" => Ok(__FieldTag::__volume_bps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Attack;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Attack")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume_pps_long => {
                            if !fields.insert(__FieldTag::__volume_pps_long) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_pps_long",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_pps_long =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_bps_long => {
                            if !fields.insert(__FieldTag::__volume_bps_long) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_bps_long",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_bps_long =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__classification => {
                            if !fields.insert(__FieldTag::__classification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classification",
                                ));
                            }
                            result.classification = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_pps => {
                            if !fields.insert(__FieldTag::__volume_pps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_pps",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_pps = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_bps => {
                            if !fields.insert(__FieldTag::__volume_bps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_bps",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_bps = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Attack {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.volume_pps_long) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumePpsLong", &__With(&self.volume_pps_long))?;
        }
        if !wkt::internal::is_default(&self.volume_bps_long) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeBpsLong", &__With(&self.volume_bps_long))?;
        }
        if !self.classification.is_empty() {
            state.serialize_entry("classification", &self.classification)?;
        }
        if !wkt::internal::is_default(&self.volume_pps) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumePps", &__With(&self.volume_pps))?;
        }
        if !wkt::internal::is_default(&self.volume_bps) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeBps", &__With(&self.volume_bps))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Attack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Attack");
        debug_struct.field("volume_pps_long", &self.volume_pps_long);
        debug_struct.field("volume_bps_long", &self.volume_bps_long);
        debug_struct.field("classification", &self.classification);
        debug_struct.field("volume_pps", &self.volume_pps);
        debug_struct.field("volume_bps", &self.volume_bps);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The [data profile](https://cloud.google.com/dlp/docs/data-profiles)
/// associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudDlpDataProfile {
    /// Name of the data profile, for example,
    /// `projects/123/locations/europe/tableProfiles/8383929`.
    pub data_profile: std::string::String,

    /// The resource hierarchy level at which the data profile was generated.
    pub parent_type: crate::model::cloud_dlp_data_profile::ParentType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudDlpDataProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_profile][crate::model::CloudDlpDataProfile::data_profile].
    pub fn set_data_profile<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_profile = v.into();
        self
    }

    /// Sets the value of [parent_type][crate::model::CloudDlpDataProfile::parent_type].
    pub fn set_parent_type<
        T: std::convert::Into<crate::model::cloud_dlp_data_profile::ParentType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.parent_type = v.into();
        self
    }
}

impl wkt::message::Message for CloudDlpDataProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CloudDlpDataProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudDlpDataProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_profile,
            __parent_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudDlpDataProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataProfile" => Ok(__FieldTag::__data_profile),
                            "data_profile" => Ok(__FieldTag::__data_profile),
                            "parentType" => Ok(__FieldTag::__parent_type),
                            "parent_type" => Ok(__FieldTag::__parent_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudDlpDataProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudDlpDataProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_profile => {
                            if !fields.insert(__FieldTag::__data_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_profile",
                                ));
                            }
                            result.data_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_type => {
                            if !fields.insert(__FieldTag::__parent_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_type",
                                ));
                            }
                            result.parent_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_dlp_data_profile::ParentType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudDlpDataProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_profile.is_empty() {
            state.serialize_entry("dataProfile", &self.data_profile)?;
        }
        if !wkt::internal::is_default(&self.parent_type) {
            state.serialize_entry("parentType", &self.parent_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudDlpDataProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudDlpDataProfile");
        debug_struct.field("data_profile", &self.data_profile);
        debug_struct.field("parent_type", &self.parent_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudDlpDataProfile].
pub mod cloud_dlp_data_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Parents for configurations that produce data profile findings.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ParentType {
        /// Unspecified parent type.
        Unspecified,
        /// Organization-level configurations.
        Organization,
        /// Project-level configurations.
        Project,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ParentType::value] or
        /// [ParentType::name].
        UnknownValue(parent_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod parent_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ParentType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Organization => std::option::Option::Some(1),
                Self::Project => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PARENT_TYPE_UNSPECIFIED"),
                Self::Organization => std::option::Option::Some("ORGANIZATION"),
                Self::Project => std::option::Option::Some("PROJECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ParentType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ParentType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ParentType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Organization,
                2 => Self::Project,
                _ => Self::UnknownValue(parent_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ParentType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PARENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ORGANIZATION" => Self::Organization,
                "PROJECT" => Self::Project,
                _ => Self::UnknownValue(parent_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ParentType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Organization => serializer.serialize_i32(1),
                Self::Project => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ParentType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ParentType>::new(
                ".google.cloud.securitycenter.v2.CloudDlpDataProfile.ParentType",
            ))
        }
    }
}

/// Details about the Cloud Data Loss Prevention (Cloud DLP) [inspection
/// job](https://cloud.google.com/dlp/docs/concepts-job-triggers) that produced
/// the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudDlpInspection {
    /// Name of the inspection job, for example,
    /// `projects/123/locations/europe/dlpJobs/i-8383929`.
    pub inspect_job: std::string::String,

    /// The type of information (or
    /// *[infoType](https://cloud.google.com/dlp/docs/infotypes-reference)*) found,
    /// for example, `EMAIL_ADDRESS` or `STREET_ADDRESS`.
    pub info_type: std::string::String,

    /// The number of times Cloud DLP found this infoType within this job
    /// and resource.
    pub info_type_count: i64,

    /// Whether Cloud DLP scanned the complete resource or a sampled subset.
    pub full_scan: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudDlpInspection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inspect_job][crate::model::CloudDlpInspection::inspect_job].
    pub fn set_inspect_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.inspect_job = v.into();
        self
    }

    /// Sets the value of [info_type][crate::model::CloudDlpInspection::info_type].
    pub fn set_info_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.info_type = v.into();
        self
    }

    /// Sets the value of [info_type_count][crate::model::CloudDlpInspection::info_type_count].
    pub fn set_info_type_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.info_type_count = v.into();
        self
    }

    /// Sets the value of [full_scan][crate::model::CloudDlpInspection::full_scan].
    pub fn set_full_scan<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.full_scan = v.into();
        self
    }
}

impl wkt::message::Message for CloudDlpInspection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CloudDlpInspection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudDlpInspection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inspect_job,
            __info_type,
            __info_type_count,
            __full_scan,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudDlpInspection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inspectJob" => Ok(__FieldTag::__inspect_job),
                            "inspect_job" => Ok(__FieldTag::__inspect_job),
                            "infoType" => Ok(__FieldTag::__info_type),
                            "info_type" => Ok(__FieldTag::__info_type),
                            "infoTypeCount" => Ok(__FieldTag::__info_type_count),
                            "info_type_count" => Ok(__FieldTag::__info_type_count),
                            "fullScan" => Ok(__FieldTag::__full_scan),
                            "full_scan" => Ok(__FieldTag::__full_scan),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudDlpInspection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudDlpInspection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inspect_job => {
                            if !fields.insert(__FieldTag::__inspect_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_job",
                                ));
                            }
                            result.inspect_job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__info_type => {
                            if !fields.insert(__FieldTag::__info_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type",
                                ));
                            }
                            result.info_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__info_type_count => {
                            if !fields.insert(__FieldTag::__info_type_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info_type_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.info_type_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__full_scan => {
                            if !fields.insert(__FieldTag::__full_scan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_scan",
                                ));
                            }
                            result.full_scan = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudDlpInspection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.inspect_job.is_empty() {
            state.serialize_entry("inspectJob", &self.inspect_job)?;
        }
        if !self.info_type.is_empty() {
            state.serialize_entry("infoType", &self.info_type)?;
        }
        if !wkt::internal::is_default(&self.info_type_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("infoTypeCount", &__With(&self.info_type_count))?;
        }
        if !wkt::internal::is_default(&self.full_scan) {
            state.serialize_entry("fullScan", &self.full_scan)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudDlpInspection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudDlpInspection");
        debug_struct.field("inspect_job", &self.inspect_job);
        debug_struct.field("info_type", &self.info_type);
        debug_struct.field("info_type_count", &self.info_type_count);
        debug_struct.field("full_scan", &self.full_scan);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains compliance information about a security standard indicating unmet
/// recommendations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Compliance {
    /// Industry-wide compliance standards or benchmarks, such as CIS, PCI, and
    /// OWASP.
    pub standard: std::string::String,

    /// Version of the standard or benchmark, for example, 1.1
    pub version: std::string::String,

    /// Policies within the standard or benchmark, for example, A.12.4.1
    pub ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Compliance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [standard][crate::model::Compliance::standard].
    pub fn set_standard<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.standard = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Compliance::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [ids][crate::model::Compliance::ids].
    pub fn set_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Compliance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Compliance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Compliance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __standard,
            __version,
            __ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Compliance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "standard" => Ok(__FieldTag::__standard),
                            "version" => Ok(__FieldTag::__version),
                            "ids" => Ok(__FieldTag::__ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Compliance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Compliance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__standard => {
                            if !fields.insert(__FieldTag::__standard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard",
                                ));
                            }
                            result.standard = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ids => {
                            if !fields.insert(__FieldTag::__ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ids",
                                ));
                            }
                            result.ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Compliance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.standard.is_empty() {
            state.serialize_entry("standard", &self.standard)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.ids.is_empty() {
            state.serialize_entry("ids", &self.ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Compliance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Compliance");
        debug_struct.field("standard", &self.standard);
        debug_struct.field("version", &self.version);
        debug_struct.field("ids", &self.ids);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information about the IP connection associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Connection {
    /// Destination IP address. Not present for sockets that are listening and not
    /// connected.
    pub destination_ip: std::string::String,

    /// Destination port. Not present for sockets that are listening and not
    /// connected.
    pub destination_port: i32,

    /// Source IP address.
    pub source_ip: std::string::String,

    /// Source port.
    pub source_port: i32,

    /// IANA Internet Protocol Number such as TCP(6) and UDP(17).
    pub protocol: crate::model::connection::Protocol,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination_ip][crate::model::Connection::destination_ip].
    pub fn set_destination_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination_ip = v.into();
        self
    }

    /// Sets the value of [destination_port][crate::model::Connection::destination_port].
    pub fn set_destination_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.destination_port = v.into();
        self
    }

    /// Sets the value of [source_ip][crate::model::Connection::source_ip].
    pub fn set_source_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_ip = v.into();
        self
    }

    /// Sets the value of [source_port][crate::model::Connection::source_port].
    pub fn set_source_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_port = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::Connection::protocol].
    pub fn set_protocol<T: std::convert::Into<crate::model::connection::Protocol>>(
        mut self,
        v: T,
    ) -> Self {
        self.protocol = v.into();
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Connection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Connection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __destination_ip,
            __destination_port,
            __source_ip,
            __source_port,
            __protocol,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Connection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "destinationIp" => Ok(__FieldTag::__destination_ip),
                            "destination_ip" => Ok(__FieldTag::__destination_ip),
                            "destinationPort" => Ok(__FieldTag::__destination_port),
                            "destination_port" => Ok(__FieldTag::__destination_port),
                            "sourceIp" => Ok(__FieldTag::__source_ip),
                            "source_ip" => Ok(__FieldTag::__source_ip),
                            "sourcePort" => Ok(__FieldTag::__source_port),
                            "source_port" => Ok(__FieldTag::__source_port),
                            "protocol" => Ok(__FieldTag::__protocol),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Connection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Connection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__destination_ip => {
                            if !fields.insert(__FieldTag::__destination_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_ip",
                                ));
                            }
                            result.destination_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_port => {
                            if !fields.insert(__FieldTag::__destination_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.destination_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_ip => {
                            if !fields.insert(__FieldTag::__source_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip",
                                ));
                            }
                            result.source_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_port => {
                            if !fields.insert(__FieldTag::__source_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map.next_value::<std::option::Option<crate::model::connection::Protocol>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Connection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.destination_ip.is_empty() {
            state.serialize_entry("destinationIp", &self.destination_ip)?;
        }
        if !wkt::internal::is_default(&self.destination_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("destinationPort", &__With(&self.destination_port))?;
        }
        if !self.source_ip.is_empty() {
            state.serialize_entry("sourceIp", &self.source_ip)?;
        }
        if !wkt::internal::is_default(&self.source_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourcePort", &__With(&self.source_port))?;
        }
        if !wkt::internal::is_default(&self.protocol) {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Connection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connection");
        debug_struct.field("destination_ip", &self.destination_ip);
        debug_struct.field("destination_port", &self.destination_port);
        debug_struct.field("source_ip", &self.source_ip);
        debug_struct.field("source_port", &self.source_port);
        debug_struct.field("protocol", &self.protocol);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// IANA Internet Protocol Number such as TCP(6) and UDP(17).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Protocol {
        /// Unspecified protocol (not HOPOPT).
        Unspecified,
        /// Internet Control Message Protocol.
        Icmp,
        /// Transmission Control Protocol.
        Tcp,
        /// User Datagram Protocol.
        Udp,
        /// Generic Routing Encapsulation.
        Gre,
        /// Encap Security Payload.
        Esp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Protocol::value] or
        /// [Protocol::name].
        UnknownValue(protocol::UnknownValue),
    }

    #[doc(hidden)]
    pub mod protocol {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Protocol {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Icmp => std::option::Option::Some(1),
                Self::Tcp => std::option::Option::Some(6),
                Self::Udp => std::option::Option::Some(17),
                Self::Gre => std::option::Option::Some(47),
                Self::Esp => std::option::Option::Some(50),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROTOCOL_UNSPECIFIED"),
                Self::Icmp => std::option::Option::Some("ICMP"),
                Self::Tcp => std::option::Option::Some("TCP"),
                Self::Udp => std::option::Option::Some("UDP"),
                Self::Gre => std::option::Option::Some("GRE"),
                Self::Esp => std::option::Option::Some("ESP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Protocol {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Protocol {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Protocol {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Icmp,
                6 => Self::Tcp,
                17 => Self::Udp,
                47 => Self::Gre,
                50 => Self::Esp,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Protocol {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROTOCOL_UNSPECIFIED" => Self::Unspecified,
                "ICMP" => Self::Icmp,
                "TCP" => Self::Tcp,
                "UDP" => Self::Udp,
                "GRE" => Self::Gre,
                "ESP" => Self::Esp,
                _ => Self::UnknownValue(protocol::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Protocol {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Icmp => serializer.serialize_i32(1),
                Self::Tcp => serializer.serialize_i32(6),
                Self::Udp => serializer.serialize_i32(17),
                Self::Gre => serializer.serialize_i32(47),
                Self::Esp => serializer.serialize_i32(50),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Protocol {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Protocol>::new(
                ".google.cloud.securitycenter.v2.Connection.Protocol",
            ))
        }
    }
}

/// Details about specific contacts
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ContactDetails {
    /// A list of contacts
    pub contacts: std::vec::Vec<crate::model::Contact>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContactDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contacts][crate::model::ContactDetails::contacts].
    pub fn set_contacts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Contact>,
    {
        use std::iter::Iterator;
        self.contacts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ContactDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ContactDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContactDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __contacts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContactDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contacts" => Ok(__FieldTag::__contacts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContactDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContactDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__contacts => {
                            if !fields.insert(__FieldTag::__contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contacts",
                                ));
                            }
                            result.contacts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Contact>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContactDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.contacts.is_empty() {
            state.serialize_entry("contacts", &self.contacts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ContactDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContactDetails");
        debug_struct.field("contacts", &self.contacts);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The email address of a contact.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Contact {
    /// An email address. For example, "`person123@company.com`".
    pub email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Contact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::Contact::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }
}

impl wkt::message::Message for Contact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Contact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Contact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Contact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Contact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Contact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Contact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Contact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Contact");
        debug_struct.field("email", &self.email);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Container associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Container {
    /// Name of the container.
    pub name: std::string::String,

    /// Container image URI provided when configuring a pod or container. This
    /// string can identify a container image version using mutable tags.
    pub uri: std::string::String,

    /// Optional container image ID, if provided by the container runtime. Uniquely
    /// identifies the container image launched using a container image digest.
    pub image_id: std::string::String,

    /// Container labels, as provided by the container runtime.
    pub labels: std::vec::Vec<crate::model::Label>,

    /// The time that the container was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Container {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Container::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Container::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [image_id][crate::model::Container::image_id].
    pub fn set_image_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Container::labels].
    pub fn set_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Label>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Container::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Container::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Container {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Container"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Container {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uri,
            __image_id,
            __labels,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Container")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uri" => Ok(__FieldTag::__uri),
                            "imageId" => Ok(__FieldTag::__image_id),
                            "image_id" => Ok(__FieldTag::__image_id),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Container;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Container")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_id => {
                            if !fields.insert(__FieldTag::__image_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_id",
                                ));
                            }
                            result.image_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Label>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Container {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.image_id.is_empty() {
            state.serialize_entry("imageId", &self.image_id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Container {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Container");
        debug_struct.field("name", &self.name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("image_id", &self.image_id);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("create_time", &self.create_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details about a data access attempt made by a principal not authorized under
/// applicable data security policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataAccessEvent {
    /// Unique identifier for data access event.
    pub event_id: std::string::String,

    /// The email address of the principal that accessed the data. The principal
    /// could be a user account, service account, Google group, or other.
    pub principal_email: std::string::String,

    /// The operation performed by the principal to access the data.
    pub operation: crate::model::data_access_event::Operation,

    /// Timestamp of data access event.
    pub event_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataAccessEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_id][crate::model::DataAccessEvent::event_id].
    pub fn set_event_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_id = v.into();
        self
    }

    /// Sets the value of [principal_email][crate::model::DataAccessEvent::principal_email].
    pub fn set_principal_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal_email = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::DataAccessEvent::operation].
    pub fn set_operation<T: std::convert::Into<crate::model::data_access_event::Operation>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::DataAccessEvent::event_time].
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::DataAccessEvent::event_time].
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataAccessEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.DataAccessEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataAccessEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __event_id,
            __principal_email,
            __operation,
            __event_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataAccessEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "eventId" => Ok(__FieldTag::__event_id),
                            "event_id" => Ok(__FieldTag::__event_id),
                            "principalEmail" => Ok(__FieldTag::__principal_email),
                            "principal_email" => Ok(__FieldTag::__principal_email),
                            "operation" => Ok(__FieldTag::__operation),
                            "eventTime" => Ok(__FieldTag::__event_time),
                            "event_time" => Ok(__FieldTag::__event_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataAccessEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataAccessEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__event_id => {
                            if !fields.insert(__FieldTag::__event_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_id",
                                ));
                            }
                            result.event_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__principal_email => {
                            if !fields.insert(__FieldTag::__principal_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_email",
                                ));
                            }
                            result.principal_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map.next_value::<std::option::Option<crate::model::data_access_event::Operation>>()?.unwrap_or_default();
                        }
                        __FieldTag::__event_time => {
                            if !fields.insert(__FieldTag::__event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_time",
                                ));
                            }
                            result.event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataAccessEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event_id.is_empty() {
            state.serialize_entry("eventId", &self.event_id)?;
        }
        if !self.principal_email.is_empty() {
            state.serialize_entry("principalEmail", &self.principal_email)?;
        }
        if !wkt::internal::is_default(&self.operation) {
            state.serialize_entry("operation", &self.operation)?;
        }
        if self.event_time.is_some() {
            state.serialize_entry("eventTime", &self.event_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataAccessEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataAccessEvent");
        debug_struct.field("event_id", &self.event_id);
        debug_struct.field("principal_email", &self.principal_email);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("event_time", &self.event_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DataAccessEvent].
pub mod data_access_event {
    #[allow(unused_imports)]
    use super::*;

    /// The operation of a data access event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operation {
        /// The operation is unspecified.
        Unspecified,
        /// Represents a read operation.
        Read,
        /// Represents a move operation.
        Move,
        /// Represents a copy operation.
        Copy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operation::value] or
        /// [Operation::name].
        UnknownValue(operation::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operation {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Operation {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Read => std::option::Option::Some(1),
                Self::Move => std::option::Option::Some(2),
                Self::Copy => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPERATION_UNSPECIFIED"),
                Self::Read => std::option::Option::Some("READ"),
                Self::Move => std::option::Option::Some("MOVE"),
                Self::Copy => std::option::Option::Some("COPY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Operation {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Operation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Operation {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Read,
                2 => Self::Move,
                3 => Self::Copy,
                _ => Self::UnknownValue(operation::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Operation {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATION_UNSPECIFIED" => Self::Unspecified,
                "READ" => Self::Read,
                "MOVE" => Self::Move,
                "COPY" => Self::Copy,
                _ => Self::UnknownValue(operation::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Operation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Read => serializer.serialize_i32(1),
                Self::Move => serializer.serialize_i32(2),
                Self::Copy => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Operation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operation>::new(
                ".google.cloud.securitycenter.v2.DataAccessEvent.Operation",
            ))
        }
    }
}

/// Details about a data flow event, in which either the data is moved to or is
/// accessed from a non-compliant geo-location, as defined in the applicable data
/// security policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataFlowEvent {
    /// Unique identifier for data flow event.
    pub event_id: std::string::String,

    /// The email address of the principal that initiated the data flow event. The
    /// principal could be a user account, service account, Google group, or other.
    pub principal_email: std::string::String,

    /// The operation performed by the principal for the data flow event.
    pub operation: crate::model::data_flow_event::Operation,

    /// Non-compliant location of the principal or the data destination.
    pub violated_location: std::string::String,

    /// Timestamp of data flow event.
    pub event_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataFlowEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_id][crate::model::DataFlowEvent::event_id].
    pub fn set_event_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_id = v.into();
        self
    }

    /// Sets the value of [principal_email][crate::model::DataFlowEvent::principal_email].
    pub fn set_principal_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.principal_email = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::DataFlowEvent::operation].
    pub fn set_operation<T: std::convert::Into<crate::model::data_flow_event::Operation>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [violated_location][crate::model::DataFlowEvent::violated_location].
    pub fn set_violated_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.violated_location = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::DataFlowEvent::event_time].
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::DataFlowEvent::event_time].
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataFlowEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.DataFlowEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataFlowEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __event_id,
            __principal_email,
            __operation,
            __violated_location,
            __event_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataFlowEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "eventId" => Ok(__FieldTag::__event_id),
                            "event_id" => Ok(__FieldTag::__event_id),
                            "principalEmail" => Ok(__FieldTag::__principal_email),
                            "principal_email" => Ok(__FieldTag::__principal_email),
                            "operation" => Ok(__FieldTag::__operation),
                            "violatedLocation" => Ok(__FieldTag::__violated_location),
                            "violated_location" => Ok(__FieldTag::__violated_location),
                            "eventTime" => Ok(__FieldTag::__event_time),
                            "event_time" => Ok(__FieldTag::__event_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataFlowEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataFlowEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__event_id => {
                            if !fields.insert(__FieldTag::__event_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_id",
                                ));
                            }
                            result.event_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__principal_email => {
                            if !fields.insert(__FieldTag::__principal_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_email",
                                ));
                            }
                            result.principal_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map.next_value::<std::option::Option<crate::model::data_flow_event::Operation>>()?.unwrap_or_default();
                        }
                        __FieldTag::__violated_location => {
                            if !fields.insert(__FieldTag::__violated_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for violated_location",
                                ));
                            }
                            result.violated_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_time => {
                            if !fields.insert(__FieldTag::__event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_time",
                                ));
                            }
                            result.event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataFlowEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event_id.is_empty() {
            state.serialize_entry("eventId", &self.event_id)?;
        }
        if !self.principal_email.is_empty() {
            state.serialize_entry("principalEmail", &self.principal_email)?;
        }
        if !wkt::internal::is_default(&self.operation) {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self.violated_location.is_empty() {
            state.serialize_entry("violatedLocation", &self.violated_location)?;
        }
        if self.event_time.is_some() {
            state.serialize_entry("eventTime", &self.event_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataFlowEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataFlowEvent");
        debug_struct.field("event_id", &self.event_id);
        debug_struct.field("principal_email", &self.principal_email);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("violated_location", &self.violated_location);
        debug_struct.field("event_time", &self.event_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DataFlowEvent].
pub mod data_flow_event {
    #[allow(unused_imports)]
    use super::*;

    /// The operation of a data flow event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operation {
        /// The operation is unspecified.
        Unspecified,
        /// Represents a read operation.
        Read,
        /// Represents a move operation.
        Move,
        /// Represents a copy operation.
        Copy,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operation::value] or
        /// [Operation::name].
        UnknownValue(operation::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operation {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Operation {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Read => std::option::Option::Some(1),
                Self::Move => std::option::Option::Some(2),
                Self::Copy => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPERATION_UNSPECIFIED"),
                Self::Read => std::option::Option::Some("READ"),
                Self::Move => std::option::Option::Some("MOVE"),
                Self::Copy => std::option::Option::Some("COPY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Operation {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Operation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Operation {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Read,
                2 => Self::Move,
                3 => Self::Copy,
                _ => Self::UnknownValue(operation::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Operation {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATION_UNSPECIFIED" => Self::Unspecified,
                "READ" => Self::Read,
                "MOVE" => Self::Move,
                "COPY" => Self::Copy,
                _ => Self::UnknownValue(operation::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Operation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Read => serializer.serialize_i32(1),
                Self::Move => serializer.serialize_i32(2),
                Self::Copy => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Operation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operation>::new(
                ".google.cloud.securitycenter.v2.DataFlowEvent.Operation",
            ))
        }
    }
}

/// Details about data retention deletion violations, in which the data is
/// non-compliant based on their retention or deletion time, as defined in the
/// applicable data security policy. The Data Retention Deletion (DRD) control is
/// a control of the DSPM (Data Security Posture Management) suite that enables
/// organizations to manage data retention and deletion policies in compliance
/// with regulations, such as GDPR and CRPA. DRD supports two primary policy
/// types: maximum storage length (max TTL) and minimum storage length (min TTL).
/// Both are aimed at helping organizations meet regulatory and data management
/// commitments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataRetentionDeletionEvent {
    /// Timestamp indicating when the event was detected.
    pub event_detection_time: std::option::Option<wkt::Timestamp>,

    /// Number of objects that violated the policy for this resource. If the number
    /// is less than 1,000, then the value of this field is the exact number. If
    /// the number of objects that violated the policy is greater than or equal to
    /// 1,000, then the value of this field is 1000.
    pub data_object_count: i64,

    /// Maximum duration of retention allowed from the DRD control. This comes
    /// from the DRD control where users set a max TTL for their data. For example,
    /// suppose that a user sets the max TTL for a Cloud Storage bucket to 90 days.
    /// However, an object in that bucket is 100 days old. In this case, a
    /// DataRetentionDeletionEvent will be generated for that Cloud Storage bucket,
    /// and the max_retention_allowed is 90 days.
    pub max_retention_allowed: std::option::Option<wkt::Duration>,

    /// Type of the DRD event.
    pub event_type: crate::model::data_retention_deletion_event::EventType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataRetentionDeletionEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_detection_time][crate::model::DataRetentionDeletionEvent::event_detection_time].
    pub fn set_event_detection_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_detection_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_detection_time][crate::model::DataRetentionDeletionEvent::event_detection_time].
    pub fn set_or_clear_event_detection_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_detection_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_object_count][crate::model::DataRetentionDeletionEvent::data_object_count].
    pub fn set_data_object_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_object_count = v.into();
        self
    }

    /// Sets the value of [max_retention_allowed][crate::model::DataRetentionDeletionEvent::max_retention_allowed].
    pub fn set_max_retention_allowed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_retention_allowed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_retention_allowed][crate::model::DataRetentionDeletionEvent::max_retention_allowed].
    pub fn set_or_clear_max_retention_allowed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_retention_allowed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_type][crate::model::DataRetentionDeletionEvent::event_type].
    pub fn set_event_type<
        T: std::convert::Into<crate::model::data_retention_deletion_event::EventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }
}

impl wkt::message::Message for DataRetentionDeletionEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.DataRetentionDeletionEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataRetentionDeletionEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __event_detection_time,
            __data_object_count,
            __max_retention_allowed,
            __event_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataRetentionDeletionEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "eventDetectionTime" => Ok(__FieldTag::__event_detection_time),
                            "event_detection_time" => Ok(__FieldTag::__event_detection_time),
                            "dataObjectCount" => Ok(__FieldTag::__data_object_count),
                            "data_object_count" => Ok(__FieldTag::__data_object_count),
                            "maxRetentionAllowed" => Ok(__FieldTag::__max_retention_allowed),
                            "max_retention_allowed" => Ok(__FieldTag::__max_retention_allowed),
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataRetentionDeletionEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataRetentionDeletionEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__event_detection_time => {
                            if !fields.insert(__FieldTag::__event_detection_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_detection_time",
                                ));
                            }
                            result.event_detection_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__data_object_count => {
                            if !fields.insert(__FieldTag::__data_object_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_object_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_object_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_retention_allowed => {
                            if !fields.insert(__FieldTag::__max_retention_allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_retention_allowed",
                                ));
                            }
                            result.max_retention_allowed =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type = map
                                .next_value::<std::option::Option<
                                    crate::model::data_retention_deletion_event::EventType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataRetentionDeletionEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.event_detection_time.is_some() {
            state.serialize_entry("eventDetectionTime", &self.event_detection_time)?;
        }
        if !wkt::internal::is_default(&self.data_object_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataObjectCount", &__With(&self.data_object_count))?;
        }
        if self.max_retention_allowed.is_some() {
            state.serialize_entry("maxRetentionAllowed", &self.max_retention_allowed)?;
        }
        if !wkt::internal::is_default(&self.event_type) {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataRetentionDeletionEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataRetentionDeletionEvent");
        debug_struct.field("event_detection_time", &self.event_detection_time);
        debug_struct.field("data_object_count", &self.data_object_count);
        debug_struct.field("max_retention_allowed", &self.max_retention_allowed);
        debug_struct.field("event_type", &self.event_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DataRetentionDeletionEvent].
pub mod data_retention_deletion_event {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the DRD event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Unspecified event type.
        Unspecified,
        /// The maximum retention time has been exceeded.
        MaxTtlExceeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MaxTtlExceeded => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::MaxTtlExceeded => std::option::Option::Some("EVENT_TYPE_MAX_TTL_EXCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MaxTtlExceeded,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EVENT_TYPE_MAX_TTL_EXCEEDED" => Self::MaxTtlExceeded,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MaxTtlExceeded => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.securitycenter.v2.DataRetentionDeletionEvent.EventType",
            ))
        }
    }
}

/// Represents database access information, such as queries. A database may be a
/// sub-resource of an instance (as in the case of Cloud SQL instances or Cloud
/// Spanner instances), or the database instance itself. Some database resources
/// might not have the [full resource
/// name](https://google.aip.dev/122#full-resource-names) populated because these
/// resource types, such as Cloud SQL databases, are not yet supported by Cloud
/// Asset Inventory. In these cases only the display name is provided.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Database {
    /// Some database resources may not have the [full resource
    /// name](https://google.aip.dev/122#full-resource-names) populated because
    /// these resource types are not yet supported by Cloud Asset Inventory (e.g.
    /// Cloud SQL databases). In these cases only the display name will be
    /// provided.
    /// The [full resource name](https://google.aip.dev/122#full-resource-names) of
    /// the database that the user connected to, if it is supported by Cloud Asset
    /// Inventory.
    pub name: std::string::String,

    /// The human-readable name of the database that the user connected to.
    pub display_name: std::string::String,

    /// The username used to connect to the database. The username might not be an
    /// IAM principal and does not have a set format.
    pub user_name: std::string::String,

    /// The SQL statement that is associated with the database access.
    pub query: std::string::String,

    /// The target usernames, roles, or groups of an SQL privilege grant, which is
    /// not an IAM policy change.
    pub grantees: std::vec::Vec<std::string::String>,

    /// The version of the database, for example, POSTGRES_14.
    /// See [the complete
    /// list](https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/SqlDatabaseVersion).
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Database::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [user_name][crate::model::Database::user_name].
    pub fn set_user_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::Database::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [grantees][crate::model::Database::grantees].
    pub fn set_grantees<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grantees = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version][crate::model::Database::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Database"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Database {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __user_name,
            __query,
            __grantees,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Database")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "userName" => Ok(__FieldTag::__user_name),
                            "user_name" => Ok(__FieldTag::__user_name),
                            "query" => Ok(__FieldTag::__query),
                            "grantees" => Ok(__FieldTag::__grantees),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Database;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Database")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_name => {
                            if !fields.insert(__FieldTag::__user_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_name",
                                ));
                            }
                            result.user_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grantees => {
                            if !fields.insert(__FieldTag::__grantees) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grantees",
                                ));
                            }
                            result.grantees = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Database {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.user_name.is_empty() {
            state.serialize_entry("userName", &self.user_name)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.grantees.is_empty() {
            state.serialize_entry("grantees", &self.grantees)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Database {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Database");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("user_name", &self.user_name);
        debug_struct.field("query", &self.query);
        debug_struct.field("grantees", &self.grantees);
        debug_struct.field("version", &self.version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information about the disk associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Disk {
    /// The name of the disk, for example,
    /// `https://www.googleapis.com/compute/v1/projects/{project-id}/zones/{zone-id}/disks/{disk-id}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Disk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Disk::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Disk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Disk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Disk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Disk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Disk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Disk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Disk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Disk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Disk");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Exfiltration represents a data exfiltration attempt from one or more sources
/// to one or more targets. The `sources` attribute lists the sources of the
/// exfiltrated data. The `targets` attribute lists the destinations the data was
/// copied to.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Exfiltration {
    /// If there are multiple sources, then the data is considered "joined" between
    /// them. For instance, BigQuery can join multiple tables, and each
    /// table would be considered a source.
    pub sources: std::vec::Vec<crate::model::ExfilResource>,

    /// If there are multiple targets, each target would get a complete copy of the
    /// "joined" source data.
    pub targets: std::vec::Vec<crate::model::ExfilResource>,

    /// Total exfiltrated bytes processed for the entire job.
    pub total_exfiltrated_bytes: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Exfiltration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sources][crate::model::Exfiltration::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExfilResource>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [targets][crate::model::Exfiltration::targets].
    pub fn set_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExfilResource>,
    {
        use std::iter::Iterator;
        self.targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_exfiltrated_bytes][crate::model::Exfiltration::total_exfiltrated_bytes].
    pub fn set_total_exfiltrated_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_exfiltrated_bytes = v.into();
        self
    }
}

impl wkt::message::Message for Exfiltration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Exfiltration"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Exfiltration {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sources,
            __targets,
            __total_exfiltrated_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Exfiltration")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sources" => Ok(__FieldTag::__sources),
                            "targets" => Ok(__FieldTag::__targets),
                            "totalExfiltratedBytes" => Ok(__FieldTag::__total_exfiltrated_bytes),
                            "total_exfiltrated_bytes" => Ok(__FieldTag::__total_exfiltrated_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Exfiltration;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Exfiltration")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sources",
                                ));
                            }
                            result.sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ExfilResource>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__targets => {
                            if !fields.insert(__FieldTag::__targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for targets",
                                ));
                            }
                            result.targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ExfilResource>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__total_exfiltrated_bytes => {
                            if !fields.insert(__FieldTag::__total_exfiltrated_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_exfiltrated_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_exfiltrated_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Exfiltration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self.targets.is_empty() {
            state.serialize_entry("targets", &self.targets)?;
        }
        if !wkt::internal::is_default(&self.total_exfiltrated_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalExfiltratedBytes",
                &__With(&self.total_exfiltrated_bytes),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Exfiltration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Exfiltration");
        debug_struct.field("sources", &self.sources);
        debug_struct.field("targets", &self.targets);
        debug_struct.field("total_exfiltrated_bytes", &self.total_exfiltrated_bytes);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Resource where data was exfiltrated from or exfiltrated to.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExfilResource {
    /// The resource's [full resource
    /// name](https://cloud.google.com/apis/design/resource_names#full_resource_name).
    pub name: std::string::String,

    /// Subcomponents of the asset that was exfiltrated, like URIs used during
    /// exfiltration, table names, databases, and filenames. For example, multiple
    /// tables might have been exfiltrated from the same Cloud SQL instance, or
    /// multiple files might have been exfiltrated from the same Cloud Storage
    /// bucket.
    pub components: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExfilResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExfilResource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [components][crate::model::ExfilResource::components].
    pub fn set_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExfilResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ExfilResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExfilResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __components,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExfilResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "components" => Ok(__FieldTag::__components),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExfilResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExfilResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__components => {
                            if !fields.insert(__FieldTag::__components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for components",
                                ));
                            }
                            result.components = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExfilResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.components.is_empty() {
            state.serialize_entry("components", &self.components)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExfilResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExfilResource");
        debug_struct.field("name", &self.name);
        debug_struct.field("components", &self.components);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Representation of third party SIEM/SOAR fields within SCC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExternalSystem {
    /// Full resource name of the external system. The following list
    /// shows some examples:
    ///
    /// + `organizations/1234/sources/5678/findings/123456/externalSystems/jira`
    ///
    /// `organizations/1234/sources/5678/locations/us/findings/123456/externalSystems/jira`
    ///
    /// + `folders/1234/sources/5678/findings/123456/externalSystems/jira`
    ///
    /// `folders/1234/sources/5678/locations/us/findings/123456/externalSystems/jira`
    ///
    /// + `projects/1234/sources/5678/findings/123456/externalSystems/jira`
    ///
    /// `projects/1234/sources/5678/locations/us/findings/123456/externalSystems/jira`
    pub name: std::string::String,

    /// References primary/secondary etc assignees in the external system.
    pub assignees: std::vec::Vec<std::string::String>,

    /// The identifier that's used to track the finding's corresponding case in the
    /// external system.
    pub external_uid: std::string::String,

    /// The most recent status of the finding's corresponding case, as reported by
    /// the external system.
    pub status: std::string::String,

    /// The time when the case was last updated, as reported by the external
    /// system.
    pub external_system_update_time: std::option::Option<wkt::Timestamp>,

    /// The link to the finding's corresponding case in the external system.
    pub case_uri: std::string::String,

    /// The priority of the finding's corresponding case in the external system.
    pub case_priority: std::string::String,

    /// The SLA of the finding's corresponding case in the external system.
    pub case_sla: std::option::Option<wkt::Timestamp>,

    /// The time when the case was created, as reported by the external system.
    pub case_create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the case was closed, as reported by the external system.
    pub case_close_time: std::option::Option<wkt::Timestamp>,

    /// Information about the ticket, if any, that is being used to track the
    /// resolution of the issue that is identified by this finding.
    pub ticket_info: std::option::Option<crate::model::external_system::TicketInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExternalSystem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExternalSystem::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [assignees][crate::model::ExternalSystem::assignees].
    pub fn set_assignees<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.assignees = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [external_uid][crate::model::ExternalSystem::external_uid].
    pub fn set_external_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_uid = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ExternalSystem::status].
    pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [external_system_update_time][crate::model::ExternalSystem::external_system_update_time].
    pub fn set_external_system_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.external_system_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_system_update_time][crate::model::ExternalSystem::external_system_update_time].
    pub fn set_or_clear_external_system_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.external_system_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [case_uri][crate::model::ExternalSystem::case_uri].
    pub fn set_case_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.case_uri = v.into();
        self
    }

    /// Sets the value of [case_priority][crate::model::ExternalSystem::case_priority].
    pub fn set_case_priority<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.case_priority = v.into();
        self
    }

    /// Sets the value of [case_sla][crate::model::ExternalSystem::case_sla].
    pub fn set_case_sla<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.case_sla = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [case_sla][crate::model::ExternalSystem::case_sla].
    pub fn set_or_clear_case_sla<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.case_sla = v.map(|x| x.into());
        self
    }

    /// Sets the value of [case_create_time][crate::model::ExternalSystem::case_create_time].
    pub fn set_case_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.case_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [case_create_time][crate::model::ExternalSystem::case_create_time].
    pub fn set_or_clear_case_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.case_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [case_close_time][crate::model::ExternalSystem::case_close_time].
    pub fn set_case_close_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.case_close_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [case_close_time][crate::model::ExternalSystem::case_close_time].
    pub fn set_or_clear_case_close_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.case_close_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ticket_info][crate::model::ExternalSystem::ticket_info].
    pub fn set_ticket_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::external_system::TicketInfo>,
    {
        self.ticket_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ticket_info][crate::model::ExternalSystem::ticket_info].
    pub fn set_or_clear_ticket_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::external_system::TicketInfo>,
    {
        self.ticket_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExternalSystem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ExternalSystem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExternalSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __assignees,
            __external_uid,
            __status,
            __external_system_update_time,
            __case_uri,
            __case_priority,
            __case_sla,
            __case_create_time,
            __case_close_time,
            __ticket_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExternalSystem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "assignees" => Ok(__FieldTag::__assignees),
                            "externalUid" => Ok(__FieldTag::__external_uid),
                            "external_uid" => Ok(__FieldTag::__external_uid),
                            "status" => Ok(__FieldTag::__status),
                            "externalSystemUpdateTime" => {
                                Ok(__FieldTag::__external_system_update_time)
                            }
                            "external_system_update_time" => {
                                Ok(__FieldTag::__external_system_update_time)
                            }
                            "caseUri" => Ok(__FieldTag::__case_uri),
                            "case_uri" => Ok(__FieldTag::__case_uri),
                            "casePriority" => Ok(__FieldTag::__case_priority),
                            "case_priority" => Ok(__FieldTag::__case_priority),
                            "caseSla" => Ok(__FieldTag::__case_sla),
                            "case_sla" => Ok(__FieldTag::__case_sla),
                            "caseCreateTime" => Ok(__FieldTag::__case_create_time),
                            "case_create_time" => Ok(__FieldTag::__case_create_time),
                            "caseCloseTime" => Ok(__FieldTag::__case_close_time),
                            "case_close_time" => Ok(__FieldTag::__case_close_time),
                            "ticketInfo" => Ok(__FieldTag::__ticket_info),
                            "ticket_info" => Ok(__FieldTag::__ticket_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExternalSystem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExternalSystem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assignees => {
                            if !fields.insert(__FieldTag::__assignees) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assignees",
                                ));
                            }
                            result.assignees = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__external_uid => {
                            if !fields.insert(__FieldTag::__external_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_uid",
                                ));
                            }
                            result.external_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_system_update_time => {
                            if !fields.insert(__FieldTag::__external_system_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_system_update_time",
                                ));
                            }
                            result.external_system_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__case_uri => {
                            if !fields.insert(__FieldTag::__case_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for case_uri",
                                ));
                            }
                            result.case_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__case_priority => {
                            if !fields.insert(__FieldTag::__case_priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for case_priority",
                                ));
                            }
                            result.case_priority = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__case_sla => {
                            if !fields.insert(__FieldTag::__case_sla) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for case_sla",
                                ));
                            }
                            result.case_sla =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__case_create_time => {
                            if !fields.insert(__FieldTag::__case_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for case_create_time",
                                ));
                            }
                            result.case_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__case_close_time => {
                            if !fields.insert(__FieldTag::__case_close_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for case_close_time",
                                ));
                            }
                            result.case_close_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__ticket_info => {
                            if !fields.insert(__FieldTag::__ticket_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ticket_info",
                                ));
                            }
                            result.ticket_info = map.next_value::<std::option::Option<crate::model::external_system::TicketInfo>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExternalSystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.assignees.is_empty() {
            state.serialize_entry("assignees", &self.assignees)?;
        }
        if !self.external_uid.is_empty() {
            state.serialize_entry("externalUid", &self.external_uid)?;
        }
        if !self.status.is_empty() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.external_system_update_time.is_some() {
            state.serialize_entry(
                "externalSystemUpdateTime",
                &self.external_system_update_time,
            )?;
        }
        if !self.case_uri.is_empty() {
            state.serialize_entry("caseUri", &self.case_uri)?;
        }
        if !self.case_priority.is_empty() {
            state.serialize_entry("casePriority", &self.case_priority)?;
        }
        if self.case_sla.is_some() {
            state.serialize_entry("caseSla", &self.case_sla)?;
        }
        if self.case_create_time.is_some() {
            state.serialize_entry("caseCreateTime", &self.case_create_time)?;
        }
        if self.case_close_time.is_some() {
            state.serialize_entry("caseCloseTime", &self.case_close_time)?;
        }
        if self.ticket_info.is_some() {
            state.serialize_entry("ticketInfo", &self.ticket_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExternalSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExternalSystem");
        debug_struct.field("name", &self.name);
        debug_struct.field("assignees", &self.assignees);
        debug_struct.field("external_uid", &self.external_uid);
        debug_struct.field("status", &self.status);
        debug_struct.field(
            "external_system_update_time",
            &self.external_system_update_time,
        );
        debug_struct.field("case_uri", &self.case_uri);
        debug_struct.field("case_priority", &self.case_priority);
        debug_struct.field("case_sla", &self.case_sla);
        debug_struct.field("case_create_time", &self.case_create_time);
        debug_struct.field("case_close_time", &self.case_close_time);
        debug_struct.field("ticket_info", &self.ticket_info);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExternalSystem].
pub mod external_system {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the ticket, if any, that is being used to track the
    /// resolution of the issue that is identified by this finding.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TicketInfo {
        /// The identifier of the ticket in the ticket system.
        pub id: std::string::String,

        /// The assignee of the ticket in the ticket system.
        pub assignee: std::string::String,

        /// The description of the ticket in the ticket system.
        pub description: std::string::String,

        /// The link to the ticket in the ticket system.
        pub uri: std::string::String,

        /// The latest status of the ticket, as reported by the ticket system.
        pub status: std::string::String,

        /// The time when the ticket was last updated, as reported by the ticket
        /// system.
        pub update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TicketInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::external_system::TicketInfo::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [assignee][crate::model::external_system::TicketInfo::assignee].
        pub fn set_assignee<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.assignee = v.into();
            self
        }

        /// Sets the value of [description][crate::model::external_system::TicketInfo::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [uri][crate::model::external_system::TicketInfo::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [status][crate::model::external_system::TicketInfo::status].
        pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::external_system::TicketInfo::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::external_system::TicketInfo::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TicketInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.ExternalSystem.TicketInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TicketInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __assignee,
                __description,
                __uri,
                __status,
                __update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TicketInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "assignee" => Ok(__FieldTag::__assignee),
                                "description" => Ok(__FieldTag::__description),
                                "uri" => Ok(__FieldTag::__uri),
                                "status" => Ok(__FieldTag::__status),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TicketInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TicketInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__assignee => {
                                if !fields.insert(__FieldTag::__assignee) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for assignee",
                                    ));
                                }
                                result.assignee = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TicketInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.assignee.is_empty() {
                state.serialize_entry("assignee", &self.assignee)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.status.is_empty() {
                state.serialize_entry("status", &self.status)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TicketInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TicketInfo");
            debug_struct.field("id", &self.id);
            debug_struct.field("assignee", &self.assignee);
            debug_struct.field("description", &self.description);
            debug_struct.field("uri", &self.uri);
            debug_struct.field("status", &self.status);
            debug_struct.field("update_time", &self.update_time);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// File information about the related binary/library used by an executable, or
/// the script used by a script interpreter
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct File {
    /// Absolute path of the file as a JSON encoded string.
    pub path: std::string::String,

    /// Size of the file in bytes.
    pub size: i64,

    /// SHA256 hash of the first hashed_size bytes of the file encoded as a
    /// hex string.  If hashed_size == size, sha256 represents the SHA256 hash
    /// of the entire file.
    pub sha256: std::string::String,

    /// The length in bytes of the file prefix that was hashed.  If
    /// hashed_size == size, any hashes reported represent the entire
    /// file.
    pub hashed_size: i64,

    /// True when the hash covers only a prefix of the file.
    pub partially_hashed: bool,

    /// Prefix of the file contents as a JSON-encoded string.
    pub contents: std::string::String,

    /// Path of the file in terms of underlying disk/partition identifiers.
    pub disk_path: std::option::Option<crate::model::file::DiskPath>,

    /// Operation(s) performed on a file.
    pub operations: std::vec::Vec<crate::model::file::FileOperation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl File {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::File::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [size][crate::model::File::size].
    pub fn set_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size = v.into();
        self
    }

    /// Sets the value of [sha256][crate::model::File::sha256].
    pub fn set_sha256<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sha256 = v.into();
        self
    }

    /// Sets the value of [hashed_size][crate::model::File::hashed_size].
    pub fn set_hashed_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.hashed_size = v.into();
        self
    }

    /// Sets the value of [partially_hashed][crate::model::File::partially_hashed].
    pub fn set_partially_hashed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partially_hashed = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::File::contents].
    pub fn set_contents<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.contents = v.into();
        self
    }

    /// Sets the value of [disk_path][crate::model::File::disk_path].
    pub fn set_disk_path<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::file::DiskPath>,
    {
        self.disk_path = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_path][crate::model::File::disk_path].
    pub fn set_or_clear_disk_path<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::file::DiskPath>,
    {
        self.disk_path = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operations][crate::model::File::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::file::FileOperation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for File {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.File"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for File {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __size,
            __sha256,
            __hashed_size,
            __partially_hashed,
            __contents,
            __disk_path,
            __operations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for File")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "size" => Ok(__FieldTag::__size),
                            "sha256" => Ok(__FieldTag::__sha256),
                            "hashedSize" => Ok(__FieldTag::__hashed_size),
                            "hashed_size" => Ok(__FieldTag::__hashed_size),
                            "partiallyHashed" => Ok(__FieldTag::__partially_hashed),
                            "partially_hashed" => Ok(__FieldTag::__partially_hashed),
                            "contents" => Ok(__FieldTag::__contents),
                            "diskPath" => Ok(__FieldTag::__disk_path),
                            "disk_path" => Ok(__FieldTag::__disk_path),
                            "operations" => Ok(__FieldTag::__operations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = File;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct File")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size => {
                            if !fields.insert(__FieldTag::__size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sha256 => {
                            if !fields.insert(__FieldTag::__sha256) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha256",
                                ));
                            }
                            result.sha256 = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hashed_size => {
                            if !fields.insert(__FieldTag::__hashed_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hashed_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hashed_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__partially_hashed => {
                            if !fields.insert(__FieldTag::__partially_hashed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partially_hashed",
                                ));
                            }
                            result.partially_hashed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            result.contents = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_path => {
                            if !fields.insert(__FieldTag::__disk_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_path",
                                ));
                            }
                            result.disk_path = map
                                .next_value::<std::option::Option<crate::model::file::DiskPath>>(
                                )?;
                        }
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::file::FileOperation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for File {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !wkt::internal::is_default(&self.size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if !self.sha256.is_empty() {
            state.serialize_entry("sha256", &self.sha256)?;
        }
        if !wkt::internal::is_default(&self.hashed_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hashedSize", &__With(&self.hashed_size))?;
        }
        if !wkt::internal::is_default(&self.partially_hashed) {
            state.serialize_entry("partiallyHashed", &self.partially_hashed)?;
        }
        if !self.contents.is_empty() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if self.disk_path.is_some() {
            state.serialize_entry("diskPath", &self.disk_path)?;
        }
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for File {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("File");
        debug_struct.field("path", &self.path);
        debug_struct.field("size", &self.size);
        debug_struct.field("sha256", &self.sha256);
        debug_struct.field("hashed_size", &self.hashed_size);
        debug_struct.field("partially_hashed", &self.partially_hashed);
        debug_struct.field("contents", &self.contents);
        debug_struct.field("disk_path", &self.disk_path);
        debug_struct.field("operations", &self.operations);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [File].
pub mod file {
    #[allow(unused_imports)]
    use super::*;

    /// Path of the file in terms of underlying disk/partition identifiers.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DiskPath {
        /// UUID of the partition (format
        /// <https://wiki.archlinux.org/title/persistent_block_device_naming#by-uuid>)
        pub partition_uuid: std::string::String,

        /// Relative path of the file in the partition as a JSON encoded string.
        /// Example: /home/user1/executable_file.sh
        pub relative_path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiskPath {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [partition_uuid][crate::model::file::DiskPath::partition_uuid].
        pub fn set_partition_uuid<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.partition_uuid = v.into();
            self
        }

        /// Sets the value of [relative_path][crate::model::file::DiskPath::relative_path].
        pub fn set_relative_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.relative_path = v.into();
            self
        }
    }

    impl wkt::message::Message for DiskPath {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.File.DiskPath"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DiskPath {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __partition_uuid,
                __relative_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DiskPath")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "partitionUuid" => Ok(__FieldTag::__partition_uuid),
                                "partition_uuid" => Ok(__FieldTag::__partition_uuid),
                                "relativePath" => Ok(__FieldTag::__relative_path),
                                "relative_path" => Ok(__FieldTag::__relative_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DiskPath;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DiskPath")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__partition_uuid => {
                                if !fields.insert(__FieldTag::__partition_uuid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for partition_uuid",
                                    ));
                                }
                                result.partition_uuid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__relative_path => {
                                if !fields.insert(__FieldTag::__relative_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for relative_path",
                                    ));
                                }
                                result.relative_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DiskPath {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.partition_uuid.is_empty() {
                state.serialize_entry("partitionUuid", &self.partition_uuid)?;
            }
            if !self.relative_path.is_empty() {
                state.serialize_entry("relativePath", &self.relative_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DiskPath {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DiskPath");
            debug_struct.field("partition_uuid", &self.partition_uuid);
            debug_struct.field("relative_path", &self.relative_path);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Operation(s) performed on a file.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FileOperation {
        /// The type of the operation
        pub r#type: crate::model::file::file_operation::OperationType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FileOperation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::file::FileOperation::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::file::file_operation::OperationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for FileOperation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.File.FileOperation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FileOperation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FileOperation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FileOperation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FileOperation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::file::file_operation::OperationType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FileOperation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FileOperation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FileOperation");
            debug_struct.field("r#type", &self.r#type);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [FileOperation].
    pub mod file_operation {
        #[allow(unused_imports)]
        use super::*;

        /// The type of the operation
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum OperationType {
            /// The operation is unspecified.
            Unspecified,
            /// Represents an open operation.
            Open,
            /// Represents a read operation.
            Read,
            /// Represents a rename operation.
            Rename,
            /// Represents a write operation.
            Write,
            /// Represents an execute operation.
            Execute,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [OperationType::value] or
            /// [OperationType::name].
            UnknownValue(operation_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod operation_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl OperationType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Open => std::option::Option::Some(1),
                    Self::Read => std::option::Option::Some(2),
                    Self::Rename => std::option::Option::Some(3),
                    Self::Write => std::option::Option::Some(4),
                    Self::Execute => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATION_TYPE_UNSPECIFIED"),
                    Self::Open => std::option::Option::Some("OPEN"),
                    Self::Read => std::option::Option::Some("READ"),
                    Self::Rename => std::option::Option::Some("RENAME"),
                    Self::Write => std::option::Option::Some("WRITE"),
                    Self::Execute => std::option::Option::Some("EXECUTE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for OperationType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for OperationType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for OperationType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Open,
                    2 => Self::Read,
                    3 => Self::Rename,
                    4 => Self::Write,
                    5 => Self::Execute,
                    _ => Self::UnknownValue(operation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for OperationType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "OPEN" => Self::Open,
                    "READ" => Self::Read,
                    "RENAME" => Self::Rename,
                    "WRITE" => Self::Write,
                    "EXECUTE" => Self::Execute,
                    _ => Self::UnknownValue(operation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for OperationType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Open => serializer.serialize_i32(1),
                    Self::Read => serializer.serialize_i32(2),
                    Self::Rename => serializer.serialize_i32(3),
                    Self::Write => serializer.serialize_i32(4),
                    Self::Execute => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for OperationType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationType>::new(
                    ".google.cloud.securitycenter.v2.File.FileOperation.OperationType",
                ))
            }
        }
    }
}

/// Security Command Center finding.
///
/// A finding is a record of assessment data like security, risk, health, or
/// privacy, that is ingested into Security Command Center for presentation,
/// notification, analysis, policy testing, and enforcement. For example, a
/// cross-site scripting (XSS) vulnerability in an App Engine application is a
/// finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Finding {
    /// Identifier. The [relative resource
    /// name](https://cloud.google.com/apis/design/resource_names#relative_resource_name)
    /// of the finding. The following list shows some examples:
    ///
    ///
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}`
    /// +
    /// `organizations/{organization_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `folders/{folder_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `folders/{folder_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `projects/{project_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `projects/{project_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    pub name: std::string::String,

    /// Output only. The canonical name of the finding. The following list shows
    /// some examples:
    ///
    ///
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}`
    /// +
    /// `organizations/{organization_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `folders/{folder_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `folders/{folder_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `projects/{project_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `projects/{project_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// The prefix is the closest CRM ancestor of the resource associated with the
    /// finding.
    pub canonical_name: std::string::String,

    /// The relative resource name of the source and location the finding belongs
    /// to. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// This field is immutable after creation time. The following list shows some
    /// examples:
    ///
    /// + `organizations/{organization_id}/sources/{source_id}`
    /// + `folders/{folders_id}/sources/{source_id}`
    /// + `projects/{projects_id}/sources/{source_id}`
    ///
    /// `organizations/{organization_id}/sources/{source_id}/locations/{location_id}`
    ///
    /// + `folders/{folders_id}/sources/{source_id}/locations/{location_id}`
    /// + `projects/{projects_id}/sources/{source_id}/locations/{location_id}`
    pub parent: std::string::String,

    /// Immutable. For findings on Google Cloud resources, the full resource
    /// name of the Google Cloud resource this finding is for. See:
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    /// When the finding is for a non-Google Cloud resource, the resourceName can
    /// be a customer or partner defined string.
    pub resource_name: std::string::String,

    /// Output only. The state of the finding.
    pub state: crate::model::finding::State,

    /// Immutable. The additional taxonomy group within findings from a given
    /// source. Example: "XSS_FLASH_INJECTION"
    pub category: std::string::String,

    /// The URI that, if available, points to a web page outside of Security
    /// Command Center where additional information about the finding can be found.
    /// This field is guaranteed to be either empty or a well formed URL.
    pub external_uri: std::string::String,

    /// Source specific properties. These properties are managed by the source
    /// that writes the finding. The key names in the source_properties map must be
    /// between 1 and 255 characters, and must start with a letter and contain
    /// alphanumeric characters or underscores only.
    pub source_properties: std::collections::HashMap<std::string::String, wkt::Value>,

    /// Output only. User specified security marks. These marks are entirely
    /// managed by the user and come from the SecurityMarks resource that belongs
    /// to the finding.
    pub security_marks: std::option::Option<crate::model::SecurityMarks>,

    /// The time the finding was first detected. If an existing finding is updated,
    /// then this is the time the update occurred.
    /// For example, if the finding represents an open firewall, this property
    /// captures the time the detector believes the firewall became open. The
    /// accuracy is determined by the detector. If the finding is later resolved,
    /// then this time reflects when the finding was resolved. This must not
    /// be set to a value greater than the current timestamp.
    pub event_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the finding was created in Security Command
    /// Center.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The severity of the finding. This field is managed by the source that
    /// writes the finding.
    pub severity: crate::model::finding::Severity,

    /// Indicates the mute state of a finding (either muted, unmuted
    /// or undefined). Unlike other attributes of a finding, a finding provider
    /// shouldn't set the value of mute.
    pub mute: crate::model::finding::Mute,

    /// Output only. The mute information regarding this finding.
    pub mute_info: std::option::Option<crate::model::finding::MuteInfo>,

    /// The class of the finding.
    pub finding_class: crate::model::finding::FindingClass,

    /// Represents what's commonly known as an *indicator of compromise* (IoC) in
    /// computer forensics. This is an artifact observed on a network or in an
    /// operating system that, with high confidence, indicates a computer
    /// intrusion. For more information, see [Indicator of
    /// compromise](https://en.wikipedia.org/wiki/Indicator_of_compromise).
    pub indicator: std::option::Option<crate::model::Indicator>,

    /// Represents vulnerability-specific fields like CVE and CVSS scores.
    /// CVE stands for Common Vulnerabilities and Exposures
    /// (<https://cve.mitre.org/about/>)
    pub vulnerability: std::option::Option<crate::model::Vulnerability>,

    /// Output only. The most recent time this finding was muted or unmuted.
    pub mute_update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Third party SIEM/SOAR fields within SCC, contains external
    /// system information and external system finding fields.
    pub external_systems:
        std::collections::HashMap<std::string::String, crate::model::ExternalSystem>,

    /// MITRE ATT&CK tactics and techniques related to this finding.
    /// See: <https://attack.mitre.org>
    pub mitre_attack: std::option::Option<crate::model::MitreAttack>,

    /// Access details associated with the finding, such as more information on the
    /// caller, which method was accessed, and from where.
    pub access: std::option::Option<crate::model::Access>,

    /// Contains information about the IP connection associated with the finding.
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// Records additional information about the mute operation, for example, the
    /// [mute
    /// configuration](https://cloud.google.com/security-command-center/docs/how-to-mute-findings)
    /// that muted the finding and the user who muted the finding.
    pub mute_initiator: std::string::String,

    /// Represents operating system processes associated with the Finding.
    pub processes: std::vec::Vec<crate::model::Process>,

    /// Output only. Map containing the points of contact for the given finding.
    /// The key represents the type of contact, while the value contains a list of
    /// all the contacts that pertain. Please refer to:
    /// <https://cloud.google.com/resource-manager/docs/managing-notification-contacts#notification-categories>
    ///
    /// ```norust
    /// {
    ///   "security": {
    ///     "contacts": [
    ///       {
    ///         "email": "person1@company.com"
    ///       },
    ///       {
    ///         "email": "person2@company.com"
    ///       }
    ///     ]
    ///   }
    /// }
    /// ```
    pub contacts: std::collections::HashMap<std::string::String, crate::model::ContactDetails>,

    /// Contains compliance information for security standards associated to the
    /// finding.
    pub compliances: std::vec::Vec<crate::model::Compliance>,

    /// Output only. The human readable display name of the finding source such as
    /// "Event Threat Detection" or "Security Health Analytics".
    pub parent_display_name: std::string::String,

    /// Contains more details about the finding.
    pub description: std::string::String,

    /// Represents exfiltrations associated with the finding.
    pub exfiltration: std::option::Option<crate::model::Exfiltration>,

    /// Represents IAM bindings associated with the finding.
    pub iam_bindings: std::vec::Vec<crate::model::IamBinding>,

    /// Steps to address the finding.
    pub next_steps: std::string::String,

    /// Unique identifier of the module which generated the finding.
    /// Example:
    /// folders/598186756061/securityHealthAnalyticsSettings/customModules/56799441161885
    pub module_name: std::string::String,

    /// Containers associated with the finding. This field provides information for
    /// both Kubernetes and non-Kubernetes containers.
    pub containers: std::vec::Vec<crate::model::Container>,

    /// Kubernetes resources associated with the finding.
    pub kubernetes: std::option::Option<crate::model::Kubernetes>,

    /// Database associated with the finding.
    pub database: std::option::Option<crate::model::Database>,

    /// The results of an attack path simulation relevant to this finding.
    pub attack_exposure: std::option::Option<crate::model::AttackExposure>,

    /// File associated with the finding.
    pub files: std::vec::Vec<crate::model::File>,

    /// Cloud Data Loss Prevention (Cloud DLP) inspection results that are
    /// associated with the finding.
    pub cloud_dlp_inspection: std::option::Option<crate::model::CloudDlpInspection>,

    /// Cloud DLP data profile that is associated with the finding.
    pub cloud_dlp_data_profile: std::option::Option<crate::model::CloudDlpDataProfile>,

    /// Signature of the kernel rootkit.
    pub kernel_rootkit: std::option::Option<crate::model::KernelRootkit>,

    /// Contains information about the org policies associated with the finding.
    pub org_policies: std::vec::Vec<crate::model::OrgPolicy>,

    /// Job associated with the finding.
    pub job: std::option::Option<crate::model::Job>,

    /// Represents an application associated with the finding.
    pub application: std::option::Option<crate::model::Application>,

    /// IP rules associated with the finding.
    pub ip_rules: std::option::Option<crate::model::IpRules>,

    /// Fields related to Backup and DR findings.
    pub backup_disaster_recovery: std::option::Option<crate::model::BackupDisasterRecovery>,

    /// The security posture associated with the finding.
    pub security_posture: std::option::Option<crate::model::SecurityPosture>,

    /// Log entries that are relevant to the finding.
    pub log_entries: std::vec::Vec<crate::model::LogEntry>,

    /// The load balancers associated with the finding.
    pub load_balancers: std::vec::Vec<crate::model::LoadBalancer>,

    /// Fields related to Cloud Armor findings.
    pub cloud_armor: std::option::Option<crate::model::CloudArmor>,

    /// Notebook associated with the finding.
    pub notebook: std::option::Option<crate::model::Notebook>,

    /// Contains details about a group of security issues that, when the issues
    /// occur together, represent a greater risk than when the issues occur
    /// independently. A group of such issues is referred to as a toxic
    /// combination.
    /// This field cannot be updated. Its value is ignored in all update requests.
    pub toxic_combination: std::option::Option<crate::model::ToxicCombination>,

    /// Contains details about groups of which this finding is a member. A group is
    /// a collection of findings that are related in some way.
    /// This field cannot be updated. Its value is ignored in all update requests.
    pub group_memberships: std::vec::Vec<crate::model::GroupMembership>,

    /// Disk associated with the finding.
    pub disk: std::option::Option<crate::model::Disk>,

    /// Data access events associated with the finding.
    pub data_access_events: std::vec::Vec<crate::model::DataAccessEvent>,

    /// Data flow events associated with the finding.
    pub data_flow_events: std::vec::Vec<crate::model::DataFlowEvent>,

    /// Represents the VPC networks that the resource is attached to.
    pub networks: std::vec::Vec<crate::model::Network>,

    /// Data retention deletion events associated with the finding.
    pub data_retention_deletion_events: std::vec::Vec<crate::model::DataRetentionDeletionEvent>,

    /// AffectedResources associated with the finding.
    pub affected_resources: std::option::Option<crate::model::AffectedResources>,

    /// The AI model associated with the finding.
    pub ai_model: std::option::Option<crate::model::AiModel>,

    /// Contains details about a chokepoint, which is a resource or resource group
    /// where high-risk attack paths converge, based on [attack path simulations]
    /// (<https://cloud.google.com/security-command-center/docs/attack-exposure-learn#attack_path_simulations>).
    /// This field cannot be updated. Its value is ignored in all update requests.
    pub chokepoint: std::option::Option<crate::model::Chokepoint>,

    /// VertexAi associated with the finding.
    pub vertex_ai: std::option::Option<crate::model::VertexAi>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Finding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Finding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [canonical_name][crate::model::Finding::canonical_name].
    pub fn set_canonical_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.canonical_name = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::Finding::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [resource_name][crate::model::Finding::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Finding::state].
    pub fn set_state<T: std::convert::Into<crate::model::finding::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [category][crate::model::Finding::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [external_uri][crate::model::Finding::external_uri].
    pub fn set_external_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_uri = v.into();
        self
    }

    /// Sets the value of [source_properties][crate::model::Finding::source_properties].
    pub fn set_source_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.source_properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [security_marks][crate::model::Finding::security_marks].
    pub fn set_security_marks<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityMarks>,
    {
        self.security_marks = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_marks][crate::model::Finding::security_marks].
    pub fn set_or_clear_security_marks<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityMarks>,
    {
        self.security_marks = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_time][crate::model::Finding::event_time].
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::Finding::event_time].
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Finding::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Finding::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [severity][crate::model::Finding::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::finding::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [mute][crate::model::Finding::mute].
    pub fn set_mute<T: std::convert::Into<crate::model::finding::Mute>>(mut self, v: T) -> Self {
        self.mute = v.into();
        self
    }

    /// Sets the value of [mute_info][crate::model::Finding::mute_info].
    pub fn set_mute_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::finding::MuteInfo>,
    {
        self.mute_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mute_info][crate::model::Finding::mute_info].
    pub fn set_or_clear_mute_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::finding::MuteInfo>,
    {
        self.mute_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finding_class][crate::model::Finding::finding_class].
    pub fn set_finding_class<T: std::convert::Into<crate::model::finding::FindingClass>>(
        mut self,
        v: T,
    ) -> Self {
        self.finding_class = v.into();
        self
    }

    /// Sets the value of [indicator][crate::model::Finding::indicator].
    pub fn set_indicator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Indicator>,
    {
        self.indicator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [indicator][crate::model::Finding::indicator].
    pub fn set_or_clear_indicator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Indicator>,
    {
        self.indicator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vulnerability][crate::model::Finding::vulnerability].
    pub fn set_vulnerability<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Vulnerability>,
    {
        self.vulnerability = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerability][crate::model::Finding::vulnerability].
    pub fn set_or_clear_vulnerability<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Vulnerability>,
    {
        self.vulnerability = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mute_update_time][crate::model::Finding::mute_update_time].
    pub fn set_mute_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.mute_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mute_update_time][crate::model::Finding::mute_update_time].
    pub fn set_or_clear_mute_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.mute_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_systems][crate::model::Finding::external_systems].
    pub fn set_external_systems<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ExternalSystem>,
    {
        use std::iter::Iterator;
        self.external_systems = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [mitre_attack][crate::model::Finding::mitre_attack].
    pub fn set_mitre_attack<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MitreAttack>,
    {
        self.mitre_attack = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mitre_attack][crate::model::Finding::mitre_attack].
    pub fn set_or_clear_mitre_attack<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MitreAttack>,
    {
        self.mitre_attack = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access][crate::model::Finding::access].
    pub fn set_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Access>,
    {
        self.access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access][crate::model::Finding::access].
    pub fn set_or_clear_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Access>,
    {
        self.access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connections][crate::model::Finding::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mute_initiator][crate::model::Finding::mute_initiator].
    pub fn set_mute_initiator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mute_initiator = v.into();
        self
    }

    /// Sets the value of [processes][crate::model::Finding::processes].
    pub fn set_processes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Process>,
    {
        use std::iter::Iterator;
        self.processes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [contacts][crate::model::Finding::contacts].
    pub fn set_contacts<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ContactDetails>,
    {
        use std::iter::Iterator;
        self.contacts = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [compliances][crate::model::Finding::compliances].
    pub fn set_compliances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Compliance>,
    {
        use std::iter::Iterator;
        self.compliances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parent_display_name][crate::model::Finding::parent_display_name].
    pub fn set_parent_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Finding::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [exfiltration][crate::model::Finding::exfiltration].
    pub fn set_exfiltration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Exfiltration>,
    {
        self.exfiltration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exfiltration][crate::model::Finding::exfiltration].
    pub fn set_or_clear_exfiltration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Exfiltration>,
    {
        self.exfiltration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [iam_bindings][crate::model::Finding::iam_bindings].
    pub fn set_iam_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IamBinding>,
    {
        use std::iter::Iterator;
        self.iam_bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_steps][crate::model::Finding::next_steps].
    pub fn set_next_steps<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_steps = v.into();
        self
    }

    /// Sets the value of [module_name][crate::model::Finding::module_name].
    pub fn set_module_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.module_name = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::Finding::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kubernetes][crate::model::Finding::kubernetes].
    pub fn set_kubernetes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Kubernetes>,
    {
        self.kubernetes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kubernetes][crate::model::Finding::kubernetes].
    pub fn set_or_clear_kubernetes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Kubernetes>,
    {
        self.kubernetes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database][crate::model::Finding::database].
    pub fn set_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database][crate::model::Finding::database].
    pub fn set_or_clear_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Database>,
    {
        self.database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attack_exposure][crate::model::Finding::attack_exposure].
    pub fn set_attack_exposure<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttackExposure>,
    {
        self.attack_exposure = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attack_exposure][crate::model::Finding::attack_exposure].
    pub fn set_or_clear_attack_exposure<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttackExposure>,
    {
        self.attack_exposure = v.map(|x| x.into());
        self
    }

    /// Sets the value of [files][crate::model::Finding::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cloud_dlp_inspection][crate::model::Finding::cloud_dlp_inspection].
    pub fn set_cloud_dlp_inspection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudDlpInspection>,
    {
        self.cloud_dlp_inspection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_dlp_inspection][crate::model::Finding::cloud_dlp_inspection].
    pub fn set_or_clear_cloud_dlp_inspection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudDlpInspection>,
    {
        self.cloud_dlp_inspection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_dlp_data_profile][crate::model::Finding::cloud_dlp_data_profile].
    pub fn set_cloud_dlp_data_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudDlpDataProfile>,
    {
        self.cloud_dlp_data_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_dlp_data_profile][crate::model::Finding::cloud_dlp_data_profile].
    pub fn set_or_clear_cloud_dlp_data_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudDlpDataProfile>,
    {
        self.cloud_dlp_data_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kernel_rootkit][crate::model::Finding::kernel_rootkit].
    pub fn set_kernel_rootkit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KernelRootkit>,
    {
        self.kernel_rootkit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kernel_rootkit][crate::model::Finding::kernel_rootkit].
    pub fn set_or_clear_kernel_rootkit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KernelRootkit>,
    {
        self.kernel_rootkit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [org_policies][crate::model::Finding::org_policies].
    pub fn set_org_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OrgPolicy>,
    {
        use std::iter::Iterator;
        self.org_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job][crate::model::Finding::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::Finding::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [application][crate::model::Finding::application].
    pub fn set_application<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [application][crate::model::Finding::application].
    pub fn set_or_clear_application<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Application>,
    {
        self.application = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_rules][crate::model::Finding::ip_rules].
    pub fn set_ip_rules<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IpRules>,
    {
        self.ip_rules = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_rules][crate::model::Finding::ip_rules].
    pub fn set_or_clear_ip_rules<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IpRules>,
    {
        self.ip_rules = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_disaster_recovery][crate::model::Finding::backup_disaster_recovery].
    pub fn set_backup_disaster_recovery<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupDisasterRecovery>,
    {
        self.backup_disaster_recovery = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_disaster_recovery][crate::model::Finding::backup_disaster_recovery].
    pub fn set_or_clear_backup_disaster_recovery<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupDisasterRecovery>,
    {
        self.backup_disaster_recovery = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_posture][crate::model::Finding::security_posture].
    pub fn set_security_posture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPosture>,
    {
        self.security_posture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_posture][crate::model::Finding::security_posture].
    pub fn set_or_clear_security_posture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPosture>,
    {
        self.security_posture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [log_entries][crate::model::Finding::log_entries].
    pub fn set_log_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.log_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [load_balancers][crate::model::Finding::load_balancers].
    pub fn set_load_balancers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LoadBalancer>,
    {
        use std::iter::Iterator;
        self.load_balancers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cloud_armor][crate::model::Finding::cloud_armor].
    pub fn set_cloud_armor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudArmor>,
    {
        self.cloud_armor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_armor][crate::model::Finding::cloud_armor].
    pub fn set_or_clear_cloud_armor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudArmor>,
    {
        self.cloud_armor = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notebook][crate::model::Finding::notebook].
    pub fn set_notebook<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Notebook>,
    {
        self.notebook = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notebook][crate::model::Finding::notebook].
    pub fn set_or_clear_notebook<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Notebook>,
    {
        self.notebook = v.map(|x| x.into());
        self
    }

    /// Sets the value of [toxic_combination][crate::model::Finding::toxic_combination].
    pub fn set_toxic_combination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ToxicCombination>,
    {
        self.toxic_combination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [toxic_combination][crate::model::Finding::toxic_combination].
    pub fn set_or_clear_toxic_combination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ToxicCombination>,
    {
        self.toxic_combination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group_memberships][crate::model::Finding::group_memberships].
    pub fn set_group_memberships<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroupMembership>,
    {
        use std::iter::Iterator;
        self.group_memberships = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk][crate::model::Finding::disk].
    pub fn set_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Disk>,
    {
        self.disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk][crate::model::Finding::disk].
    pub fn set_or_clear_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Disk>,
    {
        self.disk = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_access_events][crate::model::Finding::data_access_events].
    pub fn set_data_access_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataAccessEvent>,
    {
        use std::iter::Iterator;
        self.data_access_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_flow_events][crate::model::Finding::data_flow_events].
    pub fn set_data_flow_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataFlowEvent>,
    {
        use std::iter::Iterator;
        self.data_flow_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [networks][crate::model::Finding::networks].
    pub fn set_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Network>,
    {
        use std::iter::Iterator;
        self.networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_retention_deletion_events][crate::model::Finding::data_retention_deletion_events].
    pub fn set_data_retention_deletion_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataRetentionDeletionEvent>,
    {
        use std::iter::Iterator;
        self.data_retention_deletion_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [affected_resources][crate::model::Finding::affected_resources].
    pub fn set_affected_resources<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AffectedResources>,
    {
        self.affected_resources = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [affected_resources][crate::model::Finding::affected_resources].
    pub fn set_or_clear_affected_resources<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AffectedResources>,
    {
        self.affected_resources = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ai_model][crate::model::Finding::ai_model].
    pub fn set_ai_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AiModel>,
    {
        self.ai_model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ai_model][crate::model::Finding::ai_model].
    pub fn set_or_clear_ai_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AiModel>,
    {
        self.ai_model = v.map(|x| x.into());
        self
    }

    /// Sets the value of [chokepoint][crate::model::Finding::chokepoint].
    pub fn set_chokepoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Chokepoint>,
    {
        self.chokepoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [chokepoint][crate::model::Finding::chokepoint].
    pub fn set_or_clear_chokepoint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Chokepoint>,
    {
        self.chokepoint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vertex_ai][crate::model::Finding::vertex_ai].
    pub fn set_vertex_ai<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VertexAi>,
    {
        self.vertex_ai = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vertex_ai][crate::model::Finding::vertex_ai].
    pub fn set_or_clear_vertex_ai<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VertexAi>,
    {
        self.vertex_ai = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Finding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Finding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Finding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __canonical_name,
            __parent,
            __resource_name,
            __state,
            __category,
            __external_uri,
            __source_properties,
            __security_marks,
            __event_time,
            __create_time,
            __severity,
            __mute,
            __mute_info,
            __finding_class,
            __indicator,
            __vulnerability,
            __mute_update_time,
            __external_systems,
            __mitre_attack,
            __access,
            __connections,
            __mute_initiator,
            __processes,
            __contacts,
            __compliances,
            __parent_display_name,
            __description,
            __exfiltration,
            __iam_bindings,
            __next_steps,
            __module_name,
            __containers,
            __kubernetes,
            __database,
            __attack_exposure,
            __files,
            __cloud_dlp_inspection,
            __cloud_dlp_data_profile,
            __kernel_rootkit,
            __org_policies,
            __job,
            __application,
            __ip_rules,
            __backup_disaster_recovery,
            __security_posture,
            __log_entries,
            __load_balancers,
            __cloud_armor,
            __notebook,
            __toxic_combination,
            __group_memberships,
            __disk,
            __data_access_events,
            __data_flow_events,
            __networks,
            __data_retention_deletion_events,
            __affected_resources,
            __ai_model,
            __chokepoint,
            __vertex_ai,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Finding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "canonicalName" => Ok(__FieldTag::__canonical_name),
                            "canonical_name" => Ok(__FieldTag::__canonical_name),
                            "parent" => Ok(__FieldTag::__parent),
                            "resourceName" => Ok(__FieldTag::__resource_name),
                            "resource_name" => Ok(__FieldTag::__resource_name),
                            "state" => Ok(__FieldTag::__state),
                            "category" => Ok(__FieldTag::__category),
                            "externalUri" => Ok(__FieldTag::__external_uri),
                            "external_uri" => Ok(__FieldTag::__external_uri),
                            "sourceProperties" => Ok(__FieldTag::__source_properties),
                            "source_properties" => Ok(__FieldTag::__source_properties),
                            "securityMarks" => Ok(__FieldTag::__security_marks),
                            "security_marks" => Ok(__FieldTag::__security_marks),
                            "eventTime" => Ok(__FieldTag::__event_time),
                            "event_time" => Ok(__FieldTag::__event_time),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "severity" => Ok(__FieldTag::__severity),
                            "mute" => Ok(__FieldTag::__mute),
                            "muteInfo" => Ok(__FieldTag::__mute_info),
                            "mute_info" => Ok(__FieldTag::__mute_info),
                            "findingClass" => Ok(__FieldTag::__finding_class),
                            "finding_class" => Ok(__FieldTag::__finding_class),
                            "indicator" => Ok(__FieldTag::__indicator),
                            "vulnerability" => Ok(__FieldTag::__vulnerability),
                            "muteUpdateTime" => Ok(__FieldTag::__mute_update_time),
                            "mute_update_time" => Ok(__FieldTag::__mute_update_time),
                            "externalSystems" => Ok(__FieldTag::__external_systems),
                            "external_systems" => Ok(__FieldTag::__external_systems),
                            "mitreAttack" => Ok(__FieldTag::__mitre_attack),
                            "mitre_attack" => Ok(__FieldTag::__mitre_attack),
                            "access" => Ok(__FieldTag::__access),
                            "connections" => Ok(__FieldTag::__connections),
                            "muteInitiator" => Ok(__FieldTag::__mute_initiator),
                            "mute_initiator" => Ok(__FieldTag::__mute_initiator),
                            "processes" => Ok(__FieldTag::__processes),
                            "contacts" => Ok(__FieldTag::__contacts),
                            "compliances" => Ok(__FieldTag::__compliances),
                            "parentDisplayName" => Ok(__FieldTag::__parent_display_name),
                            "parent_display_name" => Ok(__FieldTag::__parent_display_name),
                            "description" => Ok(__FieldTag::__description),
                            "exfiltration" => Ok(__FieldTag::__exfiltration),
                            "iamBindings" => Ok(__FieldTag::__iam_bindings),
                            "iam_bindings" => Ok(__FieldTag::__iam_bindings),
                            "nextSteps" => Ok(__FieldTag::__next_steps),
                            "next_steps" => Ok(__FieldTag::__next_steps),
                            "moduleName" => Ok(__FieldTag::__module_name),
                            "module_name" => Ok(__FieldTag::__module_name),
                            "containers" => Ok(__FieldTag::__containers),
                            "kubernetes" => Ok(__FieldTag::__kubernetes),
                            "database" => Ok(__FieldTag::__database),
                            "attackExposure" => Ok(__FieldTag::__attack_exposure),
                            "attack_exposure" => Ok(__FieldTag::__attack_exposure),
                            "files" => Ok(__FieldTag::__files),
                            "cloudDlpInspection" => Ok(__FieldTag::__cloud_dlp_inspection),
                            "cloud_dlp_inspection" => Ok(__FieldTag::__cloud_dlp_inspection),
                            "cloudDlpDataProfile" => Ok(__FieldTag::__cloud_dlp_data_profile),
                            "cloud_dlp_data_profile" => Ok(__FieldTag::__cloud_dlp_data_profile),
                            "kernelRootkit" => Ok(__FieldTag::__kernel_rootkit),
                            "kernel_rootkit" => Ok(__FieldTag::__kernel_rootkit),
                            "orgPolicies" => Ok(__FieldTag::__org_policies),
                            "org_policies" => Ok(__FieldTag::__org_policies),
                            "job" => Ok(__FieldTag::__job),
                            "application" => Ok(__FieldTag::__application),
                            "ipRules" => Ok(__FieldTag::__ip_rules),
                            "ip_rules" => Ok(__FieldTag::__ip_rules),
                            "backupDisasterRecovery" => Ok(__FieldTag::__backup_disaster_recovery),
                            "backup_disaster_recovery" => {
                                Ok(__FieldTag::__backup_disaster_recovery)
                            }
                            "securityPosture" => Ok(__FieldTag::__security_posture),
                            "security_posture" => Ok(__FieldTag::__security_posture),
                            "logEntries" => Ok(__FieldTag::__log_entries),
                            "log_entries" => Ok(__FieldTag::__log_entries),
                            "loadBalancers" => Ok(__FieldTag::__load_balancers),
                            "load_balancers" => Ok(__FieldTag::__load_balancers),
                            "cloudArmor" => Ok(__FieldTag::__cloud_armor),
                            "cloud_armor" => Ok(__FieldTag::__cloud_armor),
                            "notebook" => Ok(__FieldTag::__notebook),
                            "toxicCombination" => Ok(__FieldTag::__toxic_combination),
                            "toxic_combination" => Ok(__FieldTag::__toxic_combination),
                            "groupMemberships" => Ok(__FieldTag::__group_memberships),
                            "group_memberships" => Ok(__FieldTag::__group_memberships),
                            "disk" => Ok(__FieldTag::__disk),
                            "dataAccessEvents" => Ok(__FieldTag::__data_access_events),
                            "data_access_events" => Ok(__FieldTag::__data_access_events),
                            "dataFlowEvents" => Ok(__FieldTag::__data_flow_events),
                            "data_flow_events" => Ok(__FieldTag::__data_flow_events),
                            "networks" => Ok(__FieldTag::__networks),
                            "dataRetentionDeletionEvents" => {
                                Ok(__FieldTag::__data_retention_deletion_events)
                            }
                            "data_retention_deletion_events" => {
                                Ok(__FieldTag::__data_retention_deletion_events)
                            }
                            "affectedResources" => Ok(__FieldTag::__affected_resources),
                            "affected_resources" => Ok(__FieldTag::__affected_resources),
                            "aiModel" => Ok(__FieldTag::__ai_model),
                            "ai_model" => Ok(__FieldTag::__ai_model),
                            "chokepoint" => Ok(__FieldTag::__chokepoint),
                            "vertexAi" => Ok(__FieldTag::__vertex_ai),
                            "vertex_ai" => Ok(__FieldTag::__vertex_ai),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Finding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Finding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__canonical_name => {
                            if !fields.insert(__FieldTag::__canonical_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_name",
                                ));
                            }
                            result.canonical_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_name => {
                            if !fields.insert(__FieldTag::__resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_name",
                                ));
                            }
                            result.resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::finding::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_uri => {
                            if !fields.insert(__FieldTag::__external_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_uri",
                                ));
                            }
                            result.external_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_properties => {
                            if !fields.insert(__FieldTag::__source_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_properties",
                                ));
                            }
                            result.source_properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_marks => {
                            if !fields.insert(__FieldTag::__security_marks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_marks",
                                ));
                            }
                            result.security_marks = map
                                .next_value::<std::option::Option<crate::model::SecurityMarks>>()?;
                        }
                        __FieldTag::__event_time => {
                            if !fields.insert(__FieldTag::__event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_time",
                                ));
                            }
                            result.event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::finding::Severity>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mute => {
                            if !fields.insert(__FieldTag::__mute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute",
                                ));
                            }
                            result.mute = map
                                .next_value::<std::option::Option<crate::model::finding::Mute>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mute_info => {
                            if !fields.insert(__FieldTag::__mute_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_info",
                                ));
                            }
                            result.mute_info = map
                                .next_value::<std::option::Option<crate::model::finding::MuteInfo>>(
                                )?;
                        }
                        __FieldTag::__finding_class => {
                            if !fields.insert(__FieldTag::__finding_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_class",
                                ));
                            }
                            result.finding_class = map.next_value::<std::option::Option<crate::model::finding::FindingClass>>()?.unwrap_or_default();
                        }
                        __FieldTag::__indicator => {
                            if !fields.insert(__FieldTag::__indicator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indicator",
                                ));
                            }
                            result.indicator =
                                map.next_value::<std::option::Option<crate::model::Indicator>>()?;
                        }
                        __FieldTag::__vulnerability => {
                            if !fields.insert(__FieldTag::__vulnerability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability",
                                ));
                            }
                            result.vulnerability = map
                                .next_value::<std::option::Option<crate::model::Vulnerability>>()?;
                        }
                        __FieldTag::__mute_update_time => {
                            if !fields.insert(__FieldTag::__mute_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_update_time",
                                ));
                            }
                            result.mute_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__external_systems => {
                            if !fields.insert(__FieldTag::__external_systems) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_systems",
                                ));
                            }
                            result.external_systems = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ExternalSystem,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mitre_attack => {
                            if !fields.insert(__FieldTag::__mitre_attack) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mitre_attack",
                                ));
                            }
                            result.mitre_attack =
                                map.next_value::<std::option::Option<crate::model::MitreAttack>>()?;
                        }
                        __FieldTag::__access => {
                            if !fields.insert(__FieldTag::__access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access",
                                ));
                            }
                            result.access =
                                map.next_value::<std::option::Option<crate::model::Access>>()?;
                        }
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Connection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mute_initiator => {
                            if !fields.insert(__FieldTag::__mute_initiator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_initiator",
                                ));
                            }
                            result.mute_initiator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__processes => {
                            if !fields.insert(__FieldTag::__processes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processes",
                                ));
                            }
                            result.processes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Process>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__contacts => {
                            if !fields.insert(__FieldTag::__contacts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contacts",
                                ));
                            }
                            result.contacts = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ContactDetails,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compliances => {
                            if !fields.insert(__FieldTag::__compliances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliances",
                                ));
                            }
                            result.compliances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Compliance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__parent_display_name => {
                            if !fields.insert(__FieldTag::__parent_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_display_name",
                                ));
                            }
                            result.parent_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exfiltration => {
                            if !fields.insert(__FieldTag::__exfiltration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exfiltration",
                                ));
                            }
                            result.exfiltration = map
                                .next_value::<std::option::Option<crate::model::Exfiltration>>()?;
                        }
                        __FieldTag::__iam_bindings => {
                            if !fields.insert(__FieldTag::__iam_bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_bindings",
                                ));
                            }
                            result.iam_bindings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IamBinding>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_steps => {
                            if !fields.insert(__FieldTag::__next_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_steps",
                                ));
                            }
                            result.next_steps = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__module_name => {
                            if !fields.insert(__FieldTag::__module_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for module_name",
                                ));
                            }
                            result.module_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__containers => {
                            if !fields.insert(__FieldTag::__containers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containers",
                                ));
                            }
                            result.containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Container>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kubernetes => {
                            if !fields.insert(__FieldTag::__kubernetes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes",
                                ));
                            }
                            result.kubernetes =
                                map.next_value::<std::option::Option<crate::model::Kubernetes>>()?;
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database =
                                map.next_value::<std::option::Option<crate::model::Database>>()?;
                        }
                        __FieldTag::__attack_exposure => {
                            if !fields.insert(__FieldTag::__attack_exposure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_exposure",
                                ));
                            }
                            result.attack_exposure = map
                                .next_value::<std::option::Option<crate::model::AttackExposure>>(
                                )?;
                        }
                        __FieldTag::__files => {
                            if !fields.insert(__FieldTag::__files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for files",
                                ));
                            }
                            result.files = map.next_value::<std::option::Option<std::vec::Vec<crate::model::File>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cloud_dlp_inspection => {
                            if !fields.insert(__FieldTag::__cloud_dlp_inspection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_dlp_inspection",
                                ));
                            }
                            result.cloud_dlp_inspection = map.next_value::<std::option::Option<crate::model::CloudDlpInspection>>()?
                                ;
                        }
                        __FieldTag::__cloud_dlp_data_profile => {
                            if !fields.insert(__FieldTag::__cloud_dlp_data_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_dlp_data_profile",
                                ));
                            }
                            result.cloud_dlp_data_profile = map.next_value::<std::option::Option<crate::model::CloudDlpDataProfile>>()?
                                ;
                        }
                        __FieldTag::__kernel_rootkit => {
                            if !fields.insert(__FieldTag::__kernel_rootkit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kernel_rootkit",
                                ));
                            }
                            result.kernel_rootkit = map
                                .next_value::<std::option::Option<crate::model::KernelRootkit>>()?;
                        }
                        __FieldTag::__org_policies => {
                            if !fields.insert(__FieldTag::__org_policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for org_policies",
                                ));
                            }
                            result.org_policies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OrgPolicy>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__application => {
                            if !fields.insert(__FieldTag::__application) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application",
                                ));
                            }
                            result.application =
                                map.next_value::<std::option::Option<crate::model::Application>>()?;
                        }
                        __FieldTag::__ip_rules => {
                            if !fields.insert(__FieldTag::__ip_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_rules",
                                ));
                            }
                            result.ip_rules =
                                map.next_value::<std::option::Option<crate::model::IpRules>>()?;
                        }
                        __FieldTag::__backup_disaster_recovery => {
                            if !fields.insert(__FieldTag::__backup_disaster_recovery) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_disaster_recovery",
                                ));
                            }
                            result.backup_disaster_recovery = map.next_value::<std::option::Option<crate::model::BackupDisasterRecovery>>()?
                                ;
                        }
                        __FieldTag::__security_posture => {
                            if !fields.insert(__FieldTag::__security_posture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_posture",
                                ));
                            }
                            result.security_posture = map
                                .next_value::<std::option::Option<crate::model::SecurityPosture>>(
                                )?;
                        }
                        __FieldTag::__log_entries => {
                            if !fields.insert(__FieldTag::__log_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_entries",
                                ));
                            }
                            result.log_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__load_balancers => {
                            if !fields.insert(__FieldTag::__load_balancers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancers",
                                ));
                            }
                            result.load_balancers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LoadBalancer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cloud_armor => {
                            if !fields.insert(__FieldTag::__cloud_armor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_armor",
                                ));
                            }
                            result.cloud_armor =
                                map.next_value::<std::option::Option<crate::model::CloudArmor>>()?;
                        }
                        __FieldTag::__notebook => {
                            if !fields.insert(__FieldTag::__notebook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notebook",
                                ));
                            }
                            result.notebook =
                                map.next_value::<std::option::Option<crate::model::Notebook>>()?;
                        }
                        __FieldTag::__toxic_combination => {
                            if !fields.insert(__FieldTag::__toxic_combination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for toxic_combination",
                                ));
                            }
                            result.toxic_combination = map
                                .next_value::<std::option::Option<crate::model::ToxicCombination>>(
                                )?;
                        }
                        __FieldTag::__group_memberships => {
                            if !fields.insert(__FieldTag::__group_memberships) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_memberships",
                                ));
                            }
                            result.group_memberships =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GroupMembership>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk => {
                            if !fields.insert(__FieldTag::__disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk",
                                ));
                            }
                            result.disk =
                                map.next_value::<std::option::Option<crate::model::Disk>>()?;
                        }
                        __FieldTag::__data_access_events => {
                            if !fields.insert(__FieldTag::__data_access_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_access_events",
                                ));
                            }
                            result.data_access_events =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataAccessEvent>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_flow_events => {
                            if !fields.insert(__FieldTag::__data_flow_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_flow_events",
                                ));
                            }
                            result.data_flow_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataFlowEvent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__networks => {
                            if !fields.insert(__FieldTag::__networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networks",
                                ));
                            }
                            result.networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Network>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_retention_deletion_events => {
                            if !fields.insert(__FieldTag::__data_retention_deletion_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_retention_deletion_events",
                                ));
                            }
                            result.data_retention_deletion_events = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataRetentionDeletionEvent>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_resources => {
                            if !fields.insert(__FieldTag::__affected_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_resources",
                                ));
                            }
                            result.affected_resources = map
                                .next_value::<std::option::Option<crate::model::AffectedResources>>(
                                )?;
                        }
                        __FieldTag::__ai_model => {
                            if !fields.insert(__FieldTag::__ai_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ai_model",
                                ));
                            }
                            result.ai_model =
                                map.next_value::<std::option::Option<crate::model::AiModel>>()?;
                        }
                        __FieldTag::__chokepoint => {
                            if !fields.insert(__FieldTag::__chokepoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chokepoint",
                                ));
                            }
                            result.chokepoint =
                                map.next_value::<std::option::Option<crate::model::Chokepoint>>()?;
                        }
                        __FieldTag::__vertex_ai => {
                            if !fields.insert(__FieldTag::__vertex_ai) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertex_ai",
                                ));
                            }
                            result.vertex_ai =
                                map.next_value::<std::option::Option<crate::model::VertexAi>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Finding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.canonical_name.is_empty() {
            state.serialize_entry("canonicalName", &self.canonical_name)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.resource_name.is_empty() {
            state.serialize_entry("resourceName", &self.resource_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.category.is_empty() {
            state.serialize_entry("category", &self.category)?;
        }
        if !self.external_uri.is_empty() {
            state.serialize_entry("externalUri", &self.external_uri)?;
        }
        if !self.source_properties.is_empty() {
            state.serialize_entry("sourceProperties", &self.source_properties)?;
        }
        if self.security_marks.is_some() {
            state.serialize_entry("securityMarks", &self.security_marks)?;
        }
        if self.event_time.is_some() {
            state.serialize_entry("eventTime", &self.event_time)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !wkt::internal::is_default(&self.mute) {
            state.serialize_entry("mute", &self.mute)?;
        }
        if self.mute_info.is_some() {
            state.serialize_entry("muteInfo", &self.mute_info)?;
        }
        if !wkt::internal::is_default(&self.finding_class) {
            state.serialize_entry("findingClass", &self.finding_class)?;
        }
        if self.indicator.is_some() {
            state.serialize_entry("indicator", &self.indicator)?;
        }
        if self.vulnerability.is_some() {
            state.serialize_entry("vulnerability", &self.vulnerability)?;
        }
        if self.mute_update_time.is_some() {
            state.serialize_entry("muteUpdateTime", &self.mute_update_time)?;
        }
        if !self.external_systems.is_empty() {
            state.serialize_entry("externalSystems", &self.external_systems)?;
        }
        if self.mitre_attack.is_some() {
            state.serialize_entry("mitreAttack", &self.mitre_attack)?;
        }
        if self.access.is_some() {
            state.serialize_entry("access", &self.access)?;
        }
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self.mute_initiator.is_empty() {
            state.serialize_entry("muteInitiator", &self.mute_initiator)?;
        }
        if !self.processes.is_empty() {
            state.serialize_entry("processes", &self.processes)?;
        }
        if !self.contacts.is_empty() {
            state.serialize_entry("contacts", &self.contacts)?;
        }
        if !self.compliances.is_empty() {
            state.serialize_entry("compliances", &self.compliances)?;
        }
        if !self.parent_display_name.is_empty() {
            state.serialize_entry("parentDisplayName", &self.parent_display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.exfiltration.is_some() {
            state.serialize_entry("exfiltration", &self.exfiltration)?;
        }
        if !self.iam_bindings.is_empty() {
            state.serialize_entry("iamBindings", &self.iam_bindings)?;
        }
        if !self.next_steps.is_empty() {
            state.serialize_entry("nextSteps", &self.next_steps)?;
        }
        if !self.module_name.is_empty() {
            state.serialize_entry("moduleName", &self.module_name)?;
        }
        if !self.containers.is_empty() {
            state.serialize_entry("containers", &self.containers)?;
        }
        if self.kubernetes.is_some() {
            state.serialize_entry("kubernetes", &self.kubernetes)?;
        }
        if self.database.is_some() {
            state.serialize_entry("database", &self.database)?;
        }
        if self.attack_exposure.is_some() {
            state.serialize_entry("attackExposure", &self.attack_exposure)?;
        }
        if !self.files.is_empty() {
            state.serialize_entry("files", &self.files)?;
        }
        if self.cloud_dlp_inspection.is_some() {
            state.serialize_entry("cloudDlpInspection", &self.cloud_dlp_inspection)?;
        }
        if self.cloud_dlp_data_profile.is_some() {
            state.serialize_entry("cloudDlpDataProfile", &self.cloud_dlp_data_profile)?;
        }
        if self.kernel_rootkit.is_some() {
            state.serialize_entry("kernelRootkit", &self.kernel_rootkit)?;
        }
        if !self.org_policies.is_empty() {
            state.serialize_entry("orgPolicies", &self.org_policies)?;
        }
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if self.application.is_some() {
            state.serialize_entry("application", &self.application)?;
        }
        if self.ip_rules.is_some() {
            state.serialize_entry("ipRules", &self.ip_rules)?;
        }
        if self.backup_disaster_recovery.is_some() {
            state.serialize_entry("backupDisasterRecovery", &self.backup_disaster_recovery)?;
        }
        if self.security_posture.is_some() {
            state.serialize_entry("securityPosture", &self.security_posture)?;
        }
        if !self.log_entries.is_empty() {
            state.serialize_entry("logEntries", &self.log_entries)?;
        }
        if !self.load_balancers.is_empty() {
            state.serialize_entry("loadBalancers", &self.load_balancers)?;
        }
        if self.cloud_armor.is_some() {
            state.serialize_entry("cloudArmor", &self.cloud_armor)?;
        }
        if self.notebook.is_some() {
            state.serialize_entry("notebook", &self.notebook)?;
        }
        if self.toxic_combination.is_some() {
            state.serialize_entry("toxicCombination", &self.toxic_combination)?;
        }
        if !self.group_memberships.is_empty() {
            state.serialize_entry("groupMemberships", &self.group_memberships)?;
        }
        if self.disk.is_some() {
            state.serialize_entry("disk", &self.disk)?;
        }
        if !self.data_access_events.is_empty() {
            state.serialize_entry("dataAccessEvents", &self.data_access_events)?;
        }
        if !self.data_flow_events.is_empty() {
            state.serialize_entry("dataFlowEvents", &self.data_flow_events)?;
        }
        if !self.networks.is_empty() {
            state.serialize_entry("networks", &self.networks)?;
        }
        if !self.data_retention_deletion_events.is_empty() {
            state.serialize_entry(
                "dataRetentionDeletionEvents",
                &self.data_retention_deletion_events,
            )?;
        }
        if self.affected_resources.is_some() {
            state.serialize_entry("affectedResources", &self.affected_resources)?;
        }
        if self.ai_model.is_some() {
            state.serialize_entry("aiModel", &self.ai_model)?;
        }
        if self.chokepoint.is_some() {
            state.serialize_entry("chokepoint", &self.chokepoint)?;
        }
        if self.vertex_ai.is_some() {
            state.serialize_entry("vertexAi", &self.vertex_ai)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Finding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Finding");
        debug_struct.field("name", &self.name);
        debug_struct.field("canonical_name", &self.canonical_name);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("resource_name", &self.resource_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("category", &self.category);
        debug_struct.field("external_uri", &self.external_uri);
        debug_struct.field("source_properties", &self.source_properties);
        debug_struct.field("security_marks", &self.security_marks);
        debug_struct.field("event_time", &self.event_time);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("mute", &self.mute);
        debug_struct.field("mute_info", &self.mute_info);
        debug_struct.field("finding_class", &self.finding_class);
        debug_struct.field("indicator", &self.indicator);
        debug_struct.field("vulnerability", &self.vulnerability);
        debug_struct.field("mute_update_time", &self.mute_update_time);
        debug_struct.field("external_systems", &self.external_systems);
        debug_struct.field("mitre_attack", &self.mitre_attack);
        debug_struct.field("access", &self.access);
        debug_struct.field("connections", &self.connections);
        debug_struct.field("mute_initiator", &self.mute_initiator);
        debug_struct.field("processes", &self.processes);
        debug_struct.field("contacts", &self.contacts);
        debug_struct.field("compliances", &self.compliances);
        debug_struct.field("parent_display_name", &self.parent_display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("exfiltration", &self.exfiltration);
        debug_struct.field("iam_bindings", &self.iam_bindings);
        debug_struct.field("next_steps", &self.next_steps);
        debug_struct.field("module_name", &self.module_name);
        debug_struct.field("containers", &self.containers);
        debug_struct.field("kubernetes", &self.kubernetes);
        debug_struct.field("database", &self.database);
        debug_struct.field("attack_exposure", &self.attack_exposure);
        debug_struct.field("files", &self.files);
        debug_struct.field("cloud_dlp_inspection", &self.cloud_dlp_inspection);
        debug_struct.field("cloud_dlp_data_profile", &self.cloud_dlp_data_profile);
        debug_struct.field("kernel_rootkit", &self.kernel_rootkit);
        debug_struct.field("org_policies", &self.org_policies);
        debug_struct.field("job", &self.job);
        debug_struct.field("application", &self.application);
        debug_struct.field("ip_rules", &self.ip_rules);
        debug_struct.field("backup_disaster_recovery", &self.backup_disaster_recovery);
        debug_struct.field("security_posture", &self.security_posture);
        debug_struct.field("log_entries", &self.log_entries);
        debug_struct.field("load_balancers", &self.load_balancers);
        debug_struct.field("cloud_armor", &self.cloud_armor);
        debug_struct.field("notebook", &self.notebook);
        debug_struct.field("toxic_combination", &self.toxic_combination);
        debug_struct.field("group_memberships", &self.group_memberships);
        debug_struct.field("disk", &self.disk);
        debug_struct.field("data_access_events", &self.data_access_events);
        debug_struct.field("data_flow_events", &self.data_flow_events);
        debug_struct.field("networks", &self.networks);
        debug_struct.field(
            "data_retention_deletion_events",
            &self.data_retention_deletion_events,
        );
        debug_struct.field("affected_resources", &self.affected_resources);
        debug_struct.field("ai_model", &self.ai_model);
        debug_struct.field("chokepoint", &self.chokepoint);
        debug_struct.field("vertex_ai", &self.vertex_ai);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Finding].
pub mod finding {
    #[allow(unused_imports)]
    use super::*;

    /// Mute information about the finding, including whether the finding has a
    /// static mute or any matching dynamic mute rules.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MuteInfo {
        /// If set, the static mute applied to this finding. Static mutes override
        /// dynamic mutes. If unset, there is no static mute.
        pub static_mute: std::option::Option<crate::model::finding::mute_info::StaticMute>,

        /// The list of dynamic mute rules that currently match the finding.
        pub dynamic_mute_records:
            std::vec::Vec<crate::model::finding::mute_info::DynamicMuteRecord>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MuteInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [static_mute][crate::model::finding::MuteInfo::static_mute].
        pub fn set_static_mute<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::finding::mute_info::StaticMute>,
        {
            self.static_mute = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [static_mute][crate::model::finding::MuteInfo::static_mute].
        pub fn set_or_clear_static_mute<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::finding::mute_info::StaticMute>,
        {
            self.static_mute = v.map(|x| x.into());
            self
        }

        /// Sets the value of [dynamic_mute_records][crate::model::finding::MuteInfo::dynamic_mute_records].
        pub fn set_dynamic_mute_records<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::finding::mute_info::DynamicMuteRecord>,
        {
            use std::iter::Iterator;
            self.dynamic_mute_records = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for MuteInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Finding.MuteInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MuteInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __static_mute,
                __dynamic_mute_records,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MuteInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "staticMute" => Ok(__FieldTag::__static_mute),
                                "static_mute" => Ok(__FieldTag::__static_mute),
                                "dynamicMuteRecords" => Ok(__FieldTag::__dynamic_mute_records),
                                "dynamic_mute_records" => Ok(__FieldTag::__dynamic_mute_records),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MuteInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MuteInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__static_mute => {
                                if !fields.insert(__FieldTag::__static_mute) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for static_mute",
                                    ));
                                }
                                result.static_mute = map.next_value::<std::option::Option<
                                    crate::model::finding::mute_info::StaticMute,
                                >>()?;
                            }
                            __FieldTag::__dynamic_mute_records => {
                                if !fields.insert(__FieldTag::__dynamic_mute_records) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dynamic_mute_records",
                                    ));
                                }
                                result.dynamic_mute_records = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::finding::mute_info::DynamicMuteRecord,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MuteInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.static_mute.is_some() {
                state.serialize_entry("staticMute", &self.static_mute)?;
            }
            if !self.dynamic_mute_records.is_empty() {
                state.serialize_entry("dynamicMuteRecords", &self.dynamic_mute_records)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MuteInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MuteInfo");
            debug_struct.field("static_mute", &self.static_mute);
            debug_struct.field("dynamic_mute_records", &self.dynamic_mute_records);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [MuteInfo].
    pub mod mute_info {
        #[allow(unused_imports)]
        use super::*;

        /// Information about the static mute state. A static mute state overrides
        /// any dynamic mute rules that apply to this finding. The static mute state
        /// can be set by a static mute rule or by muting the finding directly.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct StaticMute {
            /// The static mute state. If the value is `MUTED` or `UNMUTED`, then the
            /// finding's overall mute state will have the same value.
            pub state: crate::model::finding::Mute,

            /// When the static mute was applied.
            pub apply_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl StaticMute {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::finding::mute_info::StaticMute::state].
            pub fn set_state<T: std::convert::Into<crate::model::finding::Mute>>(
                mut self,
                v: T,
            ) -> Self {
                self.state = v.into();
                self
            }

            /// Sets the value of [apply_time][crate::model::finding::mute_info::StaticMute::apply_time].
            pub fn set_apply_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.apply_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [apply_time][crate::model::finding::mute_info::StaticMute::apply_time].
            pub fn set_or_clear_apply_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.apply_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for StaticMute {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.securitycenter.v2.Finding.MuteInfo.StaticMute"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for StaticMute {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __state,
                    __apply_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for StaticMute")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "state" => Ok(__FieldTag::__state),
                                    "applyTime" => Ok(__FieldTag::__apply_time),
                                    "apply_time" => Ok(__FieldTag::__apply_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = StaticMute;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct StaticMute")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__state => {
                                    if !fields.insert(__FieldTag::__state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for state"),
                                        );
                                    }
                                    result.state = map.next_value::<std::option::Option<crate::model::finding::Mute>>()?.unwrap_or_default();
                                }
                                __FieldTag::__apply_time => {
                                    if !fields.insert(__FieldTag::__apply_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for apply_time",
                                            ),
                                        );
                                    }
                                    result.apply_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for StaticMute {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.state) {
                    state.serialize_entry("state", &self.state)?;
                }
                if self.apply_time.is_some() {
                    state.serialize_entry("applyTime", &self.apply_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for StaticMute {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("StaticMute");
                debug_struct.field("state", &self.state);
                debug_struct.field("apply_time", &self.apply_time);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// The record of a dynamic mute rule that matches the finding.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DynamicMuteRecord {
            /// The relative resource name of the mute rule, represented by a mute
            /// config, that created this record, for example
            /// `organizations/123/muteConfigs/mymuteconfig` or
            /// `organizations/123/locations/global/muteConfigs/mymuteconfig`.
            pub mute_config: std::string::String,

            /// When the dynamic mute rule first matched the finding.
            pub match_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DynamicMuteRecord {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [mute_config][crate::model::finding::mute_info::DynamicMuteRecord::mute_config].
            pub fn set_mute_config<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.mute_config = v.into();
                self
            }

            /// Sets the value of [match_time][crate::model::finding::mute_info::DynamicMuteRecord::match_time].
            pub fn set_match_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.match_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [match_time][crate::model::finding::mute_info::DynamicMuteRecord::match_time].
            pub fn set_or_clear_match_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.match_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for DynamicMuteRecord {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.securitycenter.v2.Finding.MuteInfo.DynamicMuteRecord"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DynamicMuteRecord {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __mute_config,
                    __match_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DynamicMuteRecord")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "muteConfig" => Ok(__FieldTag::__mute_config),
                                    "mute_config" => Ok(__FieldTag::__mute_config),
                                    "matchTime" => Ok(__FieldTag::__match_time),
                                    "match_time" => Ok(__FieldTag::__match_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DynamicMuteRecord;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DynamicMuteRecord")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__mute_config => {
                                    if !fields.insert(__FieldTag::__mute_config) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for mute_config",
                                            ),
                                        );
                                    }
                                    result.mute_config = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__match_time => {
                                    if !fields.insert(__FieldTag::__match_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for match_time",
                                            ),
                                        );
                                    }
                                    result.match_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DynamicMuteRecord {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.mute_config.is_empty() {
                    state.serialize_entry("muteConfig", &self.mute_config)?;
                }
                if self.match_time.is_some() {
                    state.serialize_entry("matchTime", &self.match_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for DynamicMuteRecord {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("DynamicMuteRecord");
                debug_struct.field("mute_config", &self.mute_config);
                debug_struct.field("match_time", &self.match_time);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// The state of the finding.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// The finding requires attention and has not been addressed yet.
        Active,
        /// The finding has been fixed, triaged as a non-issue or otherwise addressed
        /// and is no longer active.
        Inactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Inactive => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "INACTIVE" => Self::Inactive,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Inactive => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.securitycenter.v2.Finding.State",
            ))
        }
    }

    /// The severity of the finding.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// This value is used for findings when a source doesn't write a severity
        /// value.
        Unspecified,
        /// Vulnerability:
        /// A critical vulnerability is easily discoverable by an external actor,
        /// exploitable, and results in the direct ability to execute arbitrary code,
        /// exfiltrate data, and otherwise gain additional access and privileges to
        /// cloud resources and workloads. Examples include publicly accessible
        /// unprotected user data and public SSH access with weak or no
        /// passwords.
        ///
        /// Threat:
        /// Indicates a threat that is able to access, modify, or delete data or
        /// execute unauthorized code within existing resources.
        Critical,
        /// Vulnerability:
        /// A high risk vulnerability can be easily discovered and exploited in
        /// combination with other vulnerabilities in order to gain direct access and
        /// the ability to execute arbitrary code, exfiltrate data, and otherwise
        /// gain additional access and privileges to cloud resources and workloads.
        /// An example is a database with weak or no passwords that is only
        /// accessible internally. This database could easily be compromised by an
        /// actor that had access to the internal network.
        ///
        /// Threat:
        /// Indicates a threat that is able to create new computational resources in
        /// an environment but not able to access data or execute code in existing
        /// resources.
        High,
        /// Vulnerability:
        /// A medium risk vulnerability could be used by an actor to gain access to
        /// resources or privileges that enable them to eventually (through multiple
        /// steps or a complex exploit) gain access and the ability to execute
        /// arbitrary code or exfiltrate data. An example is a service account with
        /// access to more projects than it should have. If an actor gains access to
        /// the service account, they could potentially use that access to manipulate
        /// a project the service account was not intended to.
        ///
        /// Threat:
        /// Indicates a threat that is able to cause operational impact but may not
        /// access data or execute unauthorized code.
        Medium,
        /// Vulnerability:
        /// A low risk vulnerability hampers a security organization's ability to
        /// detect vulnerabilities or active threats in their deployment, or prevents
        /// the root cause investigation of security issues. An example is monitoring
        /// and logs being disabled for resource configurations and access.
        ///
        /// Threat:
        /// Indicates a threat that has obtained minimal access to an environment but
        /// is not able to access data, execute code, or create resources.
        Low,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Critical => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::Low => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Critical,
                2 => Self::High,
                3 => Self::Medium,
                4 => Self::Low,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "CRITICAL" => Self::Critical,
                "HIGH" => Self::High,
                "MEDIUM" => Self::Medium,
                "LOW" => Self::Low,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Critical => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::Low => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.securitycenter.v2.Finding.Severity",
            ))
        }
    }

    /// Mute state a finding can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mute {
        /// Unspecified.
        Unspecified,
        /// Finding has been muted.
        Muted,
        /// Finding has been unmuted.
        Unmuted,
        /// Finding has never been muted/unmuted.
        Undefined,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mute::value] or
        /// [Mute::name].
        UnknownValue(mute::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mute {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mute {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Muted => std::option::Option::Some(1),
                Self::Unmuted => std::option::Option::Some(2),
                Self::Undefined => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MUTE_UNSPECIFIED"),
                Self::Muted => std::option::Option::Some("MUTED"),
                Self::Unmuted => std::option::Option::Some("UNMUTED"),
                Self::Undefined => std::option::Option::Some("UNDEFINED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mute {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mute {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Muted,
                2 => Self::Unmuted,
                3 => Self::Undefined,
                _ => Self::UnknownValue(mute::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mute {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MUTE_UNSPECIFIED" => Self::Unspecified,
                "MUTED" => Self::Muted,
                "UNMUTED" => Self::Unmuted,
                "UNDEFINED" => Self::Undefined,
                _ => Self::UnknownValue(mute::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mute {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Muted => serializer.serialize_i32(1),
                Self::Unmuted => serializer.serialize_i32(2),
                Self::Undefined => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mute {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mute>::new(
                ".google.cloud.securitycenter.v2.Finding.Mute",
            ))
        }
    }

    /// Represents what kind of Finding it is.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FindingClass {
        /// Unspecified finding class.
        Unspecified,
        /// Describes unwanted or malicious activity.
        Threat,
        /// Describes a potential weakness in software that increases risk to
        /// Confidentiality & Integrity & Availability.
        Vulnerability,
        /// Describes a potential weakness in cloud resource/asset configuration that
        /// increases risk.
        Misconfiguration,
        /// Describes a security observation that is for informational purposes.
        Observation,
        /// Describes an error that prevents some SCC functionality.
        SccError,
        /// Describes a potential security risk due to a change in the security
        /// posture.
        PostureViolation,
        /// Describes a combination of security issues that represent a more severe
        /// security problem when taken together.
        ToxicCombination,
        /// Describes a potential security risk to data assets that contain sensitive
        /// data.
        SensitiveDataRisk,
        /// Describes a resource or resource group where high risk attack paths
        /// converge, based on attack path simulations (APS).
        Chokepoint,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FindingClass::value] or
        /// [FindingClass::name].
        UnknownValue(finding_class::UnknownValue),
    }

    #[doc(hidden)]
    pub mod finding_class {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FindingClass {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Threat => std::option::Option::Some(1),
                Self::Vulnerability => std::option::Option::Some(2),
                Self::Misconfiguration => std::option::Option::Some(3),
                Self::Observation => std::option::Option::Some(4),
                Self::SccError => std::option::Option::Some(5),
                Self::PostureViolation => std::option::Option::Some(6),
                Self::ToxicCombination => std::option::Option::Some(7),
                Self::SensitiveDataRisk => std::option::Option::Some(8),
                Self::Chokepoint => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FINDING_CLASS_UNSPECIFIED"),
                Self::Threat => std::option::Option::Some("THREAT"),
                Self::Vulnerability => std::option::Option::Some("VULNERABILITY"),
                Self::Misconfiguration => std::option::Option::Some("MISCONFIGURATION"),
                Self::Observation => std::option::Option::Some("OBSERVATION"),
                Self::SccError => std::option::Option::Some("SCC_ERROR"),
                Self::PostureViolation => std::option::Option::Some("POSTURE_VIOLATION"),
                Self::ToxicCombination => std::option::Option::Some("TOXIC_COMBINATION"),
                Self::SensitiveDataRisk => std::option::Option::Some("SENSITIVE_DATA_RISK"),
                Self::Chokepoint => std::option::Option::Some("CHOKEPOINT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FindingClass {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FindingClass {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FindingClass {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Threat,
                2 => Self::Vulnerability,
                3 => Self::Misconfiguration,
                4 => Self::Observation,
                5 => Self::SccError,
                6 => Self::PostureViolation,
                7 => Self::ToxicCombination,
                8 => Self::SensitiveDataRisk,
                9 => Self::Chokepoint,
                _ => Self::UnknownValue(finding_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FindingClass {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FINDING_CLASS_UNSPECIFIED" => Self::Unspecified,
                "THREAT" => Self::Threat,
                "VULNERABILITY" => Self::Vulnerability,
                "MISCONFIGURATION" => Self::Misconfiguration,
                "OBSERVATION" => Self::Observation,
                "SCC_ERROR" => Self::SccError,
                "POSTURE_VIOLATION" => Self::PostureViolation,
                "TOXIC_COMBINATION" => Self::ToxicCombination,
                "SENSITIVE_DATA_RISK" => Self::SensitiveDataRisk,
                "CHOKEPOINT" => Self::Chokepoint,
                _ => Self::UnknownValue(finding_class::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FindingClass {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Threat => serializer.serialize_i32(1),
                Self::Vulnerability => serializer.serialize_i32(2),
                Self::Misconfiguration => serializer.serialize_i32(3),
                Self::Observation => serializer.serialize_i32(4),
                Self::SccError => serializer.serialize_i32(5),
                Self::PostureViolation => serializer.serialize_i32(6),
                Self::ToxicCombination => serializer.serialize_i32(7),
                Self::SensitiveDataRisk => serializer.serialize_i32(8),
                Self::Chokepoint => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FindingClass {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FindingClass>::new(
                ".google.cloud.securitycenter.v2.Finding.FindingClass",
            ))
        }
    }
}

/// Message that contains the resource name and display name of a folder
/// resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Folder {
    /// Full resource name of this folder. See:
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    pub resource_folder: std::string::String,

    /// The user defined display name for this folder.
    pub resource_folder_display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Folder {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_folder][crate::model::Folder::resource_folder].
    pub fn set_resource_folder<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_folder = v.into();
        self
    }

    /// Sets the value of [resource_folder_display_name][crate::model::Folder::resource_folder_display_name].
    pub fn set_resource_folder_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_folder_display_name = v.into();
        self
    }
}

impl wkt::message::Message for Folder {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Folder"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Folder {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_folder,
            __resource_folder_display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Folder")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceFolder" => Ok(__FieldTag::__resource_folder),
                            "resource_folder" => Ok(__FieldTag::__resource_folder),
                            "resourceFolderDisplayName" => {
                                Ok(__FieldTag::__resource_folder_display_name)
                            }
                            "resource_folder_display_name" => {
                                Ok(__FieldTag::__resource_folder_display_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Folder;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Folder")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_folder => {
                            if !fields.insert(__FieldTag::__resource_folder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_folder",
                                ));
                            }
                            result.resource_folder = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_folder_display_name => {
                            if !fields.insert(__FieldTag::__resource_folder_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_folder_display_name",
                                ));
                            }
                            result.resource_folder_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Folder {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_folder.is_empty() {
            state.serialize_entry("resourceFolder", &self.resource_folder)?;
        }
        if !self.resource_folder_display_name.is_empty() {
            state.serialize_entry(
                "resourceFolderDisplayName",
                &self.resource_folder_display_name,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Folder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Folder");
        debug_struct.field("resource_folder", &self.resource_folder);
        debug_struct.field(
            "resource_folder_display_name",
            &self.resource_folder_display_name,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains details about groups of which this finding is a member. A group is a
/// collection of findings that are related in some way.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GroupMembership {
    /// Type of group.
    pub group_type: crate::model::group_membership::GroupType,

    /// ID of the group.
    pub group_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GroupMembership {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group_type][crate::model::GroupMembership::group_type].
    pub fn set_group_type<T: std::convert::Into<crate::model::group_membership::GroupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.group_type = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::GroupMembership::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }
}

impl wkt::message::Message for GroupMembership {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GroupMembership"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GroupMembership {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group_type,
            __group_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GroupMembership")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "groupType" => Ok(__FieldTag::__group_type),
                            "group_type" => Ok(__FieldTag::__group_type),
                            "groupId" => Ok(__FieldTag::__group_id),
                            "group_id" => Ok(__FieldTag::__group_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GroupMembership;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GroupMembership")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group_type => {
                            if !fields.insert(__FieldTag::__group_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_type",
                                ));
                            }
                            result.group_type = map.next_value::<std::option::Option<crate::model::group_membership::GroupType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__group_id => {
                            if !fields.insert(__FieldTag::__group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_id",
                                ));
                            }
                            result.group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GroupMembership {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.group_type) {
            state.serialize_entry("groupType", &self.group_type)?;
        }
        if !self.group_id.is_empty() {
            state.serialize_entry("groupId", &self.group_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GroupMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GroupMembership");
        debug_struct.field("group_type", &self.group_type);
        debug_struct.field("group_id", &self.group_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GroupMembership].
pub mod group_membership {
    #[allow(unused_imports)]
    use super::*;

    /// Possible types of groups.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GroupType {
        /// Default value.
        Unspecified,
        /// Group represents a toxic combination.
        ToxicCombination,
        /// Group represents a chokepoint.
        Chokepoint,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GroupType::value] or
        /// [GroupType::name].
        UnknownValue(group_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod group_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GroupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ToxicCombination => std::option::Option::Some(1),
                Self::Chokepoint => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GROUP_TYPE_UNSPECIFIED"),
                Self::ToxicCombination => std::option::Option::Some("GROUP_TYPE_TOXIC_COMBINATION"),
                Self::Chokepoint => std::option::Option::Some("GROUP_TYPE_CHOKEPOINT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GroupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GroupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GroupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ToxicCombination,
                3 => Self::Chokepoint,
                _ => Self::UnknownValue(group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GroupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GROUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GROUP_TYPE_TOXIC_COMBINATION" => Self::ToxicCombination,
                "GROUP_TYPE_CHOKEPOINT" => Self::Chokepoint,
                _ => Self::UnknownValue(group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GroupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ToxicCombination => serializer.serialize_i32(1),
                Self::Chokepoint => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GroupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GroupType>::new(
                ".google.cloud.securitycenter.v2.GroupMembership.GroupType",
            ))
        }
    }
}

/// Represents a particular IAM binding, which captures a member's role addition,
/// removal, or state.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IamBinding {
    /// The action that was performed on a Binding.
    pub action: crate::model::iam_binding::Action,

    /// Role that is assigned to "members".
    /// For example, "roles/viewer", "roles/editor", or "roles/owner".
    pub role: std::string::String,

    /// A single identity requesting access for a Cloud Platform resource, for
    /// example, "foo@google.com".
    pub member: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IamBinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::IamBinding::action].
    pub fn set_action<T: std::convert::Into<crate::model::iam_binding::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [role][crate::model::IamBinding::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [member][crate::model::IamBinding::member].
    pub fn set_member<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.member = v.into();
        self
    }
}

impl wkt::message::Message for IamBinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.IamBinding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IamBinding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action,
            __role,
            __member,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IamBinding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "action" => Ok(__FieldTag::__action),
                            "role" => Ok(__FieldTag::__role),
                            "member" => Ok(__FieldTag::__member),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IamBinding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IamBinding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map.next_value::<std::option::Option<crate::model::iam_binding::Action>>()?.unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__member => {
                            if !fields.insert(__FieldTag::__member) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for member",
                                ));
                            }
                            result.member = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IamBinding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.action) {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.role.is_empty() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.member.is_empty() {
            state.serialize_entry("member", &self.member)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IamBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IamBinding");
        debug_struct.field("action", &self.action);
        debug_struct.field("role", &self.role);
        debug_struct.field("member", &self.member);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IamBinding].
pub mod iam_binding {
    #[allow(unused_imports)]
    use super::*;

    /// The type of action performed on a Binding in a policy.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Unspecified.
        Unspecified,
        /// Addition of a Binding.
        Add,
        /// Removal of a Binding.
        Remove,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Add => std::option::Option::Some(1),
                Self::Remove => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
                Self::Add => std::option::Option::Some("ADD"),
                Self::Remove => std::option::Option::Some("REMOVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Add,
                2 => Self::Remove,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_UNSPECIFIED" => Self::Unspecified,
                "ADD" => Self::Add,
                "REMOVE" => Self::Remove,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Add => serializer.serialize_i32(1),
                Self::Remove => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.cloud.securitycenter.v2.IamBinding.Action",
            ))
        }
    }
}

/// Represents what's commonly known as an _indicator of compromise_ (IoC) in
/// computer forensics. This is an artifact observed on a network or in an
/// operating system that, with high confidence, indicates a computer intrusion.
/// For more information, see [Indicator of
/// compromise](https://en.wikipedia.org/wiki/Indicator_of_compromise).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Indicator {
    /// The list of IP addresses that are associated with the finding.
    pub ip_addresses: std::vec::Vec<std::string::String>,

    /// List of domains associated to the Finding.
    pub domains: std::vec::Vec<std::string::String>,

    /// The list of matched signatures indicating that the given
    /// process is present in the environment.
    pub signatures: std::vec::Vec<crate::model::indicator::ProcessSignature>,

    /// The list of URIs associated to the Findings.
    pub uris: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Indicator {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_addresses][crate::model::Indicator::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [domains][crate::model::Indicator::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [signatures][crate::model::Indicator::signatures].
    pub fn set_signatures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::indicator::ProcessSignature>,
    {
        use std::iter::Iterator;
        self.signatures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uris][crate::model::Indicator::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Indicator {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Indicator"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Indicator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_addresses,
            __domains,
            __signatures,
            __uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Indicator")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipAddresses" => Ok(__FieldTag::__ip_addresses),
                            "ip_addresses" => Ok(__FieldTag::__ip_addresses),
                            "domains" => Ok(__FieldTag::__domains),
                            "signatures" => Ok(__FieldTag::__signatures),
                            "uris" => Ok(__FieldTag::__uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Indicator;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Indicator")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_addresses => {
                            if !fields.insert(__FieldTag::__ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_addresses",
                                ));
                            }
                            result.ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__domains => {
                            if !fields.insert(__FieldTag::__domains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domains",
                                ));
                            }
                            result.domains = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__signatures => {
                            if !fields.insert(__FieldTag::__signatures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signatures",
                                ));
                            }
                            result.signatures = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::indicator::ProcessSignature>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uris => {
                            if !fields.insert(__FieldTag::__uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uris",
                                ));
                            }
                            result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Indicator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_addresses.is_empty() {
            state.serialize_entry("ipAddresses", &self.ip_addresses)?;
        }
        if !self.domains.is_empty() {
            state.serialize_entry("domains", &self.domains)?;
        }
        if !self.signatures.is_empty() {
            state.serialize_entry("signatures", &self.signatures)?;
        }
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Indicator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Indicator");
        debug_struct.field("ip_addresses", &self.ip_addresses);
        debug_struct.field("domains", &self.domains);
        debug_struct.field("signatures", &self.signatures);
        debug_struct.field("uris", &self.uris);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Indicator].
pub mod indicator {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates what signature matched this process.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProcessSignature {
        /// Describes the type of resource associated with the signature.
        pub signature_type: crate::model::indicator::process_signature::SignatureType,

        /// The signature.
        pub signature: std::option::Option<crate::model::indicator::process_signature::Signature>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProcessSignature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [signature_type][crate::model::indicator::ProcessSignature::signature_type].
        pub fn set_signature_type<
            T: std::convert::Into<crate::model::indicator::process_signature::SignatureType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.signature_type = v.into();
            self
        }

        /// Sets the value of [signature][crate::model::indicator::ProcessSignature::signature].
        ///
        /// Note that all the setters affecting `signature` are mutually
        /// exclusive.
        pub fn set_signature<
            T: std::convert::Into<
                    std::option::Option<crate::model::indicator::process_signature::Signature>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.signature = v.into();
            self
        }

        /// The value of [signature][crate::model::indicator::ProcessSignature::signature]
        /// if it holds a `MemoryHashSignature`, `None` if the field is not set or
        /// holds a different branch.
        pub fn memory_hash_signature(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::indicator::process_signature::MemoryHashSignature>,
        > {
            #[allow(unreachable_patterns)]
            self.signature.as_ref().and_then(|v| match v {
                crate::model::indicator::process_signature::Signature::MemoryHashSignature(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [signature][crate::model::indicator::ProcessSignature::signature]
        /// to hold a `MemoryHashSignature`.
        ///
        /// Note that all the setters affecting `signature` are
        /// mutually exclusive.
        pub fn set_memory_hash_signature<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::indicator::process_signature::MemoryHashSignature,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.signature = std::option::Option::Some(
                crate::model::indicator::process_signature::Signature::MemoryHashSignature(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [signature][crate::model::indicator::ProcessSignature::signature]
        /// if it holds a `YaraRuleSignature`, `None` if the field is not set or
        /// holds a different branch.
        pub fn yara_rule_signature(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::indicator::process_signature::YaraRuleSignature>,
        > {
            #[allow(unreachable_patterns)]
            self.signature.as_ref().and_then(|v| match v {
                crate::model::indicator::process_signature::Signature::YaraRuleSignature(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [signature][crate::model::indicator::ProcessSignature::signature]
        /// to hold a `YaraRuleSignature`.
        ///
        /// Note that all the setters affecting `signature` are
        /// mutually exclusive.
        pub fn set_yara_rule_signature<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::indicator::process_signature::YaraRuleSignature>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.signature = std::option::Option::Some(
                crate::model::indicator::process_signature::Signature::YaraRuleSignature(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ProcessSignature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Indicator.ProcessSignature"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ProcessSignature {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __memory_hash_signature,
                __yara_rule_signature,
                __signature_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ProcessSignature")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "memoryHashSignature" => Ok(__FieldTag::__memory_hash_signature),
                                "memory_hash_signature" => Ok(__FieldTag::__memory_hash_signature),
                                "yaraRuleSignature" => Ok(__FieldTag::__yara_rule_signature),
                                "yara_rule_signature" => Ok(__FieldTag::__yara_rule_signature),
                                "signatureType" => Ok(__FieldTag::__signature_type),
                                "signature_type" => Ok(__FieldTag::__signature_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ProcessSignature;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ProcessSignature")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__memory_hash_signature => {
                                if !fields.insert(__FieldTag::__memory_hash_signature) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for memory_hash_signature",
                                    ));
                                }
                                if result.signature.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `signature`, a oneof with full ID .google.cloud.securitycenter.v2.Indicator.ProcessSignature.memory_hash_signature, latest field was memoryHashSignature",
                                    ));
                                }
                                result.signature = std::option::Option::Some(
                                    crate::model::indicator::process_signature::Signature::MemoryHashSignature(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::indicator::process_signature::MemoryHashSignature>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__yara_rule_signature => {
                                if !fields.insert(__FieldTag::__yara_rule_signature) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for yara_rule_signature",
                                    ));
                                }
                                if result.signature.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `signature`, a oneof with full ID .google.cloud.securitycenter.v2.Indicator.ProcessSignature.yara_rule_signature, latest field was yaraRuleSignature",
                                    ));
                                }
                                result.signature = std::option::Option::Some(
                                    crate::model::indicator::process_signature::Signature::YaraRuleSignature(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::indicator::process_signature::YaraRuleSignature>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__signature_type => {
                                if !fields.insert(__FieldTag::__signature_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for signature_type",
                                    ));
                                }
                                result.signature_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::indicator::process_signature::SignatureType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ProcessSignature {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.memory_hash_signature() {
                state.serialize_entry("memoryHashSignature", value)?;
            }
            if let Some(value) = self.yara_rule_signature() {
                state.serialize_entry("yaraRuleSignature", value)?;
            }
            if !wkt::internal::is_default(&self.signature_type) {
                state.serialize_entry("signatureType", &self.signature_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ProcessSignature {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ProcessSignature");
            debug_struct.field("signature_type", &self.signature_type);
            debug_struct.field("signature", &self.signature);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ProcessSignature].
    pub mod process_signature {
        #[allow(unused_imports)]
        use super::*;

        /// A signature corresponding to memory page hashes.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MemoryHashSignature {
            /// The binary family.
            pub binary_family: std::string::String,

            /// The list of memory hash detections contributing to the binary family
            /// match.
            pub detections: std::vec::Vec<
                crate::model::indicator::process_signature::memory_hash_signature::Detection,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MemoryHashSignature {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [binary_family][crate::model::indicator::process_signature::MemoryHashSignature::binary_family].
            pub fn set_binary_family<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.binary_family = v.into();
                self
            }

            /// Sets the value of [detections][crate::model::indicator::process_signature::MemoryHashSignature::detections].
            pub fn set_detections<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::indicator::process_signature::memory_hash_signature::Detection>
            {
                use std::iter::Iterator;
                self.detections = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for MemoryHashSignature {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.securitycenter.v2.Indicator.ProcessSignature.MemoryHashSignature"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MemoryHashSignature {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __binary_family,
                    __detections,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MemoryHashSignature")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "binaryFamily" => Ok(__FieldTag::__binary_family),
                                    "binary_family" => Ok(__FieldTag::__binary_family),
                                    "detections" => Ok(__FieldTag::__detections),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MemoryHashSignature;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MemoryHashSignature")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__binary_family => {
                                    if !fields.insert(__FieldTag::__binary_family) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for binary_family",
                                            ),
                                        );
                                    }
                                    result.binary_family = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__detections => {
                                    if !fields.insert(__FieldTag::__detections) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detections",
                                            ),
                                        );
                                    }
                                    result.detections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::indicator::process_signature::memory_hash_signature::Detection>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MemoryHashSignature {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.binary_family.is_empty() {
                    state.serialize_entry("binaryFamily", &self.binary_family)?;
                }
                if !self.detections.is_empty() {
                    state.serialize_entry("detections", &self.detections)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for MemoryHashSignature {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("MemoryHashSignature");
                debug_struct.field("binary_family", &self.binary_family);
                debug_struct.field("detections", &self.detections);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [MemoryHashSignature].
        pub mod memory_hash_signature {
            #[allow(unused_imports)]
            use super::*;

            /// Memory hash detection contributing to the binary family match.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Detection {
                /// The name of the binary associated with the memory hash
                /// signature detection.
                pub binary: std::string::String,

                /// The percentage of memory page hashes in the signature
                /// that were matched.
                pub percent_pages_matched: f64,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Detection {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [binary][crate::model::indicator::process_signature::memory_hash_signature::Detection::binary].
                pub fn set_binary<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.binary = v.into();
                    self
                }

                /// Sets the value of [percent_pages_matched][crate::model::indicator::process_signature::memory_hash_signature::Detection::percent_pages_matched].
                pub fn set_percent_pages_matched<T: std::convert::Into<f64>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.percent_pages_matched = v.into();
                    self
                }
            }

            impl wkt::message::Message for Detection {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.securitycenter.v2.Indicator.ProcessSignature.MemoryHashSignature.Detection"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Detection {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __binary,
                        __percent_pages_matched,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Detection")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "binary" => Ok(__FieldTag::__binary),
                                        "percentPagesMatched" => {
                                            Ok(__FieldTag::__percent_pages_matched)
                                        }
                                        "percent_pages_matched" => {
                                            Ok(__FieldTag::__percent_pages_matched)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Detection;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Detection")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__binary => {
                                        if !fields.insert(__FieldTag::__binary) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for binary",
                                                ),
                                            );
                                        }
                                        result.binary = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__percent_pages_matched => {
                                        if !fields.insert(__FieldTag::__percent_pages_matched) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for percent_pages_matched",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.percent_pages_matched =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Detection {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.binary.is_empty() {
                        state.serialize_entry("binary", &self.binary)?;
                    }
                    if !wkt::internal::is_default(&self.percent_pages_matched) {
                        struct __With<'a>(&'a f64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry(
                            "percentPagesMatched",
                            &__With(&self.percent_pages_matched),
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Detection {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Detection");
                    debug_struct.field("binary", &self.binary);
                    debug_struct.field("percent_pages_matched", &self.percent_pages_matched);

                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }
        }

        /// A signature corresponding to a YARA rule.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct YaraRuleSignature {
            /// The name of the YARA rule.
            pub yara_rule: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl YaraRuleSignature {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [yara_rule][crate::model::indicator::process_signature::YaraRuleSignature::yara_rule].
            pub fn set_yara_rule<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.yara_rule = v.into();
                self
            }
        }

        impl wkt::message::Message for YaraRuleSignature {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.securitycenter.v2.Indicator.ProcessSignature.YaraRuleSignature"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for YaraRuleSignature {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __yara_rule,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for YaraRuleSignature")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "yaraRule" => Ok(__FieldTag::__yara_rule),
                                    "yara_rule" => Ok(__FieldTag::__yara_rule),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = YaraRuleSignature;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct YaraRuleSignature")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__yara_rule => {
                                    if !fields.insert(__FieldTag::__yara_rule) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for yara_rule",
                                            ),
                                        );
                                    }
                                    result.yara_rule = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for YaraRuleSignature {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.yara_rule.is_empty() {
                    state.serialize_entry("yaraRule", &self.yara_rule)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for YaraRuleSignature {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("YaraRuleSignature");
                debug_struct.field("yara_rule", &self.yara_rule);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Possible resource types to be associated with a signature.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SignatureType {
            /// The default signature type.
            Unspecified,
            /// Used for signatures concerning processes.
            Process,
            /// Used for signatures concerning disks.
            File,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SignatureType::value] or
            /// [SignatureType::name].
            UnknownValue(signature_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod signature_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SignatureType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Process => std::option::Option::Some(1),
                    Self::File => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SIGNATURE_TYPE_UNSPECIFIED"),
                    Self::Process => std::option::Option::Some("SIGNATURE_TYPE_PROCESS"),
                    Self::File => std::option::Option::Some("SIGNATURE_TYPE_FILE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SignatureType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SignatureType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SignatureType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Process,
                    2 => Self::File,
                    _ => Self::UnknownValue(signature_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SignatureType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SIGNATURE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SIGNATURE_TYPE_PROCESS" => Self::Process,
                    "SIGNATURE_TYPE_FILE" => Self::File,
                    _ => Self::UnknownValue(signature_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SignatureType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Process => serializer.serialize_i32(1),
                    Self::File => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SignatureType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SignatureType>::new(
                    ".google.cloud.securitycenter.v2.Indicator.ProcessSignature.SignatureType",
                ))
            }
        }

        /// The signature.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Signature {
            /// Signature indicating that a binary family was matched.
            MemoryHashSignature(
                std::boxed::Box<crate::model::indicator::process_signature::MemoryHashSignature>,
            ),
            /// Signature indicating that a YARA rule was matched.
            YaraRuleSignature(
                std::boxed::Box<crate::model::indicator::process_signature::YaraRuleSignature>,
            ),
        }
    }
}

/// IP rules associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IpRules {
    /// The direction that the rule is applicable to, one of ingress or egress.
    pub direction: crate::model::ip_rules::Direction,

    /// If source IP ranges are specified, the firewall rule applies only to
    /// traffic that has a source IP address in these ranges. These ranges must be
    /// expressed in CIDR format. Only supports IPv4.
    pub source_ip_ranges: std::vec::Vec<std::string::String>,

    /// If destination IP ranges are specified, the firewall rule applies only to
    /// traffic that has a destination IP address in these ranges. These ranges
    /// must be expressed in CIDR format. Only supports IPv4.
    pub destination_ip_ranges: std::vec::Vec<std::string::String>,

    /// Name of the network protocol service, such as FTP, that is exposed by the
    /// open port. Follows the naming convention available at:
    /// <https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml>.
    pub exposed_services: std::vec::Vec<std::string::String>,

    /// The list of allow rules specified by this firewall. Each rule specifies a
    /// protocol and port-range tuple that describes a permitted connection.
    pub rules: std::option::Option<crate::model::ip_rules::Rules>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpRules {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [direction][crate::model::IpRules::direction].
    pub fn set_direction<T: std::convert::Into<crate::model::ip_rules::Direction>>(
        mut self,
        v: T,
    ) -> Self {
        self.direction = v.into();
        self
    }

    /// Sets the value of [source_ip_ranges][crate::model::IpRules::source_ip_ranges].
    pub fn set_source_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [destination_ip_ranges][crate::model::IpRules::destination_ip_ranges].
    pub fn set_destination_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.destination_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exposed_services][crate::model::IpRules::exposed_services].
    pub fn set_exposed_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exposed_services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::IpRules::rules].
    ///
    /// Note that all the setters affecting `rules` are mutually
    /// exclusive.
    pub fn set_rules<T: std::convert::Into<std::option::Option<crate::model::ip_rules::Rules>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rules = v.into();
        self
    }

    /// The value of [rules][crate::model::IpRules::rules]
    /// if it holds a `Allowed`, `None` if the field is not set or
    /// holds a different branch.
    pub fn allowed(&self) -> std::option::Option<&std::boxed::Box<crate::model::Allowed>> {
        #[allow(unreachable_patterns)]
        self.rules.as_ref().and_then(|v| match v {
            crate::model::ip_rules::Rules::Allowed(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rules][crate::model::IpRules::rules]
    /// to hold a `Allowed`.
    ///
    /// Note that all the setters affecting `rules` are
    /// mutually exclusive.
    pub fn set_allowed<T: std::convert::Into<std::boxed::Box<crate::model::Allowed>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rules = std::option::Option::Some(crate::model::ip_rules::Rules::Allowed(v.into()));
        self
    }

    /// The value of [rules][crate::model::IpRules::rules]
    /// if it holds a `Denied`, `None` if the field is not set or
    /// holds a different branch.
    pub fn denied(&self) -> std::option::Option<&std::boxed::Box<crate::model::Denied>> {
        #[allow(unreachable_patterns)]
        self.rules.as_ref().and_then(|v| match v {
            crate::model::ip_rules::Rules::Denied(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rules][crate::model::IpRules::rules]
    /// to hold a `Denied`.
    ///
    /// Note that all the setters affecting `rules` are
    /// mutually exclusive.
    pub fn set_denied<T: std::convert::Into<std::boxed::Box<crate::model::Denied>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rules = std::option::Option::Some(crate::model::ip_rules::Rules::Denied(v.into()));
        self
    }
}

impl wkt::message::Message for IpRules {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.IpRules"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IpRules {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __direction,
            __allowed,
            __denied,
            __source_ip_ranges,
            __destination_ip_ranges,
            __exposed_services,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IpRules")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "direction" => Ok(__FieldTag::__direction),
                            "allowed" => Ok(__FieldTag::__allowed),
                            "denied" => Ok(__FieldTag::__denied),
                            "sourceIpRanges" => Ok(__FieldTag::__source_ip_ranges),
                            "source_ip_ranges" => Ok(__FieldTag::__source_ip_ranges),
                            "destinationIpRanges" => Ok(__FieldTag::__destination_ip_ranges),
                            "destination_ip_ranges" => Ok(__FieldTag::__destination_ip_ranges),
                            "exposedServices" => Ok(__FieldTag::__exposed_services),
                            "exposed_services" => Ok(__FieldTag::__exposed_services),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IpRules;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IpRules")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__direction => {
                            if !fields.insert(__FieldTag::__direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direction",
                                ));
                            }
                            result.direction = map.next_value::<std::option::Option<crate::model::ip_rules::Direction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__allowed => {
                            if !fields.insert(__FieldTag::__allowed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed",
                                ));
                            }
                            if result.rules.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rules`, a oneof with full ID .google.cloud.securitycenter.v2.IpRules.allowed, latest field was allowed",
                                ));
                            }
                            result.rules =
                                std::option::Option::Some(
                                    crate::model::ip_rules::Rules::Allowed(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Allowed>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__denied => {
                            if !fields.insert(__FieldTag::__denied) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denied",
                                ));
                            }
                            if result.rules.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rules`, a oneof with full ID .google.cloud.securitycenter.v2.IpRules.denied, latest field was denied",
                                ));
                            }
                            result.rules =
                                std::option::Option::Some(
                                    crate::model::ip_rules::Rules::Denied(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Denied>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__source_ip_ranges => {
                            if !fields.insert(__FieldTag::__source_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_ip_ranges",
                                ));
                            }
                            result.source_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__destination_ip_ranges => {
                            if !fields.insert(__FieldTag::__destination_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_ip_ranges",
                                ));
                            }
                            result.destination_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exposed_services => {
                            if !fields.insert(__FieldTag::__exposed_services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exposed_services",
                                ));
                            }
                            result.exposed_services = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IpRules {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.direction) {
            state.serialize_entry("direction", &self.direction)?;
        }
        if let Some(value) = self.allowed() {
            state.serialize_entry("allowed", value)?;
        }
        if let Some(value) = self.denied() {
            state.serialize_entry("denied", value)?;
        }
        if !self.source_ip_ranges.is_empty() {
            state.serialize_entry("sourceIpRanges", &self.source_ip_ranges)?;
        }
        if !self.destination_ip_ranges.is_empty() {
            state.serialize_entry("destinationIpRanges", &self.destination_ip_ranges)?;
        }
        if !self.exposed_services.is_empty() {
            state.serialize_entry("exposedServices", &self.exposed_services)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IpRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IpRules");
        debug_struct.field("direction", &self.direction);
        debug_struct.field("source_ip_ranges", &self.source_ip_ranges);
        debug_struct.field("destination_ip_ranges", &self.destination_ip_ranges);
        debug_struct.field("exposed_services", &self.exposed_services);
        debug_struct.field("rules", &self.rules);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IpRules].
pub mod ip_rules {
    #[allow(unused_imports)]
    use super::*;

    /// The type of direction that the rule is applicable to, one of ingress or
    /// egress. Not applicable to OPEN_X_PORT findings.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Unspecified direction value.
        Unspecified,
        /// Ingress direction value.
        Ingress,
        /// Egress direction value.
        Egress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ingress => std::option::Option::Some(1),
                Self::Egress => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIRECTION_UNSPECIFIED"),
                Self::Ingress => std::option::Option::Some("INGRESS"),
                Self::Egress => std::option::Option::Some("EGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ingress,
                2 => Self::Egress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "INGRESS" => Self::Ingress,
                "EGRESS" => Self::Egress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ingress => serializer.serialize_i32(1),
                Self::Egress => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.cloud.securitycenter.v2.IpRules.Direction",
            ))
        }
    }

    /// The list of allow rules specified by this firewall. Each rule specifies a
    /// protocol and port-range tuple that describes a permitted connection.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Rules {
        /// Tuple with allowed rules.
        Allowed(std::boxed::Box<crate::model::Allowed>),
        /// Tuple with denied rules.
        Denied(std::boxed::Box<crate::model::Denied>),
    }
}

/// IP rule information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IpRule {
    /// The IP protocol this rule applies to. This value can either be one of the
    /// following well known protocol strings (TCP, UDP, ICMP, ESP, AH, IPIP,
    /// SCTP) or a string representation of the integer value.
    pub protocol: std::string::String,

    /// Optional. An optional list of ports to which this rule applies. This field
    /// is only applicable for the UDP or (S)TCP protocols. Each entry must be
    /// either an integer or a range including a min and max port number.
    pub port_ranges: std::vec::Vec<crate::model::ip_rule::PortRange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IpRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [protocol][crate::model::IpRule::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }

    /// Sets the value of [port_ranges][crate::model::IpRule::port_ranges].
    pub fn set_port_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ip_rule::PortRange>,
    {
        use std::iter::Iterator;
        self.port_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IpRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.IpRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IpRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __protocol,
            __port_ranges,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IpRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "protocol" => Ok(__FieldTag::__protocol),
                            "portRanges" => Ok(__FieldTag::__port_ranges),
                            "port_ranges" => Ok(__FieldTag::__port_ranges),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IpRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IpRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port_ranges => {
                            if !fields.insert(__FieldTag::__port_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port_ranges",
                                ));
                            }
                            result.port_ranges = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ip_rule::PortRange>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IpRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self.port_ranges.is_empty() {
            state.serialize_entry("portRanges", &self.port_ranges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IpRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IpRule");
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field("port_ranges", &self.port_ranges);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [IpRule].
pub mod ip_rule {
    #[allow(unused_imports)]
    use super::*;

    /// A port range which is inclusive of the min and max values.
    /// Values are between 0 and 2^16-1. The max can be equal / must be not smaller
    /// than the min value. If min and max are equal this indicates that it is a
    /// single port.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PortRange {
        /// Minimum port value.
        pub min: i64,

        /// Maximum port value.
        pub max: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PortRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min][crate::model::ip_rule::PortRange::min].
        pub fn set_min<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.min = v.into();
            self
        }

        /// Sets the value of [max][crate::model::ip_rule::PortRange::max].
        pub fn set_max<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.max = v.into();
            self
        }
    }

    impl wkt::message::Message for PortRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.IpRule.PortRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PortRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min,
                __max,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PortRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "min" => Ok(__FieldTag::__min),
                                "max" => Ok(__FieldTag::__max),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PortRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PortRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min => {
                                if !fields.insert(__FieldTag::__min) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.min = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max => {
                                if !fields.insert(__FieldTag::__max) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PortRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.min) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("min", &__With(&self.min))?;
            }
            if !wkt::internal::is_default(&self.max) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("max", &__With(&self.max))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PortRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PortRange");
            debug_struct.field("min", &self.min);
            debug_struct.field("max", &self.max);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Allowed IP rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Allowed {
    /// Optional. Optional list of allowed IP rules.
    pub ip_rules: std::vec::Vec<crate::model::IpRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Allowed {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_rules][crate::model::Allowed::ip_rules].
    pub fn set_ip_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpRule>,
    {
        use std::iter::Iterator;
        self.ip_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Allowed {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Allowed"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Allowed {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Allowed")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipRules" => Ok(__FieldTag::__ip_rules),
                            "ip_rules" => Ok(__FieldTag::__ip_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Allowed;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Allowed")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_rules => {
                            if !fields.insert(__FieldTag::__ip_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_rules",
                                ));
                            }
                            result.ip_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IpRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Allowed {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_rules.is_empty() {
            state.serialize_entry("ipRules", &self.ip_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Allowed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Allowed");
        debug_struct.field("ip_rules", &self.ip_rules);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Denied IP rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Denied {
    /// Optional. Optional list of denied IP rules.
    pub ip_rules: std::vec::Vec<crate::model::IpRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Denied {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_rules][crate::model::Denied::ip_rules].
    pub fn set_ip_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IpRule>,
    {
        use std::iter::Iterator;
        self.ip_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Denied {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Denied"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Denied {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ip_rules,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Denied")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ipRules" => Ok(__FieldTag::__ip_rules),
                            "ip_rules" => Ok(__FieldTag::__ip_rules),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Denied;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Denied")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ip_rules => {
                            if !fields.insert(__FieldTag::__ip_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_rules",
                                ));
                            }
                            result.ip_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IpRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Denied {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_rules.is_empty() {
            state.serialize_entry("ipRules", &self.ip_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Denied {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Denied");
        debug_struct.field("ip_rules", &self.ip_rules);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes a job
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Job {
    /// The fully-qualified name for a job.
    /// e.g. `projects/<project_id>/jobs/<job_id>`
    pub name: std::string::String,

    /// Output only. State of the job, such as `RUNNING` or `PENDING`.
    pub state: crate::model::JobState,

    /// Optional. If the job did not complete successfully, this field describes
    /// why.
    pub error_code: i32,

    /// Optional. Gives the location where the job ran, such as `US` or
    /// `europe-west1`
    pub location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Job::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Job::state].
    pub fn set_state<T: std::convert::Into<crate::model::JobState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_code][crate::model::Job::error_code].
    pub fn set_error_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Job::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Job"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __error_code,
            __location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "errorCode" => Ok(__FieldTag::__error_code),
                            "error_code" => Ok(__FieldTag::__error_code),
                            "location" => Ok(__FieldTag::__location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::JobState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_code => {
                            if !fields.insert(__FieldTag::__error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.error_code = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Job {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.error_code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("errorCode", &__With(&self.error_code))?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Job");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("error_code", &self.error_code);
        debug_struct.field("location", &self.location);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Kernel mode rootkit signatures.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct KernelRootkit {
    /// Rootkit name, when available.
    pub name: std::string::String,

    /// True if unexpected modifications of kernel code memory are present.
    pub unexpected_code_modification: bool,

    /// True if unexpected modifications of kernel read-only data memory are
    /// present.
    pub unexpected_read_only_data_modification: bool,

    /// True if `ftrace` points are present with callbacks pointing to regions
    /// that are not in the expected kernel or module code range.
    pub unexpected_ftrace_handler: bool,

    /// True if `kprobe` points are present with callbacks pointing to regions
    /// that are not in the expected kernel or module code range.
    pub unexpected_kprobe_handler: bool,

    /// True if kernel code pages that are not in the expected kernel or module
    /// code regions are present.
    pub unexpected_kernel_code_pages: bool,

    /// True if system call handlers that are are not in the expected kernel or
    /// module code regions are present.
    pub unexpected_system_call_handler: bool,

    /// True if interrupt handlers that are are not in the expected kernel or
    /// module code regions are present.
    pub unexpected_interrupt_handler: bool,

    /// True if unexpected processes in the scheduler run queue are present. Such
    /// processes are in the run queue, but not in the process task list.
    pub unexpected_processes_in_runqueue: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KernelRootkit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KernelRootkit::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [unexpected_code_modification][crate::model::KernelRootkit::unexpected_code_modification].
    pub fn set_unexpected_code_modification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unexpected_code_modification = v.into();
        self
    }

    /// Sets the value of [unexpected_read_only_data_modification][crate::model::KernelRootkit::unexpected_read_only_data_modification].
    pub fn set_unexpected_read_only_data_modification<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.unexpected_read_only_data_modification = v.into();
        self
    }

    /// Sets the value of [unexpected_ftrace_handler][crate::model::KernelRootkit::unexpected_ftrace_handler].
    pub fn set_unexpected_ftrace_handler<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unexpected_ftrace_handler = v.into();
        self
    }

    /// Sets the value of [unexpected_kprobe_handler][crate::model::KernelRootkit::unexpected_kprobe_handler].
    pub fn set_unexpected_kprobe_handler<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unexpected_kprobe_handler = v.into();
        self
    }

    /// Sets the value of [unexpected_kernel_code_pages][crate::model::KernelRootkit::unexpected_kernel_code_pages].
    pub fn set_unexpected_kernel_code_pages<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unexpected_kernel_code_pages = v.into();
        self
    }

    /// Sets the value of [unexpected_system_call_handler][crate::model::KernelRootkit::unexpected_system_call_handler].
    pub fn set_unexpected_system_call_handler<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unexpected_system_call_handler = v.into();
        self
    }

    /// Sets the value of [unexpected_interrupt_handler][crate::model::KernelRootkit::unexpected_interrupt_handler].
    pub fn set_unexpected_interrupt_handler<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unexpected_interrupt_handler = v.into();
        self
    }

    /// Sets the value of [unexpected_processes_in_runqueue][crate::model::KernelRootkit::unexpected_processes_in_runqueue].
    pub fn set_unexpected_processes_in_runqueue<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.unexpected_processes_in_runqueue = v.into();
        self
    }
}

impl wkt::message::Message for KernelRootkit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.KernelRootkit"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KernelRootkit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __unexpected_code_modification,
            __unexpected_read_only_data_modification,
            __unexpected_ftrace_handler,
            __unexpected_kprobe_handler,
            __unexpected_kernel_code_pages,
            __unexpected_system_call_handler,
            __unexpected_interrupt_handler,
            __unexpected_processes_in_runqueue,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KernelRootkit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "unexpectedCodeModification" => {
                                Ok(__FieldTag::__unexpected_code_modification)
                            }
                            "unexpected_code_modification" => {
                                Ok(__FieldTag::__unexpected_code_modification)
                            }
                            "unexpectedReadOnlyDataModification" => {
                                Ok(__FieldTag::__unexpected_read_only_data_modification)
                            }
                            "unexpected_read_only_data_modification" => {
                                Ok(__FieldTag::__unexpected_read_only_data_modification)
                            }
                            "unexpectedFtraceHandler" => {
                                Ok(__FieldTag::__unexpected_ftrace_handler)
                            }
                            "unexpected_ftrace_handler" => {
                                Ok(__FieldTag::__unexpected_ftrace_handler)
                            }
                            "unexpectedKprobeHandler" => {
                                Ok(__FieldTag::__unexpected_kprobe_handler)
                            }
                            "unexpected_kprobe_handler" => {
                                Ok(__FieldTag::__unexpected_kprobe_handler)
                            }
                            "unexpectedKernelCodePages" => {
                                Ok(__FieldTag::__unexpected_kernel_code_pages)
                            }
                            "unexpected_kernel_code_pages" => {
                                Ok(__FieldTag::__unexpected_kernel_code_pages)
                            }
                            "unexpectedSystemCallHandler" => {
                                Ok(__FieldTag::__unexpected_system_call_handler)
                            }
                            "unexpected_system_call_handler" => {
                                Ok(__FieldTag::__unexpected_system_call_handler)
                            }
                            "unexpectedInterruptHandler" => {
                                Ok(__FieldTag::__unexpected_interrupt_handler)
                            }
                            "unexpected_interrupt_handler" => {
                                Ok(__FieldTag::__unexpected_interrupt_handler)
                            }
                            "unexpectedProcessesInRunqueue" => {
                                Ok(__FieldTag::__unexpected_processes_in_runqueue)
                            }
                            "unexpected_processes_in_runqueue" => {
                                Ok(__FieldTag::__unexpected_processes_in_runqueue)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KernelRootkit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KernelRootkit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_code_modification => {
                            if !fields.insert(__FieldTag::__unexpected_code_modification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_code_modification",
                                ));
                            }
                            result.unexpected_code_modification = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_read_only_data_modification => {
                            if !fields.insert(__FieldTag::__unexpected_read_only_data_modification)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_read_only_data_modification",
                                ));
                            }
                            result.unexpected_read_only_data_modification = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_ftrace_handler => {
                            if !fields.insert(__FieldTag::__unexpected_ftrace_handler) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_ftrace_handler",
                                ));
                            }
                            result.unexpected_ftrace_handler = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_kprobe_handler => {
                            if !fields.insert(__FieldTag::__unexpected_kprobe_handler) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_kprobe_handler",
                                ));
                            }
                            result.unexpected_kprobe_handler = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_kernel_code_pages => {
                            if !fields.insert(__FieldTag::__unexpected_kernel_code_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_kernel_code_pages",
                                ));
                            }
                            result.unexpected_kernel_code_pages = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_system_call_handler => {
                            if !fields.insert(__FieldTag::__unexpected_system_call_handler) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_system_call_handler",
                                ));
                            }
                            result.unexpected_system_call_handler = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_interrupt_handler => {
                            if !fields.insert(__FieldTag::__unexpected_interrupt_handler) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_interrupt_handler",
                                ));
                            }
                            result.unexpected_interrupt_handler = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unexpected_processes_in_runqueue => {
                            if !fields.insert(__FieldTag::__unexpected_processes_in_runqueue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unexpected_processes_in_runqueue",
                                ));
                            }
                            result.unexpected_processes_in_runqueue = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KernelRootkit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.unexpected_code_modification) {
            state.serialize_entry(
                "unexpectedCodeModification",
                &self.unexpected_code_modification,
            )?;
        }
        if !wkt::internal::is_default(&self.unexpected_read_only_data_modification) {
            state.serialize_entry(
                "unexpectedReadOnlyDataModification",
                &self.unexpected_read_only_data_modification,
            )?;
        }
        if !wkt::internal::is_default(&self.unexpected_ftrace_handler) {
            state.serialize_entry("unexpectedFtraceHandler", &self.unexpected_ftrace_handler)?;
        }
        if !wkt::internal::is_default(&self.unexpected_kprobe_handler) {
            state.serialize_entry("unexpectedKprobeHandler", &self.unexpected_kprobe_handler)?;
        }
        if !wkt::internal::is_default(&self.unexpected_kernel_code_pages) {
            state.serialize_entry(
                "unexpectedKernelCodePages",
                &self.unexpected_kernel_code_pages,
            )?;
        }
        if !wkt::internal::is_default(&self.unexpected_system_call_handler) {
            state.serialize_entry(
                "unexpectedSystemCallHandler",
                &self.unexpected_system_call_handler,
            )?;
        }
        if !wkt::internal::is_default(&self.unexpected_interrupt_handler) {
            state.serialize_entry(
                "unexpectedInterruptHandler",
                &self.unexpected_interrupt_handler,
            )?;
        }
        if !wkt::internal::is_default(&self.unexpected_processes_in_runqueue) {
            state.serialize_entry(
                "unexpectedProcessesInRunqueue",
                &self.unexpected_processes_in_runqueue,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for KernelRootkit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KernelRootkit");
        debug_struct.field("name", &self.name);
        debug_struct.field(
            "unexpected_code_modification",
            &self.unexpected_code_modification,
        );
        debug_struct.field(
            "unexpected_read_only_data_modification",
            &self.unexpected_read_only_data_modification,
        );
        debug_struct.field("unexpected_ftrace_handler", &self.unexpected_ftrace_handler);
        debug_struct.field("unexpected_kprobe_handler", &self.unexpected_kprobe_handler);
        debug_struct.field(
            "unexpected_kernel_code_pages",
            &self.unexpected_kernel_code_pages,
        );
        debug_struct.field(
            "unexpected_system_call_handler",
            &self.unexpected_system_call_handler,
        );
        debug_struct.field(
            "unexpected_interrupt_handler",
            &self.unexpected_interrupt_handler,
        );
        debug_struct.field(
            "unexpected_processes_in_runqueue",
            &self.unexpected_processes_in_runqueue,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Kubernetes-related attributes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Kubernetes {
    /// Kubernetes
    /// [Pods](https://cloud.google.com/kubernetes-engine/docs/concepts/pod)
    /// associated with the finding. This field contains Pod records for each
    /// container that is owned by a Pod.
    pub pods: std::vec::Vec<crate::model::kubernetes::Pod>,

    /// Provides Kubernetes
    /// [node](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture#nodes)
    /// information.
    pub nodes: std::vec::Vec<crate::model::kubernetes::Node>,

    /// GKE [node
    /// pools](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pools)
    /// associated with the finding. This field contains node pool information for
    /// each node, when it is available.
    pub node_pools: std::vec::Vec<crate::model::kubernetes::NodePool>,

    /// Provides Kubernetes role information for findings that involve [Roles or
    /// ClusterRoles](https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control).
    pub roles: std::vec::Vec<crate::model::kubernetes::Role>,

    /// Provides Kubernetes role binding information for findings that involve
    /// [RoleBindings or
    /// ClusterRoleBindings](https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control).
    pub bindings: std::vec::Vec<crate::model::kubernetes::Binding>,

    /// Provides information on any Kubernetes access reviews (privilege checks)
    /// relevant to the finding.
    pub access_reviews: std::vec::Vec<crate::model::kubernetes::AccessReview>,

    /// Kubernetes objects related to the finding.
    pub objects: std::vec::Vec<crate::model::kubernetes::Object>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Kubernetes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pods][crate::model::Kubernetes::pods].
    pub fn set_pods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::kubernetes::Pod>,
    {
        use std::iter::Iterator;
        self.pods = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [nodes][crate::model::Kubernetes::nodes].
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::kubernetes::Node>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_pools][crate::model::Kubernetes::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::kubernetes::NodePool>,
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [roles][crate::model::Kubernetes::roles].
    pub fn set_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::kubernetes::Role>,
    {
        use std::iter::Iterator;
        self.roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bindings][crate::model::Kubernetes::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::kubernetes::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [access_reviews][crate::model::Kubernetes::access_reviews].
    pub fn set_access_reviews<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::kubernetes::AccessReview>,
    {
        use std::iter::Iterator;
        self.access_reviews = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [objects][crate::model::Kubernetes::objects].
    pub fn set_objects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::kubernetes::Object>,
    {
        use std::iter::Iterator;
        self.objects = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Kubernetes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Kubernetes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pods,
            __nodes,
            __node_pools,
            __roles,
            __bindings,
            __access_reviews,
            __objects,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Kubernetes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pods" => Ok(__FieldTag::__pods),
                            "nodes" => Ok(__FieldTag::__nodes),
                            "nodePools" => Ok(__FieldTag::__node_pools),
                            "node_pools" => Ok(__FieldTag::__node_pools),
                            "roles" => Ok(__FieldTag::__roles),
                            "bindings" => Ok(__FieldTag::__bindings),
                            "accessReviews" => Ok(__FieldTag::__access_reviews),
                            "access_reviews" => Ok(__FieldTag::__access_reviews),
                            "objects" => Ok(__FieldTag::__objects),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Kubernetes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Kubernetes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pods => {
                            if !fields.insert(__FieldTag::__pods) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pods",
                                ));
                            }
                            result.pods =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::kubernetes::Pod>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodes => {
                            if !fields.insert(__FieldTag::__nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodes",
                                ));
                            }
                            result.nodes =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::kubernetes::Node>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pools => {
                            if !fields.insert(__FieldTag::__node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pools",
                                ));
                            }
                            result.node_pools = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::kubernetes::NodePool>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__roles => {
                            if !fields.insert(__FieldTag::__roles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for roles",
                                ));
                            }
                            result.roles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::kubernetes::Role>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bindings => {
                            if !fields.insert(__FieldTag::__bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bindings",
                                ));
                            }
                            result.bindings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::kubernetes::Binding>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_reviews => {
                            if !fields.insert(__FieldTag::__access_reviews) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_reviews",
                                ));
                            }
                            result.access_reviews = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::kubernetes::AccessReview>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__objects => {
                            if !fields.insert(__FieldTag::__objects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for objects",
                                ));
                            }
                            result.objects = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::kubernetes::Object>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Kubernetes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pods.is_empty() {
            state.serialize_entry("pods", &self.pods)?;
        }
        if !self.nodes.is_empty() {
            state.serialize_entry("nodes", &self.nodes)?;
        }
        if !self.node_pools.is_empty() {
            state.serialize_entry("nodePools", &self.node_pools)?;
        }
        if !self.roles.is_empty() {
            state.serialize_entry("roles", &self.roles)?;
        }
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if !self.access_reviews.is_empty() {
            state.serialize_entry("accessReviews", &self.access_reviews)?;
        }
        if !self.objects.is_empty() {
            state.serialize_entry("objects", &self.objects)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Kubernetes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Kubernetes");
        debug_struct.field("pods", &self.pods);
        debug_struct.field("nodes", &self.nodes);
        debug_struct.field("node_pools", &self.node_pools);
        debug_struct.field("roles", &self.roles);
        debug_struct.field("bindings", &self.bindings);
        debug_struct.field("access_reviews", &self.access_reviews);
        debug_struct.field("objects", &self.objects);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Kubernetes].
pub mod kubernetes {
    #[allow(unused_imports)]
    use super::*;

    /// A Kubernetes Pod.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Pod {
        /// Kubernetes Pod namespace.
        pub ns: std::string::String,

        /// Kubernetes Pod name.
        pub name: std::string::String,

        /// Pod labels.  For Kubernetes containers, these are applied to the
        /// container.
        pub labels: std::vec::Vec<crate::model::Label>,

        /// Pod containers associated with this finding, if any.
        pub containers: std::vec::Vec<crate::model::Container>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Pod {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ns][crate::model::kubernetes::Pod::ns].
        pub fn set_ns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ns = v.into();
            self
        }

        /// Sets the value of [name][crate::model::kubernetes::Pod::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [labels][crate::model::kubernetes::Pod::labels].
        pub fn set_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Label>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [containers][crate::model::kubernetes::Pod::containers].
        pub fn set_containers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Container>,
        {
            use std::iter::Iterator;
            self.containers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Pod {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.Pod"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Pod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ns,
                __name,
                __labels,
                __containers,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Pod")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ns" => Ok(__FieldTag::__ns),
                                "name" => Ok(__FieldTag::__name),
                                "labels" => Ok(__FieldTag::__labels),
                                "containers" => Ok(__FieldTag::__containers),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Pod;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Pod")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ns => {
                                if !fields.insert(__FieldTag::__ns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ns",
                                    ));
                                }
                                result.ns = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Label>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__containers => {
                                if !fields.insert(__FieldTag::__containers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for containers",
                                    ));
                                }
                                result.containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Container>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Pod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ns.is_empty() {
                state.serialize_entry("ns", &self.ns)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self.containers.is_empty() {
                state.serialize_entry("containers", &self.containers)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Pod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Pod");
            debug_struct.field("ns", &self.ns);
            debug_struct.field("name", &self.name);
            debug_struct.field("labels", &self.labels);
            debug_struct.field("containers", &self.containers);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Kubernetes nodes associated with the finding.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Node {
        /// [Full resource name](https://google.aip.dev/122#full-resource-names) of
        /// the Compute Engine VM running the cluster node.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Node {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::kubernetes::Node::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for Node {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.Node"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Node {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Node")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Node;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Node")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Node {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Node {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Node");
            debug_struct.field("name", &self.name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Provides GKE node pool information.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NodePool {
        /// Kubernetes node pool name.
        pub name: std::string::String,

        /// Nodes associated with the finding.
        pub nodes: std::vec::Vec<crate::model::kubernetes::Node>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NodePool {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::kubernetes::NodePool::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [nodes][crate::model::kubernetes::NodePool::nodes].
        pub fn set_nodes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::kubernetes::Node>,
        {
            use std::iter::Iterator;
            self.nodes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NodePool {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.NodePool"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NodePool {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __nodes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NodePool")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "nodes" => Ok(__FieldTag::__nodes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NodePool;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NodePool")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__nodes => {
                                if !fields.insert(__FieldTag::__nodes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for nodes",
                                    ));
                                }
                                result.nodes = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::kubernetes::Node>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NodePool {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.nodes.is_empty() {
                state.serialize_entry("nodes", &self.nodes)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NodePool {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NodePool");
            debug_struct.field("name", &self.name);
            debug_struct.field("nodes", &self.nodes);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Kubernetes Role or ClusterRole.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Role {
        /// Role type.
        pub kind: crate::model::kubernetes::role::Kind,

        /// Role namespace.
        pub ns: std::string::String,

        /// Role name.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Role {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::kubernetes::Role::kind].
        pub fn set_kind<T: std::convert::Into<crate::model::kubernetes::role::Kind>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// Sets the value of [ns][crate::model::kubernetes::Role::ns].
        pub fn set_ns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ns = v.into();
            self
        }

        /// Sets the value of [name][crate::model::kubernetes::Role::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for Role {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.Role"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kind,
                __ns,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Role")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kind" => Ok(__FieldTag::__kind),
                                "ns" => Ok(__FieldTag::__ns),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Role;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Role")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kind => {
                                if !fields.insert(__FieldTag::__kind) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kind",
                                    ));
                                }
                                result.kind = map.next_value::<std::option::Option<crate::model::kubernetes::role::Kind>>()?.unwrap_or_default();
                            }
                            __FieldTag::__ns => {
                                if !fields.insert(__FieldTag::__ns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ns",
                                    ));
                                }
                                result.ns = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.kind) {
                state.serialize_entry("kind", &self.kind)?;
            }
            if !self.ns.is_empty() {
                state.serialize_entry("ns", &self.ns)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Role");
            debug_struct.field("kind", &self.kind);
            debug_struct.field("ns", &self.ns);
            debug_struct.field("name", &self.name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Role].
    pub mod role {
        #[allow(unused_imports)]
        use super::*;

        /// Types of Kubernetes roles.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// Role type is not specified.
            Unspecified,
            /// Kubernetes Role.
            Role,
            /// Kubernetes ClusterRole.
            ClusterRole,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Kind::value] or
            /// [Kind::name].
            UnknownValue(kind::UnknownValue),
        }

        #[doc(hidden)]
        pub mod kind {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Kind {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Role => std::option::Option::Some(1),
                    Self::ClusterRole => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("KIND_UNSPECIFIED"),
                    Self::Role => std::option::Option::Some("ROLE"),
                    Self::ClusterRole => std::option::Option::Some("CLUSTER_ROLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Kind {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Kind {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Kind {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Role,
                    2 => Self::ClusterRole,
                    _ => Self::UnknownValue(kind::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Kind {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "KIND_UNSPECIFIED" => Self::Unspecified,
                    "ROLE" => Self::Role,
                    "CLUSTER_ROLE" => Self::ClusterRole,
                    _ => Self::UnknownValue(kind::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Kind {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Role => serializer.serialize_i32(1),
                    Self::ClusterRole => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Kind {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                    ".google.cloud.securitycenter.v2.Kubernetes.Role.Kind",
                ))
            }
        }
    }

    /// Represents a Kubernetes RoleBinding or ClusterRoleBinding.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Binding {
        /// Namespace for the binding.
        pub ns: std::string::String,

        /// Name for the binding.
        pub name: std::string::String,

        /// The Role or ClusterRole referenced by the binding.
        pub role: std::option::Option<crate::model::kubernetes::Role>,

        /// Represents one or more subjects that are bound to the role. Not always
        /// available for PATCH requests.
        pub subjects: std::vec::Vec<crate::model::kubernetes::Subject>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Binding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ns][crate::model::kubernetes::Binding::ns].
        pub fn set_ns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ns = v.into();
            self
        }

        /// Sets the value of [name][crate::model::kubernetes::Binding::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [role][crate::model::kubernetes::Binding::role].
        pub fn set_role<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::kubernetes::Role>,
        {
            self.role = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [role][crate::model::kubernetes::Binding::role].
        pub fn set_or_clear_role<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::kubernetes::Role>,
        {
            self.role = v.map(|x| x.into());
            self
        }

        /// Sets the value of [subjects][crate::model::kubernetes::Binding::subjects].
        pub fn set_subjects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::kubernetes::Subject>,
        {
            use std::iter::Iterator;
            self.subjects = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Binding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.Binding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Binding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ns,
                __name,
                __role,
                __subjects,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Binding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ns" => Ok(__FieldTag::__ns),
                                "name" => Ok(__FieldTag::__name),
                                "role" => Ok(__FieldTag::__role),
                                "subjects" => Ok(__FieldTag::__subjects),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Binding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Binding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ns => {
                                if !fields.insert(__FieldTag::__ns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ns",
                                    ));
                                }
                                result.ns = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__role => {
                                if !fields.insert(__FieldTag::__role) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for role",
                                    ));
                                }
                                result.role = map.next_value::<std::option::Option<crate::model::kubernetes::Role>>()?
                                    ;
                            }
                            __FieldTag::__subjects => {
                                if !fields.insert(__FieldTag::__subjects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subjects",
                                    ));
                                }
                                result.subjects = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::kubernetes::Subject>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Binding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ns.is_empty() {
                state.serialize_entry("ns", &self.ns)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if self.role.is_some() {
                state.serialize_entry("role", &self.role)?;
            }
            if !self.subjects.is_empty() {
                state.serialize_entry("subjects", &self.subjects)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Binding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Binding");
            debug_struct.field("ns", &self.ns);
            debug_struct.field("name", &self.name);
            debug_struct.field("role", &self.role);
            debug_struct.field("subjects", &self.subjects);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents a Kubernetes subject.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Subject {
        /// Authentication type for the subject.
        pub kind: crate::model::kubernetes::subject::AuthType,

        /// Namespace for the subject.
        pub ns: std::string::String,

        /// Name for the subject.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Subject {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::kubernetes::Subject::kind].
        pub fn set_kind<T: std::convert::Into<crate::model::kubernetes::subject::AuthType>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// Sets the value of [ns][crate::model::kubernetes::Subject::ns].
        pub fn set_ns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ns = v.into();
            self
        }

        /// Sets the value of [name][crate::model::kubernetes::Subject::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for Subject {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.Subject"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Subject {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kind,
                __ns,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Subject")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kind" => Ok(__FieldTag::__kind),
                                "ns" => Ok(__FieldTag::__ns),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Subject;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Subject")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kind => {
                                if !fields.insert(__FieldTag::__kind) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kind",
                                    ));
                                }
                                result.kind = map
                                    .next_value::<std::option::Option<
                                        crate::model::kubernetes::subject::AuthType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ns => {
                                if !fields.insert(__FieldTag::__ns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ns",
                                    ));
                                }
                                result.ns = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Subject {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.kind) {
                state.serialize_entry("kind", &self.kind)?;
            }
            if !self.ns.is_empty() {
                state.serialize_entry("ns", &self.ns)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Subject {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Subject");
            debug_struct.field("kind", &self.kind);
            debug_struct.field("ns", &self.ns);
            debug_struct.field("name", &self.name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Subject].
    pub mod subject {
        #[allow(unused_imports)]
        use super::*;

        /// Auth types that can be used for the subject's kind field.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AuthType {
            /// Authentication is not specified.
            Unspecified,
            /// User with valid certificate.
            User,
            /// Users managed by Kubernetes API with credentials stored as secrets.
            Serviceaccount,
            /// Collection of users.
            Group,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [AuthType::value] or
            /// [AuthType::name].
            UnknownValue(auth_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod auth_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl AuthType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::User => std::option::Option::Some(1),
                    Self::Serviceaccount => std::option::Option::Some(2),
                    Self::Group => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("AUTH_TYPE_UNSPECIFIED"),
                    Self::User => std::option::Option::Some("USER"),
                    Self::Serviceaccount => std::option::Option::Some("SERVICEACCOUNT"),
                    Self::Group => std::option::Option::Some("GROUP"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for AuthType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for AuthType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for AuthType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::User,
                    2 => Self::Serviceaccount,
                    3 => Self::Group,
                    _ => Self::UnknownValue(auth_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for AuthType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "AUTH_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "USER" => Self::User,
                    "SERVICEACCOUNT" => Self::Serviceaccount,
                    "GROUP" => Self::Group,
                    _ => Self::UnknownValue(auth_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for AuthType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::User => serializer.serialize_i32(1),
                    Self::Serviceaccount => serializer.serialize_i32(2),
                    Self::Group => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for AuthType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthType>::new(
                    ".google.cloud.securitycenter.v2.Kubernetes.Subject.AuthType",
                ))
            }
        }
    }

    /// Conveys information about a Kubernetes access review (such as one returned
    /// by a [`kubectl auth
    /// can-i`](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#checking-api-access)
    /// command) that was involved in a finding.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AccessReview {
        /// The API group of the resource. "*" means all.
        pub group: std::string::String,

        /// Namespace of the action being requested. Currently, there is no
        /// distinction between no namespace and all namespaces.  Both
        /// are represented by "" (empty).
        pub ns: std::string::String,

        /// The name of the resource being requested. Empty means all.
        pub name: std::string::String,

        /// The optional resource type requested. "*" means all.
        pub resource: std::string::String,

        /// The optional subresource type.
        pub subresource: std::string::String,

        /// A Kubernetes resource API verb, like get, list, watch, create, update,
        /// delete, proxy. "*" means all.
        pub verb: std::string::String,

        /// The API version of the resource. "*" means all.
        pub version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AccessReview {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [group][crate::model::kubernetes::AccessReview::group].
        pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group = v.into();
            self
        }

        /// Sets the value of [ns][crate::model::kubernetes::AccessReview::ns].
        pub fn set_ns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ns = v.into();
            self
        }

        /// Sets the value of [name][crate::model::kubernetes::AccessReview::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::kubernetes::AccessReview::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [subresource][crate::model::kubernetes::AccessReview::subresource].
        pub fn set_subresource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subresource = v.into();
            self
        }

        /// Sets the value of [verb][crate::model::kubernetes::AccessReview::verb].
        pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.verb = v.into();
            self
        }

        /// Sets the value of [version][crate::model::kubernetes::AccessReview::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    impl wkt::message::Message for AccessReview {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.AccessReview"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AccessReview {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __group,
                __ns,
                __name,
                __resource,
                __subresource,
                __verb,
                __version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AccessReview")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "group" => Ok(__FieldTag::__group),
                                "ns" => Ok(__FieldTag::__ns),
                                "name" => Ok(__FieldTag::__name),
                                "resource" => Ok(__FieldTag::__resource),
                                "subresource" => Ok(__FieldTag::__subresource),
                                "verb" => Ok(__FieldTag::__verb),
                                "version" => Ok(__FieldTag::__version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AccessReview;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AccessReview")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__group => {
                                if !fields.insert(__FieldTag::__group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group",
                                    ));
                                }
                                result.group = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ns => {
                                if !fields.insert(__FieldTag::__ns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ns",
                                    ));
                                }
                                result.ns = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource => {
                                if !fields.insert(__FieldTag::__resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource",
                                    ));
                                }
                                result.resource = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__subresource => {
                                if !fields.insert(__FieldTag::__subresource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subresource",
                                    ));
                                }
                                result.subresource = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__verb => {
                                if !fields.insert(__FieldTag::__verb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for verb",
                                    ));
                                }
                                result.verb = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AccessReview {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.group.is_empty() {
                state.serialize_entry("group", &self.group)?;
            }
            if !self.ns.is_empty() {
                state.serialize_entry("ns", &self.ns)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.resource.is_empty() {
                state.serialize_entry("resource", &self.resource)?;
            }
            if !self.subresource.is_empty() {
                state.serialize_entry("subresource", &self.subresource)?;
            }
            if !self.verb.is_empty() {
                state.serialize_entry("verb", &self.verb)?;
            }
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AccessReview {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AccessReview");
            debug_struct.field("group", &self.group);
            debug_struct.field("ns", &self.ns);
            debug_struct.field("name", &self.name);
            debug_struct.field("resource", &self.resource);
            debug_struct.field("subresource", &self.subresource);
            debug_struct.field("verb", &self.verb);
            debug_struct.field("version", &self.version);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Kubernetes object related to the finding, uniquely identified by GKNN.
    /// Used if the object Kind is not one of Pod, Node, NodePool, Binding, or
    /// AccessReview.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Object {
        /// Kubernetes object group, such as "policy.k8s.io/v1".
        pub group: std::string::String,

        /// Kubernetes object kind, such as "Namespace".
        pub kind: std::string::String,

        /// Kubernetes object namespace. Must be a valid DNS label. Named
        /// "ns" to avoid collision with C++ namespace keyword. For details see
        /// <https://kubernetes.io/docs/tasks/administer-cluster/namespaces/>.
        pub ns: std::string::String,

        /// Kubernetes object name. For details see
        /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/>.
        pub name: std::string::String,

        /// Pod containers associated with this finding, if any.
        pub containers: std::vec::Vec<crate::model::Container>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Object {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [group][crate::model::kubernetes::Object::group].
        pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.group = v.into();
            self
        }

        /// Sets the value of [kind][crate::model::kubernetes::Object::kind].
        pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kind = v.into();
            self
        }

        /// Sets the value of [ns][crate::model::kubernetes::Object::ns].
        pub fn set_ns<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ns = v.into();
            self
        }

        /// Sets the value of [name][crate::model::kubernetes::Object::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [containers][crate::model::kubernetes::Object::containers].
        pub fn set_containers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Container>,
        {
            use std::iter::Iterator;
            self.containers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Object {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.Kubernetes.Object"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Object {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __group,
                __kind,
                __ns,
                __name,
                __containers,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Object")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "group" => Ok(__FieldTag::__group),
                                "kind" => Ok(__FieldTag::__kind),
                                "ns" => Ok(__FieldTag::__ns),
                                "name" => Ok(__FieldTag::__name),
                                "containers" => Ok(__FieldTag::__containers),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Object;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Object")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__group => {
                                if !fields.insert(__FieldTag::__group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group",
                                    ));
                                }
                                result.group = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kind => {
                                if !fields.insert(__FieldTag::__kind) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kind",
                                    ));
                                }
                                result.kind = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ns => {
                                if !fields.insert(__FieldTag::__ns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ns",
                                    ));
                                }
                                result.ns = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__containers => {
                                if !fields.insert(__FieldTag::__containers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for containers",
                                    ));
                                }
                                result.containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Container>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Object {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.group.is_empty() {
                state.serialize_entry("group", &self.group)?;
            }
            if !self.kind.is_empty() {
                state.serialize_entry("kind", &self.kind)?;
            }
            if !self.ns.is_empty() {
                state.serialize_entry("ns", &self.ns)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.containers.is_empty() {
                state.serialize_entry("containers", &self.containers)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Object {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Object");
            debug_struct.field("group", &self.group);
            debug_struct.field("kind", &self.kind);
            debug_struct.field("ns", &self.ns);
            debug_struct.field("name", &self.name);
            debug_struct.field("containers", &self.containers);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Represents a generic name-value label. A label has separate name and value
/// fields to support filtering with the `contains()` function. For more
/// information, see [Filtering on array-type
/// fields](https://cloud.google.com/security-command-center/docs/how-to-api-list-findings#array-contains-filtering).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Label {
    /// Name of the label.
    pub name: std::string::String,

    /// Value that corresponds to the label's name.
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Label {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Label::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Label::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Label {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Label"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Label {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Label")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Label;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Label")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Label {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Label {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Label");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information related to the load balancer associated with the
/// finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadBalancer {
    /// The name of the load balancer associated with the finding.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoadBalancer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LoadBalancer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for LoadBalancer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.LoadBalancer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadBalancer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadBalancer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadBalancer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadBalancer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoadBalancer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoadBalancer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadBalancer");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An individual entry in a log.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LogEntry {
    /// The log entry.
    pub log_entry: std::option::Option<crate::model::log_entry::LogEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_entry][crate::model::LogEntry::log_entry].
    ///
    /// Note that all the setters affecting `log_entry` are mutually
    /// exclusive.
    pub fn set_log_entry<
        T: std::convert::Into<std::option::Option<crate::model::log_entry::LogEntry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_entry = v.into();
        self
    }

    /// The value of [log_entry][crate::model::LogEntry::log_entry]
    /// if it holds a `CloudLoggingEntry`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_logging_entry(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudLoggingEntry>> {
        #[allow(unreachable_patterns)]
        self.log_entry.as_ref().and_then(|v| match v {
            crate::model::log_entry::LogEntry::CloudLoggingEntry(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [log_entry][crate::model::LogEntry::log_entry]
    /// to hold a `CloudLoggingEntry`.
    ///
    /// Note that all the setters affecting `log_entry` are
    /// mutually exclusive.
    pub fn set_cloud_logging_entry<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudLoggingEntry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.log_entry = std::option::Option::Some(
            crate::model::log_entry::LogEntry::CloudLoggingEntry(v.into()),
        );
        self
    }
}

impl wkt::message::Message for LogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.LogEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_logging_entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudLoggingEntry" => Ok(__FieldTag::__cloud_logging_entry),
                            "cloud_logging_entry" => Ok(__FieldTag::__cloud_logging_entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_logging_entry => {
                            if !fields.insert(__FieldTag::__cloud_logging_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_logging_entry",
                                ));
                            }
                            if result.log_entry.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `log_entry`, a oneof with full ID .google.cloud.securitycenter.v2.LogEntry.cloud_logging_entry, latest field was cloudLoggingEntry",
                                ));
                            }
                            result.log_entry = std::option::Option::Some(
                                crate::model::log_entry::LogEntry::CloudLoggingEntry(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudLoggingEntry>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_logging_entry() {
            state.serialize_entry("cloudLoggingEntry", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LogEntry");
        debug_struct.field("log_entry", &self.log_entry);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LogEntry].
pub mod log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The log entry.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogEntry {
        /// An individual entry in a log stored in Cloud Logging.
        CloudLoggingEntry(std::boxed::Box<crate::model::CloudLoggingEntry>),
    }
}

/// Metadata taken from a [Cloud Logging
/// LogEntry](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudLoggingEntry {
    /// A unique identifier for the log entry.
    pub insert_id: std::string::String,

    /// The type of the log (part of `log_name`. `log_name` is the resource name of
    /// the log to which this log entry belongs). For example:
    /// `cloudresourcemanager.googleapis.com/activity` Note that this field is not
    /// URL-encoded, unlike in `LogEntry`.
    pub log_id: std::string::String,

    /// The organization, folder, or project of the monitored resource that
    /// produced this log entry.
    pub resource_container: std::string::String,

    /// The time the event described by the log entry occurred.
    pub timestamp: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudLoggingEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insert_id][crate::model::CloudLoggingEntry::insert_id].
    pub fn set_insert_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.insert_id = v.into();
        self
    }

    /// Sets the value of [log_id][crate::model::CloudLoggingEntry::log_id].
    pub fn set_log_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_id = v.into();
        self
    }

    /// Sets the value of [resource_container][crate::model::CloudLoggingEntry::resource_container].
    pub fn set_resource_container<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_container = v.into();
        self
    }

    /// Sets the value of [timestamp][crate::model::CloudLoggingEntry::timestamp].
    pub fn set_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp][crate::model::CloudLoggingEntry::timestamp].
    pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CloudLoggingEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CloudLoggingEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudLoggingEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __insert_id,
            __log_id,
            __resource_container,
            __timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudLoggingEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insertId" => Ok(__FieldTag::__insert_id),
                            "insert_id" => Ok(__FieldTag::__insert_id),
                            "logId" => Ok(__FieldTag::__log_id),
                            "log_id" => Ok(__FieldTag::__log_id),
                            "resourceContainer" => Ok(__FieldTag::__resource_container),
                            "resource_container" => Ok(__FieldTag::__resource_container),
                            "timestamp" => Ok(__FieldTag::__timestamp),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudLoggingEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudLoggingEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__insert_id => {
                            if !fields.insert(__FieldTag::__insert_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insert_id",
                                ));
                            }
                            result.insert_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_id => {
                            if !fields.insert(__FieldTag::__log_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_id",
                                ));
                            }
                            result.log_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_container => {
                            if !fields.insert(__FieldTag::__resource_container) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_container",
                                ));
                            }
                            result.resource_container = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timestamp => {
                            if !fields.insert(__FieldTag::__timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp",
                                ));
                            }
                            result.timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudLoggingEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.insert_id.is_empty() {
            state.serialize_entry("insertId", &self.insert_id)?;
        }
        if !self.log_id.is_empty() {
            state.serialize_entry("logId", &self.log_id)?;
        }
        if !self.resource_container.is_empty() {
            state.serialize_entry("resourceContainer", &self.resource_container)?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudLoggingEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudLoggingEntry");
        debug_struct.field("insert_id", &self.insert_id);
        debug_struct.field("log_id", &self.log_id);
        debug_struct.field("resource_container", &self.resource_container);
        debug_struct.field("timestamp", &self.timestamp);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MITRE ATT&CK tactics and techniques related to this finding.
/// See: <https://attack.mitre.org>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MitreAttack {
    /// The MITRE ATT&CK tactic most closely represented by this finding, if any.
    pub primary_tactic: crate::model::mitre_attack::Tactic,

    /// The MITRE ATT&CK technique most closely represented by this finding, if
    /// any. primary_techniques is a repeated field because there are multiple
    /// levels of MITRE ATT&CK techniques.  If the technique most closely
    /// represented by this finding is a sub-technique (e.g. `SCANNING_IP_BLOCKS`),
    /// both the sub-technique and its parent technique(s) will be listed (e.g.
    /// `SCANNING_IP_BLOCKS`, `ACTIVE_SCANNING`).
    pub primary_techniques: std::vec::Vec<crate::model::mitre_attack::Technique>,

    /// Additional MITRE ATT&CK tactics related to this finding, if any.
    pub additional_tactics: std::vec::Vec<crate::model::mitre_attack::Tactic>,

    /// Additional MITRE ATT&CK techniques related to this finding, if any, along
    /// with any of their respective parent techniques.
    pub additional_techniques: std::vec::Vec<crate::model::mitre_attack::Technique>,

    /// The MITRE ATT&CK version referenced by the above fields. E.g. "8".
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MitreAttack {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_tactic][crate::model::MitreAttack::primary_tactic].
    pub fn set_primary_tactic<T: std::convert::Into<crate::model::mitre_attack::Tactic>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_tactic = v.into();
        self
    }

    /// Sets the value of [primary_techniques][crate::model::MitreAttack::primary_techniques].
    pub fn set_primary_techniques<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::mitre_attack::Technique>,
    {
        use std::iter::Iterator;
        self.primary_techniques = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_tactics][crate::model::MitreAttack::additional_tactics].
    pub fn set_additional_tactics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::mitre_attack::Tactic>,
    {
        use std::iter::Iterator;
        self.additional_tactics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_techniques][crate::model::MitreAttack::additional_techniques].
    pub fn set_additional_techniques<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::mitre_attack::Technique>,
    {
        use std::iter::Iterator;
        self.additional_techniques = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version][crate::model::MitreAttack::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for MitreAttack {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.MitreAttack"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MitreAttack {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __primary_tactic,
            __primary_techniques,
            __additional_tactics,
            __additional_techniques,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MitreAttack")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "primaryTactic" => Ok(__FieldTag::__primary_tactic),
                            "primary_tactic" => Ok(__FieldTag::__primary_tactic),
                            "primaryTechniques" => Ok(__FieldTag::__primary_techniques),
                            "primary_techniques" => Ok(__FieldTag::__primary_techniques),
                            "additionalTactics" => Ok(__FieldTag::__additional_tactics),
                            "additional_tactics" => Ok(__FieldTag::__additional_tactics),
                            "additionalTechniques" => Ok(__FieldTag::__additional_techniques),
                            "additional_techniques" => Ok(__FieldTag::__additional_techniques),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MitreAttack;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MitreAttack")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__primary_tactic => {
                            if !fields.insert(__FieldTag::__primary_tactic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_tactic",
                                ));
                            }
                            result.primary_tactic = map.next_value::<std::option::Option<crate::model::mitre_attack::Tactic>>()?.unwrap_or_default();
                        }
                        __FieldTag::__primary_techniques => {
                            if !fields.insert(__FieldTag::__primary_techniques) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_techniques",
                                ));
                            }
                            result.primary_techniques = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::mitre_attack::Technique>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_tactics => {
                            if !fields.insert(__FieldTag::__additional_tactics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_tactics",
                                ));
                            }
                            result.additional_tactics = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::mitre_attack::Tactic>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_techniques => {
                            if !fields.insert(__FieldTag::__additional_techniques) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_techniques",
                                ));
                            }
                            result.additional_techniques = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::mitre_attack::Technique>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MitreAttack {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.primary_tactic) {
            state.serialize_entry("primaryTactic", &self.primary_tactic)?;
        }
        if !self.primary_techniques.is_empty() {
            state.serialize_entry("primaryTechniques", &self.primary_techniques)?;
        }
        if !self.additional_tactics.is_empty() {
            state.serialize_entry("additionalTactics", &self.additional_tactics)?;
        }
        if !self.additional_techniques.is_empty() {
            state.serialize_entry("additionalTechniques", &self.additional_techniques)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MitreAttack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MitreAttack");
        debug_struct.field("primary_tactic", &self.primary_tactic);
        debug_struct.field("primary_techniques", &self.primary_techniques);
        debug_struct.field("additional_tactics", &self.additional_tactics);
        debug_struct.field("additional_techniques", &self.additional_techniques);
        debug_struct.field("version", &self.version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MitreAttack].
pub mod mitre_attack {
    #[allow(unused_imports)]
    use super::*;

    /// MITRE ATT&CK tactics that can be referenced by SCC findings.
    /// See: <https://attack.mitre.org/tactics/enterprise/>
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tactic {
        /// Unspecified value.
        Unspecified,
        /// TA0043
        Reconnaissance,
        /// TA0042
        ResourceDevelopment,
        /// TA0001
        InitialAccess,
        /// TA0002
        Execution,
        /// TA0003
        Persistence,
        /// TA0004
        PrivilegeEscalation,
        /// TA0005
        DefenseEvasion,
        /// TA0006
        CredentialAccess,
        /// TA0007
        Discovery,
        /// TA0008
        LateralMovement,
        /// TA0009
        Collection,
        /// TA0011
        CommandAndControl,
        /// TA0010
        Exfiltration,
        /// TA0040
        Impact,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Tactic::value] or
        /// [Tactic::name].
        UnknownValue(tactic::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tactic {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Tactic {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Reconnaissance => std::option::Option::Some(1),
                Self::ResourceDevelopment => std::option::Option::Some(2),
                Self::InitialAccess => std::option::Option::Some(5),
                Self::Execution => std::option::Option::Some(3),
                Self::Persistence => std::option::Option::Some(6),
                Self::PrivilegeEscalation => std::option::Option::Some(8),
                Self::DefenseEvasion => std::option::Option::Some(7),
                Self::CredentialAccess => std::option::Option::Some(9),
                Self::Discovery => std::option::Option::Some(10),
                Self::LateralMovement => std::option::Option::Some(11),
                Self::Collection => std::option::Option::Some(12),
                Self::CommandAndControl => std::option::Option::Some(4),
                Self::Exfiltration => std::option::Option::Some(13),
                Self::Impact => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TACTIC_UNSPECIFIED"),
                Self::Reconnaissance => std::option::Option::Some("RECONNAISSANCE"),
                Self::ResourceDevelopment => std::option::Option::Some("RESOURCE_DEVELOPMENT"),
                Self::InitialAccess => std::option::Option::Some("INITIAL_ACCESS"),
                Self::Execution => std::option::Option::Some("EXECUTION"),
                Self::Persistence => std::option::Option::Some("PERSISTENCE"),
                Self::PrivilegeEscalation => std::option::Option::Some("PRIVILEGE_ESCALATION"),
                Self::DefenseEvasion => std::option::Option::Some("DEFENSE_EVASION"),
                Self::CredentialAccess => std::option::Option::Some("CREDENTIAL_ACCESS"),
                Self::Discovery => std::option::Option::Some("DISCOVERY"),
                Self::LateralMovement => std::option::Option::Some("LATERAL_MOVEMENT"),
                Self::Collection => std::option::Option::Some("COLLECTION"),
                Self::CommandAndControl => std::option::Option::Some("COMMAND_AND_CONTROL"),
                Self::Exfiltration => std::option::Option::Some("EXFILTRATION"),
                Self::Impact => std::option::Option::Some("IMPACT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Tactic {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Tactic {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Tactic {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Reconnaissance,
                2 => Self::ResourceDevelopment,
                3 => Self::Execution,
                4 => Self::CommandAndControl,
                5 => Self::InitialAccess,
                6 => Self::Persistence,
                7 => Self::DefenseEvasion,
                8 => Self::PrivilegeEscalation,
                9 => Self::CredentialAccess,
                10 => Self::Discovery,
                11 => Self::LateralMovement,
                12 => Self::Collection,
                13 => Self::Exfiltration,
                14 => Self::Impact,
                _ => Self::UnknownValue(tactic::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Tactic {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TACTIC_UNSPECIFIED" => Self::Unspecified,
                "RECONNAISSANCE" => Self::Reconnaissance,
                "RESOURCE_DEVELOPMENT" => Self::ResourceDevelopment,
                "INITIAL_ACCESS" => Self::InitialAccess,
                "EXECUTION" => Self::Execution,
                "PERSISTENCE" => Self::Persistence,
                "PRIVILEGE_ESCALATION" => Self::PrivilegeEscalation,
                "DEFENSE_EVASION" => Self::DefenseEvasion,
                "CREDENTIAL_ACCESS" => Self::CredentialAccess,
                "DISCOVERY" => Self::Discovery,
                "LATERAL_MOVEMENT" => Self::LateralMovement,
                "COLLECTION" => Self::Collection,
                "COMMAND_AND_CONTROL" => Self::CommandAndControl,
                "EXFILTRATION" => Self::Exfiltration,
                "IMPACT" => Self::Impact,
                _ => Self::UnknownValue(tactic::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Tactic {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Reconnaissance => serializer.serialize_i32(1),
                Self::ResourceDevelopment => serializer.serialize_i32(2),
                Self::InitialAccess => serializer.serialize_i32(5),
                Self::Execution => serializer.serialize_i32(3),
                Self::Persistence => serializer.serialize_i32(6),
                Self::PrivilegeEscalation => serializer.serialize_i32(8),
                Self::DefenseEvasion => serializer.serialize_i32(7),
                Self::CredentialAccess => serializer.serialize_i32(9),
                Self::Discovery => serializer.serialize_i32(10),
                Self::LateralMovement => serializer.serialize_i32(11),
                Self::Collection => serializer.serialize_i32(12),
                Self::CommandAndControl => serializer.serialize_i32(4),
                Self::Exfiltration => serializer.serialize_i32(13),
                Self::Impact => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Tactic {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tactic>::new(
                ".google.cloud.securitycenter.v2.MitreAttack.Tactic",
            ))
        }
    }

    /// MITRE ATT&CK techniques that can be referenced by Security Command Center
    /// findings. See: <https://attack.mitre.org/techniques/enterprise/>
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Technique {
        /// Unspecified value.
        Unspecified,
        /// T1001
        DataObfuscation,
        /// T1001.002
        DataObfuscationSteganography,
        /// T1003
        OsCredentialDumping,
        /// T1003.007
        OsCredentialDumpingProcFilesystem,
        /// T1003.008
        OsCredentialDumpingEtcPasswordAndEtcShadow,
        /// T1005
        DataFromLocalSystem,
        /// T1020
        AutomatedExfiltration,
        /// T1027
        ObfuscatedFilesOrInfo,
        /// T1027.003
        Steganography,
        /// T1027.004
        CompileAfterDelivery,
        /// T1027.010
        CommandObfuscation,
        /// T1029
        ScheduledTransfer,
        /// T1033
        SystemOwnerUserDiscovery,
        /// T1036
        Masquerading,
        /// T1036.005
        MatchLegitimateNameOrLocation,
        /// T1037
        BootOrLogonInitializationScripts,
        /// T1037.005
        StartupItems,
        /// T1046
        NetworkServiceDiscovery,
        /// T1053
        ScheduledTaskJob,
        /// T1053.003
        ScheduledTaskJobCron,
        /// T1053.007
        ContainerOrchestrationJob,
        /// T1055
        ProcessInjection,
        /// T1056
        InputCapture,
        /// T1056.001
        InputCaptureKeylogging,
        /// T1057
        ProcessDiscovery,
        /// T1059
        CommandAndScriptingInterpreter,
        /// T1059.004
        UnixShell,
        /// T1059.006
        Python,
        /// T1068
        ExploitationForPrivilegeEscalation,
        /// T1069
        PermissionGroupsDiscovery,
        /// T1069.003
        CloudGroups,
        /// T1070
        IndicatorRemoval,
        /// T1070.002
        IndicatorRemovalClearLinuxOrMacSystemLogs,
        /// T1070.003
        IndicatorRemovalClearCommandHistory,
        /// T1070.004
        IndicatorRemovalFileDeletion,
        /// T1070.006
        IndicatorRemovalTimestomp,
        /// T1070.008
        IndicatorRemovalClearMailboxData,
        /// T1071
        ApplicationLayerProtocol,
        /// T1071.004
        Dns,
        /// T1072
        SoftwareDeploymentTools,
        /// T1078
        ValidAccounts,
        /// T1078.001
        DefaultAccounts,
        /// T1078.003
        LocalAccounts,
        /// T1078.004
        CloudAccounts,
        /// T1083
        FileAndDirectoryDiscovery,
        /// T1087.001
        AccountDiscoveryLocalAccount,
        /// T1090
        Proxy,
        /// T1090.002
        ExternalProxy,
        /// T1090.003
        MultiHopProxy,
        /// T1098
        AccountManipulation,
        /// T1098.001
        AdditionalCloudCredentials,
        /// T1098.003
        AdditionalCloudRoles,
        /// T1098.004
        SshAuthorizedKeys,
        /// T1098.006
        AdditionalContainerClusterRoles,
        /// T1104
        MultiStageChannels,
        /// T1105
        IngressToolTransfer,
        /// T1106
        NativeApi,
        /// T1110
        BruteForce,
        /// T1119
        AutomatedCollection,
        /// T1129
        SharedModules,
        /// T1132
        DataEncoding,
        /// T1132.001
        StandardEncoding,
        /// T1134
        AccessTokenManipulation,
        /// T1134.001
        TokenImpersonationOrTheft,
        /// T1136
        CreateAccount,
        /// T1136.001
        LocalAccount,
        /// T1140
        DeobfuscateDecodeFilesOrInfo,
        /// T1190
        ExploitPublicFacingApplication,
        /// T1195
        SupplyChainCompromise,
        /// T1195.001
        CompromiseSoftwareDependenciesAndDevelopmentTools,
        /// T1203
        ExploitationForClientExecution,
        /// T1204
        UserExecution,
        /// T1222.002
        LinuxAndMacFileAndDirectoryPermissionsModification,
        /// T1484
        DomainPolicyModification,
        /// T1485
        DataDestruction,
        /// T1486
        DataEncryptedForImpact,
        /// T1489
        ServiceStop,
        /// T1490
        InhibitSystemRecovery,
        /// T1495
        FirmwareCorruption,
        /// T1496
        ResourceHijacking,
        /// T1498
        NetworkDenialOfService,
        /// T1526
        CloudServiceDiscovery,
        /// T1528
        StealApplicationAccessToken,
        /// T1531
        AccountAccessRemoval,
        /// T1537
        TransferDataToCloudAccount,
        /// T1539
        StealWebSessionCookie,
        /// T1543
        CreateOrModifySystemProcess,
        /// T1546
        EventTriggeredExecution,
        /// T1547
        BootOrLogonAutostartExecution,
        /// T1547.006
        KernelModulesAndExtensions,
        /// T1547.009
        ShortcutModification,
        /// T1548
        AbuseElevationControlMechanism,
        /// T1548.001
        AbuseElevationControlMechanismSetuidAndSetgid,
        /// T1548.003
        AbuseElevationControlMechanismSudoAndSudoCaching,
        /// T1552
        UnsecuredCredentials,
        /// T1552.001
        CredentialsInFiles,
        /// T1552.003
        BashHistory,
        /// T1552.004
        PrivateKeys,
        /// T1553
        SubvertTrustControl,
        /// T1553.004
        InstallRootCertificate,
        /// T1554
        CompromiseHostSoftwareBinary,
        /// T1555
        CredentialsFromPasswordStores,
        /// T1556
        ModifyAuthenticationProcess,
        /// T1556.003
        PluggableAuthenticationModules,
        /// T1556.006
        MultiFactorAuthentication,
        /// T1562
        ImpairDefenses,
        /// T1562.001
        DisableOrModifyTools,
        /// T1562.006
        IndicatorBlocking,
        /// T1562.012
        DisableOrModifyLinuxAuditSystem,
        /// T1564
        HideArtifacts,
        /// T1564.001
        HiddenFilesAndDirectories,
        /// T1564.002
        HiddenUsers,
        /// T1567
        ExfiltrationOverWebService,
        /// T1567.002
        ExfiltrationToCloudStorage,
        /// T1568
        DynamicResolution,
        /// T1570
        LateralToolTransfer,
        /// T1574
        HijackExecutionFlow,
        /// T1574.006
        HijackExecutionFlowDynamicLinkerHijacking,
        /// T1578
        ModifyCloudComputeInfrastructure,
        /// T1578.001
        CreateSnapshot,
        /// T1580
        CloudInfrastructureDiscovery,
        /// T1587
        DevelopCapabilities,
        /// T1587.001
        DevelopCapabilitiesMalware,
        /// T1588
        ObtainCapabilities,
        /// T1588.001
        ObtainCapabilitiesMalware,
        /// T1588.006
        ObtainCapabilitiesVulnerabilities,
        /// T1595
        ActiveScanning,
        /// T1595.001
        ScanningIpBlocks,
        /// T1608
        StageCapabilities,
        /// T1608.001
        UploadMalware,
        /// T1609
        ContainerAdministrationCommand,
        /// T1610
        DeployContainer,
        /// T1611
        EscapeToHost,
        /// T1613
        ContainerAndResourceDiscovery,
        /// T1620
        ReflectiveCodeLoading,
        /// T1649
        StealOrForgeAuthenticationCertificates,
        /// T1657
        FinancialTheft,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Technique::value] or
        /// [Technique::name].
        UnknownValue(technique::UnknownValue),
    }

    #[doc(hidden)]
    pub mod technique {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Technique {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DataObfuscation => std::option::Option::Some(70),
                Self::DataObfuscationSteganography => std::option::Option::Some(71),
                Self::OsCredentialDumping => std::option::Option::Some(114),
                Self::OsCredentialDumpingProcFilesystem => std::option::Option::Some(115),
                Self::OsCredentialDumpingEtcPasswordAndEtcShadow => std::option::Option::Some(122),
                Self::DataFromLocalSystem => std::option::Option::Some(117),
                Self::AutomatedExfiltration => std::option::Option::Some(68),
                Self::ObfuscatedFilesOrInfo => std::option::Option::Some(72),
                Self::Steganography => std::option::Option::Some(73),
                Self::CompileAfterDelivery => std::option::Option::Some(74),
                Self::CommandObfuscation => std::option::Option::Some(75),
                Self::ScheduledTransfer => std::option::Option::Some(120),
                Self::SystemOwnerUserDiscovery => std::option::Option::Some(118),
                Self::Masquerading => std::option::Option::Some(49),
                Self::MatchLegitimateNameOrLocation => std::option::Option::Some(50),
                Self::BootOrLogonInitializationScripts => std::option::Option::Some(37),
                Self::StartupItems => std::option::Option::Some(38),
                Self::NetworkServiceDiscovery => std::option::Option::Some(32),
                Self::ScheduledTaskJob => std::option::Option::Some(89),
                Self::ScheduledTaskJobCron => std::option::Option::Some(119),
                Self::ContainerOrchestrationJob => std::option::Option::Some(90),
                Self::ProcessInjection => std::option::Option::Some(93),
                Self::InputCapture => std::option::Option::Some(103),
                Self::InputCaptureKeylogging => std::option::Option::Some(104),
                Self::ProcessDiscovery => std::option::Option::Some(56),
                Self::CommandAndScriptingInterpreter => std::option::Option::Some(6),
                Self::UnixShell => std::option::Option::Some(7),
                Self::Python => std::option::Option::Some(59),
                Self::ExploitationForPrivilegeEscalation => std::option::Option::Some(63),
                Self::PermissionGroupsDiscovery => std::option::Option::Some(18),
                Self::CloudGroups => std::option::Option::Some(19),
                Self::IndicatorRemoval => std::option::Option::Some(123),
                Self::IndicatorRemovalClearLinuxOrMacSystemLogs => std::option::Option::Some(124),
                Self::IndicatorRemovalClearCommandHistory => std::option::Option::Some(125),
                Self::IndicatorRemovalFileDeletion => std::option::Option::Some(64),
                Self::IndicatorRemovalTimestomp => std::option::Option::Some(128),
                Self::IndicatorRemovalClearMailboxData => std::option::Option::Some(126),
                Self::ApplicationLayerProtocol => std::option::Option::Some(45),
                Self::Dns => std::option::Option::Some(46),
                Self::SoftwareDeploymentTools => std::option::Option::Some(47),
                Self::ValidAccounts => std::option::Option::Some(14),
                Self::DefaultAccounts => std::option::Option::Some(35),
                Self::LocalAccounts => std::option::Option::Some(15),
                Self::CloudAccounts => std::option::Option::Some(16),
                Self::FileAndDirectoryDiscovery => std::option::Option::Some(121),
                Self::AccountDiscoveryLocalAccount => std::option::Option::Some(116),
                Self::Proxy => std::option::Option::Some(9),
                Self::ExternalProxy => std::option::Option::Some(10),
                Self::MultiHopProxy => std::option::Option::Some(11),
                Self::AccountManipulation => std::option::Option::Some(22),
                Self::AdditionalCloudCredentials => std::option::Option::Some(40),
                Self::AdditionalCloudRoles => std::option::Option::Some(67),
                Self::SshAuthorizedKeys => std::option::Option::Some(23),
                Self::AdditionalContainerClusterRoles => std::option::Option::Some(58),
                Self::MultiStageChannels => std::option::Option::Some(76),
                Self::IngressToolTransfer => std::option::Option::Some(3),
                Self::NativeApi => std::option::Option::Some(4),
                Self::BruteForce => std::option::Option::Some(44),
                Self::AutomatedCollection => std::option::Option::Some(94),
                Self::SharedModules => std::option::Option::Some(5),
                Self::DataEncoding => std::option::Option::Some(77),
                Self::StandardEncoding => std::option::Option::Some(78),
                Self::AccessTokenManipulation => std::option::Option::Some(33),
                Self::TokenImpersonationOrTheft => std::option::Option::Some(39),
                Self::CreateAccount => std::option::Option::Some(79),
                Self::LocalAccount => std::option::Option::Some(80),
                Self::DeobfuscateDecodeFilesOrInfo => std::option::Option::Some(95),
                Self::ExploitPublicFacingApplication => std::option::Option::Some(27),
                Self::SupplyChainCompromise => std::option::Option::Some(129),
                Self::CompromiseSoftwareDependenciesAndDevelopmentTools => {
                    std::option::Option::Some(130)
                }
                Self::ExploitationForClientExecution => std::option::Option::Some(134),
                Self::UserExecution => std::option::Option::Some(69),
                Self::LinuxAndMacFileAndDirectoryPermissionsModification => {
                    std::option::Option::Some(135)
                }
                Self::DomainPolicyModification => std::option::Option::Some(30),
                Self::DataDestruction => std::option::Option::Some(29),
                Self::DataEncryptedForImpact => std::option::Option::Some(132),
                Self::ServiceStop => std::option::Option::Some(52),
                Self::InhibitSystemRecovery => std::option::Option::Some(36),
                Self::FirmwareCorruption => std::option::Option::Some(81),
                Self::ResourceHijacking => std::option::Option::Some(8),
                Self::NetworkDenialOfService => std::option::Option::Some(17),
                Self::CloudServiceDiscovery => std::option::Option::Some(48),
                Self::StealApplicationAccessToken => std::option::Option::Some(42),
                Self::AccountAccessRemoval => std::option::Option::Some(51),
                Self::TransferDataToCloudAccount => std::option::Option::Some(91),
                Self::StealWebSessionCookie => std::option::Option::Some(25),
                Self::CreateOrModifySystemProcess => std::option::Option::Some(24),
                Self::EventTriggeredExecution => std::option::Option::Some(65),
                Self::BootOrLogonAutostartExecution => std::option::Option::Some(82),
                Self::KernelModulesAndExtensions => std::option::Option::Some(83),
                Self::ShortcutModification => std::option::Option::Some(127),
                Self::AbuseElevationControlMechanism => std::option::Option::Some(34),
                Self::AbuseElevationControlMechanismSetuidAndSetgid => {
                    std::option::Option::Some(136)
                }
                Self::AbuseElevationControlMechanismSudoAndSudoCaching => {
                    std::option::Option::Some(109)
                }
                Self::UnsecuredCredentials => std::option::Option::Some(13),
                Self::CredentialsInFiles => std::option::Option::Some(105),
                Self::BashHistory => std::option::Option::Some(96),
                Self::PrivateKeys => std::option::Option::Some(97),
                Self::SubvertTrustControl => std::option::Option::Some(106),
                Self::InstallRootCertificate => std::option::Option::Some(107),
                Self::CompromiseHostSoftwareBinary => std::option::Option::Some(84),
                Self::CredentialsFromPasswordStores => std::option::Option::Some(98),
                Self::ModifyAuthenticationProcess => std::option::Option::Some(28),
                Self::PluggableAuthenticationModules => std::option::Option::Some(108),
                Self::MultiFactorAuthentication => std::option::Option::Some(137),
                Self::ImpairDefenses => std::option::Option::Some(31),
                Self::DisableOrModifyTools => std::option::Option::Some(55),
                Self::IndicatorBlocking => std::option::Option::Some(110),
                Self::DisableOrModifyLinuxAuditSystem => std::option::Option::Some(111),
                Self::HideArtifacts => std::option::Option::Some(85),
                Self::HiddenFilesAndDirectories => std::option::Option::Some(86),
                Self::HiddenUsers => std::option::Option::Some(87),
                Self::ExfiltrationOverWebService => std::option::Option::Some(20),
                Self::ExfiltrationToCloudStorage => std::option::Option::Some(21),
                Self::DynamicResolution => std::option::Option::Some(12),
                Self::LateralToolTransfer => std::option::Option::Some(41),
                Self::HijackExecutionFlow => std::option::Option::Some(112),
                Self::HijackExecutionFlowDynamicLinkerHijacking => std::option::Option::Some(113),
                Self::ModifyCloudComputeInfrastructure => std::option::Option::Some(26),
                Self::CreateSnapshot => std::option::Option::Some(54),
                Self::CloudInfrastructureDiscovery => std::option::Option::Some(53),
                Self::DevelopCapabilities => std::option::Option::Some(99),
                Self::DevelopCapabilitiesMalware => std::option::Option::Some(100),
                Self::ObtainCapabilities => std::option::Option::Some(43),
                Self::ObtainCapabilitiesMalware => std::option::Option::Some(101),
                Self::ObtainCapabilitiesVulnerabilities => std::option::Option::Some(133),
                Self::ActiveScanning => std::option::Option::Some(1),
                Self::ScanningIpBlocks => std::option::Option::Some(2),
                Self::StageCapabilities => std::option::Option::Some(88),
                Self::UploadMalware => std::option::Option::Some(102),
                Self::ContainerAdministrationCommand => std::option::Option::Some(60),
                Self::DeployContainer => std::option::Option::Some(66),
                Self::EscapeToHost => std::option::Option::Some(61),
                Self::ContainerAndResourceDiscovery => std::option::Option::Some(57),
                Self::ReflectiveCodeLoading => std::option::Option::Some(92),
                Self::StealOrForgeAuthenticationCertificates => std::option::Option::Some(62),
                Self::FinancialTheft => std::option::Option::Some(131),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TECHNIQUE_UNSPECIFIED"),
                Self::DataObfuscation => std::option::Option::Some("DATA_OBFUSCATION"),
                Self::DataObfuscationSteganography => {
                    std::option::Option::Some("DATA_OBFUSCATION_STEGANOGRAPHY")
                }
                Self::OsCredentialDumping => std::option::Option::Some("OS_CREDENTIAL_DUMPING"),
                Self::OsCredentialDumpingProcFilesystem => {
                    std::option::Option::Some("OS_CREDENTIAL_DUMPING_PROC_FILESYSTEM")
                }
                Self::OsCredentialDumpingEtcPasswordAndEtcShadow => {
                    std::option::Option::Some("OS_CREDENTIAL_DUMPING_ETC_PASSWORD_AND_ETC_SHADOW")
                }
                Self::DataFromLocalSystem => std::option::Option::Some("DATA_FROM_LOCAL_SYSTEM"),
                Self::AutomatedExfiltration => std::option::Option::Some("AUTOMATED_EXFILTRATION"),
                Self::ObfuscatedFilesOrInfo => {
                    std::option::Option::Some("OBFUSCATED_FILES_OR_INFO")
                }
                Self::Steganography => std::option::Option::Some("STEGANOGRAPHY"),
                Self::CompileAfterDelivery => std::option::Option::Some("COMPILE_AFTER_DELIVERY"),
                Self::CommandObfuscation => std::option::Option::Some("COMMAND_OBFUSCATION"),
                Self::ScheduledTransfer => std::option::Option::Some("SCHEDULED_TRANSFER"),
                Self::SystemOwnerUserDiscovery => {
                    std::option::Option::Some("SYSTEM_OWNER_USER_DISCOVERY")
                }
                Self::Masquerading => std::option::Option::Some("MASQUERADING"),
                Self::MatchLegitimateNameOrLocation => {
                    std::option::Option::Some("MATCH_LEGITIMATE_NAME_OR_LOCATION")
                }
                Self::BootOrLogonInitializationScripts => {
                    std::option::Option::Some("BOOT_OR_LOGON_INITIALIZATION_SCRIPTS")
                }
                Self::StartupItems => std::option::Option::Some("STARTUP_ITEMS"),
                Self::NetworkServiceDiscovery => {
                    std::option::Option::Some("NETWORK_SERVICE_DISCOVERY")
                }
                Self::ScheduledTaskJob => std::option::Option::Some("SCHEDULED_TASK_JOB"),
                Self::ScheduledTaskJobCron => std::option::Option::Some("SCHEDULED_TASK_JOB_CRON"),
                Self::ContainerOrchestrationJob => {
                    std::option::Option::Some("CONTAINER_ORCHESTRATION_JOB")
                }
                Self::ProcessInjection => std::option::Option::Some("PROCESS_INJECTION"),
                Self::InputCapture => std::option::Option::Some("INPUT_CAPTURE"),
                Self::InputCaptureKeylogging => {
                    std::option::Option::Some("INPUT_CAPTURE_KEYLOGGING")
                }
                Self::ProcessDiscovery => std::option::Option::Some("PROCESS_DISCOVERY"),
                Self::CommandAndScriptingInterpreter => {
                    std::option::Option::Some("COMMAND_AND_SCRIPTING_INTERPRETER")
                }
                Self::UnixShell => std::option::Option::Some("UNIX_SHELL"),
                Self::Python => std::option::Option::Some("PYTHON"),
                Self::ExploitationForPrivilegeEscalation => {
                    std::option::Option::Some("EXPLOITATION_FOR_PRIVILEGE_ESCALATION")
                }
                Self::PermissionGroupsDiscovery => {
                    std::option::Option::Some("PERMISSION_GROUPS_DISCOVERY")
                }
                Self::CloudGroups => std::option::Option::Some("CLOUD_GROUPS"),
                Self::IndicatorRemoval => std::option::Option::Some("INDICATOR_REMOVAL"),
                Self::IndicatorRemovalClearLinuxOrMacSystemLogs => {
                    std::option::Option::Some("INDICATOR_REMOVAL_CLEAR_LINUX_OR_MAC_SYSTEM_LOGS")
                }
                Self::IndicatorRemovalClearCommandHistory => {
                    std::option::Option::Some("INDICATOR_REMOVAL_CLEAR_COMMAND_HISTORY")
                }
                Self::IndicatorRemovalFileDeletion => {
                    std::option::Option::Some("INDICATOR_REMOVAL_FILE_DELETION")
                }
                Self::IndicatorRemovalTimestomp => {
                    std::option::Option::Some("INDICATOR_REMOVAL_TIMESTOMP")
                }
                Self::IndicatorRemovalClearMailboxData => {
                    std::option::Option::Some("INDICATOR_REMOVAL_CLEAR_MAILBOX_DATA")
                }
                Self::ApplicationLayerProtocol => {
                    std::option::Option::Some("APPLICATION_LAYER_PROTOCOL")
                }
                Self::Dns => std::option::Option::Some("DNS"),
                Self::SoftwareDeploymentTools => {
                    std::option::Option::Some("SOFTWARE_DEPLOYMENT_TOOLS")
                }
                Self::ValidAccounts => std::option::Option::Some("VALID_ACCOUNTS"),
                Self::DefaultAccounts => std::option::Option::Some("DEFAULT_ACCOUNTS"),
                Self::LocalAccounts => std::option::Option::Some("LOCAL_ACCOUNTS"),
                Self::CloudAccounts => std::option::Option::Some("CLOUD_ACCOUNTS"),
                Self::FileAndDirectoryDiscovery => {
                    std::option::Option::Some("FILE_AND_DIRECTORY_DISCOVERY")
                }
                Self::AccountDiscoveryLocalAccount => {
                    std::option::Option::Some("ACCOUNT_DISCOVERY_LOCAL_ACCOUNT")
                }
                Self::Proxy => std::option::Option::Some("PROXY"),
                Self::ExternalProxy => std::option::Option::Some("EXTERNAL_PROXY"),
                Self::MultiHopProxy => std::option::Option::Some("MULTI_HOP_PROXY"),
                Self::AccountManipulation => std::option::Option::Some("ACCOUNT_MANIPULATION"),
                Self::AdditionalCloudCredentials => {
                    std::option::Option::Some("ADDITIONAL_CLOUD_CREDENTIALS")
                }
                Self::AdditionalCloudRoles => std::option::Option::Some("ADDITIONAL_CLOUD_ROLES"),
                Self::SshAuthorizedKeys => std::option::Option::Some("SSH_AUTHORIZED_KEYS"),
                Self::AdditionalContainerClusterRoles => {
                    std::option::Option::Some("ADDITIONAL_CONTAINER_CLUSTER_ROLES")
                }
                Self::MultiStageChannels => std::option::Option::Some("MULTI_STAGE_CHANNELS"),
                Self::IngressToolTransfer => std::option::Option::Some("INGRESS_TOOL_TRANSFER"),
                Self::NativeApi => std::option::Option::Some("NATIVE_API"),
                Self::BruteForce => std::option::Option::Some("BRUTE_FORCE"),
                Self::AutomatedCollection => std::option::Option::Some("AUTOMATED_COLLECTION"),
                Self::SharedModules => std::option::Option::Some("SHARED_MODULES"),
                Self::DataEncoding => std::option::Option::Some("DATA_ENCODING"),
                Self::StandardEncoding => std::option::Option::Some("STANDARD_ENCODING"),
                Self::AccessTokenManipulation => {
                    std::option::Option::Some("ACCESS_TOKEN_MANIPULATION")
                }
                Self::TokenImpersonationOrTheft => {
                    std::option::Option::Some("TOKEN_IMPERSONATION_OR_THEFT")
                }
                Self::CreateAccount => std::option::Option::Some("CREATE_ACCOUNT"),
                Self::LocalAccount => std::option::Option::Some("LOCAL_ACCOUNT"),
                Self::DeobfuscateDecodeFilesOrInfo => {
                    std::option::Option::Some("DEOBFUSCATE_DECODE_FILES_OR_INFO")
                }
                Self::ExploitPublicFacingApplication => {
                    std::option::Option::Some("EXPLOIT_PUBLIC_FACING_APPLICATION")
                }
                Self::SupplyChainCompromise => std::option::Option::Some("SUPPLY_CHAIN_COMPROMISE"),
                Self::CompromiseSoftwareDependenciesAndDevelopmentTools => {
                    std::option::Option::Some(
                        "COMPROMISE_SOFTWARE_DEPENDENCIES_AND_DEVELOPMENT_TOOLS",
                    )
                }
                Self::ExploitationForClientExecution => {
                    std::option::Option::Some("EXPLOITATION_FOR_CLIENT_EXECUTION")
                }
                Self::UserExecution => std::option::Option::Some("USER_EXECUTION"),
                Self::LinuxAndMacFileAndDirectoryPermissionsModification => {
                    std::option::Option::Some(
                        "LINUX_AND_MAC_FILE_AND_DIRECTORY_PERMISSIONS_MODIFICATION",
                    )
                }
                Self::DomainPolicyModification => {
                    std::option::Option::Some("DOMAIN_POLICY_MODIFICATION")
                }
                Self::DataDestruction => std::option::Option::Some("DATA_DESTRUCTION"),
                Self::DataEncryptedForImpact => {
                    std::option::Option::Some("DATA_ENCRYPTED_FOR_IMPACT")
                }
                Self::ServiceStop => std::option::Option::Some("SERVICE_STOP"),
                Self::InhibitSystemRecovery => std::option::Option::Some("INHIBIT_SYSTEM_RECOVERY"),
                Self::FirmwareCorruption => std::option::Option::Some("FIRMWARE_CORRUPTION"),
                Self::ResourceHijacking => std::option::Option::Some("RESOURCE_HIJACKING"),
                Self::NetworkDenialOfService => {
                    std::option::Option::Some("NETWORK_DENIAL_OF_SERVICE")
                }
                Self::CloudServiceDiscovery => std::option::Option::Some("CLOUD_SERVICE_DISCOVERY"),
                Self::StealApplicationAccessToken => {
                    std::option::Option::Some("STEAL_APPLICATION_ACCESS_TOKEN")
                }
                Self::AccountAccessRemoval => std::option::Option::Some("ACCOUNT_ACCESS_REMOVAL"),
                Self::TransferDataToCloudAccount => {
                    std::option::Option::Some("TRANSFER_DATA_TO_CLOUD_ACCOUNT")
                }
                Self::StealWebSessionCookie => {
                    std::option::Option::Some("STEAL_WEB_SESSION_COOKIE")
                }
                Self::CreateOrModifySystemProcess => {
                    std::option::Option::Some("CREATE_OR_MODIFY_SYSTEM_PROCESS")
                }
                Self::EventTriggeredExecution => {
                    std::option::Option::Some("EVENT_TRIGGERED_EXECUTION")
                }
                Self::BootOrLogonAutostartExecution => {
                    std::option::Option::Some("BOOT_OR_LOGON_AUTOSTART_EXECUTION")
                }
                Self::KernelModulesAndExtensions => {
                    std::option::Option::Some("KERNEL_MODULES_AND_EXTENSIONS")
                }
                Self::ShortcutModification => std::option::Option::Some("SHORTCUT_MODIFICATION"),
                Self::AbuseElevationControlMechanism => {
                    std::option::Option::Some("ABUSE_ELEVATION_CONTROL_MECHANISM")
                }
                Self::AbuseElevationControlMechanismSetuidAndSetgid => {
                    std::option::Option::Some("ABUSE_ELEVATION_CONTROL_MECHANISM_SETUID_AND_SETGID")
                }
                Self::AbuseElevationControlMechanismSudoAndSudoCaching => {
                    std::option::Option::Some(
                        "ABUSE_ELEVATION_CONTROL_MECHANISM_SUDO_AND_SUDO_CACHING",
                    )
                }
                Self::UnsecuredCredentials => std::option::Option::Some("UNSECURED_CREDENTIALS"),
                Self::CredentialsInFiles => std::option::Option::Some("CREDENTIALS_IN_FILES"),
                Self::BashHistory => std::option::Option::Some("BASH_HISTORY"),
                Self::PrivateKeys => std::option::Option::Some("PRIVATE_KEYS"),
                Self::SubvertTrustControl => std::option::Option::Some("SUBVERT_TRUST_CONTROL"),
                Self::InstallRootCertificate => {
                    std::option::Option::Some("INSTALL_ROOT_CERTIFICATE")
                }
                Self::CompromiseHostSoftwareBinary => {
                    std::option::Option::Some("COMPROMISE_HOST_SOFTWARE_BINARY")
                }
                Self::CredentialsFromPasswordStores => {
                    std::option::Option::Some("CREDENTIALS_FROM_PASSWORD_STORES")
                }
                Self::ModifyAuthenticationProcess => {
                    std::option::Option::Some("MODIFY_AUTHENTICATION_PROCESS")
                }
                Self::PluggableAuthenticationModules => {
                    std::option::Option::Some("PLUGGABLE_AUTHENTICATION_MODULES")
                }
                Self::MultiFactorAuthentication => {
                    std::option::Option::Some("MULTI_FACTOR_AUTHENTICATION")
                }
                Self::ImpairDefenses => std::option::Option::Some("IMPAIR_DEFENSES"),
                Self::DisableOrModifyTools => std::option::Option::Some("DISABLE_OR_MODIFY_TOOLS"),
                Self::IndicatorBlocking => std::option::Option::Some("INDICATOR_BLOCKING"),
                Self::DisableOrModifyLinuxAuditSystem => {
                    std::option::Option::Some("DISABLE_OR_MODIFY_LINUX_AUDIT_SYSTEM")
                }
                Self::HideArtifacts => std::option::Option::Some("HIDE_ARTIFACTS"),
                Self::HiddenFilesAndDirectories => {
                    std::option::Option::Some("HIDDEN_FILES_AND_DIRECTORIES")
                }
                Self::HiddenUsers => std::option::Option::Some("HIDDEN_USERS"),
                Self::ExfiltrationOverWebService => {
                    std::option::Option::Some("EXFILTRATION_OVER_WEB_SERVICE")
                }
                Self::ExfiltrationToCloudStorage => {
                    std::option::Option::Some("EXFILTRATION_TO_CLOUD_STORAGE")
                }
                Self::DynamicResolution => std::option::Option::Some("DYNAMIC_RESOLUTION"),
                Self::LateralToolTransfer => std::option::Option::Some("LATERAL_TOOL_TRANSFER"),
                Self::HijackExecutionFlow => std::option::Option::Some("HIJACK_EXECUTION_FLOW"),
                Self::HijackExecutionFlowDynamicLinkerHijacking => {
                    std::option::Option::Some("HIJACK_EXECUTION_FLOW_DYNAMIC_LINKER_HIJACKING")
                }
                Self::ModifyCloudComputeInfrastructure => {
                    std::option::Option::Some("MODIFY_CLOUD_COMPUTE_INFRASTRUCTURE")
                }
                Self::CreateSnapshot => std::option::Option::Some("CREATE_SNAPSHOT"),
                Self::CloudInfrastructureDiscovery => {
                    std::option::Option::Some("CLOUD_INFRASTRUCTURE_DISCOVERY")
                }
                Self::DevelopCapabilities => std::option::Option::Some("DEVELOP_CAPABILITIES"),
                Self::DevelopCapabilitiesMalware => {
                    std::option::Option::Some("DEVELOP_CAPABILITIES_MALWARE")
                }
                Self::ObtainCapabilities => std::option::Option::Some("OBTAIN_CAPABILITIES"),
                Self::ObtainCapabilitiesMalware => {
                    std::option::Option::Some("OBTAIN_CAPABILITIES_MALWARE")
                }
                Self::ObtainCapabilitiesVulnerabilities => {
                    std::option::Option::Some("OBTAIN_CAPABILITIES_VULNERABILITIES")
                }
                Self::ActiveScanning => std::option::Option::Some("ACTIVE_SCANNING"),
                Self::ScanningIpBlocks => std::option::Option::Some("SCANNING_IP_BLOCKS"),
                Self::StageCapabilities => std::option::Option::Some("STAGE_CAPABILITIES"),
                Self::UploadMalware => std::option::Option::Some("UPLOAD_MALWARE"),
                Self::ContainerAdministrationCommand => {
                    std::option::Option::Some("CONTAINER_ADMINISTRATION_COMMAND")
                }
                Self::DeployContainer => std::option::Option::Some("DEPLOY_CONTAINER"),
                Self::EscapeToHost => std::option::Option::Some("ESCAPE_TO_HOST"),
                Self::ContainerAndResourceDiscovery => {
                    std::option::Option::Some("CONTAINER_AND_RESOURCE_DISCOVERY")
                }
                Self::ReflectiveCodeLoading => std::option::Option::Some("REFLECTIVE_CODE_LOADING"),
                Self::StealOrForgeAuthenticationCertificates => {
                    std::option::Option::Some("STEAL_OR_FORGE_AUTHENTICATION_CERTIFICATES")
                }
                Self::FinancialTheft => std::option::Option::Some("FINANCIAL_THEFT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Technique {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Technique {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Technique {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ActiveScanning,
                2 => Self::ScanningIpBlocks,
                3 => Self::IngressToolTransfer,
                4 => Self::NativeApi,
                5 => Self::SharedModules,
                6 => Self::CommandAndScriptingInterpreter,
                7 => Self::UnixShell,
                8 => Self::ResourceHijacking,
                9 => Self::Proxy,
                10 => Self::ExternalProxy,
                11 => Self::MultiHopProxy,
                12 => Self::DynamicResolution,
                13 => Self::UnsecuredCredentials,
                14 => Self::ValidAccounts,
                15 => Self::LocalAccounts,
                16 => Self::CloudAccounts,
                17 => Self::NetworkDenialOfService,
                18 => Self::PermissionGroupsDiscovery,
                19 => Self::CloudGroups,
                20 => Self::ExfiltrationOverWebService,
                21 => Self::ExfiltrationToCloudStorage,
                22 => Self::AccountManipulation,
                23 => Self::SshAuthorizedKeys,
                24 => Self::CreateOrModifySystemProcess,
                25 => Self::StealWebSessionCookie,
                26 => Self::ModifyCloudComputeInfrastructure,
                27 => Self::ExploitPublicFacingApplication,
                28 => Self::ModifyAuthenticationProcess,
                29 => Self::DataDestruction,
                30 => Self::DomainPolicyModification,
                31 => Self::ImpairDefenses,
                32 => Self::NetworkServiceDiscovery,
                33 => Self::AccessTokenManipulation,
                34 => Self::AbuseElevationControlMechanism,
                35 => Self::DefaultAccounts,
                36 => Self::InhibitSystemRecovery,
                37 => Self::BootOrLogonInitializationScripts,
                38 => Self::StartupItems,
                39 => Self::TokenImpersonationOrTheft,
                40 => Self::AdditionalCloudCredentials,
                41 => Self::LateralToolTransfer,
                42 => Self::StealApplicationAccessToken,
                43 => Self::ObtainCapabilities,
                44 => Self::BruteForce,
                45 => Self::ApplicationLayerProtocol,
                46 => Self::Dns,
                47 => Self::SoftwareDeploymentTools,
                48 => Self::CloudServiceDiscovery,
                49 => Self::Masquerading,
                50 => Self::MatchLegitimateNameOrLocation,
                51 => Self::AccountAccessRemoval,
                52 => Self::ServiceStop,
                53 => Self::CloudInfrastructureDiscovery,
                54 => Self::CreateSnapshot,
                55 => Self::DisableOrModifyTools,
                56 => Self::ProcessDiscovery,
                57 => Self::ContainerAndResourceDiscovery,
                58 => Self::AdditionalContainerClusterRoles,
                59 => Self::Python,
                60 => Self::ContainerAdministrationCommand,
                61 => Self::EscapeToHost,
                62 => Self::StealOrForgeAuthenticationCertificates,
                63 => Self::ExploitationForPrivilegeEscalation,
                64 => Self::IndicatorRemovalFileDeletion,
                65 => Self::EventTriggeredExecution,
                66 => Self::DeployContainer,
                67 => Self::AdditionalCloudRoles,
                68 => Self::AutomatedExfiltration,
                69 => Self::UserExecution,
                70 => Self::DataObfuscation,
                71 => Self::DataObfuscationSteganography,
                72 => Self::ObfuscatedFilesOrInfo,
                73 => Self::Steganography,
                74 => Self::CompileAfterDelivery,
                75 => Self::CommandObfuscation,
                76 => Self::MultiStageChannels,
                77 => Self::DataEncoding,
                78 => Self::StandardEncoding,
                79 => Self::CreateAccount,
                80 => Self::LocalAccount,
                81 => Self::FirmwareCorruption,
                82 => Self::BootOrLogonAutostartExecution,
                83 => Self::KernelModulesAndExtensions,
                84 => Self::CompromiseHostSoftwareBinary,
                85 => Self::HideArtifacts,
                86 => Self::HiddenFilesAndDirectories,
                87 => Self::HiddenUsers,
                88 => Self::StageCapabilities,
                89 => Self::ScheduledTaskJob,
                90 => Self::ContainerOrchestrationJob,
                91 => Self::TransferDataToCloudAccount,
                92 => Self::ReflectiveCodeLoading,
                93 => Self::ProcessInjection,
                94 => Self::AutomatedCollection,
                95 => Self::DeobfuscateDecodeFilesOrInfo,
                96 => Self::BashHistory,
                97 => Self::PrivateKeys,
                98 => Self::CredentialsFromPasswordStores,
                99 => Self::DevelopCapabilities,
                100 => Self::DevelopCapabilitiesMalware,
                101 => Self::ObtainCapabilitiesMalware,
                102 => Self::UploadMalware,
                103 => Self::InputCapture,
                104 => Self::InputCaptureKeylogging,
                105 => Self::CredentialsInFiles,
                106 => Self::SubvertTrustControl,
                107 => Self::InstallRootCertificate,
                108 => Self::PluggableAuthenticationModules,
                109 => Self::AbuseElevationControlMechanismSudoAndSudoCaching,
                110 => Self::IndicatorBlocking,
                111 => Self::DisableOrModifyLinuxAuditSystem,
                112 => Self::HijackExecutionFlow,
                113 => Self::HijackExecutionFlowDynamicLinkerHijacking,
                114 => Self::OsCredentialDumping,
                115 => Self::OsCredentialDumpingProcFilesystem,
                116 => Self::AccountDiscoveryLocalAccount,
                117 => Self::DataFromLocalSystem,
                118 => Self::SystemOwnerUserDiscovery,
                119 => Self::ScheduledTaskJobCron,
                120 => Self::ScheduledTransfer,
                121 => Self::FileAndDirectoryDiscovery,
                122 => Self::OsCredentialDumpingEtcPasswordAndEtcShadow,
                123 => Self::IndicatorRemoval,
                124 => Self::IndicatorRemovalClearLinuxOrMacSystemLogs,
                125 => Self::IndicatorRemovalClearCommandHistory,
                126 => Self::IndicatorRemovalClearMailboxData,
                127 => Self::ShortcutModification,
                128 => Self::IndicatorRemovalTimestomp,
                129 => Self::SupplyChainCompromise,
                130 => Self::CompromiseSoftwareDependenciesAndDevelopmentTools,
                131 => Self::FinancialTheft,
                132 => Self::DataEncryptedForImpact,
                133 => Self::ObtainCapabilitiesVulnerabilities,
                134 => Self::ExploitationForClientExecution,
                135 => Self::LinuxAndMacFileAndDirectoryPermissionsModification,
                136 => Self::AbuseElevationControlMechanismSetuidAndSetgid,
                137 => Self::MultiFactorAuthentication,
                _ => Self::UnknownValue(technique::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Technique {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TECHNIQUE_UNSPECIFIED" => Self::Unspecified,
                "DATA_OBFUSCATION" => Self::DataObfuscation,
                "DATA_OBFUSCATION_STEGANOGRAPHY" => Self::DataObfuscationSteganography,
                "OS_CREDENTIAL_DUMPING" => Self::OsCredentialDumping,
                "OS_CREDENTIAL_DUMPING_PROC_FILESYSTEM" => Self::OsCredentialDumpingProcFilesystem,
                "OS_CREDENTIAL_DUMPING_ETC_PASSWORD_AND_ETC_SHADOW" => {
                    Self::OsCredentialDumpingEtcPasswordAndEtcShadow
                }
                "DATA_FROM_LOCAL_SYSTEM" => Self::DataFromLocalSystem,
                "AUTOMATED_EXFILTRATION" => Self::AutomatedExfiltration,
                "OBFUSCATED_FILES_OR_INFO" => Self::ObfuscatedFilesOrInfo,
                "STEGANOGRAPHY" => Self::Steganography,
                "COMPILE_AFTER_DELIVERY" => Self::CompileAfterDelivery,
                "COMMAND_OBFUSCATION" => Self::CommandObfuscation,
                "SCHEDULED_TRANSFER" => Self::ScheduledTransfer,
                "SYSTEM_OWNER_USER_DISCOVERY" => Self::SystemOwnerUserDiscovery,
                "MASQUERADING" => Self::Masquerading,
                "MATCH_LEGITIMATE_NAME_OR_LOCATION" => Self::MatchLegitimateNameOrLocation,
                "BOOT_OR_LOGON_INITIALIZATION_SCRIPTS" => Self::BootOrLogonInitializationScripts,
                "STARTUP_ITEMS" => Self::StartupItems,
                "NETWORK_SERVICE_DISCOVERY" => Self::NetworkServiceDiscovery,
                "SCHEDULED_TASK_JOB" => Self::ScheduledTaskJob,
                "SCHEDULED_TASK_JOB_CRON" => Self::ScheduledTaskJobCron,
                "CONTAINER_ORCHESTRATION_JOB" => Self::ContainerOrchestrationJob,
                "PROCESS_INJECTION" => Self::ProcessInjection,
                "INPUT_CAPTURE" => Self::InputCapture,
                "INPUT_CAPTURE_KEYLOGGING" => Self::InputCaptureKeylogging,
                "PROCESS_DISCOVERY" => Self::ProcessDiscovery,
                "COMMAND_AND_SCRIPTING_INTERPRETER" => Self::CommandAndScriptingInterpreter,
                "UNIX_SHELL" => Self::UnixShell,
                "PYTHON" => Self::Python,
                "EXPLOITATION_FOR_PRIVILEGE_ESCALATION" => Self::ExploitationForPrivilegeEscalation,
                "PERMISSION_GROUPS_DISCOVERY" => Self::PermissionGroupsDiscovery,
                "CLOUD_GROUPS" => Self::CloudGroups,
                "INDICATOR_REMOVAL" => Self::IndicatorRemoval,
                "INDICATOR_REMOVAL_CLEAR_LINUX_OR_MAC_SYSTEM_LOGS" => {
                    Self::IndicatorRemovalClearLinuxOrMacSystemLogs
                }
                "INDICATOR_REMOVAL_CLEAR_COMMAND_HISTORY" => {
                    Self::IndicatorRemovalClearCommandHistory
                }
                "INDICATOR_REMOVAL_FILE_DELETION" => Self::IndicatorRemovalFileDeletion,
                "INDICATOR_REMOVAL_TIMESTOMP" => Self::IndicatorRemovalTimestomp,
                "INDICATOR_REMOVAL_CLEAR_MAILBOX_DATA" => Self::IndicatorRemovalClearMailboxData,
                "APPLICATION_LAYER_PROTOCOL" => Self::ApplicationLayerProtocol,
                "DNS" => Self::Dns,
                "SOFTWARE_DEPLOYMENT_TOOLS" => Self::SoftwareDeploymentTools,
                "VALID_ACCOUNTS" => Self::ValidAccounts,
                "DEFAULT_ACCOUNTS" => Self::DefaultAccounts,
                "LOCAL_ACCOUNTS" => Self::LocalAccounts,
                "CLOUD_ACCOUNTS" => Self::CloudAccounts,
                "FILE_AND_DIRECTORY_DISCOVERY" => Self::FileAndDirectoryDiscovery,
                "ACCOUNT_DISCOVERY_LOCAL_ACCOUNT" => Self::AccountDiscoveryLocalAccount,
                "PROXY" => Self::Proxy,
                "EXTERNAL_PROXY" => Self::ExternalProxy,
                "MULTI_HOP_PROXY" => Self::MultiHopProxy,
                "ACCOUNT_MANIPULATION" => Self::AccountManipulation,
                "ADDITIONAL_CLOUD_CREDENTIALS" => Self::AdditionalCloudCredentials,
                "ADDITIONAL_CLOUD_ROLES" => Self::AdditionalCloudRoles,
                "SSH_AUTHORIZED_KEYS" => Self::SshAuthorizedKeys,
                "ADDITIONAL_CONTAINER_CLUSTER_ROLES" => Self::AdditionalContainerClusterRoles,
                "MULTI_STAGE_CHANNELS" => Self::MultiStageChannels,
                "INGRESS_TOOL_TRANSFER" => Self::IngressToolTransfer,
                "NATIVE_API" => Self::NativeApi,
                "BRUTE_FORCE" => Self::BruteForce,
                "AUTOMATED_COLLECTION" => Self::AutomatedCollection,
                "SHARED_MODULES" => Self::SharedModules,
                "DATA_ENCODING" => Self::DataEncoding,
                "STANDARD_ENCODING" => Self::StandardEncoding,
                "ACCESS_TOKEN_MANIPULATION" => Self::AccessTokenManipulation,
                "TOKEN_IMPERSONATION_OR_THEFT" => Self::TokenImpersonationOrTheft,
                "CREATE_ACCOUNT" => Self::CreateAccount,
                "LOCAL_ACCOUNT" => Self::LocalAccount,
                "DEOBFUSCATE_DECODE_FILES_OR_INFO" => Self::DeobfuscateDecodeFilesOrInfo,
                "EXPLOIT_PUBLIC_FACING_APPLICATION" => Self::ExploitPublicFacingApplication,
                "SUPPLY_CHAIN_COMPROMISE" => Self::SupplyChainCompromise,
                "COMPROMISE_SOFTWARE_DEPENDENCIES_AND_DEVELOPMENT_TOOLS" => {
                    Self::CompromiseSoftwareDependenciesAndDevelopmentTools
                }
                "EXPLOITATION_FOR_CLIENT_EXECUTION" => Self::ExploitationForClientExecution,
                "USER_EXECUTION" => Self::UserExecution,
                "LINUX_AND_MAC_FILE_AND_DIRECTORY_PERMISSIONS_MODIFICATION" => {
                    Self::LinuxAndMacFileAndDirectoryPermissionsModification
                }
                "DOMAIN_POLICY_MODIFICATION" => Self::DomainPolicyModification,
                "DATA_DESTRUCTION" => Self::DataDestruction,
                "DATA_ENCRYPTED_FOR_IMPACT" => Self::DataEncryptedForImpact,
                "SERVICE_STOP" => Self::ServiceStop,
                "INHIBIT_SYSTEM_RECOVERY" => Self::InhibitSystemRecovery,
                "FIRMWARE_CORRUPTION" => Self::FirmwareCorruption,
                "RESOURCE_HIJACKING" => Self::ResourceHijacking,
                "NETWORK_DENIAL_OF_SERVICE" => Self::NetworkDenialOfService,
                "CLOUD_SERVICE_DISCOVERY" => Self::CloudServiceDiscovery,
                "STEAL_APPLICATION_ACCESS_TOKEN" => Self::StealApplicationAccessToken,
                "ACCOUNT_ACCESS_REMOVAL" => Self::AccountAccessRemoval,
                "TRANSFER_DATA_TO_CLOUD_ACCOUNT" => Self::TransferDataToCloudAccount,
                "STEAL_WEB_SESSION_COOKIE" => Self::StealWebSessionCookie,
                "CREATE_OR_MODIFY_SYSTEM_PROCESS" => Self::CreateOrModifySystemProcess,
                "EVENT_TRIGGERED_EXECUTION" => Self::EventTriggeredExecution,
                "BOOT_OR_LOGON_AUTOSTART_EXECUTION" => Self::BootOrLogonAutostartExecution,
                "KERNEL_MODULES_AND_EXTENSIONS" => Self::KernelModulesAndExtensions,
                "SHORTCUT_MODIFICATION" => Self::ShortcutModification,
                "ABUSE_ELEVATION_CONTROL_MECHANISM" => Self::AbuseElevationControlMechanism,
                "ABUSE_ELEVATION_CONTROL_MECHANISM_SETUID_AND_SETGID" => {
                    Self::AbuseElevationControlMechanismSetuidAndSetgid
                }
                "ABUSE_ELEVATION_CONTROL_MECHANISM_SUDO_AND_SUDO_CACHING" => {
                    Self::AbuseElevationControlMechanismSudoAndSudoCaching
                }
                "UNSECURED_CREDENTIALS" => Self::UnsecuredCredentials,
                "CREDENTIALS_IN_FILES" => Self::CredentialsInFiles,
                "BASH_HISTORY" => Self::BashHistory,
                "PRIVATE_KEYS" => Self::PrivateKeys,
                "SUBVERT_TRUST_CONTROL" => Self::SubvertTrustControl,
                "INSTALL_ROOT_CERTIFICATE" => Self::InstallRootCertificate,
                "COMPROMISE_HOST_SOFTWARE_BINARY" => Self::CompromiseHostSoftwareBinary,
                "CREDENTIALS_FROM_PASSWORD_STORES" => Self::CredentialsFromPasswordStores,
                "MODIFY_AUTHENTICATION_PROCESS" => Self::ModifyAuthenticationProcess,
                "PLUGGABLE_AUTHENTICATION_MODULES" => Self::PluggableAuthenticationModules,
                "MULTI_FACTOR_AUTHENTICATION" => Self::MultiFactorAuthentication,
                "IMPAIR_DEFENSES" => Self::ImpairDefenses,
                "DISABLE_OR_MODIFY_TOOLS" => Self::DisableOrModifyTools,
                "INDICATOR_BLOCKING" => Self::IndicatorBlocking,
                "DISABLE_OR_MODIFY_LINUX_AUDIT_SYSTEM" => Self::DisableOrModifyLinuxAuditSystem,
                "HIDE_ARTIFACTS" => Self::HideArtifacts,
                "HIDDEN_FILES_AND_DIRECTORIES" => Self::HiddenFilesAndDirectories,
                "HIDDEN_USERS" => Self::HiddenUsers,
                "EXFILTRATION_OVER_WEB_SERVICE" => Self::ExfiltrationOverWebService,
                "EXFILTRATION_TO_CLOUD_STORAGE" => Self::ExfiltrationToCloudStorage,
                "DYNAMIC_RESOLUTION" => Self::DynamicResolution,
                "LATERAL_TOOL_TRANSFER" => Self::LateralToolTransfer,
                "HIJACK_EXECUTION_FLOW" => Self::HijackExecutionFlow,
                "HIJACK_EXECUTION_FLOW_DYNAMIC_LINKER_HIJACKING" => {
                    Self::HijackExecutionFlowDynamicLinkerHijacking
                }
                "MODIFY_CLOUD_COMPUTE_INFRASTRUCTURE" => Self::ModifyCloudComputeInfrastructure,
                "CREATE_SNAPSHOT" => Self::CreateSnapshot,
                "CLOUD_INFRASTRUCTURE_DISCOVERY" => Self::CloudInfrastructureDiscovery,
                "DEVELOP_CAPABILITIES" => Self::DevelopCapabilities,
                "DEVELOP_CAPABILITIES_MALWARE" => Self::DevelopCapabilitiesMalware,
                "OBTAIN_CAPABILITIES" => Self::ObtainCapabilities,
                "OBTAIN_CAPABILITIES_MALWARE" => Self::ObtainCapabilitiesMalware,
                "OBTAIN_CAPABILITIES_VULNERABILITIES" => Self::ObtainCapabilitiesVulnerabilities,
                "ACTIVE_SCANNING" => Self::ActiveScanning,
                "SCANNING_IP_BLOCKS" => Self::ScanningIpBlocks,
                "STAGE_CAPABILITIES" => Self::StageCapabilities,
                "UPLOAD_MALWARE" => Self::UploadMalware,
                "CONTAINER_ADMINISTRATION_COMMAND" => Self::ContainerAdministrationCommand,
                "DEPLOY_CONTAINER" => Self::DeployContainer,
                "ESCAPE_TO_HOST" => Self::EscapeToHost,
                "CONTAINER_AND_RESOURCE_DISCOVERY" => Self::ContainerAndResourceDiscovery,
                "REFLECTIVE_CODE_LOADING" => Self::ReflectiveCodeLoading,
                "STEAL_OR_FORGE_AUTHENTICATION_CERTIFICATES" => {
                    Self::StealOrForgeAuthenticationCertificates
                }
                "FINANCIAL_THEFT" => Self::FinancialTheft,
                _ => Self::UnknownValue(technique::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Technique {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DataObfuscation => serializer.serialize_i32(70),
                Self::DataObfuscationSteganography => serializer.serialize_i32(71),
                Self::OsCredentialDumping => serializer.serialize_i32(114),
                Self::OsCredentialDumpingProcFilesystem => serializer.serialize_i32(115),
                Self::OsCredentialDumpingEtcPasswordAndEtcShadow => serializer.serialize_i32(122),
                Self::DataFromLocalSystem => serializer.serialize_i32(117),
                Self::AutomatedExfiltration => serializer.serialize_i32(68),
                Self::ObfuscatedFilesOrInfo => serializer.serialize_i32(72),
                Self::Steganography => serializer.serialize_i32(73),
                Self::CompileAfterDelivery => serializer.serialize_i32(74),
                Self::CommandObfuscation => serializer.serialize_i32(75),
                Self::ScheduledTransfer => serializer.serialize_i32(120),
                Self::SystemOwnerUserDiscovery => serializer.serialize_i32(118),
                Self::Masquerading => serializer.serialize_i32(49),
                Self::MatchLegitimateNameOrLocation => serializer.serialize_i32(50),
                Self::BootOrLogonInitializationScripts => serializer.serialize_i32(37),
                Self::StartupItems => serializer.serialize_i32(38),
                Self::NetworkServiceDiscovery => serializer.serialize_i32(32),
                Self::ScheduledTaskJob => serializer.serialize_i32(89),
                Self::ScheduledTaskJobCron => serializer.serialize_i32(119),
                Self::ContainerOrchestrationJob => serializer.serialize_i32(90),
                Self::ProcessInjection => serializer.serialize_i32(93),
                Self::InputCapture => serializer.serialize_i32(103),
                Self::InputCaptureKeylogging => serializer.serialize_i32(104),
                Self::ProcessDiscovery => serializer.serialize_i32(56),
                Self::CommandAndScriptingInterpreter => serializer.serialize_i32(6),
                Self::UnixShell => serializer.serialize_i32(7),
                Self::Python => serializer.serialize_i32(59),
                Self::ExploitationForPrivilegeEscalation => serializer.serialize_i32(63),
                Self::PermissionGroupsDiscovery => serializer.serialize_i32(18),
                Self::CloudGroups => serializer.serialize_i32(19),
                Self::IndicatorRemoval => serializer.serialize_i32(123),
                Self::IndicatorRemovalClearLinuxOrMacSystemLogs => serializer.serialize_i32(124),
                Self::IndicatorRemovalClearCommandHistory => serializer.serialize_i32(125),
                Self::IndicatorRemovalFileDeletion => serializer.serialize_i32(64),
                Self::IndicatorRemovalTimestomp => serializer.serialize_i32(128),
                Self::IndicatorRemovalClearMailboxData => serializer.serialize_i32(126),
                Self::ApplicationLayerProtocol => serializer.serialize_i32(45),
                Self::Dns => serializer.serialize_i32(46),
                Self::SoftwareDeploymentTools => serializer.serialize_i32(47),
                Self::ValidAccounts => serializer.serialize_i32(14),
                Self::DefaultAccounts => serializer.serialize_i32(35),
                Self::LocalAccounts => serializer.serialize_i32(15),
                Self::CloudAccounts => serializer.serialize_i32(16),
                Self::FileAndDirectoryDiscovery => serializer.serialize_i32(121),
                Self::AccountDiscoveryLocalAccount => serializer.serialize_i32(116),
                Self::Proxy => serializer.serialize_i32(9),
                Self::ExternalProxy => serializer.serialize_i32(10),
                Self::MultiHopProxy => serializer.serialize_i32(11),
                Self::AccountManipulation => serializer.serialize_i32(22),
                Self::AdditionalCloudCredentials => serializer.serialize_i32(40),
                Self::AdditionalCloudRoles => serializer.serialize_i32(67),
                Self::SshAuthorizedKeys => serializer.serialize_i32(23),
                Self::AdditionalContainerClusterRoles => serializer.serialize_i32(58),
                Self::MultiStageChannels => serializer.serialize_i32(76),
                Self::IngressToolTransfer => serializer.serialize_i32(3),
                Self::NativeApi => serializer.serialize_i32(4),
                Self::BruteForce => serializer.serialize_i32(44),
                Self::AutomatedCollection => serializer.serialize_i32(94),
                Self::SharedModules => serializer.serialize_i32(5),
                Self::DataEncoding => serializer.serialize_i32(77),
                Self::StandardEncoding => serializer.serialize_i32(78),
                Self::AccessTokenManipulation => serializer.serialize_i32(33),
                Self::TokenImpersonationOrTheft => serializer.serialize_i32(39),
                Self::CreateAccount => serializer.serialize_i32(79),
                Self::LocalAccount => serializer.serialize_i32(80),
                Self::DeobfuscateDecodeFilesOrInfo => serializer.serialize_i32(95),
                Self::ExploitPublicFacingApplication => serializer.serialize_i32(27),
                Self::SupplyChainCompromise => serializer.serialize_i32(129),
                Self::CompromiseSoftwareDependenciesAndDevelopmentTools => {
                    serializer.serialize_i32(130)
                }
                Self::ExploitationForClientExecution => serializer.serialize_i32(134),
                Self::UserExecution => serializer.serialize_i32(69),
                Self::LinuxAndMacFileAndDirectoryPermissionsModification => {
                    serializer.serialize_i32(135)
                }
                Self::DomainPolicyModification => serializer.serialize_i32(30),
                Self::DataDestruction => serializer.serialize_i32(29),
                Self::DataEncryptedForImpact => serializer.serialize_i32(132),
                Self::ServiceStop => serializer.serialize_i32(52),
                Self::InhibitSystemRecovery => serializer.serialize_i32(36),
                Self::FirmwareCorruption => serializer.serialize_i32(81),
                Self::ResourceHijacking => serializer.serialize_i32(8),
                Self::NetworkDenialOfService => serializer.serialize_i32(17),
                Self::CloudServiceDiscovery => serializer.serialize_i32(48),
                Self::StealApplicationAccessToken => serializer.serialize_i32(42),
                Self::AccountAccessRemoval => serializer.serialize_i32(51),
                Self::TransferDataToCloudAccount => serializer.serialize_i32(91),
                Self::StealWebSessionCookie => serializer.serialize_i32(25),
                Self::CreateOrModifySystemProcess => serializer.serialize_i32(24),
                Self::EventTriggeredExecution => serializer.serialize_i32(65),
                Self::BootOrLogonAutostartExecution => serializer.serialize_i32(82),
                Self::KernelModulesAndExtensions => serializer.serialize_i32(83),
                Self::ShortcutModification => serializer.serialize_i32(127),
                Self::AbuseElevationControlMechanism => serializer.serialize_i32(34),
                Self::AbuseElevationControlMechanismSetuidAndSetgid => {
                    serializer.serialize_i32(136)
                }
                Self::AbuseElevationControlMechanismSudoAndSudoCaching => {
                    serializer.serialize_i32(109)
                }
                Self::UnsecuredCredentials => serializer.serialize_i32(13),
                Self::CredentialsInFiles => serializer.serialize_i32(105),
                Self::BashHistory => serializer.serialize_i32(96),
                Self::PrivateKeys => serializer.serialize_i32(97),
                Self::SubvertTrustControl => serializer.serialize_i32(106),
                Self::InstallRootCertificate => serializer.serialize_i32(107),
                Self::CompromiseHostSoftwareBinary => serializer.serialize_i32(84),
                Self::CredentialsFromPasswordStores => serializer.serialize_i32(98),
                Self::ModifyAuthenticationProcess => serializer.serialize_i32(28),
                Self::PluggableAuthenticationModules => serializer.serialize_i32(108),
                Self::MultiFactorAuthentication => serializer.serialize_i32(137),
                Self::ImpairDefenses => serializer.serialize_i32(31),
                Self::DisableOrModifyTools => serializer.serialize_i32(55),
                Self::IndicatorBlocking => serializer.serialize_i32(110),
                Self::DisableOrModifyLinuxAuditSystem => serializer.serialize_i32(111),
                Self::HideArtifacts => serializer.serialize_i32(85),
                Self::HiddenFilesAndDirectories => serializer.serialize_i32(86),
                Self::HiddenUsers => serializer.serialize_i32(87),
                Self::ExfiltrationOverWebService => serializer.serialize_i32(20),
                Self::ExfiltrationToCloudStorage => serializer.serialize_i32(21),
                Self::DynamicResolution => serializer.serialize_i32(12),
                Self::LateralToolTransfer => serializer.serialize_i32(41),
                Self::HijackExecutionFlow => serializer.serialize_i32(112),
                Self::HijackExecutionFlowDynamicLinkerHijacking => serializer.serialize_i32(113),
                Self::ModifyCloudComputeInfrastructure => serializer.serialize_i32(26),
                Self::CreateSnapshot => serializer.serialize_i32(54),
                Self::CloudInfrastructureDiscovery => serializer.serialize_i32(53),
                Self::DevelopCapabilities => serializer.serialize_i32(99),
                Self::DevelopCapabilitiesMalware => serializer.serialize_i32(100),
                Self::ObtainCapabilities => serializer.serialize_i32(43),
                Self::ObtainCapabilitiesMalware => serializer.serialize_i32(101),
                Self::ObtainCapabilitiesVulnerabilities => serializer.serialize_i32(133),
                Self::ActiveScanning => serializer.serialize_i32(1),
                Self::ScanningIpBlocks => serializer.serialize_i32(2),
                Self::StageCapabilities => serializer.serialize_i32(88),
                Self::UploadMalware => serializer.serialize_i32(102),
                Self::ContainerAdministrationCommand => serializer.serialize_i32(60),
                Self::DeployContainer => serializer.serialize_i32(66),
                Self::EscapeToHost => serializer.serialize_i32(61),
                Self::ContainerAndResourceDiscovery => serializer.serialize_i32(57),
                Self::ReflectiveCodeLoading => serializer.serialize_i32(92),
                Self::StealOrForgeAuthenticationCertificates => serializer.serialize_i32(62),
                Self::FinancialTheft => serializer.serialize_i32(131),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Technique {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Technique>::new(
                ".google.cloud.securitycenter.v2.MitreAttack.Technique",
            ))
        }
    }
}

/// A mute config is a Cloud SCC resource that contains the configuration
/// to mute create/update events of findings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MuteConfig {
    /// Identifier. This field will be ignored if provided on config creation. The
    /// following list shows some examples of the format:
    ///
    /// + `organizations/{organization}/muteConfigs/{mute_config}`
    ///
    /// `organizations/{organization}locations/{location}//muteConfigs/{mute_config}`
    ///
    /// + `folders/{folder}/muteConfigs/{mute_config}`
    /// + `folders/{folder}/locations/{location}/muteConfigs/{mute_config}`
    /// + `projects/{project}/muteConfigs/{mute_config}`
    /// + `projects/{project}/locations/{location}/muteConfigs/{mute_config}`
    pub name: std::string::String,

    /// A description of the mute config.
    pub description: std::string::String,

    /// Required. An expression that defines the filter to apply across
    /// create/update events of findings. While creating a filter string, be
    /// mindful of the scope in which the mute configuration is being created.
    /// E.g., If a filter contains project = X but is created under the project = Y
    /// scope, it might not match any findings.
    ///
    /// The following field and operator combinations are supported:
    ///
    /// * severity: `=`, `:`
    /// * category: `=`, `:`
    /// * resource.name: `=`, `:`
    /// * resource.project_name: `=`, `:`
    /// * resource.project_display_name: `=`, `:`
    /// * resource.folders.resource_folder: `=`, `:`
    /// * resource.parent_name: `=`, `:`
    /// * resource.parent_display_name: `=`, `:`
    /// * resource.type: `=`, `:`
    /// * finding_class: `=`, `:`
    /// * indicator.ip_addresses: `=`, `:`
    /// * indicator.domains: `=`, `:`
    pub filter: std::string::String,

    /// Output only. The time at which the mute config was created.
    /// This field is set by the server and will be ignored if provided on config
    /// creation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time at which the mute config was updated.
    /// This field is set by the server and will be ignored if provided on config
    /// creation or update.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Email address of the user who last edited the mute config.
    /// This field is set by the server and will be ignored if provided on config
    /// creation or update.
    pub most_recent_editor: std::string::String,

    /// Required. The type of the mute config, which determines what type of mute
    /// state the config affects. Immutable after creation.
    pub r#type: crate::model::mute_config::MuteConfigType,

    /// Optional. The expiry of the mute config. Only applicable for dynamic
    /// configs. If the expiry is set, when the config expires, it is removed from
    /// all findings.
    pub expiry_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MuteConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MuteConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MuteConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::MuteConfig::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MuteConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MuteConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MuteConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MuteConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [most_recent_editor][crate::model::MuteConfig::most_recent_editor].
    pub fn set_most_recent_editor<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.most_recent_editor = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MuteConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::mute_config::MuteConfigType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [expiry_time][crate::model::MuteConfig::expiry_time].
    pub fn set_expiry_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiry_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiry_time][crate::model::MuteConfig::expiry_time].
    pub fn set_or_clear_expiry_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiry_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MuteConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.MuteConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MuteConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __filter,
            __create_time,
            __update_time,
            __most_recent_editor,
            __type,
            __expiry_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MuteConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "filter" => Ok(__FieldTag::__filter),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "mostRecentEditor" => Ok(__FieldTag::__most_recent_editor),
                            "most_recent_editor" => Ok(__FieldTag::__most_recent_editor),
                            "type" => Ok(__FieldTag::__type),
                            "expiryTime" => Ok(__FieldTag::__expiry_time),
                            "expiry_time" => Ok(__FieldTag::__expiry_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MuteConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MuteConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__most_recent_editor => {
                            if !fields.insert(__FieldTag::__most_recent_editor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for most_recent_editor",
                                ));
                            }
                            result.most_recent_editor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::mute_config::MuteConfigType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__expiry_time => {
                            if !fields.insert(__FieldTag::__expiry_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiry_time",
                                ));
                            }
                            result.expiry_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MuteConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.most_recent_editor.is_empty() {
            state.serialize_entry("mostRecentEditor", &self.most_recent_editor)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.expiry_time.is_some() {
            state.serialize_entry("expiryTime", &self.expiry_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MuteConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MuteConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("most_recent_editor", &self.most_recent_editor);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("expiry_time", &self.expiry_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MuteConfig].
pub mod mute_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of MuteConfig.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MuteConfigType {
        /// Unused.
        Unspecified,
        /// A static mute config, which sets the static mute state of future matching
        /// findings to muted. Once the static mute state has been set, finding or
        /// config modifications will not affect the state.
        Static,
        /// A dynamic mute config, which is applied to existing and future matching
        /// findings, setting their dynamic mute state to "muted". If the config is
        /// updated or deleted, or a matching finding is updated, such that the
        /// finding doesn't match the config, the config will be removed from the
        /// finding, and the finding's dynamic mute state may become "unmuted"
        /// (unless other configs still match).
        Dynamic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MuteConfigType::value] or
        /// [MuteConfigType::name].
        UnknownValue(mute_config_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mute_config_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MuteConfigType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Static => std::option::Option::Some(1),
                Self::Dynamic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MUTE_CONFIG_TYPE_UNSPECIFIED"),
                Self::Static => std::option::Option::Some("STATIC"),
                Self::Dynamic => std::option::Option::Some("DYNAMIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MuteConfigType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MuteConfigType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MuteConfigType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Static,
                2 => Self::Dynamic,
                _ => Self::UnknownValue(mute_config_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MuteConfigType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MUTE_CONFIG_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STATIC" => Self::Static,
                "DYNAMIC" => Self::Dynamic,
                _ => Self::UnknownValue(mute_config_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MuteConfigType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Static => serializer.serialize_i32(1),
                Self::Dynamic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MuteConfigType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MuteConfigType>::new(
                ".google.cloud.securitycenter.v2.MuteConfig.MuteConfigType",
            ))
        }
    }
}

/// Contains information about a VPC network associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Network {
    /// The name of the VPC network resource, for example,
    /// `//compute.googleapis.com/projects/my-project/global/networks/my-network`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Network {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Network::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Network {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Network"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Network {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Network")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Network;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Network")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Network {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Network");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a Jupyter notebook IPYNB file, such as a [Colab Enterprise
/// notebook](https://cloud.google.com/colab/docs/introduction) file, that is
/// associated with a finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Notebook {
    /// The name of the notebook.
    pub name: std::string::String,

    /// The source notebook service, for example, "Colab Enterprise".
    pub service: std::string::String,

    /// The user ID of the latest author to modify the notebook.
    pub last_author: std::string::String,

    /// The most recent time the notebook was updated.
    pub notebook_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Notebook {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Notebook::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Notebook::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [last_author][crate::model::Notebook::last_author].
    pub fn set_last_author<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_author = v.into();
        self
    }

    /// Sets the value of [notebook_update_time][crate::model::Notebook::notebook_update_time].
    pub fn set_notebook_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.notebook_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notebook_update_time][crate::model::Notebook::notebook_update_time].
    pub fn set_or_clear_notebook_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.notebook_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Notebook {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Notebook"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Notebook {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __service,
            __last_author,
            __notebook_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Notebook")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "service" => Ok(__FieldTag::__service),
                            "lastAuthor" => Ok(__FieldTag::__last_author),
                            "last_author" => Ok(__FieldTag::__last_author),
                            "notebookUpdateTime" => Ok(__FieldTag::__notebook_update_time),
                            "notebook_update_time" => Ok(__FieldTag::__notebook_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Notebook;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Notebook")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_author => {
                            if !fields.insert(__FieldTag::__last_author) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_author",
                                ));
                            }
                            result.last_author = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notebook_update_time => {
                            if !fields.insert(__FieldTag::__notebook_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notebook_update_time",
                                ));
                            }
                            result.notebook_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Notebook {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.last_author.is_empty() {
            state.serialize_entry("lastAuthor", &self.last_author)?;
        }
        if self.notebook_update_time.is_some() {
            state.serialize_entry("notebookUpdateTime", &self.notebook_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Notebook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Notebook");
        debug_struct.field("name", &self.name);
        debug_struct.field("service", &self.service);
        debug_struct.field("last_author", &self.last_author);
        debug_struct.field("notebook_update_time", &self.notebook_update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Cloud Security Command Center (Cloud SCC) notification configs.
///
/// A notification config is a Cloud SCC resource that contains the configuration
/// to send notifications for create/update events of findings, assets and etc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NotificationConfig {
    /// Identifier. The relative resource name of this notification config. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// The following list shows some examples:
    /// +
    /// `organizations/{organization_id}/locations/{location_id}/notificationConfigs/notify_public_bucket`
    /// +
    /// `folders/{folder_id}/locations/{location_id}/notificationConfigs/notify_public_bucket`
    /// +
    /// `projects/{project_id}/locations/{location_id}/notificationConfigs/notify_public_bucket`
    pub name: std::string::String,

    /// The description of the notification config (max of 1024 characters).
    pub description: std::string::String,

    /// The Pub/Sub topic to send notifications to. Its format is
    /// "projects/[project_id]/topics/[topic]".
    pub pubsub_topic: std::string::String,

    /// Output only. The service account that needs "pubsub.topics.publish"
    /// permission to publish to the Pub/Sub topic.
    pub service_account: std::string::String,

    /// Output only. The timestamp of when the notification config was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The config for triggering notifications.
    pub notify_config: std::option::Option<crate::model::notification_config::NotifyConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NotificationConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NotificationConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [pubsub_topic][crate::model::NotificationConfig::pubsub_topic].
    pub fn set_pubsub_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pubsub_topic = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::NotificationConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NotificationConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::NotificationConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notify_config][crate::model::NotificationConfig::notify_config].
    ///
    /// Note that all the setters affecting `notify_config` are mutually
    /// exclusive.
    pub fn set_notify_config<
        T: std::convert::Into<std::option::Option<crate::model::notification_config::NotifyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notify_config = v.into();
        self
    }

    /// The value of [notify_config][crate::model::NotificationConfig::notify_config]
    /// if it holds a `StreamingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn streaming_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::notification_config::StreamingConfig>>
    {
        #[allow(unreachable_patterns)]
        self.notify_config.as_ref().and_then(|v| match v {
            crate::model::notification_config::NotifyConfig::StreamingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [notify_config][crate::model::NotificationConfig::notify_config]
    /// to hold a `StreamingConfig`.
    ///
    /// Note that all the setters affecting `notify_config` are
    /// mutually exclusive.
    pub fn set_streaming_config<
        T: std::convert::Into<std::boxed::Box<crate::model::notification_config::StreamingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.notify_config = std::option::Option::Some(
            crate::model::notification_config::NotifyConfig::StreamingConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for NotificationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.NotificationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotificationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __pubsub_topic,
            __service_account,
            __streaming_config,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "pubsubTopic" => Ok(__FieldTag::__pubsub_topic),
                            "pubsub_topic" => Ok(__FieldTag::__pubsub_topic),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "streamingConfig" => Ok(__FieldTag::__streaming_config),
                            "streaming_config" => Ok(__FieldTag::__streaming_config),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotificationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pubsub_topic => {
                            if !fields.insert(__FieldTag::__pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_topic",
                                ));
                            }
                            result.pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__streaming_config => {
                            if !fields.insert(__FieldTag::__streaming_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_config",
                                ));
                            }
                            if result.notify_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `notify_config`, a oneof with full ID .google.cloud.securitycenter.v2.NotificationConfig.streaming_config, latest field was streamingConfig",
                                ));
                            }
                            result.notify_config = std::option::Option::Some(
                                crate::model::notification_config::NotifyConfig::StreamingConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::notification_config::StreamingConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NotificationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.pubsub_topic.is_empty() {
            state.serialize_entry("pubsubTopic", &self.pubsub_topic)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if let Some(value) = self.streaming_config() {
            state.serialize_entry("streamingConfig", value)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NotificationConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("pubsub_topic", &self.pubsub_topic);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("notify_config", &self.notify_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NotificationConfig].
pub mod notification_config {
    #[allow(unused_imports)]
    use super::*;

    /// The config for streaming-based notifications, which send each event as soon
    /// as it is detected.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StreamingConfig {
        /// Expression that defines the filter to apply across create/update events
        /// of assets or findings as specified by the event type. The expression is a
        /// list of zero or more restrictions combined via logical operators `AND`
        /// and `OR`. Parentheses are supported, and `OR` has higher precedence than
        /// `AND`.
        ///
        /// Restrictions have the form `<field> <operator> <value>` and may have a
        /// `-` character in front of them to indicate negation. The fields map to
        /// those defined in the corresponding resource.
        ///
        /// The supported operators are:
        ///
        /// * `=` for all value types.
        /// * `>`, `<`, `>=`, `<=` for integer values.
        /// * `:`, meaning substring matching, for strings.
        ///
        /// The supported value types are:
        ///
        /// * string literals in quotes.
        /// * integer literals without quotes.
        /// * boolean literals `true` and `false` without quotes.
        pub filter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StreamingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::notification_config::StreamingConfig::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for StreamingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.NotificationConfig.StreamingConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StreamingConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StreamingConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "filter" => Ok(__FieldTag::__filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StreamingConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StreamingConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StreamingConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.filter.is_empty() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for StreamingConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("StreamingConfig");
            debug_struct.field("filter", &self.filter);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The config for triggering notifications.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NotifyConfig {
        /// The config for triggering streaming-based notifications.
        StreamingConfig(std::boxed::Box<crate::model::notification_config::StreamingConfig>),
    }
}

/// Cloud SCC's Notification
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NotificationMessage {
    /// Name of the notification config that generated current notification.
    pub notification_config_name: std::string::String,

    /// The Cloud resource tied to this notification's Finding.
    pub resource: std::option::Option<crate::model::Resource>,

    /// Notification Event.
    pub event: std::option::Option<crate::model::notification_message::Event>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notification_config_name][crate::model::NotificationMessage::notification_config_name].
    pub fn set_notification_config_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notification_config_name = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::NotificationMessage::resource].
    pub fn set_resource<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Resource>,
    {
        self.resource = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource][crate::model::NotificationMessage::resource].
    pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Resource>,
    {
        self.resource = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event][crate::model::NotificationMessage::event].
    ///
    /// Note that all the setters affecting `event` are mutually
    /// exclusive.
    pub fn set_event<
        T: std::convert::Into<std::option::Option<crate::model::notification_message::Event>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }

    /// The value of [event][crate::model::NotificationMessage::event]
    /// if it holds a `Finding`, `None` if the field is not set or
    /// holds a different branch.
    pub fn finding(&self) -> std::option::Option<&std::boxed::Box<crate::model::Finding>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::notification_message::Event::Finding(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [event][crate::model::NotificationMessage::event]
    /// to hold a `Finding`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_finding<T: std::convert::Into<std::boxed::Box<crate::model::Finding>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event =
            std::option::Option::Some(crate::model::notification_message::Event::Finding(v.into()));
        self
    }
}

impl wkt::message::Message for NotificationMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.NotificationMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotificationMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notification_config_name,
            __finding,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notificationConfigName" => Ok(__FieldTag::__notification_config_name),
                            "notification_config_name" => {
                                Ok(__FieldTag::__notification_config_name)
                            }
                            "finding" => Ok(__FieldTag::__finding),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotificationMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notification_config_name => {
                            if !fields.insert(__FieldTag::__notification_config_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config_name",
                                ));
                            }
                            result.notification_config_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding => {
                            if !fields.insert(__FieldTag::__finding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding",
                                ));
                            }
                            if result.event.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `event`, a oneof with full ID .google.cloud.securitycenter.v2.NotificationMessage.finding, latest field was finding",
                                ));
                            }
                            result.event =
                                std::option::Option::Some(
                                    crate::model::notification_message::Event::Finding(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Finding>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource =
                                map.next_value::<std::option::Option<crate::model::Resource>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NotificationMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.notification_config_name.is_empty() {
            state.serialize_entry("notificationConfigName", &self.notification_config_name)?;
        }
        if let Some(value) = self.finding() {
            state.serialize_entry("finding", value)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NotificationMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NotificationMessage");
        debug_struct.field("notification_config_name", &self.notification_config_name);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("event", &self.event);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NotificationMessage].
pub mod notification_message {
    #[allow(unused_imports)]
    use super::*;

    /// Notification Event.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Event {
        /// If it's a Finding based notification config, this field will be
        /// populated.
        Finding(std::boxed::Box<crate::model::Finding>),
    }
}

/// Contains information about the org policies associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OrgPolicy {
    /// Identifier. The resource name of the org policy.
    /// Example:
    /// "organizations/{organization_id}/policies/{constraint_name}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrgPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OrgPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for OrgPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.OrgPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OrgPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OrgPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OrgPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OrgPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OrgPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OrgPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OrgPolicy");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents an operating system process.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Process {
    /// The process name, as displayed in utilities like `top` and `ps`. This name
    /// can be accessed through `/proc/[pid]/comm` and changed with
    /// `prctl(PR_SET_NAME)`.
    pub name: std::string::String,

    /// File information for the process executable.
    pub binary: std::option::Option<crate::model::File>,

    /// File information for libraries loaded by the process.
    pub libraries: std::vec::Vec<crate::model::File>,

    /// When the process represents the invocation of a script, `binary` provides
    /// information about the interpreter, while `script` provides information
    /// about the script file provided to the interpreter.
    pub script: std::option::Option<crate::model::File>,

    /// Process arguments as JSON encoded strings.
    pub args: std::vec::Vec<std::string::String>,

    /// True if `args` is incomplete.
    pub arguments_truncated: bool,

    /// Process environment variables.
    pub env_variables: std::vec::Vec<crate::model::EnvironmentVariable>,

    /// True if `env_variables` is incomplete.
    pub env_variables_truncated: bool,

    /// The process ID.
    pub pid: i64,

    /// The parent process ID.
    pub parent_pid: i64,

    /// The ID of the user that executed the process. E.g. If this is the root user
    /// this will always be 0.
    pub user_id: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Process {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Process::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [binary][crate::model::Process::binary].
    pub fn set_binary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::File>,
    {
        self.binary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [binary][crate::model::Process::binary].
    pub fn set_or_clear_binary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::File>,
    {
        self.binary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [libraries][crate::model::Process::libraries].
    pub fn set_libraries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::File>,
    {
        use std::iter::Iterator;
        self.libraries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [script][crate::model::Process::script].
    pub fn set_script<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::File>,
    {
        self.script = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [script][crate::model::Process::script].
    pub fn set_or_clear_script<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::File>,
    {
        self.script = v.map(|x| x.into());
        self
    }

    /// Sets the value of [args][crate::model::Process::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [arguments_truncated][crate::model::Process::arguments_truncated].
    pub fn set_arguments_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.arguments_truncated = v.into();
        self
    }

    /// Sets the value of [env_variables][crate::model::Process::env_variables].
    pub fn set_env_variables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvironmentVariable>,
    {
        use std::iter::Iterator;
        self.env_variables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env_variables_truncated][crate::model::Process::env_variables_truncated].
    pub fn set_env_variables_truncated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.env_variables_truncated = v.into();
        self
    }

    /// Sets the value of [pid][crate::model::Process::pid].
    pub fn set_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pid = v.into();
        self
    }

    /// Sets the value of [parent_pid][crate::model::Process::parent_pid].
    pub fn set_parent_pid<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parent_pid = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::Process::user_id].
    pub fn set_user_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }
}

impl wkt::message::Message for Process {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Process"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Process {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __binary,
            __libraries,
            __script,
            __args,
            __arguments_truncated,
            __env_variables,
            __env_variables_truncated,
            __pid,
            __parent_pid,
            __user_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Process")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "binary" => Ok(__FieldTag::__binary),
                            "libraries" => Ok(__FieldTag::__libraries),
                            "script" => Ok(__FieldTag::__script),
                            "args" => Ok(__FieldTag::__args),
                            "argumentsTruncated" => Ok(__FieldTag::__arguments_truncated),
                            "arguments_truncated" => Ok(__FieldTag::__arguments_truncated),
                            "envVariables" => Ok(__FieldTag::__env_variables),
                            "env_variables" => Ok(__FieldTag::__env_variables),
                            "envVariablesTruncated" => Ok(__FieldTag::__env_variables_truncated),
                            "env_variables_truncated" => Ok(__FieldTag::__env_variables_truncated),
                            "pid" => Ok(__FieldTag::__pid),
                            "parentPid" => Ok(__FieldTag::__parent_pid),
                            "parent_pid" => Ok(__FieldTag::__parent_pid),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Process;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Process")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__binary => {
                            if !fields.insert(__FieldTag::__binary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary",
                                ));
                            }
                            result.binary =
                                map.next_value::<std::option::Option<crate::model::File>>()?;
                        }
                        __FieldTag::__libraries => {
                            if !fields.insert(__FieldTag::__libraries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for libraries",
                                ));
                            }
                            result.libraries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::File>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            result.script =
                                map.next_value::<std::option::Option<crate::model::File>>()?;
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__arguments_truncated => {
                            if !fields.insert(__FieldTag::__arguments_truncated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for arguments_truncated",
                                ));
                            }
                            result.arguments_truncated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env_variables => {
                            if !fields.insert(__FieldTag::__env_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env_variables",
                                ));
                            }
                            result.env_variables = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EnvironmentVariable>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__env_variables_truncated => {
                            if !fields.insert(__FieldTag::__env_variables_truncated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env_variables_truncated",
                                ));
                            }
                            result.env_variables_truncated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid => {
                            if !fields.insert(__FieldTag::__pid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pid = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__parent_pid => {
                            if !fields.insert(__FieldTag::__parent_pid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_pid",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.parent_pid = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.user_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Process {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.binary.is_some() {
            state.serialize_entry("binary", &self.binary)?;
        }
        if !self.libraries.is_empty() {
            state.serialize_entry("libraries", &self.libraries)?;
        }
        if self.script.is_some() {
            state.serialize_entry("script", &self.script)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !wkt::internal::is_default(&self.arguments_truncated) {
            state.serialize_entry("argumentsTruncated", &self.arguments_truncated)?;
        }
        if !self.env_variables.is_empty() {
            state.serialize_entry("envVariables", &self.env_variables)?;
        }
        if !wkt::internal::is_default(&self.env_variables_truncated) {
            state.serialize_entry("envVariablesTruncated", &self.env_variables_truncated)?;
        }
        if !wkt::internal::is_default(&self.pid) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pid", &__With(&self.pid))?;
        }
        if !wkt::internal::is_default(&self.parent_pid) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("parentPid", &__With(&self.parent_pid))?;
        }
        if !wkt::internal::is_default(&self.user_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("userId", &__With(&self.user_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Process {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Process");
        debug_struct.field("name", &self.name);
        debug_struct.field("binary", &self.binary);
        debug_struct.field("libraries", &self.libraries);
        debug_struct.field("script", &self.script);
        debug_struct.field("args", &self.args);
        debug_struct.field("arguments_truncated", &self.arguments_truncated);
        debug_struct.field("env_variables", &self.env_variables);
        debug_struct.field("env_variables_truncated", &self.env_variables_truncated);
        debug_struct.field("pid", &self.pid);
        debug_struct.field("parent_pid", &self.parent_pid);
        debug_struct.field("user_id", &self.user_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A name-value pair representing an environment variable used in an operating
/// system process.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvironmentVariable {
    /// Environment variable name as a JSON encoded string.
    pub name: std::string::String,

    /// Environment variable value as a JSON encoded string.
    pub val: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvironmentVariable {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnvironmentVariable::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [val][crate::model::EnvironmentVariable::val].
    pub fn set_val<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.val = v.into();
        self
    }
}

impl wkt::message::Message for EnvironmentVariable {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.EnvironmentVariable"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnvironmentVariable {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __val,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvironmentVariable")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "val" => Ok(__FieldTag::__val),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnvironmentVariable;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvironmentVariable")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__val => {
                            if !fields.insert(__FieldTag::__val) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for val",
                                ));
                            }
                            result.val = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnvironmentVariable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.val.is_empty() {
            state.serialize_entry("val", &self.val)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnvironmentVariable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnvironmentVariable");
        debug_struct.field("name", &self.name);
        debug_struct.field("val", &self.val);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information related to the Google Cloud resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Resource {
    /// The full resource name of the resource. See:
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    pub name: std::string::String,

    /// The human readable name of the resource.
    pub display_name: std::string::String,

    /// The full resource type of the resource.
    pub r#type: std::string::String,

    /// Indicates which cloud provider the finding is from.
    pub cloud_provider: crate::model::CloudProvider,

    /// The service or resource provider associated with the resource.
    pub service: std::string::String,

    /// The region or location of the service (if applicable).
    pub location: std::string::String,

    /// Provides the path to the resource within the resource hierarchy.
    pub resource_path: std::option::Option<crate::model::ResourcePath>,

    /// A string representation of the resource path.
    /// For Google Cloud, it has the format of
    /// `organizations/{organization_id}/folders/{folder_id}/folders/{folder_id}/projects/{project_id}`
    /// where there can be any number of folders.
    /// For AWS, it has the format of
    /// `org/{organization_id}/ou/{organizational_unit_id}/ou/{organizational_unit_id}/account/{account_id}`
    /// where there can be any number of organizational units.
    /// For Azure, it has the format of
    /// `mg/{management_group_id}/mg/{management_group_id}/subscription/{subscription_id}/rg/{resource_group_name}`
    /// where there can be any number of management groups.
    pub resource_path_string: std::string::String,

    /// The metadata associated with the cloud provider.
    pub cloud_provider_metadata: std::option::Option<crate::model::resource::CloudProviderMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Resource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Resource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Resource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Resource::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [cloud_provider][crate::model::Resource::cloud_provider].
    pub fn set_cloud_provider<T: std::convert::Into<crate::model::CloudProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Resource::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Resource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [resource_path][crate::model::Resource::resource_path].
    pub fn set_resource_path<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourcePath>,
    {
        self.resource_path = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_path][crate::model::Resource::resource_path].
    pub fn set_or_clear_resource_path<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourcePath>,
    {
        self.resource_path = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_path_string][crate::model::Resource::resource_path_string].
    pub fn set_resource_path_string<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_path_string = v.into();
        self
    }

    /// Sets the value of [cloud_provider_metadata][crate::model::Resource::cloud_provider_metadata].
    ///
    /// Note that all the setters affecting `cloud_provider_metadata` are mutually
    /// exclusive.
    pub fn set_cloud_provider_metadata<
        T: std::convert::Into<std::option::Option<crate::model::resource::CloudProviderMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider_metadata = v.into();
        self
    }

    /// The value of [cloud_provider_metadata][crate::model::Resource::cloud_provider_metadata]
    /// if it holds a `GcpMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_metadata(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcpMetadata>> {
        #[allow(unreachable_patterns)]
        self.cloud_provider_metadata.as_ref().and_then(|v| match v {
            crate::model::resource::CloudProviderMetadata::GcpMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cloud_provider_metadata][crate::model::Resource::cloud_provider_metadata]
    /// to hold a `GcpMetadata`.
    ///
    /// Note that all the setters affecting `cloud_provider_metadata` are
    /// mutually exclusive.
    pub fn set_gcp_metadata<T: std::convert::Into<std::boxed::Box<crate::model::GcpMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider_metadata = std::option::Option::Some(
            crate::model::resource::CloudProviderMetadata::GcpMetadata(v.into()),
        );
        self
    }

    /// The value of [cloud_provider_metadata][crate::model::Resource::cloud_provider_metadata]
    /// if it holds a `AwsMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_metadata(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsMetadata>> {
        #[allow(unreachable_patterns)]
        self.cloud_provider_metadata.as_ref().and_then(|v| match v {
            crate::model::resource::CloudProviderMetadata::AwsMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cloud_provider_metadata][crate::model::Resource::cloud_provider_metadata]
    /// to hold a `AwsMetadata`.
    ///
    /// Note that all the setters affecting `cloud_provider_metadata` are
    /// mutually exclusive.
    pub fn set_aws_metadata<T: std::convert::Into<std::boxed::Box<crate::model::AwsMetadata>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider_metadata = std::option::Option::Some(
            crate::model::resource::CloudProviderMetadata::AwsMetadata(v.into()),
        );
        self
    }

    /// The value of [cloud_provider_metadata][crate::model::Resource::cloud_provider_metadata]
    /// if it holds a `AzureMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureMetadata>> {
        #[allow(unreachable_patterns)]
        self.cloud_provider_metadata.as_ref().and_then(|v| match v {
            crate::model::resource::CloudProviderMetadata::AzureMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cloud_provider_metadata][crate::model::Resource::cloud_provider_metadata]
    /// to hold a `AzureMetadata`.
    ///
    /// Note that all the setters affecting `cloud_provider_metadata` are
    /// mutually exclusive.
    pub fn set_azure_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider_metadata = std::option::Option::Some(
            crate::model::resource::CloudProviderMetadata::AzureMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Resource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Resource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Resource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __type,
            __cloud_provider,
            __service,
            __location,
            __gcp_metadata,
            __aws_metadata,
            __azure_metadata,
            __resource_path,
            __resource_path_string,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Resource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "type" => Ok(__FieldTag::__type),
                            "cloudProvider" => Ok(__FieldTag::__cloud_provider),
                            "cloud_provider" => Ok(__FieldTag::__cloud_provider),
                            "service" => Ok(__FieldTag::__service),
                            "location" => Ok(__FieldTag::__location),
                            "gcpMetadata" => Ok(__FieldTag::__gcp_metadata),
                            "gcp_metadata" => Ok(__FieldTag::__gcp_metadata),
                            "awsMetadata" => Ok(__FieldTag::__aws_metadata),
                            "aws_metadata" => Ok(__FieldTag::__aws_metadata),
                            "azureMetadata" => Ok(__FieldTag::__azure_metadata),
                            "azure_metadata" => Ok(__FieldTag::__azure_metadata),
                            "resourcePath" => Ok(__FieldTag::__resource_path),
                            "resource_path" => Ok(__FieldTag::__resource_path),
                            "resourcePathString" => Ok(__FieldTag::__resource_path_string),
                            "resource_path_string" => Ok(__FieldTag::__resource_path_string),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Resource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Resource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_provider => {
                            if !fields.insert(__FieldTag::__cloud_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_provider",
                                ));
                            }
                            result.cloud_provider = map
                                .next_value::<std::option::Option<crate::model::CloudProvider>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_metadata => {
                            if !fields.insert(__FieldTag::__gcp_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_metadata",
                                ));
                            }
                            if result.cloud_provider_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cloud_provider_metadata`, a oneof with full ID .google.cloud.securitycenter.v2.Resource.gcp_metadata, latest field was gcpMetadata",
                                ));
                            }
                            result.cloud_provider_metadata = std::option::Option::Some(
                                crate::model::resource::CloudProviderMetadata::GcpMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcpMetadata>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_metadata => {
                            if !fields.insert(__FieldTag::__aws_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_metadata",
                                ));
                            }
                            if result.cloud_provider_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cloud_provider_metadata`, a oneof with full ID .google.cloud.securitycenter.v2.Resource.aws_metadata, latest field was awsMetadata",
                                ));
                            }
                            result.cloud_provider_metadata = std::option::Option::Some(
                                crate::model::resource::CloudProviderMetadata::AwsMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsMetadata>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure_metadata => {
                            if !fields.insert(__FieldTag::__azure_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_metadata",
                                ));
                            }
                            if result.cloud_provider_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cloud_provider_metadata`, a oneof with full ID .google.cloud.securitycenter.v2.Resource.azure_metadata, latest field was azureMetadata",
                                ));
                            }
                            result.cloud_provider_metadata = std::option::Option::Some(
                                crate::model::resource::CloudProviderMetadata::AzureMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureMetadata>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__resource_path => {
                            if !fields.insert(__FieldTag::__resource_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_path",
                                ));
                            }
                            result.resource_path = map
                                .next_value::<std::option::Option<crate::model::ResourcePath>>()?;
                        }
                        __FieldTag::__resource_path_string => {
                            if !fields.insert(__FieldTag::__resource_path_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_path_string",
                                ));
                            }
                            result.resource_path_string = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Resource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.cloud_provider) {
            state.serialize_entry("cloudProvider", &self.cloud_provider)?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if let Some(value) = self.gcp_metadata() {
            state.serialize_entry("gcpMetadata", value)?;
        }
        if let Some(value) = self.aws_metadata() {
            state.serialize_entry("awsMetadata", value)?;
        }
        if let Some(value) = self.azure_metadata() {
            state.serialize_entry("azureMetadata", value)?;
        }
        if self.resource_path.is_some() {
            state.serialize_entry("resourcePath", &self.resource_path)?;
        }
        if !self.resource_path_string.is_empty() {
            state.serialize_entry("resourcePathString", &self.resource_path_string)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Resource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Resource");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("cloud_provider", &self.cloud_provider);
        debug_struct.field("service", &self.service);
        debug_struct.field("location", &self.location);
        debug_struct.field("resource_path", &self.resource_path);
        debug_struct.field("resource_path_string", &self.resource_path_string);
        debug_struct.field("cloud_provider_metadata", &self.cloud_provider_metadata);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Resource].
pub mod resource {
    #[allow(unused_imports)]
    use super::*;

    /// The metadata associated with the cloud provider.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudProviderMetadata {
        /// The GCP metadata associated with the finding.
        GcpMetadata(std::boxed::Box<crate::model::GcpMetadata>),
        /// The AWS metadata associated with the finding.
        AwsMetadata(std::boxed::Box<crate::model::AwsMetadata>),
        /// The Azure metadata associated with the finding.
        AzureMetadata(std::boxed::Box<crate::model::AzureMetadata>),
    }
}

/// Google Cloud metadata associated with the resource. Only applicable if the
/// finding's cloud provider is Google Cloud.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcpMetadata {
    /// The full resource name of project that the resource belongs to.
    pub project: std::string::String,

    /// The project ID that the resource belongs to.
    pub project_display_name: std::string::String,

    /// The full resource name of resource's parent.
    pub parent: std::string::String,

    /// The human readable name of resource's parent.
    pub parent_display_name: std::string::String,

    /// Output only. Contains a Folder message for each folder in the assets
    /// ancestry. The first folder is the deepest nested folder, and the last
    /// folder is the folder directly under the Organization.
    pub folders: std::vec::Vec<crate::model::Folder>,

    /// The name of the organization that the resource belongs to.
    pub organization: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GcpMetadata::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [project_display_name][crate::model::GcpMetadata::project_display_name].
    pub fn set_project_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_display_name = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::GcpMetadata::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [parent_display_name][crate::model::GcpMetadata::parent_display_name].
    pub fn set_parent_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_display_name = v.into();
        self
    }

    /// Sets the value of [folders][crate::model::GcpMetadata::folders].
    pub fn set_folders<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Folder>,
    {
        use std::iter::Iterator;
        self.folders = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [organization][crate::model::GcpMetadata::organization].
    pub fn set_organization<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.organization = v.into();
        self
    }
}

impl wkt::message::Message for GcpMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GcpMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcpMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __project_display_name,
            __parent,
            __parent_display_name,
            __folders,
            __organization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "projectDisplayName" => Ok(__FieldTag::__project_display_name),
                            "project_display_name" => Ok(__FieldTag::__project_display_name),
                            "parent" => Ok(__FieldTag::__parent),
                            "parentDisplayName" => Ok(__FieldTag::__parent_display_name),
                            "parent_display_name" => Ok(__FieldTag::__parent_display_name),
                            "folders" => Ok(__FieldTag::__folders),
                            "organization" => Ok(__FieldTag::__organization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcpMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_display_name => {
                            if !fields.insert(__FieldTag::__project_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_display_name",
                                ));
                            }
                            result.project_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_display_name => {
                            if !fields.insert(__FieldTag::__parent_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_display_name",
                                ));
                            }
                            result.parent_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__folders => {
                            if !fields.insert(__FieldTag::__folders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folders",
                                ));
                            }
                            result.folders = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Folder>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__organization => {
                            if !fields.insert(__FieldTag::__organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization",
                                ));
                            }
                            result.organization = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcpMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.project_display_name.is_empty() {
            state.serialize_entry("projectDisplayName", &self.project_display_name)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.parent_display_name.is_empty() {
            state.serialize_entry("parentDisplayName", &self.parent_display_name)?;
        }
        if !self.folders.is_empty() {
            state.serialize_entry("folders", &self.folders)?;
        }
        if !self.organization.is_empty() {
            state.serialize_entry("organization", &self.organization)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcpMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcpMetadata");
        debug_struct.field("project", &self.project);
        debug_struct.field("project_display_name", &self.project_display_name);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("parent_display_name", &self.parent_display_name);
        debug_struct.field("folders", &self.folders);
        debug_struct.field("organization", &self.organization);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AWS metadata associated with the resource, only applicable if the finding's
/// cloud provider is Amazon Web Services.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsMetadata {
    /// The AWS organization associated with the resource.
    pub organization: std::option::Option<crate::model::aws_metadata::AwsOrganization>,

    /// A list of AWS organizational units associated with the resource, ordered
    /// from lowest level (closest to the account) to highest level.
    pub organizational_units: std::vec::Vec<crate::model::aws_metadata::AwsOrganizationalUnit>,

    /// The AWS account associated with the resource.
    pub account: std::option::Option<crate::model::aws_metadata::AwsAccount>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [organization][crate::model::AwsMetadata::organization].
    pub fn set_organization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::aws_metadata::AwsOrganization>,
    {
        self.organization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [organization][crate::model::AwsMetadata::organization].
    pub fn set_or_clear_organization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::aws_metadata::AwsOrganization>,
    {
        self.organization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [organizational_units][crate::model::AwsMetadata::organizational_units].
    pub fn set_organizational_units<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::aws_metadata::AwsOrganizationalUnit>,
    {
        use std::iter::Iterator;
        self.organizational_units = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [account][crate::model::AwsMetadata::account].
    pub fn set_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::aws_metadata::AwsAccount>,
    {
        self.account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account][crate::model::AwsMetadata::account].
    pub fn set_or_clear_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::aws_metadata::AwsAccount>,
    {
        self.account = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AwsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.AwsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __organization,
            __organizational_units,
            __account,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "organization" => Ok(__FieldTag::__organization),
                            "organizationalUnits" => Ok(__FieldTag::__organizational_units),
                            "organizational_units" => Ok(__FieldTag::__organizational_units),
                            "account" => Ok(__FieldTag::__account),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__organization => {
                            if !fields.insert(__FieldTag::__organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization",
                                ));
                            }
                            result.organization =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_metadata::AwsOrganization,
                                >>()?;
                        }
                        __FieldTag::__organizational_units => {
                            if !fields.insert(__FieldTag::__organizational_units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organizational_units",
                                ));
                            }
                            result.organizational_units = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::aws_metadata::AwsOrganizationalUnit,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account => {
                            if !fields.insert(__FieldTag::__account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account",
                                ));
                            }
                            result.account = map.next_value::<std::option::Option<crate::model::aws_metadata::AwsAccount>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.organization.is_some() {
            state.serialize_entry("organization", &self.organization)?;
        }
        if !self.organizational_units.is_empty() {
            state.serialize_entry("organizationalUnits", &self.organizational_units)?;
        }
        if self.account.is_some() {
            state.serialize_entry("account", &self.account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsMetadata");
        debug_struct.field("organization", &self.organization);
        debug_struct.field("organizational_units", &self.organizational_units);
        debug_struct.field("account", &self.account);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsMetadata].
pub mod aws_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// An organization is a collection of accounts that are centrally managed
    /// together using consolidated billing, organized hierarchically with
    /// organizational units (OUs), and controlled with policies.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsOrganization {
        /// The unique identifier (ID) for the organization. The regex pattern for an
        /// organization ID string requires "o-" followed by from 10 to 32 lowercase
        /// letters or digits.
        pub id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsOrganization {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::aws_metadata::AwsOrganization::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsOrganization {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AwsMetadata.AwsOrganization"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AwsOrganization {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AwsOrganization")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AwsOrganization;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AwsOrganization")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AwsOrganization {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AwsOrganization {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AwsOrganization");
            debug_struct.field("id", &self.id);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An Organizational Unit (OU) is a container of AWS accounts within a root of
    /// an organization. Policies that are attached to an OU apply to all accounts
    /// contained in that OU and in any child OUs.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsOrganizationalUnit {
        /// The unique identifier (ID) associated with this OU. The regex pattern for
        /// an organizational unit ID string requires "ou-" followed by from 4 to 32
        /// lowercase letters or digits (the ID of the root that contains the OU).
        /// This string is followed by a second "-" dash and from 8 to 32 additional
        /// lowercase letters or digits. For example, "ou-ab12-cd34ef56".
        pub id: std::string::String,

        /// The friendly name of the OU.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsOrganizationalUnit {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::aws_metadata::AwsOrganizationalUnit::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::aws_metadata::AwsOrganizationalUnit::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsOrganizationalUnit {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AwsMetadata.AwsOrganizationalUnit"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AwsOrganizationalUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AwsOrganizationalUnit")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AwsOrganizationalUnit;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AwsOrganizationalUnit")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AwsOrganizationalUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AwsOrganizationalUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AwsOrganizationalUnit");
            debug_struct.field("id", &self.id);
            debug_struct.field("name", &self.name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An AWS account that is a member of an organization.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsAccount {
        /// The unique identifier (ID) of the account, containing exactly 12 digits.
        pub id: std::string::String,

        /// The friendly name of this account.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsAccount {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::aws_metadata::AwsAccount::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::aws_metadata::AwsAccount::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsAccount {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AwsMetadata.AwsAccount"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AwsAccount {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AwsAccount")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AwsAccount;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AwsAccount")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AwsAccount {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AwsAccount {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AwsAccount");
            debug_struct.field("id", &self.id);
            debug_struct.field("name", &self.name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Azure metadata associated with the resource, only applicable if the finding's
/// cloud provider is Microsoft Azure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureMetadata {
    /// A list of Azure management groups associated with the resource, ordered
    /// from lowest level (closest to the subscription) to highest level.
    pub management_groups: std::vec::Vec<crate::model::azure_metadata::AzureManagementGroup>,

    /// The Azure subscription associated with the resource.
    pub subscription: std::option::Option<crate::model::azure_metadata::AzureSubscription>,

    /// The Azure resource group associated with the resource.
    pub resource_group: std::option::Option<crate::model::azure_metadata::AzureResourceGroup>,

    /// The Azure Entra tenant associated with the resource.
    pub tenant: std::option::Option<crate::model::azure_metadata::AzureTenant>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [management_groups][crate::model::AzureMetadata::management_groups].
    pub fn set_management_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::azure_metadata::AzureManagementGroup>,
    {
        use std::iter::Iterator;
        self.management_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subscription][crate::model::AzureMetadata::subscription].
    pub fn set_subscription<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::azure_metadata::AzureSubscription>,
    {
        self.subscription = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subscription][crate::model::AzureMetadata::subscription].
    pub fn set_or_clear_subscription<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::azure_metadata::AzureSubscription>,
    {
        self.subscription = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_group][crate::model::AzureMetadata::resource_group].
    pub fn set_resource_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::azure_metadata::AzureResourceGroup>,
    {
        self.resource_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_group][crate::model::AzureMetadata::resource_group].
    pub fn set_or_clear_resource_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::azure_metadata::AzureResourceGroup>,
    {
        self.resource_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tenant][crate::model::AzureMetadata::tenant].
    pub fn set_tenant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::azure_metadata::AzureTenant>,
    {
        self.tenant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tenant][crate::model::AzureMetadata::tenant].
    pub fn set_or_clear_tenant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::azure_metadata::AzureTenant>,
    {
        self.tenant = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AzureMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.AzureMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __management_groups,
            __subscription,
            __resource_group,
            __tenant,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "managementGroups" => Ok(__FieldTag::__management_groups),
                            "management_groups" => Ok(__FieldTag::__management_groups),
                            "subscription" => Ok(__FieldTag::__subscription),
                            "resourceGroup" => Ok(__FieldTag::__resource_group),
                            "resource_group" => Ok(__FieldTag::__resource_group),
                            "tenant" => Ok(__FieldTag::__tenant),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__management_groups => {
                            if !fields.insert(__FieldTag::__management_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management_groups",
                                ));
                            }
                            result.management_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::azure_metadata::AzureManagementGroup,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map.next_value::<std::option::Option<
                                crate::model::azure_metadata::AzureSubscription,
                            >>()?;
                        }
                        __FieldTag::__resource_group => {
                            if !fields.insert(__FieldTag::__resource_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_group",
                                ));
                            }
                            result.resource_group = map.next_value::<std::option::Option<
                                crate::model::azure_metadata::AzureResourceGroup,
                            >>()?;
                        }
                        __FieldTag::__tenant => {
                            if !fields.insert(__FieldTag::__tenant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant",
                                ));
                            }
                            result.tenant = map.next_value::<std::option::Option<crate::model::azure_metadata::AzureTenant>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.management_groups.is_empty() {
            state.serialize_entry("managementGroups", &self.management_groups)?;
        }
        if self.subscription.is_some() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if self.resource_group.is_some() {
            state.serialize_entry("resourceGroup", &self.resource_group)?;
        }
        if self.tenant.is_some() {
            state.serialize_entry("tenant", &self.tenant)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureMetadata");
        debug_struct.field("management_groups", &self.management_groups);
        debug_struct.field("subscription", &self.subscription);
        debug_struct.field("resource_group", &self.resource_group);
        debug_struct.field("tenant", &self.tenant);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AzureMetadata].
pub mod azure_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an Azure management group.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AzureManagementGroup {
        /// The UUID of the Azure management group, for example,
        /// `20000000-0001-0000-0000-000000000000`.
        pub id: std::string::String,

        /// The display name of the Azure management group.
        pub display_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AzureManagementGroup {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::azure_metadata::AzureManagementGroup::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::azure_metadata::AzureManagementGroup::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for AzureManagementGroup {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AzureMetadata.AzureManagementGroup"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AzureManagementGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __display_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AzureManagementGroup")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AzureManagementGroup;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AzureManagementGroup")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AzureManagementGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AzureManagementGroup {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AzureManagementGroup");
            debug_struct.field("id", &self.id);
            debug_struct.field("display_name", &self.display_name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents an Azure subscription.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AzureSubscription {
        /// The UUID of the Azure subscription, for example,
        /// `291bba3f-e0a5-47bc-a099-3bdcb2a50a05`.
        pub id: std::string::String,

        /// The display name of the Azure subscription.
        pub display_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AzureSubscription {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::azure_metadata::AzureSubscription::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::azure_metadata::AzureSubscription::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for AzureSubscription {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AzureMetadata.AzureSubscription"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AzureSubscription {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __display_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AzureSubscription")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AzureSubscription;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AzureSubscription")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AzureSubscription {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AzureSubscription {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AzureSubscription");
            debug_struct.field("id", &self.id);
            debug_struct.field("display_name", &self.display_name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents an Azure resource group.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AzureResourceGroup {
        /// The ID of the Azure resource group.
        pub id: std::string::String,

        /// The name of the Azure resource group. This is not a UUID.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AzureResourceGroup {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::azure_metadata::AzureResourceGroup::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::azure_metadata::AzureResourceGroup::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    impl wkt::message::Message for AzureResourceGroup {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AzureMetadata.AzureResourceGroup"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AzureResourceGroup {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AzureResourceGroup")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AzureResourceGroup;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AzureResourceGroup")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AzureResourceGroup {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AzureResourceGroup {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AzureResourceGroup");
            debug_struct.field("id", &self.id);
            debug_struct.field("name", &self.name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents a Microsoft Entra tenant.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AzureTenant {
        /// The ID of the Microsoft Entra tenant, for example,
        /// "a11aaa11-aa11-1aa1-11aa-1aaa11a".
        pub id: std::string::String,

        /// The display name of the Azure tenant.
        pub display_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AzureTenant {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::azure_metadata::AzureTenant::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::azure_metadata::AzureTenant::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for AzureTenant {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.AzureMetadata.AzureTenant"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AzureTenant {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __display_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AzureTenant")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AzureTenant;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AzureTenant")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AzureTenant {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AzureTenant {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AzureTenant");
            debug_struct.field("id", &self.id);
            debug_struct.field("display_name", &self.display_name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Represents the path of resources leading up to the resource this finding is
/// about.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourcePath {
    /// The list of nodes that make the up resource path, ordered from lowest
    /// level to highest level.
    pub nodes: std::vec::Vec<crate::model::resource_path::ResourcePathNode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourcePath {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nodes][crate::model::ResourcePath::nodes].
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::resource_path::ResourcePathNode>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ResourcePath {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ResourcePath"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourcePath {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __nodes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourcePath")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodes" => Ok(__FieldTag::__nodes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourcePath;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourcePath")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__nodes => {
                            if !fields.insert(__FieldTag::__nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodes",
                                ));
                            }
                            result.nodes = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::resource_path::ResourcePathNode>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourcePath {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.nodes.is_empty() {
            state.serialize_entry("nodes", &self.nodes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourcePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourcePath");
        debug_struct.field("nodes", &self.nodes);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ResourcePath].
pub mod resource_path {
    #[allow(unused_imports)]
    use super::*;

    /// A node within the resource path. Each node represents a resource within the
    /// resource hierarchy.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourcePathNode {
        /// The type of resource this node represents.
        pub node_type: crate::model::resource_path::ResourcePathNodeType,

        /// The ID of the resource this node represents.
        pub id: std::string::String,

        /// The display name of the resource this node represents.
        pub display_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourcePathNode {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node_type][crate::model::resource_path::ResourcePathNode::node_type].
        pub fn set_node_type<
            T: std::convert::Into<crate::model::resource_path::ResourcePathNodeType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.node_type = v.into();
            self
        }

        /// Sets the value of [id][crate::model::resource_path::ResourcePathNode::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::resource_path::ResourcePathNode::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourcePathNode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.ResourcePath.ResourcePathNode"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourcePathNode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __node_type,
                __id,
                __display_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourcePathNode")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "nodeType" => Ok(__FieldTag::__node_type),
                                "node_type" => Ok(__FieldTag::__node_type),
                                "id" => Ok(__FieldTag::__id),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourcePathNode;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourcePathNode")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__node_type => {
                                if !fields.insert(__FieldTag::__node_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node_type",
                                    ));
                                }
                                result.node_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::resource_path::ResourcePathNodeType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourcePathNode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.node_type) {
                state.serialize_entry("nodeType", &self.node_type)?;
            }
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ResourcePathNode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ResourcePathNode");
            debug_struct.field("node_type", &self.node_type);
            debug_struct.field("id", &self.id);
            debug_struct.field("display_name", &self.display_name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The type of resource the node represents.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourcePathNodeType {
        /// Node type is unspecified.
        Unspecified,
        /// The node represents a Google Cloud organization.
        GcpOrganization,
        /// The node represents a Google Cloud folder.
        GcpFolder,
        /// The node represents a Google Cloud project.
        GcpProject,
        /// The node represents an AWS organization.
        AwsOrganization,
        /// The node represents an AWS organizational unit.
        AwsOrganizationalUnit,
        /// The node represents an AWS account.
        AwsAccount,
        /// The node represents an Azure management group.
        AzureManagementGroup,
        /// The node represents an Azure subscription.
        AzureSubscription,
        /// The node represents an Azure resource group.
        AzureResourceGroup,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResourcePathNodeType::value] or
        /// [ResourcePathNodeType::name].
        UnknownValue(resource_path_node_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod resource_path_node_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResourcePathNodeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GcpOrganization => std::option::Option::Some(1),
                Self::GcpFolder => std::option::Option::Some(2),
                Self::GcpProject => std::option::Option::Some(3),
                Self::AwsOrganization => std::option::Option::Some(4),
                Self::AwsOrganizationalUnit => std::option::Option::Some(5),
                Self::AwsAccount => std::option::Option::Some(6),
                Self::AzureManagementGroup => std::option::Option::Some(7),
                Self::AzureSubscription => std::option::Option::Some(8),
                Self::AzureResourceGroup => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("RESOURCE_PATH_NODE_TYPE_UNSPECIFIED")
                }
                Self::GcpOrganization => std::option::Option::Some("GCP_ORGANIZATION"),
                Self::GcpFolder => std::option::Option::Some("GCP_FOLDER"),
                Self::GcpProject => std::option::Option::Some("GCP_PROJECT"),
                Self::AwsOrganization => std::option::Option::Some("AWS_ORGANIZATION"),
                Self::AwsOrganizationalUnit => std::option::Option::Some("AWS_ORGANIZATIONAL_UNIT"),
                Self::AwsAccount => std::option::Option::Some("AWS_ACCOUNT"),
                Self::AzureManagementGroup => std::option::Option::Some("AZURE_MANAGEMENT_GROUP"),
                Self::AzureSubscription => std::option::Option::Some("AZURE_SUBSCRIPTION"),
                Self::AzureResourceGroup => std::option::Option::Some("AZURE_RESOURCE_GROUP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResourcePathNodeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResourcePathNodeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResourcePathNodeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GcpOrganization,
                2 => Self::GcpFolder,
                3 => Self::GcpProject,
                4 => Self::AwsOrganization,
                5 => Self::AwsOrganizationalUnit,
                6 => Self::AwsAccount,
                7 => Self::AzureManagementGroup,
                8 => Self::AzureSubscription,
                9 => Self::AzureResourceGroup,
                _ => Self::UnknownValue(resource_path_node_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResourcePathNodeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESOURCE_PATH_NODE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GCP_ORGANIZATION" => Self::GcpOrganization,
                "GCP_FOLDER" => Self::GcpFolder,
                "GCP_PROJECT" => Self::GcpProject,
                "AWS_ORGANIZATION" => Self::AwsOrganization,
                "AWS_ORGANIZATIONAL_UNIT" => Self::AwsOrganizationalUnit,
                "AWS_ACCOUNT" => Self::AwsAccount,
                "AZURE_MANAGEMENT_GROUP" => Self::AzureManagementGroup,
                "AZURE_SUBSCRIPTION" => Self::AzureSubscription,
                "AZURE_RESOURCE_GROUP" => Self::AzureResourceGroup,
                _ => Self::UnknownValue(resource_path_node_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResourcePathNodeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GcpOrganization => serializer.serialize_i32(1),
                Self::GcpFolder => serializer.serialize_i32(2),
                Self::GcpProject => serializer.serialize_i32(3),
                Self::AwsOrganization => serializer.serialize_i32(4),
                Self::AwsOrganizationalUnit => serializer.serialize_i32(5),
                Self::AwsAccount => serializer.serialize_i32(6),
                Self::AzureManagementGroup => serializer.serialize_i32(7),
                Self::AzureSubscription => serializer.serialize_i32(8),
                Self::AzureResourceGroup => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResourcePathNodeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourcePathNodeType>::new(
                ".google.cloud.securitycenter.v2.ResourcePath.ResourcePathNodeType",
            ))
        }
    }
}

/// A resource value configuration (RVC) is a mapping configuration of user's
/// resources to resource values. Used in Attack path simulations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceValueConfig {
    /// Identifier. Name for the resource value configuration
    pub name: std::string::String,

    /// Resource value level this expression represents
    /// Only required when there is no Sensitive Data Protection mapping in the
    /// request
    pub resource_value: crate::model::ResourceValue,

    /// Tag values combined with `AND` to check against.
    /// For Google Cloud resources, they are tag value IDs in the form of
    /// "tagValues/123". Example: `[ "tagValues/123", "tagValues/456",
    /// "tagValues/789" ]`
    /// <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing>
    pub tag_values: std::vec::Vec<std::string::String>,

    /// Apply resource_value only to resources that match resource_type.
    /// resource_type will be checked with `AND` of other resources.
    /// For example, "storage.googleapis.com/Bucket" with resource_value "HIGH"
    /// will apply "HIGH" value only to "storage.googleapis.com/Bucket" resources.
    pub resource_type: std::string::String,

    /// Project or folder to scope this configuration to.
    /// For example, "project/456" would apply this configuration only to resources
    /// in "project/456" scope and will be checked with `AND` of other resources.
    pub scope: std::string::String,

    /// List of resource labels to search for, evaluated with `AND`.
    /// For example, "resource_labels_selector": {"key": "value", "env": "prod"}
    /// will match resources with labels "key": "value" `AND` "env":
    /// "prod"
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels>
    pub resource_labels_selector:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Description of the resource value configuration.
    pub description: std::string::String,

    /// Output only. Timestamp this resource value configuration was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp this resource value configuration was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Cloud provider this configuration applies to
    pub cloud_provider: crate::model::CloudProvider,

    /// A mapping of the sensitivity on Sensitive Data Protection finding to
    /// resource values. This mapping can only be used in combination with a
    /// resource_type that is related to BigQuery, e.g.
    /// "bigquery.googleapis.com/Dataset".
    pub sensitive_data_protection_mapping:
        std::option::Option<crate::model::resource_value_config::SensitiveDataProtectionMapping>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceValueConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceValueConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource_value][crate::model::ResourceValueConfig::resource_value].
    pub fn set_resource_value<T: std::convert::Into<crate::model::ResourceValue>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_value = v.into();
        self
    }

    /// Sets the value of [tag_values][crate::model::ResourceValueConfig::tag_values].
    pub fn set_tag_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tag_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_type][crate::model::ResourceValueConfig::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::ResourceValueConfig::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [resource_labels_selector][crate::model::ResourceValueConfig::resource_labels_selector].
    pub fn set_resource_labels_selector<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels_selector = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::ResourceValueConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ResourceValueConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ResourceValueConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ResourceValueConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ResourceValueConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_provider][crate::model::ResourceValueConfig::cloud_provider].
    pub fn set_cloud_provider<T: std::convert::Into<crate::model::CloudProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider = v.into();
        self
    }

    /// Sets the value of [sensitive_data_protection_mapping][crate::model::ResourceValueConfig::sensitive_data_protection_mapping].
    pub fn set_sensitive_data_protection_mapping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::resource_value_config::SensitiveDataProtectionMapping>,
    {
        self.sensitive_data_protection_mapping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sensitive_data_protection_mapping][crate::model::ResourceValueConfig::sensitive_data_protection_mapping].
    pub fn set_or_clear_sensitive_data_protection_mapping<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::resource_value_config::SensitiveDataProtectionMapping>,
    {
        self.sensitive_data_protection_mapping = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ResourceValueConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ResourceValueConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceValueConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __resource_value,
            __tag_values,
            __resource_type,
            __scope,
            __resource_labels_selector,
            __description,
            __create_time,
            __update_time,
            __cloud_provider,
            __sensitive_data_protection_mapping,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceValueConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "resourceValue" => Ok(__FieldTag::__resource_value),
                            "resource_value" => Ok(__FieldTag::__resource_value),
                            "tagValues" => Ok(__FieldTag::__tag_values),
                            "tag_values" => Ok(__FieldTag::__tag_values),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "scope" => Ok(__FieldTag::__scope),
                            "resourceLabelsSelector" => Ok(__FieldTag::__resource_labels_selector),
                            "resource_labels_selector" => {
                                Ok(__FieldTag::__resource_labels_selector)
                            }
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "cloudProvider" => Ok(__FieldTag::__cloud_provider),
                            "cloud_provider" => Ok(__FieldTag::__cloud_provider),
                            "sensitiveDataProtectionMapping" => {
                                Ok(__FieldTag::__sensitive_data_protection_mapping)
                            }
                            "sensitive_data_protection_mapping" => {
                                Ok(__FieldTag::__sensitive_data_protection_mapping)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceValueConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceValueConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_value => {
                            if !fields.insert(__FieldTag::__resource_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value",
                                ));
                            }
                            result.resource_value = map
                                .next_value::<std::option::Option<crate::model::ResourceValue>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag_values => {
                            if !fields.insert(__FieldTag::__tag_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag_values",
                                ));
                            }
                            result.tag_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_labels_selector => {
                            if !fields.insert(__FieldTag::__resource_labels_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels_selector",
                                ));
                            }
                            result.resource_labels_selector = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cloud_provider => {
                            if !fields.insert(__FieldTag::__cloud_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_provider",
                                ));
                            }
                            result.cloud_provider = map
                                .next_value::<std::option::Option<crate::model::CloudProvider>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sensitive_data_protection_mapping => {
                            if !fields.insert(__FieldTag::__sensitive_data_protection_mapping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sensitive_data_protection_mapping",
                                ));
                            }
                            result.sensitive_data_protection_mapping = map
                                .next_value::<std::option::Option<
                                crate::model::resource_value_config::SensitiveDataProtectionMapping,
                            >>(
                            )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceValueConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.resource_value) {
            state.serialize_entry("resourceValue", &self.resource_value)?;
        }
        if !self.tag_values.is_empty() {
            state.serialize_entry("tagValues", &self.tag_values)?;
        }
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self.resource_labels_selector.is_empty() {
            state.serialize_entry("resourceLabelsSelector", &self.resource_labels_selector)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.cloud_provider) {
            state.serialize_entry("cloudProvider", &self.cloud_provider)?;
        }
        if self.sensitive_data_protection_mapping.is_some() {
            state.serialize_entry(
                "sensitiveDataProtectionMapping",
                &self.sensitive_data_protection_mapping,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceValueConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceValueConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("resource_value", &self.resource_value);
        debug_struct.field("tag_values", &self.tag_values);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("scope", &self.scope);
        debug_struct.field("resource_labels_selector", &self.resource_labels_selector);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("cloud_provider", &self.cloud_provider);
        debug_struct.field(
            "sensitive_data_protection_mapping",
            &self.sensitive_data_protection_mapping,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ResourceValueConfig].
pub mod resource_value_config {
    #[allow(unused_imports)]
    use super::*;

    /// Resource value mapping for Sensitive Data Protection findings
    /// If any of these mappings have a resource value that is not unspecified,
    /// the resource_value field will be ignored when reading this configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SensitiveDataProtectionMapping {
        /// Resource value mapping for high-sensitivity Sensitive Data Protection
        /// findings
        pub high_sensitivity_mapping: crate::model::ResourceValue,

        /// Resource value mapping for medium-sensitivity Sensitive Data Protection
        /// findings
        pub medium_sensitivity_mapping: crate::model::ResourceValue,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SensitiveDataProtectionMapping {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [high_sensitivity_mapping][crate::model::resource_value_config::SensitiveDataProtectionMapping::high_sensitivity_mapping].
        pub fn set_high_sensitivity_mapping<T: std::convert::Into<crate::model::ResourceValue>>(
            mut self,
            v: T,
        ) -> Self {
            self.high_sensitivity_mapping = v.into();
            self
        }

        /// Sets the value of [medium_sensitivity_mapping][crate::model::resource_value_config::SensitiveDataProtectionMapping::medium_sensitivity_mapping].
        pub fn set_medium_sensitivity_mapping<
            T: std::convert::Into<crate::model::ResourceValue>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.medium_sensitivity_mapping = v.into();
            self
        }
    }

    impl wkt::message::Message for SensitiveDataProtectionMapping {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.ResourceValueConfig.SensitiveDataProtectionMapping"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SensitiveDataProtectionMapping {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __high_sensitivity_mapping,
                __medium_sensitivity_mapping,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SensitiveDataProtectionMapping")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "highSensitivityMapping" => {
                                    Ok(__FieldTag::__high_sensitivity_mapping)
                                }
                                "high_sensitivity_mapping" => {
                                    Ok(__FieldTag::__high_sensitivity_mapping)
                                }
                                "mediumSensitivityMapping" => {
                                    Ok(__FieldTag::__medium_sensitivity_mapping)
                                }
                                "medium_sensitivity_mapping" => {
                                    Ok(__FieldTag::__medium_sensitivity_mapping)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SensitiveDataProtectionMapping;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SensitiveDataProtectionMapping")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__high_sensitivity_mapping => {
                                if !fields.insert(__FieldTag::__high_sensitivity_mapping) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for high_sensitivity_mapping",
                                    ));
                                }
                                result.high_sensitivity_mapping = map
                                    .next_value::<std::option::Option<crate::model::ResourceValue>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__medium_sensitivity_mapping => {
                                if !fields.insert(__FieldTag::__medium_sensitivity_mapping) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for medium_sensitivity_mapping",
                                    ));
                                }
                                result.medium_sensitivity_mapping = map
                                    .next_value::<std::option::Option<crate::model::ResourceValue>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SensitiveDataProtectionMapping {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.high_sensitivity_mapping) {
                state.serialize_entry("highSensitivityMapping", &self.high_sensitivity_mapping)?;
            }
            if !wkt::internal::is_default(&self.medium_sensitivity_mapping) {
                state.serialize_entry(
                    "mediumSensitivityMapping",
                    &self.medium_sensitivity_mapping,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SensitiveDataProtectionMapping {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SensitiveDataProtectionMapping");
            debug_struct.field("high_sensitivity_mapping", &self.high_sensitivity_mapping);
            debug_struct.field(
                "medium_sensitivity_mapping",
                &self.medium_sensitivity_mapping,
            );

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// User specified security marks that are attached to the parent Security
/// Command Center resource. Security marks are scoped within a Security Command
/// Center organization -- they can be modified and viewed by all users who have
/// proper permissions on the organization.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityMarks {
    /// The relative resource name of the SecurityMarks. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// The following list shows some examples:
    ///
    /// + `organizations/{organization_id}/assets/{asset_id}/securityMarks`
    ///
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}/securityMarks`
    /// +
    /// `organizations/{organization_id}/sources/{source_id}/locations/{location}/findings/{finding_id}/securityMarks`
    pub name: std::string::String,

    /// Mutable user specified security marks belonging to the parent resource.
    /// Constraints are as follows:
    ///
    /// * Keys and values are treated as case insensitive
    /// * Keys must be between 1 - 256 characters (inclusive)
    /// * Keys must be letters, numbers, underscores, or dashes
    /// * Values have leading and trailing whitespace trimmed, remaining
    ///   characters must be between 1 - 4096 characters (inclusive)
    pub marks: std::collections::HashMap<std::string::String, std::string::String>,

    /// The canonical name of the marks. The following list shows some examples:
    ///
    /// + `organizations/{organization_id}/assets/{asset_id}/securityMarks`
    ///
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}/securityMarks`
    /// +
    /// `organizations/{organization_id}/sources/{source_id}/locations/{location}/findings/{finding_id}/securityMarks`
    ///
    /// + `folders/{folder_id}/assets/{asset_id}/securityMarks`
    ///
    /// `folders/{folder_id}/sources/{source_id}/findings/{finding_id}/securityMarks`
    /// +
    /// `folders/{folder_id}/sources/{source_id}/locations/{location}/findings/{finding_id}/securityMarks`
    ///
    /// + `projects/{project_number}/assets/{asset_id}/securityMarks`
    ///
    /// `projects/{project_number}/sources/{source_id}/findings/{finding_id}/securityMarks`
    /// +
    /// `projects/{project_number}/sources/{source_id}/locations/{location}/findings/{finding_id}/securityMarks`
    pub canonical_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityMarks {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SecurityMarks::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [marks][crate::model::SecurityMarks::marks].
    pub fn set_marks<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.marks = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [canonical_name][crate::model::SecurityMarks::canonical_name].
    pub fn set_canonical_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.canonical_name = v.into();
        self
    }
}

impl wkt::message::Message for SecurityMarks {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.SecurityMarks"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityMarks {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __marks,
            __canonical_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityMarks")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "marks" => Ok(__FieldTag::__marks),
                            "canonicalName" => Ok(__FieldTag::__canonical_name),
                            "canonical_name" => Ok(__FieldTag::__canonical_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityMarks;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityMarks")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__marks => {
                            if !fields.insert(__FieldTag::__marks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for marks",
                                ));
                            }
                            result.marks = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__canonical_name => {
                            if !fields.insert(__FieldTag::__canonical_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_name",
                                ));
                            }
                            result.canonical_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityMarks {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.marks.is_empty() {
            state.serialize_entry("marks", &self.marks)?;
        }
        if !self.canonical_name.is_empty() {
            state.serialize_entry("canonicalName", &self.canonical_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecurityMarks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityMarks");
        debug_struct.field("name", &self.name);
        debug_struct.field("marks", &self.marks);
        debug_struct.field("canonical_name", &self.canonical_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a posture that is deployed on Google Cloud by the
/// Security Command Center Posture Management service.
/// A posture contains one or more policy sets. A policy set is a
/// group of policies that enforce a set of security rules on Google
/// Cloud.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityPosture {
    /// Name of the posture, for example, `CIS-Posture`.
    pub name: std::string::String,

    /// The version of the posture, for example, `c7cfa2a8`.
    pub revision_id: std::string::String,

    /// The project, folder, or organization on which the posture is deployed,
    /// for example, `projects/{project_number}`.
    pub posture_deployment_resource: std::string::String,

    /// The name of the posture deployment, for example,
    /// `organizations/{org_id}/posturedeployments/{posture_deployment_id}`.
    pub posture_deployment: std::string::String,

    /// The name of the updated policy, for example,
    /// `projects/{project_id}/policies/{constraint_name}`.
    pub changed_policy: std::string::String,

    /// The name of the updated policy set, for example, `cis-policyset`.
    pub policy_set: std::string::String,

    /// The ID of the updated policy, for example, `compute-policy-1`.
    pub policy: std::string::String,

    /// The details about a change in an updated policy that violates the deployed
    /// posture.
    pub policy_drift_details: std::vec::Vec<crate::model::security_posture::PolicyDriftDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityPosture {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SecurityPosture::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::SecurityPosture::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [posture_deployment_resource][crate::model::SecurityPosture::posture_deployment_resource].
    pub fn set_posture_deployment_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.posture_deployment_resource = v.into();
        self
    }

    /// Sets the value of [posture_deployment][crate::model::SecurityPosture::posture_deployment].
    pub fn set_posture_deployment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.posture_deployment = v.into();
        self
    }

    /// Sets the value of [changed_policy][crate::model::SecurityPosture::changed_policy].
    pub fn set_changed_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.changed_policy = v.into();
        self
    }

    /// Sets the value of [policy_set][crate::model::SecurityPosture::policy_set].
    pub fn set_policy_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_set = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::SecurityPosture::policy].
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [policy_drift_details][crate::model::SecurityPosture::policy_drift_details].
    pub fn set_policy_drift_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::security_posture::PolicyDriftDetails>,
    {
        use std::iter::Iterator;
        self.policy_drift_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SecurityPosture {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.SecurityPosture"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityPosture {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __revision_id,
            __posture_deployment_resource,
            __posture_deployment,
            __changed_policy,
            __policy_set,
            __policy,
            __policy_drift_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityPosture")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "postureDeploymentResource" => {
                                Ok(__FieldTag::__posture_deployment_resource)
                            }
                            "posture_deployment_resource" => {
                                Ok(__FieldTag::__posture_deployment_resource)
                            }
                            "postureDeployment" => Ok(__FieldTag::__posture_deployment),
                            "posture_deployment" => Ok(__FieldTag::__posture_deployment),
                            "changedPolicy" => Ok(__FieldTag::__changed_policy),
                            "changed_policy" => Ok(__FieldTag::__changed_policy),
                            "policySet" => Ok(__FieldTag::__policy_set),
                            "policy_set" => Ok(__FieldTag::__policy_set),
                            "policy" => Ok(__FieldTag::__policy),
                            "policyDriftDetails" => Ok(__FieldTag::__policy_drift_details),
                            "policy_drift_details" => Ok(__FieldTag::__policy_drift_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityPosture;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityPosture")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__posture_deployment_resource => {
                            if !fields.insert(__FieldTag::__posture_deployment_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posture_deployment_resource",
                                ));
                            }
                            result.posture_deployment_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__posture_deployment => {
                            if !fields.insert(__FieldTag::__posture_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posture_deployment",
                                ));
                            }
                            result.posture_deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__changed_policy => {
                            if !fields.insert(__FieldTag::__changed_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for changed_policy",
                                ));
                            }
                            result.changed_policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_set => {
                            if !fields.insert(__FieldTag::__policy_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_set",
                                ));
                            }
                            result.policy_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_drift_details => {
                            if !fields.insert(__FieldTag::__policy_drift_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_drift_details",
                                ));
                            }
                            result.policy_drift_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::security_posture::PolicyDriftDetails,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityPosture {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self.posture_deployment_resource.is_empty() {
            state.serialize_entry(
                "postureDeploymentResource",
                &self.posture_deployment_resource,
            )?;
        }
        if !self.posture_deployment.is_empty() {
            state.serialize_entry("postureDeployment", &self.posture_deployment)?;
        }
        if !self.changed_policy.is_empty() {
            state.serialize_entry("changedPolicy", &self.changed_policy)?;
        }
        if !self.policy_set.is_empty() {
            state.serialize_entry("policySet", &self.policy_set)?;
        }
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self.policy_drift_details.is_empty() {
            state.serialize_entry("policyDriftDetails", &self.policy_drift_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecurityPosture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityPosture");
        debug_struct.field("name", &self.name);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field(
            "posture_deployment_resource",
            &self.posture_deployment_resource,
        );
        debug_struct.field("posture_deployment", &self.posture_deployment);
        debug_struct.field("changed_policy", &self.changed_policy);
        debug_struct.field("policy_set", &self.policy_set);
        debug_struct.field("policy", &self.policy);
        debug_struct.field("policy_drift_details", &self.policy_drift_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SecurityPosture].
pub mod security_posture {
    #[allow(unused_imports)]
    use super::*;

    /// The policy field that violates the deployed posture and its expected and
    /// detected values.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PolicyDriftDetails {
        /// The name of the updated field, for example
        /// constraint.implementation.policy_rules[0].enforce
        pub field: std::string::String,

        /// The value of this field that was configured in a posture, for example,
        /// `true` or `allowed_values={"projects/29831892"}`.
        pub expected_value: std::string::String,

        /// The detected value that violates the deployed posture, for example,
        /// `false` or `allowed_values={"projects/22831892"}`.
        pub detected_value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PolicyDriftDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::security_posture::PolicyDriftDetails::field].
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [expected_value][crate::model::security_posture::PolicyDriftDetails::expected_value].
        pub fn set_expected_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.expected_value = v.into();
            self
        }

        /// Sets the value of [detected_value][crate::model::security_posture::PolicyDriftDetails::detected_value].
        pub fn set_detected_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.detected_value = v.into();
            self
        }
    }

    impl wkt::message::Message for PolicyDriftDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.SecurityPosture.PolicyDriftDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PolicyDriftDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field,
                __expected_value,
                __detected_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PolicyDriftDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "field" => Ok(__FieldTag::__field),
                                "expectedValue" => Ok(__FieldTag::__expected_value),
                                "expected_value" => Ok(__FieldTag::__expected_value),
                                "detectedValue" => Ok(__FieldTag::__detected_value),
                                "detected_value" => Ok(__FieldTag::__detected_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PolicyDriftDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PolicyDriftDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field => {
                                if !fields.insert(__FieldTag::__field) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field",
                                    ));
                                }
                                result.field = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__expected_value => {
                                if !fields.insert(__FieldTag::__expected_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expected_value",
                                    ));
                                }
                                result.expected_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__detected_value => {
                                if !fields.insert(__FieldTag::__detected_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detected_value",
                                    ));
                                }
                                result.detected_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PolicyDriftDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.field.is_empty() {
                state.serialize_entry("field", &self.field)?;
            }
            if !self.expected_value.is_empty() {
                state.serialize_entry("expectedValue", &self.expected_value)?;
            }
            if !self.detected_value.is_empty() {
                state.serialize_entry("detectedValue", &self.detected_value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PolicyDriftDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PolicyDriftDetails");
            debug_struct.field("field", &self.field);
            debug_struct.field("expected_value", &self.expected_value);
            debug_struct.field("detected_value", &self.detected_value);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Request message to create multiple resource value configs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateResourceValueConfigsRequest {
    /// Required. Resource name of the new ResourceValueConfig's parent.
    /// The parent field in the CreateResourceValueConfigRequest
    /// messages must either be empty or match this field.
    pub parent: std::string::String,

    /// Required. The resource value configs to be created.
    pub requests: std::vec::Vec<crate::model::CreateResourceValueConfigRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateResourceValueConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateResourceValueConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateResourceValueConfigsRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateResourceValueConfigRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateResourceValueConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.BatchCreateResourceValueConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateResourceValueConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for BatchCreateResourceValueConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requests" => Ok(__FieldTag::__requests),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateResourceValueConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateResourceValueConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CreateResourceValueConfigRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateResourceValueConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchCreateResourceValueConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateResourceValueConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("requests", &self.requests);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for BatchCreateResourceValueConfigs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateResourceValueConfigsResponse {
    /// The resource value configs created
    pub resource_value_configs: std::vec::Vec<crate::model::ResourceValueConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateResourceValueConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_value_configs][crate::model::BatchCreateResourceValueConfigsResponse::resource_value_configs].
    pub fn set_resource_value_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceValueConfig>,
    {
        use std::iter::Iterator;
        self.resource_value_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateResourceValueConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.BatchCreateResourceValueConfigsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateResourceValueConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_value_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for BatchCreateResourceValueConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceValueConfigs" => Ok(__FieldTag::__resource_value_configs),
                            "resource_value_configs" => Ok(__FieldTag::__resource_value_configs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateResourceValueConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateResourceValueConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_value_configs => {
                            if !fields.insert(__FieldTag::__resource_value_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value_configs",
                                ));
                            }
                            result.resource_value_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceValueConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateResourceValueConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_value_configs.is_empty() {
            state.serialize_entry("resourceValueConfigs", &self.resource_value_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchCreateResourceValueConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateResourceValueConfigsResponse");
        debug_struct.field("resource_value_configs", &self.resource_value_configs);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for bulk findings update.
///
/// Note:
///
/// 1. If multiple bulk update requests match the same resource, the order in
///    which they get executed is not defined.
/// 1. Once a bulk operation is started, there is no way to stop it.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkMuteFindingsRequest {
    /// Required. The parent, at which bulk action needs to be applied. If no
    /// location is specified, findings are updated in global. The following list
    /// shows some examples:
    ///
    /// + `organizations/[organization_id]`
    /// + `organizations/[organization_id]/locations/[location_id]`
    /// + `folders/[folder_id]`
    /// + `folders/[folder_id]/locations/[location_id]`
    /// + `projects/[project_id]`
    /// + `projects/[project_id]/locations/[location_id]`
    pub parent: std::string::String,

    /// Expression that identifies findings that should be updated.
    /// The expression is a list of zero or more restrictions combined
    /// via logical operators `AND` and `OR`. Parentheses are supported, and `OR`
    /// has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a
    /// `-` character in front of them to indicate negation. The fields map to
    /// those defined in the corresponding resource.
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    pub filter: std::string::String,

    /// Optional. All findings matching the given filter will have their mute state
    /// set to this value. The default value is `MUTED`. Setting this to
    /// `UNDEFINED` will clear the mute state on all matching findings.
    pub mute_state: crate::model::bulk_mute_findings_request::MuteState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkMuteFindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BulkMuteFindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::BulkMuteFindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [mute_state][crate::model::BulkMuteFindingsRequest::mute_state].
    pub fn set_mute_state<
        T: std::convert::Into<crate::model::bulk_mute_findings_request::MuteState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mute_state = v.into();
        self
    }
}

impl wkt::message::Message for BulkMuteFindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.BulkMuteFindingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkMuteFindingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __mute_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkMuteFindingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "muteState" => Ok(__FieldTag::__mute_state),
                            "mute_state" => Ok(__FieldTag::__mute_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkMuteFindingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkMuteFindingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mute_state => {
                            if !fields.insert(__FieldTag::__mute_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_state",
                                ));
                            }
                            result.mute_state = map
                                .next_value::<std::option::Option<
                                    crate::model::bulk_mute_findings_request::MuteState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkMuteFindingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.mute_state) {
            state.serialize_entry("muteState", &self.mute_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkMuteFindingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkMuteFindingsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("mute_state", &self.mute_state);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BulkMuteFindingsRequest].
pub mod bulk_mute_findings_request {
    #[allow(unused_imports)]
    use super::*;

    /// The mute state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MuteState {
        /// Unused.
        Unspecified,
        /// Matching findings will be muted (default).
        Muted,
        /// Matching findings will have their mute state cleared.
        Undefined,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MuteState::value] or
        /// [MuteState::name].
        UnknownValue(mute_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mute_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MuteState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Muted => std::option::Option::Some(1),
                Self::Undefined => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MUTE_STATE_UNSPECIFIED"),
                Self::Muted => std::option::Option::Some("MUTED"),
                Self::Undefined => std::option::Option::Some("UNDEFINED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MuteState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MuteState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MuteState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Muted,
                2 => Self::Undefined,
                _ => Self::UnknownValue(mute_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MuteState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MUTE_STATE_UNSPECIFIED" => Self::Unspecified,
                "MUTED" => Self::Muted,
                "UNDEFINED" => Self::Undefined,
                _ => Self::UnknownValue(mute_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MuteState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Muted => serializer.serialize_i32(1),
                Self::Undefined => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MuteState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MuteState>::new(
                ".google.cloud.securitycenter.v2.BulkMuteFindingsRequest.MuteState",
            ))
        }
    }
}

/// The response to a BulkMute request. Contains the LRO information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkMuteFindingsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BulkMuteFindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BulkMuteFindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.BulkMuteFindingsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BulkMuteFindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BulkMuteFindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BulkMuteFindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BulkMuteFindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BulkMuteFindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BulkMuteFindingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BulkMuteFindingsResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for creating a BigQuery export.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBigQueryExportRequest {
    /// Required. The name of the parent resource of the new BigQuery export. Its
    /// format is `organizations/[organization_id]/locations/[location_id]`,
    /// `folders/[folder_id]/locations/[location_id]`, or
    /// `projects/[project_id]/locations/[location_id]`.
    pub parent: std::string::String,

    /// Required. The BigQuery export being created.
    pub big_query_export: std::option::Option<crate::model::BigQueryExport>,

    /// Required. Unique identifier provided by the client within the parent scope.
    /// It must consist of only lowercase letters, numbers, and hyphens, must start
    /// with a letter, must end with either a letter or a number, and must be 63
    /// characters or less.
    pub big_query_export_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBigQueryExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBigQueryExportRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [big_query_export][crate::model::CreateBigQueryExportRequest::big_query_export].
    pub fn set_big_query_export<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryExport>,
    {
        self.big_query_export = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [big_query_export][crate::model::CreateBigQueryExportRequest::big_query_export].
    pub fn set_or_clear_big_query_export<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryExport>,
    {
        self.big_query_export = v.map(|x| x.into());
        self
    }

    /// Sets the value of [big_query_export_id][crate::model::CreateBigQueryExportRequest::big_query_export_id].
    pub fn set_big_query_export_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.big_query_export_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBigQueryExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CreateBigQueryExportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBigQueryExportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __big_query_export,
            __big_query_export_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBigQueryExportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "bigQueryExport" => Ok(__FieldTag::__big_query_export),
                            "big_query_export" => Ok(__FieldTag::__big_query_export),
                            "bigQueryExportId" => Ok(__FieldTag::__big_query_export_id),
                            "big_query_export_id" => Ok(__FieldTag::__big_query_export_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBigQueryExportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBigQueryExportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__big_query_export => {
                            if !fields.insert(__FieldTag::__big_query_export) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_export",
                                ));
                            }
                            result.big_query_export = map
                                .next_value::<std::option::Option<crate::model::BigQueryExport>>(
                                )?;
                        }
                        __FieldTag::__big_query_export_id => {
                            if !fields.insert(__FieldTag::__big_query_export_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_export_id",
                                ));
                            }
                            result.big_query_export_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBigQueryExportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.big_query_export.is_some() {
            state.serialize_entry("bigQueryExport", &self.big_query_export)?;
        }
        if !self.big_query_export_id.is_empty() {
            state.serialize_entry("bigQueryExportId", &self.big_query_export_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateBigQueryExportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBigQueryExportRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("big_query_export", &self.big_query_export);
        debug_struct.field("big_query_export_id", &self.big_query_export_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for creating a finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFindingRequest {
    /// Required. Resource name of the new finding's parent. The following list
    /// shows some examples of the format:
    /// +
    /// `organizations/[organization_id]/sources/[source_id]`
    /// +
    /// `organizations/[organization_id]/sources/[source_id]/locations/[location_id]`
    pub parent: std::string::String,

    /// Required. Unique identifier provided by the client within the parent scope.
    /// It must be alphanumeric and less than or equal to 32 characters and
    /// greater than 0 characters in length.
    pub finding_id: std::string::String,

    /// Required. The Finding being created. The name and security_marks will be
    /// ignored as they are both output only fields on this resource.
    pub finding: std::option::Option<crate::model::Finding>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFindingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [finding_id][crate::model::CreateFindingRequest::finding_id].
    pub fn set_finding_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finding_id = v.into();
        self
    }

    /// Sets the value of [finding][crate::model::CreateFindingRequest::finding].
    pub fn set_finding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Finding>,
    {
        self.finding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finding][crate::model::CreateFindingRequest::finding].
    pub fn set_or_clear_finding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Finding>,
    {
        self.finding = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateFindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CreateFindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateFindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __finding_id,
            __finding,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateFindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "findingId" => Ok(__FieldTag::__finding_id),
                            "finding_id" => Ok(__FieldTag::__finding_id),
                            "finding" => Ok(__FieldTag::__finding),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateFindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateFindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding_id => {
                            if !fields.insert(__FieldTag::__finding_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_id",
                                ));
                            }
                            result.finding_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding => {
                            if !fields.insert(__FieldTag::__finding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding",
                                ));
                            }
                            result.finding =
                                map.next_value::<std::option::Option<crate::model::Finding>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateFindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.finding_id.is_empty() {
            state.serialize_entry("findingId", &self.finding_id)?;
        }
        if self.finding.is_some() {
            state.serialize_entry("finding", &self.finding)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateFindingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateFindingRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("finding_id", &self.finding_id);
        debug_struct.field("finding", &self.finding);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for creating a mute config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMuteConfigRequest {
    /// Required. Resource name of the new mute configs's parent. Its format is
    /// `organizations/[organization_id]/locations/[location_id]`,
    /// `folders/[folder_id]/locations/[location_id]`, or
    /// `projects/[project_id]/locations/[location_id]`.
    pub parent: std::string::String,

    /// Required. The mute config being created.
    pub mute_config: std::option::Option<crate::model::MuteConfig>,

    /// Required. Unique identifier provided by the client within the parent scope.
    /// It must consist of only lowercase letters, numbers, and hyphens, must start
    /// with a letter, must end with either a letter or a number, and must be 63
    /// characters or less.
    pub mute_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMuteConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMuteConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [mute_config][crate::model::CreateMuteConfigRequest::mute_config].
    pub fn set_mute_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MuteConfig>,
    {
        self.mute_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mute_config][crate::model::CreateMuteConfigRequest::mute_config].
    pub fn set_or_clear_mute_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MuteConfig>,
    {
        self.mute_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mute_config_id][crate::model::CreateMuteConfigRequest::mute_config_id].
    pub fn set_mute_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mute_config_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMuteConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CreateMuteConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMuteConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __mute_config,
            __mute_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMuteConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "muteConfig" => Ok(__FieldTag::__mute_config),
                            "mute_config" => Ok(__FieldTag::__mute_config),
                            "muteConfigId" => Ok(__FieldTag::__mute_config_id),
                            "mute_config_id" => Ok(__FieldTag::__mute_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMuteConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMuteConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mute_config => {
                            if !fields.insert(__FieldTag::__mute_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_config",
                                ));
                            }
                            result.mute_config =
                                map.next_value::<std::option::Option<crate::model::MuteConfig>>()?;
                        }
                        __FieldTag::__mute_config_id => {
                            if !fields.insert(__FieldTag::__mute_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_config_id",
                                ));
                            }
                            result.mute_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMuteConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.mute_config.is_some() {
            state.serialize_entry("muteConfig", &self.mute_config)?;
        }
        if !self.mute_config_id.is_empty() {
            state.serialize_entry("muteConfigId", &self.mute_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateMuteConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateMuteConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("mute_config", &self.mute_config);
        debug_struct.field("mute_config_id", &self.mute_config_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for creating a notification config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNotificationConfigRequest {
    /// Required. Resource name of the new notification config's parent. Its format
    /// is `organizations/[organization_id]/locations/[location_id]`,
    /// `folders/[folder_id]/locations/[location_id]`, or
    /// `projects/[project_id]/locations/[location_id]`.
    pub parent: std::string::String,

    /// Required.
    /// Unique identifier provided by the client within the parent scope.
    /// It must be between 1 and 128 characters and contain alphanumeric
    /// characters, underscores, or hyphens only.
    pub config_id: std::string::String,

    /// Required. The notification config being created. The name and the service
    /// account will be ignored as they are both output only fields on this
    /// resource.
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNotificationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNotificationConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::CreateNotificationConfigRequest::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }

    /// Sets the value of [notification_config][crate::model::CreateNotificationConfigRequest::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::CreateNotificationConfigRequest::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateNotificationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CreateNotificationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateNotificationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __config_id,
            __notification_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNotificationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "configId" => Ok(__FieldTag::__config_id),
                            "config_id" => Ok(__FieldTag::__config_id),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateNotificationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNotificationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_id => {
                            if !fields.insert(__FieldTag::__config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_id",
                                ));
                            }
                            result.config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateNotificationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.config_id.is_empty() {
            state.serialize_entry("configId", &self.config_id)?;
        }
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateNotificationConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateNotificationConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("config_id", &self.config_id);
        debug_struct.field("notification_config", &self.notification_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to create single resource value config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateResourceValueConfigRequest {
    /// Required. Resource name of the new ResourceValueConfig's parent.
    pub parent: std::string::String,

    /// Required. The resource value config being created.
    pub resource_value_config: std::option::Option<crate::model::ResourceValueConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateResourceValueConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateResourceValueConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [resource_value_config][crate::model::CreateResourceValueConfigRequest::resource_value_config].
    pub fn set_resource_value_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceValueConfig>,
    {
        self.resource_value_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_value_config][crate::model::CreateResourceValueConfigRequest::resource_value_config].
    pub fn set_or_clear_resource_value_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceValueConfig>,
    {
        self.resource_value_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateResourceValueConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CreateResourceValueConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateResourceValueConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __resource_value_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateResourceValueConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "resourceValueConfig" => Ok(__FieldTag::__resource_value_config),
                            "resource_value_config" => Ok(__FieldTag::__resource_value_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateResourceValueConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateResourceValueConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_value_config => {
                            if !fields.insert(__FieldTag::__resource_value_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value_config",
                                ));
                            }
                            result.resource_value_config = map.next_value::<std::option::Option<crate::model::ResourceValueConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateResourceValueConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.resource_value_config.is_some() {
            state.serialize_entry("resourceValueConfig", &self.resource_value_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateResourceValueConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateResourceValueConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("resource_value_config", &self.resource_value_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for creating a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSourceRequest {
    /// Required. Resource name of the new source's parent. Its format should be
    /// `organizations/[organization_id]`.
    pub parent: std::string::String,

    /// Required. The Source being created, only the display_name and description
    /// will be used. All other fields will be ignored.
    pub source: std::option::Option<crate::model::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.CreateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSourceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("source", &self.source);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for deleting a BigQuery export.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBigQueryExportRequest {
    /// Required. The name of the BigQuery export to delete. The following list
    /// shows some examples of the format:
    ///
    ///
    /// `organizations/{organization}/locations/{location}/bigQueryExports/{export_id}`
    ///
    /// + `folders/{folder}/locations/{location}/bigQueryExports/{export_id}`
    /// + `projects/{project}/locations/{location}/bigQueryExports/{export_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBigQueryExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBigQueryExportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBigQueryExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.DeleteBigQueryExportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBigQueryExportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBigQueryExportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBigQueryExportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBigQueryExportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBigQueryExportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteBigQueryExportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBigQueryExportRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for deleting a mute config. If no location is specified,
/// default is global.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMuteConfigRequest {
    /// Required. Name of the mute config to delete. The following list shows some
    /// examples of the format:
    ///
    /// + `organizations/{organization}/muteConfigs/{config_id}`
    ///
    /// `organizations/{organization}/locations/{location}/muteConfigs/{config_id}`
    ///
    /// + `folders/{folder}/muteConfigs/{config_id}`
    /// + `folders/{folder}/locations/{location}/muteConfigs/{config_id}`
    /// + `projects/{project}/muteConfigs/{config_id}`
    /// + `projects/{project}/locations/{location}/muteConfigs/{config_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMuteConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMuteConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMuteConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.DeleteMuteConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMuteConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMuteConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMuteConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMuteConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMuteConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteMuteConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteMuteConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for deleting a notification config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNotificationConfigRequest {
    /// Required. Name of the notification config to delete. The following list
    /// shows some examples of the format:
    ///
    ///
    /// `organizations/[organization_id]/locations/[location_id]/notificationConfigs/[config_id]`
    /// +
    /// `folders/[folder_id]/locations/[location_id]notificationConfigs/[config_id]`
    /// +
    /// `projects/[project_id]/locations/[location_id]notificationConfigs/[config_id]`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNotificationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNotificationConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNotificationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.DeleteNotificationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteNotificationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNotificationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteNotificationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNotificationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteNotificationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteNotificationConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteNotificationConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to delete resource value config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteResourceValueConfigRequest {
    /// Required. Name of the ResourceValueConfig to delete
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteResourceValueConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteResourceValueConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteResourceValueConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.DeleteResourceValueConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteResourceValueConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteResourceValueConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteResourceValueConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteResourceValueConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteResourceValueConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteResourceValueConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteResourceValueConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The destination big query dataset to export findings to.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryDestination {
    /// Required. The relative resource name of the destination dataset, in the
    /// form projects/{projectId}/datasets/{datasetId}.
    pub dataset: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::BigQueryDestination::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.BigQueryDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQueryDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryDestination");
        debug_struct.field("dataset", &self.dataset);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The LRO metadata for a ExportFindings request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportFindingsMetadata {
    /// Optional. Timestamp at which export was started
    pub export_start_time: std::option::Option<wkt::Timestamp>,

    /// The destination to export findings to.
    pub destination: std::option::Option<crate::model::export_findings_metadata::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportFindingsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [export_start_time][crate::model::ExportFindingsMetadata::export_start_time].
    pub fn set_export_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.export_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [export_start_time][crate::model::ExportFindingsMetadata::export_start_time].
    pub fn set_or_clear_export_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.export_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination][crate::model::ExportFindingsMetadata::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_findings_metadata::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportFindingsMetadata::destination]
    /// if it holds a `BigQueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQueryDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_findings_metadata::Destination::BigQueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportFindingsMetadata::destination]
    /// to hold a `BigQueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_big_query_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_findings_metadata::Destination::BigQueryDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportFindingsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ExportFindingsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportFindingsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __export_start_time,
            __big_query_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportFindingsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exportStartTime" => Ok(__FieldTag::__export_start_time),
                            "export_start_time" => Ok(__FieldTag::__export_start_time),
                            "bigQueryDestination" => Ok(__FieldTag::__big_query_destination),
                            "big_query_destination" => Ok(__FieldTag::__big_query_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportFindingsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportFindingsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__export_start_time => {
                            if !fields.insert(__FieldTag::__export_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_start_time",
                                ));
                            }
                            result.export_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__big_query_destination => {
                            if !fields.insert(__FieldTag::__big_query_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.securitycenter.v2.ExportFindingsMetadata.big_query_destination, latest field was bigQueryDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_findings_metadata::Destination::BigQueryDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::BigQueryDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportFindingsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.export_start_time.is_some() {
            state.serialize_entry("exportStartTime", &self.export_start_time)?;
        }
        if let Some(value) = self.big_query_destination() {
            state.serialize_entry("bigQueryDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportFindingsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportFindingsMetadata");
        debug_struct.field("export_start_time", &self.export_start_time);
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExportFindingsMetadata].
pub mod export_findings_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The destination to export findings to.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Required. The destination big query dataset to export findings to.
        BigQueryDestination(std::boxed::Box<crate::model::BigQueryDestination>),
    }
}

/// The response to a ExportFindings request. Contains the LRO information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportFindingsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportFindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportFindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ExportFindingsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportFindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportFindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportFindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportFindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportFindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportFindingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportFindingsResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for retrieving a BigQuery export.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBigQueryExportRequest {
    /// Required. Name of the BigQuery export to retrieve. The following list shows
    /// some examples of the format:
    ///
    ///
    /// `organizations/{organization}/locations/{location}/bigQueryExports/{export_id}`
    ///
    /// + `folders/{folder}/locations/{location}/bigQueryExports/{export_id}`
    /// + `projects/{project}locations/{location}//bigQueryExports/{export_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBigQueryExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBigQueryExportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBigQueryExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GetBigQueryExportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBigQueryExportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBigQueryExportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBigQueryExportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBigQueryExportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBigQueryExportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBigQueryExportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBigQueryExportRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for retrieving a mute config. If no location is specified,
/// default is global.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMuteConfigRequest {
    /// Required. Name of the mute config to retrieve. The following list shows
    /// some examples of the format:
    ///
    /// + `organizations/{organization}/muteConfigs/{config_id}`
    ///
    /// `organizations/{organization}/locations/{location}/muteConfigs/{config_id}`
    ///
    /// + `folders/{folder}/muteConfigs/{config_id}`
    /// + `folders/{folder}/locations/{location}/muteConfigs/{config_id}`
    /// + `projects/{project}/muteConfigs/{config_id}`
    /// + `projects/{project}/locations/{location}/muteConfigs/{config_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMuteConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMuteConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMuteConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GetMuteConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMuteConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMuteConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMuteConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMuteConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMuteConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetMuteConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMuteConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for getting a notification config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNotificationConfigRequest {
    /// Required. Name of the notification config to get. The following list shows
    /// some examples of the format:
    ///
    ///
    /// `organizations/[organization_id]/locations/[location_id]/notificationConfigs/[config_id]`
    /// +
    /// `folders/[folder_id]/locations/[location_id]/notificationConfigs/[config_id]`
    /// +
    /// `projects/[project_id]/locations/[location_id]/notificationConfigs/[config_id]`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNotificationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNotificationConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNotificationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GetNotificationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNotificationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNotificationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNotificationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNotificationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNotificationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetNotificationConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetNotificationConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to get resource value config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetResourceValueConfigRequest {
    /// Required. Name of the resource value config to retrieve. Its format is
    /// organizations/{organization}/resourceValueConfigs/{config_id}.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetResourceValueConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetResourceValueConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetResourceValueConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GetResourceValueConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetResourceValueConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetResourceValueConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetResourceValueConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetResourceValueConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetResourceValueConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetResourceValueConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetResourceValueConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for getting a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSourceRequest {
    /// Required. Relative resource name of the source. Its format is
    /// `organizations/[organization_id]/source/[source_id]`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GetSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSourceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for grouping by findings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GroupFindingsRequest {
    /// Required. Name of the source to groupBy. If no location is specified,
    /// finding is assumed to be in global.
    /// The following list shows some examples:
    ///
    /// + `organizations/[organization_id]/sources/[source_id]`
    ///
    /// `organizations/[organization_id]/sources/[source_id]/locations/[location_id]`
    ///
    /// + `folders/[folder_id]/sources/[source_id]`
    /// + `folders/[folder_id]/sources/[source_id]/locations/[location_id]`
    /// + `projects/[project_id]/sources/[source_id]`
    /// + `projects/[project_id]/sources/[source_id]/locations/[location_id]`
    ///
    /// To groupBy across all sources provide a source_id of `-`. The following
    /// list shows some examples:
    ///
    /// + `organizations/{organization_id}/sources/-`
    /// + `organizations/{organization_id}/sources/-/locations/[location_id]`
    /// + `folders/{folder_id}/sources/-`
    /// + `folders/{folder_id}/sources/-/locations/[location_id]`
    /// + `projects/{project_id}/sources/-`
    /// + `projects/{project_id}/sources/-/locations/[location_id]`
    pub parent: std::string::String,

    /// Expression that defines the filter to apply across findings.
    /// The expression is a list of one or more restrictions combined via logical
    /// operators `AND` and `OR`.
    /// Parentheses are supported, and `OR` has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a `-`
    /// character in front of them to indicate negation. Examples include:
    ///
    /// * name
    /// * security_marks.marks.marka
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    ///
    /// The following field and operator combinations are supported:
    ///
    /// * name: `=`
    ///
    /// * parent: `=`, `:`
    ///
    /// * resource_name: `=`, `:`
    ///
    /// * state: `=`, `:`
    ///
    /// * category: `=`, `:`
    ///
    /// * external_uri: `=`, `:`
    ///
    /// * event_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///   Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///   Examples:
    ///   `event_time = "2019-06-10T16:07:18-07:00"`
    ///   `event_time = 1560208038000`
    ///
    /// * severity: `=`, `:`
    ///
    /// * security_marks.marks: `=`, `:`
    ///
    /// * resource:
    ///
    ///   * resource.name: `=`, `:`
    ///   * resource.parent_name: `=`, `:`
    ///   * resource.parent_display_name: `=`, `:`
    ///   * resource.project_name: `=`, `:`
    ///   * resource.project_display_name: `=`, `:`
    ///   * resource.type: `=`, `:`
    pub filter: std::string::String,

    /// Required. Expression that defines what assets fields to use for grouping.
    /// The string value should follow SQL syntax: comma separated list of fields.
    /// For example: "parent,resource_name".
    pub group_by: std::string::String,

    /// The value returned by the last `GroupFindingsResponse`; indicates
    /// that this is a continuation of a prior `GroupFindings` call, and
    /// that the system should return the next page of data.
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GroupFindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GroupFindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::GroupFindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [group_by][crate::model::GroupFindingsRequest::group_by].
    pub fn set_group_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_by = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::GroupFindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::GroupFindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for GroupFindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GroupFindingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GroupFindingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __group_by,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GroupFindingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "groupBy" => Ok(__FieldTag::__group_by),
                            "group_by" => Ok(__FieldTag::__group_by),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GroupFindingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GroupFindingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_by => {
                            if !fields.insert(__FieldTag::__group_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_by",
                                ));
                            }
                            result.group_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GroupFindingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.group_by.is_empty() {
            state.serialize_entry("groupBy", &self.group_by)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GroupFindingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GroupFindingsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("group_by", &self.group_by);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for group by findings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GroupFindingsResponse {
    /// Group results. There exists an element for each existing unique
    /// combination of property/values. The element contains a count for the number
    /// of times those specific property/values appear.
    pub group_by_results: std::vec::Vec<crate::model::GroupResult>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    pub next_page_token: std::string::String,

    /// The total number of results matching the query.
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GroupFindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group_by_results][crate::model::GroupFindingsResponse::group_by_results].
    pub fn set_group_by_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroupResult>,
    {
        use std::iter::Iterator;
        self.group_by_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::GroupFindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::GroupFindingsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for GroupFindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GroupFindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for GroupFindingsResponse {
    type PageItem = crate::model::GroupResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.group_by_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GroupFindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group_by_results,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GroupFindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "groupByResults" => Ok(__FieldTag::__group_by_results),
                            "group_by_results" => Ok(__FieldTag::__group_by_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GroupFindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GroupFindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group_by_results => {
                            if !fields.insert(__FieldTag::__group_by_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_by_results",
                                ));
                            }
                            result.group_by_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GroupResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GroupFindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group_by_results.is_empty() {
            state.serialize_entry("groupByResults", &self.group_by_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GroupFindingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GroupFindingsResponse");
        debug_struct.field("group_by_results", &self.group_by_results);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Result containing the properties and count of a groupBy request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GroupResult {
    /// Properties matching the groupBy fields in the request.
    pub properties: std::collections::HashMap<std::string::String, wkt::Value>,

    /// Total count of resources for the given properties.
    pub count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GroupResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [properties][crate::model::GroupResult::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [count][crate::model::GroupResult::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }
}

impl wkt::message::Message for GroupResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GroupResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GroupResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __properties,
            __count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GroupResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "properties" => Ok(__FieldTag::__properties),
                            "count" => Ok(__FieldTag::__count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GroupResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GroupResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GroupResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GroupResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GroupResult");
        debug_struct.field("properties", &self.properties);
        debug_struct.field("count", &self.count);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing the attack paths for a given simulation or valued
/// resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttackPathsRequest {
    /// Required. Name of parent to list attack paths.
    ///
    /// Valid formats:
    /// `organizations/{organization}`,
    /// `organizations/{organization}/simulations/{simulation}`
    /// `organizations/{organization}/simulations/{simulation}/attackExposureResults/{attack_exposure_result_v2}`
    /// `organizations/{organization}/simulations/{simulation}/valuedResources/{valued_resource}`
    pub parent: std::string::String,

    /// The filter expression that filters the attack path in the response.
    /// Supported fields:
    ///
    /// * `valued_resources` supports =
    pub filter: std::string::String,

    /// The value returned by the last `ListAttackPathsResponse`; indicates
    /// that this is a continuation of a prior `ListAttackPaths` call, and
    /// that the system should return the next page of data.
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttackPathsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAttackPathsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAttackPathsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttackPathsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttackPathsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListAttackPathsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListAttackPathsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAttackPathsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAttackPathsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAttackPathsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAttackPathsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAttackPathsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAttackPathsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAttackPathsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing the attack paths for a given simulation or
/// valued resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAttackPathsResponse {
    /// The attack paths that the attack path simulation identified.
    pub attack_paths: std::vec::Vec<crate::model::AttackPath>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttackPathsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attack_paths][crate::model::ListAttackPathsResponse::attack_paths].
    pub fn set_attack_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttackPath>,
    {
        use std::iter::Iterator;
        self.attack_paths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAttackPathsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttackPathsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListAttackPathsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAttackPathsResponse {
    type PageItem = crate::model::AttackPath;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attack_paths
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAttackPathsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attack_paths,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAttackPathsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attackPaths" => Ok(__FieldTag::__attack_paths),
                            "attack_paths" => Ok(__FieldTag::__attack_paths),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAttackPathsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAttackPathsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attack_paths => {
                            if !fields.insert(__FieldTag::__attack_paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_paths",
                                ));
                            }
                            result.attack_paths = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AttackPath>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAttackPathsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attack_paths.is_empty() {
            state.serialize_entry("attackPaths", &self.attack_paths)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListAttackPathsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAttackPathsResponse");
        debug_struct.field("attack_paths", &self.attack_paths);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for getting simulation.
/// Simulation name can include "latest" to retrieve the latest simulation
/// For example, "organizations/123/simulations/latest"
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSimulationRequest {
    /// Required. The organization name or simulation name of this simulation
    ///
    /// Valid format:
    /// `organizations/{organization}/simulations/latest`
    /// `organizations/{organization}/simulations/{simulation}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSimulationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSimulationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSimulationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GetSimulationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSimulationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSimulationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSimulationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSimulationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSimulationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSimulationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSimulationRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for getting a valued resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetValuedResourceRequest {
    /// Required. The name of this valued resource
    ///
    /// Valid format:
    /// `organizations/{organization}/simulations/{simulation}/valuedResources/{valued_resource}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetValuedResourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetValuedResourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetValuedResourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.GetValuedResourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetValuedResourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetValuedResourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetValuedResourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetValuedResourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetValuedResourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetValuedResourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetValuedResourceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing BigQuery exports at a given scope e.g.
/// organization, folder or project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBigQueryExportsRequest {
    /// Required. The parent, which owns the collection of BigQuery exports. Its
    /// format is `organizations/[organization_id]/locations/[location_id]`,
    /// `folders/[folder_id]/locations/[location_id]`, or
    /// `projects/[project_id]/locations/[location_id]`.
    pub parent: std::string::String,

    /// The maximum number of configs to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListBigQueryExports` call.
    /// Provide this to retrieve the subsequent page.
    /// When paginating, all other parameters provided to `ListBigQueryExports`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBigQueryExportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBigQueryExportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBigQueryExportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBigQueryExportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBigQueryExportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListBigQueryExportsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBigQueryExportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBigQueryExportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBigQueryExportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBigQueryExportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBigQueryExportsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBigQueryExportsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBigQueryExportsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing BigQuery exports.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBigQueryExportsResponse {
    /// The BigQuery exports from the specified parent.
    pub big_query_exports: std::vec::Vec<crate::model::BigQueryExport>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBigQueryExportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [big_query_exports][crate::model::ListBigQueryExportsResponse::big_query_exports].
    pub fn set_big_query_exports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryExport>,
    {
        use std::iter::Iterator;
        self.big_query_exports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBigQueryExportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBigQueryExportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListBigQueryExportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBigQueryExportsResponse {
    type PageItem = crate::model::BigQueryExport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.big_query_exports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBigQueryExportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __big_query_exports,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBigQueryExportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigQueryExports" => Ok(__FieldTag::__big_query_exports),
                            "big_query_exports" => Ok(__FieldTag::__big_query_exports),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBigQueryExportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBigQueryExportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__big_query_exports => {
                            if !fields.insert(__FieldTag::__big_query_exports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_exports",
                                ));
                            }
                            result.big_query_exports =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigQueryExport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBigQueryExportsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.big_query_exports.is_empty() {
            state.serialize_entry("bigQueryExports", &self.big_query_exports)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBigQueryExportsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBigQueryExportsResponse");
        debug_struct.field("big_query_exports", &self.big_query_exports);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing findings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFindingsRequest {
    /// Required. Name of the source the findings belong to. If no location is
    /// specified, the default is global. The following list shows some examples:
    ///
    /// + `organizations/[organization_id]/sources/[source_id]`
    ///
    /// `organizations/[organization_id]/sources/[source_id]/locations/[location_id]`
    ///
    /// + `folders/[folder_id]/sources/[source_id]`
    /// + `folders/[folder_id]/sources/[source_id]/locations/[location_id]`
    /// + `projects/[project_id]/sources/[source_id]`
    /// + `projects/[project_id]/sources/[source_id]/locations/[location_id]`
    ///
    /// To list across all sources provide a source_id of `-`. The following
    /// list shows some examples:
    ///
    /// + `organizations/{organization_id}/sources/-`
    /// + `organizations/{organization_id}/sources/-/locations/{location_id}`
    /// + `folders/{folder_id}/sources/-`
    /// + `folders/{folder_id}/sources/-locations/{location_id}`
    /// + `projects/{projects_id}/sources/-`
    /// + `projects/{projects_id}/sources/-/locations/{location_id}`
    pub parent: std::string::String,

    /// Expression that defines the filter to apply across findings.
    /// The expression is a list of one or more restrictions combined via logical
    /// operators `AND` and `OR`.
    /// Parentheses are supported, and `OR` has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a `-`
    /// character in front of them to indicate negation. Examples include:
    ///
    /// * name
    /// * security_marks.marks.marka
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    ///
    /// The following field and operator combinations are supported:
    ///
    /// * name: `=`
    ///
    /// * parent: `=`, `:`
    ///
    /// * resource_name: `=`, `:`
    ///
    /// * state: `=`, `:`
    ///
    /// * category: `=`, `:`
    ///
    /// * external_uri: `=`, `:`
    ///
    /// * event_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///   Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///   Examples:
    ///   `event_time = "2019-06-10T16:07:18-07:00"`
    ///   `event_time = 1560208038000`
    ///
    /// * severity: `=`, `:`
    ///
    /// * security_marks.marks: `=`, `:`
    ///
    /// * resource:
    ///
    ///   * resource.name: `=`, `:`
    ///   * resource.parent_name: `=`, `:`
    ///   * resource.parent_display_name: `=`, `:`
    ///   * resource.project_name: `=`, `:`
    ///   * resource.project_display_name: `=`, `:`
    ///   * resource.type: `=`, `:`
    ///   * resource.folders.resource_folder: `=`, `:`
    ///   * resource.display_name: `=`, `:`
    pub filter: std::string::String,

    /// Expression that defines what fields and order to use for sorting. The
    /// string value should follow SQL syntax: comma separated list of fields. For
    /// example: "name,parent". The default sorting order
    /// is ascending. To specify descending order for a field, a suffix " desc"
    /// should be appended to the field name. For example: "name
    /// desc,parent". Redundant space characters in the
    /// syntax are insignificant. "name desc,parent" and "
    /// name     desc  ,   parent  " are equivalent.
    ///
    /// The following fields are supported:
    /// name
    /// parent
    /// state
    /// category
    /// resource_name
    /// event_time
    /// security_marks.marks
    pub order_by: std::string::String,

    /// A field mask to specify the Finding fields to be listed in the response.
    /// An empty field mask will list all fields.
    pub field_mask: std::option::Option<wkt::FieldMask>,

    /// The value returned by the last `ListFindingsResponse`; indicates
    /// that this is a continuation of a prior `ListFindings` call, and
    /// that the system should return the next page of data.
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFindingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::ListFindingsRequest::field_mask].
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::ListFindingsRequest::field_mask].
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_token][crate::model::ListFindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListFindingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFindingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __order_by,
            __field_mask,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFindingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "fieldMask" => Ok(__FieldTag::__field_mask),
                            "field_mask" => Ok(__FieldTag::__field_mask),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFindingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFindingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__field_mask => {
                            if !fields.insert(__FieldTag::__field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_mask",
                                ));
                            }
                            result.field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFindingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if self.field_mask.is_some() {
            state.serialize_entry("fieldMask", &self.field_mask)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFindingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFindingsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("field_mask", &self.field_mask);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing findings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFindingsResponse {
    /// Findings matching the list request.
    pub list_findings_results:
        std::vec::Vec<crate::model::list_findings_response::ListFindingsResult>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    pub next_page_token: std::string::String,

    /// The total number of findings matching the query.
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [list_findings_results][crate::model::ListFindingsResponse::list_findings_results].
    pub fn set_list_findings_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::list_findings_response::ListFindingsResult>,
    {
        use std::iter::Iterator;
        self.list_findings_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListFindingsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListFindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListFindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFindingsResponse {
    type PageItem = crate::model::list_findings_response::ListFindingsResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.list_findings_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __list_findings_results,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "listFindingsResults" => Ok(__FieldTag::__list_findings_results),
                            "list_findings_results" => Ok(__FieldTag::__list_findings_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__list_findings_results => {
                            if !fields.insert(__FieldTag::__list_findings_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for list_findings_results",
                                ));
                            }
                            result.list_findings_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::list_findings_response::ListFindingsResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.list_findings_results.is_empty() {
            state.serialize_entry("listFindingsResults", &self.list_findings_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFindingsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFindingsResponse");
        debug_struct.field("list_findings_results", &self.list_findings_results);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ListFindingsResponse].
pub mod list_findings_response {
    #[allow(unused_imports)]
    use super::*;

    /// Result containing the Finding.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListFindingsResult {
        /// Finding matching the search request.
        pub finding: std::option::Option<crate::model::Finding>,

        /// Output only. Resource that is associated with this finding.
        pub resource: std::option::Option<
            crate::model::list_findings_response::list_findings_result::Resource,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ListFindingsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [finding][crate::model::list_findings_response::ListFindingsResult::finding].
        pub fn set_finding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Finding>,
        {
            self.finding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [finding][crate::model::list_findings_response::ListFindingsResult::finding].
        pub fn set_or_clear_finding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Finding>,
        {
            self.finding = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resource][crate::model::list_findings_response::ListFindingsResult::resource].
        pub fn set_resource<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::list_findings_response::list_findings_result::Resource,
                >,
        {
            self.resource = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [resource][crate::model::list_findings_response::ListFindingsResult::resource].
        pub fn set_or_clear_resource<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::list_findings_response::list_findings_result::Resource,
                >,
        {
            self.resource = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ListFindingsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.ListFindingsResponse.ListFindingsResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ListFindingsResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __finding,
                __resource,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ListFindingsResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "finding" => Ok(__FieldTag::__finding),
                                "resource" => Ok(__FieldTag::__resource),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ListFindingsResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ListFindingsResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__finding => {
                                if !fields.insert(__FieldTag::__finding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for finding",
                                    ));
                                }
                                result.finding =
                                    map.next_value::<std::option::Option<crate::model::Finding>>()?;
                            }
                            __FieldTag::__resource => {
                                if !fields.insert(__FieldTag::__resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource",
                                    ));
                                }
                                result.resource = map.next_value::<std::option::Option<crate::model::list_findings_response::list_findings_result::Resource>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ListFindingsResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.finding.is_some() {
                state.serialize_entry("finding", &self.finding)?;
            }
            if self.resource.is_some() {
                state.serialize_entry("resource", &self.resource)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ListFindingsResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ListFindingsResult");
            debug_struct.field("finding", &self.finding);
            debug_struct.field("resource", &self.resource);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ListFindingsResult].
    pub mod list_findings_result {
        #[allow(unused_imports)]
        use super::*;

        /// Information related to the Google Cloud resource that is
        /// associated with this finding.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Resource {

            /// The full resource name of the resource. See:
            /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
            pub name: std::string::String,

            /// The human readable name of the resource.
            pub display_name: std::string::String,

            /// The full resource type of the resource.
            pub r#type: std::string::String,

            /// Indicates which cloud provider the finding is from.
            pub cloud_provider: crate::model::CloudProvider,

            /// The service or resource provider associated with the resource.
            pub service: std::string::String,

            /// The region or location of the service (if applicable).
            pub location: std::string::String,

            /// Provides the path to the resource within the resource hierarchy.
            pub resource_path: std::option::Option<crate::model::ResourcePath>,

            /// A string representation of the resource path.
            /// For Google Cloud, it has the format of
            /// `organizations/{organization_id}/folders/{folder_id}/folders/{folder_id}/projects/{project_id}`
            /// where there can be any number of folders.
            /// For AWS, it has the format of
            /// `org/{organization_id}/ou/{organizational_unit_id}/ou/{organizational_unit_id}/account/{account_id}`
            /// where there can be any number of organizational units.
            /// For Azure, it has the format of
            /// `mg/{management_group_id}/mg/{management_group_id}/subscription/{subscription_id}/rg/{resource_group_name}`
            /// where there can be any number of management groups.
            pub resource_path_string: std::string::String,

            /// The metadata associated with the cloud provider.
            pub cloud_provider_metadata: std::option::Option<crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Resource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::list_findings_response::list_findings_result::Resource::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [display_name][crate::model::list_findings_response::list_findings_result::Resource::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::list_findings_response::list_findings_result::Resource::type].
            pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [cloud_provider][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider].
            pub fn set_cloud_provider<T: std::convert::Into<crate::model::CloudProvider>>(
                mut self,
                v: T,
            ) -> Self {
                self.cloud_provider = v.into();
                self
            }

            /// Sets the value of [service][crate::model::list_findings_response::list_findings_result::Resource::service].
            pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.service = v.into();
                self
            }

            /// Sets the value of [location][crate::model::list_findings_response::list_findings_result::Resource::location].
            pub fn set_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.location = v.into();
                self
            }

            /// Sets the value of [resource_path][crate::model::list_findings_response::list_findings_result::Resource::resource_path].
            pub fn set_resource_path<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::ResourcePath>,
            {
                self.resource_path = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [resource_path][crate::model::list_findings_response::list_findings_result::Resource::resource_path].
            pub fn set_or_clear_resource_path<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::ResourcePath>,
            {
                self.resource_path = v.map(|x| x.into());
                self
            }

            /// Sets the value of [resource_path_string][crate::model::list_findings_response::list_findings_result::Resource::resource_path_string].
            pub fn set_resource_path_string<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.resource_path_string = v.into();
                self
            }

            /// Sets the value of [cloud_provider_metadata][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider_metadata].
            ///
            /// Note that all the setters affecting `cloud_provider_metadata` are mutually
            /// exclusive.
            pub fn set_cloud_provider_metadata<T: std::convert::Into<std::option::Option<crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata>>>(mut self, v: T) -> Self
            {
                self.cloud_provider_metadata = v.into();
                self
            }

            /// The value of [cloud_provider_metadata][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider_metadata]
            /// if it holds a `GcpMetadata`, `None` if the field is not set or
            /// holds a different branch.
            pub fn gcp_metadata(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::GcpMetadata>> {
                #[allow(unreachable_patterns)]
                self.cloud_provider_metadata.as_ref().and_then(|v| match v {
                    crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::GcpMetadata(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [cloud_provider_metadata][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider_metadata]
            /// to hold a `GcpMetadata`.
            ///
            /// Note that all the setters affecting `cloud_provider_metadata` are
            /// mutually exclusive.
            pub fn set_gcp_metadata<
                T: std::convert::Into<std::boxed::Box<crate::model::GcpMetadata>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.cloud_provider_metadata = std::option::Option::Some(
                    crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::GcpMetadata(
                        v.into()
                    )
                );
                self
            }

            /// The value of [cloud_provider_metadata][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider_metadata]
            /// if it holds a `AwsMetadata`, `None` if the field is not set or
            /// holds a different branch.
            pub fn aws_metadata(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::AwsMetadata>> {
                #[allow(unreachable_patterns)]
                self.cloud_provider_metadata.as_ref().and_then(|v| match v {
                    crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::AwsMetadata(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [cloud_provider_metadata][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider_metadata]
            /// to hold a `AwsMetadata`.
            ///
            /// Note that all the setters affecting `cloud_provider_metadata` are
            /// mutually exclusive.
            pub fn set_aws_metadata<
                T: std::convert::Into<std::boxed::Box<crate::model::AwsMetadata>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.cloud_provider_metadata = std::option::Option::Some(
                    crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::AwsMetadata(
                        v.into()
                    )
                );
                self
            }

            /// The value of [cloud_provider_metadata][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider_metadata]
            /// if it holds a `AzureMetadata`, `None` if the field is not set or
            /// holds a different branch.
            pub fn azure_metadata(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::AzureMetadata>> {
                #[allow(unreachable_patterns)]
                self.cloud_provider_metadata.as_ref().and_then(|v| match v {
                    crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::AzureMetadata(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [cloud_provider_metadata][crate::model::list_findings_response::list_findings_result::Resource::cloud_provider_metadata]
            /// to hold a `AzureMetadata`.
            ///
            /// Note that all the setters affecting `cloud_provider_metadata` are
            /// mutually exclusive.
            pub fn set_azure_metadata<
                T: std::convert::Into<std::boxed::Box<crate::model::AzureMetadata>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.cloud_provider_metadata = std::option::Option::Some(
                    crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::AzureMetadata(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for Resource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.securitycenter.v2.ListFindingsResponse.ListFindingsResult.Resource"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Resource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __name,
                    __display_name,
                    __type,
                    __cloud_provider,
                    __service,
                    __location,
                    __gcp_metadata,
                    __aws_metadata,
                    __azure_metadata,
                    __resource_path,
                    __resource_path_string,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Resource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "name" => Ok(__FieldTag::__name),
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "type" => Ok(__FieldTag::__type),
                                    "cloudProvider" => Ok(__FieldTag::__cloud_provider),
                                    "cloud_provider" => Ok(__FieldTag::__cloud_provider),
                                    "service" => Ok(__FieldTag::__service),
                                    "location" => Ok(__FieldTag::__location),
                                    "gcpMetadata" => Ok(__FieldTag::__gcp_metadata),
                                    "gcp_metadata" => Ok(__FieldTag::__gcp_metadata),
                                    "awsMetadata" => Ok(__FieldTag::__aws_metadata),
                                    "aws_metadata" => Ok(__FieldTag::__aws_metadata),
                                    "azureMetadata" => Ok(__FieldTag::__azure_metadata),
                                    "azure_metadata" => Ok(__FieldTag::__azure_metadata),
                                    "resourcePath" => Ok(__FieldTag::__resource_path),
                                    "resource_path" => Ok(__FieldTag::__resource_path),
                                    "resourcePathString" => Ok(__FieldTag::__resource_path_string),
                                    "resource_path_string" => {
                                        Ok(__FieldTag::__resource_path_string)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Resource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Resource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__cloud_provider => {
                                    if !fields.insert(__FieldTag::__cloud_provider) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for cloud_provider",
                                            ),
                                        );
                                    }
                                    result.cloud_provider = map.next_value::<std::option::Option<crate::model::CloudProvider>>()?.unwrap_or_default();
                                }
                                __FieldTag::__service => {
                                    if !fields.insert(__FieldTag::__service) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for service",
                                            ),
                                        );
                                    }
                                    result.service = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__location => {
                                    if !fields.insert(__FieldTag::__location) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for location",
                                            ),
                                        );
                                    }
                                    result.location = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__gcp_metadata => {
                                    if !fields.insert(__FieldTag::__gcp_metadata) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for gcp_metadata",
                                            ),
                                        );
                                    }
                                    if result.cloud_provider_metadata.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `cloud_provider_metadata`, a oneof with full ID .google.cloud.securitycenter.v2.ListFindingsResponse.ListFindingsResult.Resource.gcp_metadata, latest field was gcpMetadata",
                                            ),
                                        );
                                    }
                                    result.cloud_provider_metadata = std::option::Option::Some(
                                        crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::GcpMetadata(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcpMetadata>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__aws_metadata => {
                                    if !fields.insert(__FieldTag::__aws_metadata) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for aws_metadata",
                                            ),
                                        );
                                    }
                                    if result.cloud_provider_metadata.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `cloud_provider_metadata`, a oneof with full ID .google.cloud.securitycenter.v2.ListFindingsResponse.ListFindingsResult.Resource.aws_metadata, latest field was awsMetadata",
                                            ),
                                        );
                                    }
                                    result.cloud_provider_metadata = std::option::Option::Some(
                                        crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::AwsMetadata(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::AwsMetadata>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__azure_metadata => {
                                    if !fields.insert(__FieldTag::__azure_metadata) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for azure_metadata",
                                            ),
                                        );
                                    }
                                    if result.cloud_provider_metadata.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `cloud_provider_metadata`, a oneof with full ID .google.cloud.securitycenter.v2.ListFindingsResponse.ListFindingsResult.Resource.azure_metadata, latest field was azureMetadata",
                                            ),
                                        );
                                    }
                                    result.cloud_provider_metadata = std::option::Option::Some(
                                        crate::model::list_findings_response::list_findings_result::resource::CloudProviderMetadata::AzureMetadata(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::AzureMetadata>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__resource_path => {
                                    if !fields.insert(__FieldTag::__resource_path) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for resource_path",
                                            ),
                                        );
                                    }
                                    result.resource_path = map.next_value::<std::option::Option<crate::model::ResourcePath>>()?
                                        ;
                                }
                                __FieldTag::__resource_path_string => {
                                    if !fields.insert(__FieldTag::__resource_path_string) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for resource_path_string",
                                            ),
                                        );
                                    }
                                    result.resource_path_string = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Resource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.r#type.is_empty() {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !wkt::internal::is_default(&self.cloud_provider) {
                    state.serialize_entry("cloudProvider", &self.cloud_provider)?;
                }
                if !self.service.is_empty() {
                    state.serialize_entry("service", &self.service)?;
                }
                if !self.location.is_empty() {
                    state.serialize_entry("location", &self.location)?;
                }
                if let Some(value) = self.gcp_metadata() {
                    state.serialize_entry("gcpMetadata", value)?;
                }
                if let Some(value) = self.aws_metadata() {
                    state.serialize_entry("awsMetadata", value)?;
                }
                if let Some(value) = self.azure_metadata() {
                    state.serialize_entry("azureMetadata", value)?;
                }
                if self.resource_path.is_some() {
                    state.serialize_entry("resourcePath", &self.resource_path)?;
                }
                if !self.resource_path_string.is_empty() {
                    state.serialize_entry("resourcePathString", &self.resource_path_string)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Resource {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Resource");
                debug_struct.field("name", &self.name);
                debug_struct.field("display_name", &self.display_name);
                debug_struct.field("r#type", &self.r#type);
                debug_struct.field("cloud_provider", &self.cloud_provider);
                debug_struct.field("service", &self.service);
                debug_struct.field("location", &self.location);
                debug_struct.field("resource_path", &self.resource_path);
                debug_struct.field("resource_path_string", &self.resource_path_string);
                debug_struct.field("cloud_provider_metadata", &self.cloud_provider_metadata);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Resource].
        pub mod resource {
            #[allow(unused_imports)]
            use super::*;

            /// The metadata associated with the cloud provider.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum CloudProviderMetadata {
                /// The GCP metadata associated with the finding.
                GcpMetadata(std::boxed::Box<crate::model::GcpMetadata>),
                /// The AWS metadata associated with the finding.
                AwsMetadata(std::boxed::Box<crate::model::AwsMetadata>),
                /// The Azure metadata associated with the finding.
                AzureMetadata(std::boxed::Box<crate::model::AzureMetadata>),
            }
        }
    }
}

/// Request message for listing  mute configs at a given scope e.g. organization,
/// folder or project. If no location is specified, default is
/// global.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMuteConfigsRequest {
    /// Required. The parent, which owns the collection of mute configs. Its format
    /// is `organizations/[organization_id]", "folders/[folder_id]`,
    /// `projects/[project_id]`,
    /// `organizations/[organization_id]/locations/[location_id]`,
    /// `folders/[folder_id]/locations/[location_id]`,
    /// `projects/[project_id]/locations/[location_id]`.
    pub parent: std::string::String,

    /// The maximum number of configs to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListMuteConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMuteConfigs` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMuteConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMuteConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMuteConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMuteConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMuteConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListMuteConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMuteConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMuteConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMuteConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMuteConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMuteConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMuteConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMuteConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing mute configs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMuteConfigsResponse {
    /// The mute configs from the specified parent.
    pub mute_configs: std::vec::Vec<crate::model::MuteConfig>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMuteConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mute_configs][crate::model::ListMuteConfigsResponse::mute_configs].
    pub fn set_mute_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MuteConfig>,
    {
        use std::iter::Iterator;
        self.mute_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMuteConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMuteConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListMuteConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMuteConfigsResponse {
    type PageItem = crate::model::MuteConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.mute_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMuteConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mute_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMuteConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "muteConfigs" => Ok(__FieldTag::__mute_configs),
                            "mute_configs" => Ok(__FieldTag::__mute_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMuteConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMuteConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mute_configs => {
                            if !fields.insert(__FieldTag::__mute_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_configs",
                                ));
                            }
                            result.mute_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MuteConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMuteConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mute_configs.is_empty() {
            state.serialize_entry("muteConfigs", &self.mute_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMuteConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMuteConfigsResponse");
        debug_struct.field("mute_configs", &self.mute_configs);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing notification configs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotificationConfigsRequest {
    /// Required. The name of the parent in which to list the notification
    /// configurations. Its format is
    /// "organizations/[organization_id]/locations/[location_id]",
    /// "folders/[folder_id]/locations/[location_id]", or
    /// "projects/[project_id]/locations/[location_id]".
    pub parent: std::string::String,

    /// The value returned by the last `ListNotificationConfigsResponse`; indicates
    /// that this is a continuation of a prior `ListNotificationConfigs` call, and
    /// that the system should return the next page of data.
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotificationConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNotificationConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNotificationConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNotificationConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListNotificationConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotificationConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotificationConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotificationConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotificationConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotificationConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListNotificationConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNotificationConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing notification configs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNotificationConfigsResponse {
    /// Notification configs belonging to the requested parent.
    pub notification_configs: std::vec::Vec<crate::model::NotificationConfig>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNotificationConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notification_configs][crate::model::ListNotificationConfigsResponse::notification_configs].
    pub fn set_notification_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NotificationConfig>,
    {
        use std::iter::Iterator;
        self.notification_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNotificationConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListNotificationConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListNotificationConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNotificationConfigsResponse {
    type PageItem = crate::model::NotificationConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.notification_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNotificationConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notification_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNotificationConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notificationConfigs" => Ok(__FieldTag::__notification_configs),
                            "notification_configs" => Ok(__FieldTag::__notification_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNotificationConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNotificationConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notification_configs => {
                            if !fields.insert(__FieldTag::__notification_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_configs",
                                ));
                            }
                            result.notification_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NotificationConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNotificationConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.notification_configs.is_empty() {
            state.serialize_entry("notificationConfigs", &self.notification_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListNotificationConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNotificationConfigsResponse");
        debug_struct.field("notification_configs", &self.notification_configs);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to list resource value configs of a parent
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListResourceValueConfigsRequest {
    /// Required. The parent, which owns the collection of resource value configs.
    /// Its format is
    /// `organizations/[organization_id]`
    pub parent: std::string::String,

    /// The maximum number of configs to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListResourceValueConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListResourceValueConfigs` must match the call that provided the
    /// page token.
    ///
    /// page_size can be specified, and the new page_size will be used.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListResourceValueConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListResourceValueConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListResourceValueConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListResourceValueConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListResourceValueConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListResourceValueConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListResourceValueConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListResourceValueConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListResourceValueConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListResourceValueConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListResourceValueConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListResourceValueConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListResourceValueConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message to list resource value configs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListResourceValueConfigsResponse {
    /// The resource value configs from the specified parent.
    pub resource_value_configs: std::vec::Vec<crate::model::ResourceValueConfig>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is empty, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListResourceValueConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_value_configs][crate::model::ListResourceValueConfigsResponse::resource_value_configs].
    pub fn set_resource_value_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceValueConfig>,
    {
        use std::iter::Iterator;
        self.resource_value_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListResourceValueConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListResourceValueConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListResourceValueConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListResourceValueConfigsResponse {
    type PageItem = crate::model::ResourceValueConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resource_value_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListResourceValueConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_value_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListResourceValueConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceValueConfigs" => Ok(__FieldTag::__resource_value_configs),
                            "resource_value_configs" => Ok(__FieldTag::__resource_value_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListResourceValueConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListResourceValueConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_value_configs => {
                            if !fields.insert(__FieldTag::__resource_value_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value_configs",
                                ));
                            }
                            result.resource_value_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceValueConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListResourceValueConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_value_configs.is_empty() {
            state.serialize_entry("resourceValueConfigs", &self.resource_value_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListResourceValueConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListResourceValueConfigsResponse");
        debug_struct.field("resource_value_configs", &self.resource_value_configs);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing sources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesRequest {
    /// Required. Resource name of the parent of sources to list. Its format should
    /// be `organizations/[organization_id]`, `folders/[folder_id]`, or
    /// `projects/[project_id]`.
    pub parent: std::string::String,

    /// The value returned by the last `ListSourcesResponse`; indicates
    /// that this is a continuation of a prior `ListSources` call, and
    /// that the system should return the next page of data.
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing sources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesResponse {
    /// Sources belonging to the requested parent.
    pub sources: std::vec::Vec<crate::model::Source>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sources][crate::model::ListSourcesResponse::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Source>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSourcesResponse {
    type PageItem = crate::model::Source;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sources,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sources" => Ok(__FieldTag::__sources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sources",
                                ));
                            }
                            result.sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Source>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesResponse");
        debug_struct.field("sources", &self.sources);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing the valued resources for a given simulation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListValuedResourcesRequest {
    /// Required. Name of parent to list exposed resources.
    ///
    /// Valid formats:
    /// `organizations/{organization}`,
    /// `organizations/{organization}/simulations/{simulation}`
    /// `organizations/{organization}/simulations/{simulation}/attackExposureResults/{attack_exposure_result_v2}`
    pub parent: std::string::String,

    /// The filter expression that filters the valued resources in the response.
    /// Supported fields:
    ///
    /// * `resource_value` supports =
    /// * `resource_type` supports =
    pub filter: std::string::String,

    /// The value returned by the last `ListValuedResourcesResponse`; indicates
    /// that this is a continuation of a prior `ListValuedResources` call, and
    /// that the system should return the next page of data.
    pub page_token: std::string::String,

    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    pub page_size: i32,

    /// Optional. The fields by which to order the valued resources response.
    ///
    /// Supported fields:
    ///
    /// * `exposed_score`
    ///
    /// * `resource_value`
    ///
    /// * `resource_type`
    ///
    ///
    /// Values should be a comma separated list of fields. For example:
    /// `exposed_score,resource_value`.
    ///
    /// The default sorting order is descending. To specify ascending or descending
    /// order for a field, append a " ASC" or a " DESC" suffix, respectively; for
    /// example: `exposed_score DESC`.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListValuedResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListValuedResourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListValuedResourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListValuedResourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListValuedResourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListValuedResourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListValuedResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListValuedResourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListValuedResourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_token,
            __page_size,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListValuedResourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListValuedResourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListValuedResourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListValuedResourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListValuedResourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListValuedResourcesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing the valued resources for a given simulation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListValuedResourcesResponse {
    /// The valued resources that the attack path simulation identified.
    pub valued_resources: std::vec::Vec<crate::model::ValuedResource>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    pub next_page_token: std::string::String,

    /// The estimated total number of results matching the query.
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListValuedResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [valued_resources][crate::model::ListValuedResourcesResponse::valued_resources].
    pub fn set_valued_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ValuedResource>,
    {
        use std::iter::Iterator;
        self.valued_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListValuedResourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListValuedResourcesResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListValuedResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ListValuedResourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListValuedResourcesResponse {
    type PageItem = crate::model::ValuedResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.valued_resources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListValuedResourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __valued_resources,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListValuedResourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "valuedResources" => Ok(__FieldTag::__valued_resources),
                            "valued_resources" => Ok(__FieldTag::__valued_resources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListValuedResourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListValuedResourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__valued_resources => {
                            if !fields.insert(__FieldTag::__valued_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valued_resources",
                                ));
                            }
                            result.valued_resources =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ValuedResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListValuedResourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.valued_resources.is_empty() {
            state.serialize_entry("valuedResources", &self.valued_resources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListValuedResourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListValuedResourcesResponse");
        debug_struct.field("valued_resources", &self.valued_resources);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("total_size", &self.total_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a finding's state.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetFindingStateRequest {
    /// Required. The [relative resource
    /// name](https://cloud.google.com/apis/design/resource_names#relative_resource_name)
    /// of the finding. If no location is specified, finding is assumed to be in
    /// global. The following list shows some examples:
    ///
    ///
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}`
    /// +
    /// `organizations/{organization_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `folders/{folder_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `folders/{folder_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `projects/{project_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `projects/{project_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    pub name: std::string::String,

    /// Required. The desired State of the finding.
    pub state: crate::model::finding::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetFindingStateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SetFindingStateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::SetFindingStateRequest::state].
    pub fn set_state<T: std::convert::Into<crate::model::finding::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for SetFindingStateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.SetFindingStateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetFindingStateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetFindingStateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetFindingStateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetFindingStateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::finding::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetFindingStateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetFindingStateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetFindingStateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a finding's mute status.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetMuteRequest {
    /// Required. The [relative resource
    /// name](https://cloud.google.com/apis/design/resource_names#relative_resource_name)
    /// of the finding. If no location is specified, finding is assumed to be in
    /// global. The following list shows some examples:
    ///
    ///
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}`
    /// +
    /// `organizations/{organization_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `folders/{folder_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `folders/{folder_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    ///
    /// + `projects/{project_id}/sources/{source_id}/findings/{finding_id}`
    ///
    /// `projects/{project_id}/sources/{source_id}/locations/{location_id}/findings/{finding_id}`
    pub name: std::string::String,

    /// Required. The desired state of the Mute.
    pub mute: crate::model::finding::Mute,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetMuteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SetMuteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mute][crate::model::SetMuteRequest::mute].
    pub fn set_mute<T: std::convert::Into<crate::model::finding::Mute>>(mut self, v: T) -> Self {
        self.mute = v.into();
        self
    }
}

impl wkt::message::Message for SetMuteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.SetMuteRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetMuteRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __mute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetMuteRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "mute" => Ok(__FieldTag::__mute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetMuteRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetMuteRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mute => {
                            if !fields.insert(__FieldTag::__mute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute",
                                ));
                            }
                            result.mute = map
                                .next_value::<std::option::Option<crate::model::finding::Mute>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetMuteRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.mute) {
            state.serialize_entry("mute", &self.mute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetMuteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetMuteRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("mute", &self.mute);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a BigQuery export.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBigQueryExportRequest {
    /// Required. The BigQuery export being updated.
    pub big_query_export: std::option::Option<crate::model::BigQueryExport>,

    /// The list of fields to be updated.
    /// If empty all mutable fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBigQueryExportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [big_query_export][crate::model::UpdateBigQueryExportRequest::big_query_export].
    pub fn set_big_query_export<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryExport>,
    {
        self.big_query_export = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [big_query_export][crate::model::UpdateBigQueryExportRequest::big_query_export].
    pub fn set_or_clear_big_query_export<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigQueryExport>,
    {
        self.big_query_export = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBigQueryExportRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBigQueryExportRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBigQueryExportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateBigQueryExportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBigQueryExportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __big_query_export,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBigQueryExportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigQueryExport" => Ok(__FieldTag::__big_query_export),
                            "big_query_export" => Ok(__FieldTag::__big_query_export),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBigQueryExportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBigQueryExportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__big_query_export => {
                            if !fields.insert(__FieldTag::__big_query_export) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_export",
                                ));
                            }
                            result.big_query_export = map
                                .next_value::<std::option::Option<crate::model::BigQueryExport>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBigQueryExportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.big_query_export.is_some() {
            state.serialize_entry("bigQueryExport", &self.big_query_export)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateBigQueryExportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateBigQueryExportRequest");
        debug_struct.field("big_query_export", &self.big_query_export);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a ExternalSystem resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateExternalSystemRequest {
    /// Required. The external system resource to update.
    pub external_system: std::option::Option<crate::model::ExternalSystem>,

    /// The FieldMask to use when updating the external system resource.
    ///
    /// If empty all mutable fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateExternalSystemRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_system][crate::model::UpdateExternalSystemRequest::external_system].
    pub fn set_external_system<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExternalSystem>,
    {
        self.external_system = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_system][crate::model::UpdateExternalSystemRequest::external_system].
    pub fn set_or_clear_external_system<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExternalSystem>,
    {
        self.external_system = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateExternalSystemRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExternalSystemRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateExternalSystemRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateExternalSystemRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateExternalSystemRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __external_system,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateExternalSystemRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "externalSystem" => Ok(__FieldTag::__external_system),
                            "external_system" => Ok(__FieldTag::__external_system),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateExternalSystemRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateExternalSystemRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__external_system => {
                            if !fields.insert(__FieldTag::__external_system) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_system",
                                ));
                            }
                            result.external_system = map
                                .next_value::<std::option::Option<crate::model::ExternalSystem>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateExternalSystemRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.external_system.is_some() {
            state.serialize_entry("externalSystem", &self.external_system)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateExternalSystemRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateExternalSystemRequest");
        debug_struct.field("external_system", &self.external_system);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating or creating a finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFindingRequest {
    /// Required. The finding resource to update or create if it does not already
    /// exist. parent, security_marks, and update_time will be ignored.
    ///
    /// In the case of creation, the finding id portion of the name must be
    /// alphanumeric and less than or equal to 32 characters and greater than 0
    /// characters in length.
    pub finding: std::option::Option<crate::model::Finding>,

    /// The FieldMask to use when updating the finding resource. This field should
    /// not be specified when creating a finding.
    ///
    /// When updating a finding, an empty mask is treated as updating all mutable
    /// fields and replacing source_properties.  Individual source_properties can
    /// be added/updated by using "source_properties.\<property key\>" in the field
    /// mask.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [finding][crate::model::UpdateFindingRequest::finding].
    pub fn set_finding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Finding>,
    {
        self.finding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finding][crate::model::UpdateFindingRequest::finding].
    pub fn set_or_clear_finding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Finding>,
    {
        self.finding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFindingRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFindingRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateFindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateFindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __finding,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "finding" => Ok(__FieldTag::__finding),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__finding => {
                            if !fields.insert(__FieldTag::__finding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding",
                                ));
                            }
                            result.finding =
                                map.next_value::<std::option::Option<crate::model::Finding>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateFindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.finding.is_some() {
            state.serialize_entry("finding", &self.finding)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateFindingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateFindingRequest");
        debug_struct.field("finding", &self.finding);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a mute config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMuteConfigRequest {
    /// Required. The mute config being updated.
    pub mute_config: std::option::Option<crate::model::MuteConfig>,

    /// The list of fields to be updated.
    /// If empty all mutable fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMuteConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mute_config][crate::model::UpdateMuteConfigRequest::mute_config].
    pub fn set_mute_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MuteConfig>,
    {
        self.mute_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mute_config][crate::model::UpdateMuteConfigRequest::mute_config].
    pub fn set_or_clear_mute_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MuteConfig>,
    {
        self.mute_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateMuteConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateMuteConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateMuteConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateMuteConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMuteConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mute_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMuteConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "muteConfig" => Ok(__FieldTag::__mute_config),
                            "mute_config" => Ok(__FieldTag::__mute_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMuteConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMuteConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mute_config => {
                            if !fields.insert(__FieldTag::__mute_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mute_config",
                                ));
                            }
                            result.mute_config =
                                map.next_value::<std::option::Option<crate::model::MuteConfig>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMuteConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mute_config.is_some() {
            state.serialize_entry("muteConfig", &self.mute_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateMuteConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateMuteConfigRequest");
        debug_struct.field("mute_config", &self.mute_config);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a notification config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNotificationConfigRequest {
    /// Required. The notification config to update.
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// The FieldMask to use when updating the notification config.
    ///
    /// If empty all mutable fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNotificationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notification_config][crate::model::UpdateNotificationConfigRequest::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::UpdateNotificationConfigRequest::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateNotificationConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNotificationConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNotificationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateNotificationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateNotificationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notification_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNotificationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateNotificationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNotificationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateNotificationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateNotificationConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateNotificationConfigRequest");
        debug_struct.field("notification_config", &self.notification_config);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to update resource value config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateResourceValueConfigRequest {
    /// Required. The resource value config being updated.
    pub resource_value_config: std::option::Option<crate::model::ResourceValueConfig>,

    /// The list of fields to be updated.
    /// If empty all mutable fields will be updated.
    ///
    /// To update nested fields, include the top level field in the mask
    /// For example, to update gcp_metadata.resource_type, include the
    /// "gcp_metadata" field mask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateResourceValueConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_value_config][crate::model::UpdateResourceValueConfigRequest::resource_value_config].
    pub fn set_resource_value_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceValueConfig>,
    {
        self.resource_value_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_value_config][crate::model::UpdateResourceValueConfigRequest::resource_value_config].
    pub fn set_or_clear_resource_value_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceValueConfig>,
    {
        self.resource_value_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateResourceValueConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateResourceValueConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateResourceValueConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateResourceValueConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateResourceValueConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_value_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateResourceValueConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceValueConfig" => Ok(__FieldTag::__resource_value_config),
                            "resource_value_config" => Ok(__FieldTag::__resource_value_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateResourceValueConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateResourceValueConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_value_config => {
                            if !fields.insert(__FieldTag::__resource_value_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value_config",
                                ));
                            }
                            result.resource_value_config = map.next_value::<std::option::Option<crate::model::ResourceValueConfig>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateResourceValueConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource_value_config.is_some() {
            state.serialize_entry("resourceValueConfig", &self.resource_value_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateResourceValueConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateResourceValueConfigRequest");
        debug_struct.field("resource_value_config", &self.resource_value_config);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a SecurityMarks resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSecurityMarksRequest {
    /// Required. The security marks resource to update.
    pub security_marks: std::option::Option<crate::model::SecurityMarks>,

    /// The FieldMask to use when updating the security marks resource.
    ///
    /// The field mask must not contain duplicate fields.
    /// If empty or set to "marks", all marks will be replaced.  Individual
    /// marks can be updated using "marks.<mark_key>".
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSecurityMarksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [security_marks][crate::model::UpdateSecurityMarksRequest::security_marks].
    pub fn set_security_marks<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityMarks>,
    {
        self.security_marks = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_marks][crate::model::UpdateSecurityMarksRequest::security_marks].
    pub fn set_or_clear_security_marks<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityMarks>,
    {
        self.security_marks = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSecurityMarksRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSecurityMarksRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSecurityMarksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateSecurityMarksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSecurityMarksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __security_marks,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSecurityMarksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "securityMarks" => Ok(__FieldTag::__security_marks),
                            "security_marks" => Ok(__FieldTag::__security_marks),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSecurityMarksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSecurityMarksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__security_marks => {
                            if !fields.insert(__FieldTag::__security_marks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_marks",
                                ));
                            }
                            result.security_marks = map
                                .next_value::<std::option::Option<crate::model::SecurityMarks>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSecurityMarksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.security_marks.is_some() {
            state.serialize_entry("securityMarks", &self.security_marks)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSecurityMarksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSecurityMarksRequest");
        debug_struct.field("security_marks", &self.security_marks);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for updating a source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSourceRequest {
    /// Required. The source resource to update.
    pub source: std::option::Option<crate::model::Source>,

    /// The FieldMask to use when updating the source resource.
    ///
    /// If empty all mutable fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.UpdateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSourceRequest");
        debug_struct.field("source", &self.source);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Attack path simulation
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Simulation {
    /// Full resource name of the Simulation:
    /// `organizations/123/simulations/456`
    pub name: std::string::String,

    /// Output only. Time simulation was created
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Resource value configurations' metadata used in this simulation. Maximum of
    /// 100.
    pub resource_value_configs_metadata: std::vec::Vec<crate::model::ResourceValueConfigMetadata>,

    /// Indicates which cloud provider was used in this simulation.
    pub cloud_provider: crate::model::CloudProvider,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Simulation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Simulation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Simulation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Simulation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_value_configs_metadata][crate::model::Simulation::resource_value_configs_metadata].
    pub fn set_resource_value_configs_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceValueConfigMetadata>,
    {
        use std::iter::Iterator;
        self.resource_value_configs_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cloud_provider][crate::model::Simulation::cloud_provider].
    pub fn set_cloud_provider<T: std::convert::Into<crate::model::CloudProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_provider = v.into();
        self
    }
}

impl wkt::message::Message for Simulation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Simulation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Simulation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __resource_value_configs_metadata,
            __cloud_provider,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Simulation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "resourceValueConfigsMetadata" => {
                                Ok(__FieldTag::__resource_value_configs_metadata)
                            }
                            "resource_value_configs_metadata" => {
                                Ok(__FieldTag::__resource_value_configs_metadata)
                            }
                            "cloudProvider" => Ok(__FieldTag::__cloud_provider),
                            "cloud_provider" => Ok(__FieldTag::__cloud_provider),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Simulation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Simulation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resource_value_configs_metadata => {
                            if !fields.insert(__FieldTag::__resource_value_configs_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value_configs_metadata",
                                ));
                            }
                            result.resource_value_configs_metadata = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceValueConfigMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_provider => {
                            if !fields.insert(__FieldTag::__cloud_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_provider",
                                ));
                            }
                            result.cloud_provider = map
                                .next_value::<std::option::Option<crate::model::CloudProvider>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Simulation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.resource_value_configs_metadata.is_empty() {
            state.serialize_entry(
                "resourceValueConfigsMetadata",
                &self.resource_value_configs_metadata,
            )?;
        }
        if !wkt::internal::is_default(&self.cloud_provider) {
            state.serialize_entry("cloudProvider", &self.cloud_provider)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Simulation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Simulation");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field(
            "resource_value_configs_metadata",
            &self.resource_value_configs_metadata,
        );
        debug_struct.field("cloud_provider", &self.cloud_provider);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Security Command Center finding source. A finding source
/// is an entity or a mechanism that can produce a finding. A source is like a
/// container of findings that come from the same scanner, logger, monitor, and
/// other tools.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Source {
    /// The relative resource name of this source. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// Example:
    /// "organizations/{organization_id}/sources/{source_id}"
    pub name: std::string::String,

    /// The source's display name.
    /// A source's display name must be unique amongst its siblings, for example,
    /// two sources with the same parent can't share the same display name.
    /// The display name must have a length between 1 and 64 characters
    /// (inclusive).
    pub display_name: std::string::String,

    /// The description of the source (max of 1024 characters).
    /// Example:
    /// "Web Security Scanner is a web security scanner for common
    /// vulnerabilities in App Engine applications. It can automatically
    /// scan and detect four common vulnerabilities, including cross-site-scripting
    /// (XSS), Flash injection, mixed content (HTTP in HTTPS), and
    /// outdated or insecure libraries."
    pub description: std::string::String,

    /// The canonical name of the finding source. It's either
    /// "organizations/{organization_id}/sources/{source_id}",
    /// "folders/{folder_id}/sources/{source_id}", or
    /// "projects/{project_number}/sources/{source_id}",
    /// depending on the closest CRM ancestor of the resource associated with the
    /// finding.
    pub canonical_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Source::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Source::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Source::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [canonical_name][crate::model::Source::canonical_name].
    pub fn set_canonical_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.canonical_name = v.into();
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Source"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __canonical_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "canonicalName" => Ok(__FieldTag::__canonical_name),
                            "canonical_name" => Ok(__FieldTag::__canonical_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__canonical_name => {
                            if !fields.insert(__FieldTag::__canonical_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_name",
                                ));
                            }
                            result.canonical_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Source {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.canonical_name.is_empty() {
            state.serialize_entry("canonicalName", &self.canonical_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("canonical_name", &self.canonical_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains details about a group of security issues that, when the issues
/// occur together, represent a greater risk than when the issues occur
/// independently. A group of such issues is referred to as a toxic
/// combination.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ToxicCombination {
    /// The
    /// [Attack exposure
    /// score](https://cloud.google.com/security-command-center/docs/attack-exposure-learn#attack_exposure_scores)
    /// of this toxic combination. The score is a measure of how much this toxic
    /// combination exposes one or more high-value resources to potential attack.
    pub attack_exposure_score: f64,

    /// List of resource names of findings associated with this toxic combination.
    /// For example, `organizations/123/sources/456/findings/789`.
    pub related_findings: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ToxicCombination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attack_exposure_score][crate::model::ToxicCombination::attack_exposure_score].
    pub fn set_attack_exposure_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.attack_exposure_score = v.into();
        self
    }

    /// Sets the value of [related_findings][crate::model::ToxicCombination::related_findings].
    pub fn set_related_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ToxicCombination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ToxicCombination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ToxicCombination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attack_exposure_score,
            __related_findings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ToxicCombination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attackExposureScore" => Ok(__FieldTag::__attack_exposure_score),
                            "attack_exposure_score" => Ok(__FieldTag::__attack_exposure_score),
                            "relatedFindings" => Ok(__FieldTag::__related_findings),
                            "related_findings" => Ok(__FieldTag::__related_findings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ToxicCombination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ToxicCombination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attack_exposure_score => {
                            if !fields.insert(__FieldTag::__attack_exposure_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_exposure_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.attack_exposure_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__related_findings => {
                            if !fields.insert(__FieldTag::__related_findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_findings",
                                ));
                            }
                            result.related_findings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ToxicCombination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.attack_exposure_score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("attackExposureScore", &__With(&self.attack_exposure_score))?;
        }
        if !self.related_findings.is_empty() {
            state.serialize_entry("relatedFindings", &self.related_findings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ToxicCombination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ToxicCombination");
        debug_struct.field("attack_exposure_score", &self.attack_exposure_score);
        debug_struct.field("related_findings", &self.related_findings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that is determined to have value to a user's system
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValuedResource {
    /// Valued resource name, for example,
    /// e.g.:
    /// `organizations/123/simulations/456/valuedResources/789`
    pub name: std::string::String,

    /// The
    /// [full resource
    /// name](https://cloud.google.com/apis/design/resource_names#full_resource_name)
    /// of the valued resource.
    pub resource: std::string::String,

    /// The [resource
    /// type](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
    /// of the valued resource.
    pub resource_type: std::string::String,

    /// Human-readable name of the valued resource.
    pub display_name: std::string::String,

    /// How valuable this resource is.
    pub resource_value: crate::model::valued_resource::ResourceValue,

    /// Exposed score for this valued resource. A value of 0 means no exposure was
    /// detected exposure.
    pub exposed_score: f64,

    /// List of resource value configurations' metadata used to determine the value
    /// of this resource. Maximum of 100.
    pub resource_value_configs_used: std::vec::Vec<crate::model::ResourceValueConfigMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValuedResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValuedResource::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::ValuedResource::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::ValuedResource::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ValuedResource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [resource_value][crate::model::ValuedResource::resource_value].
    pub fn set_resource_value<
        T: std::convert::Into<crate::model::valued_resource::ResourceValue>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_value = v.into();
        self
    }

    /// Sets the value of [exposed_score][crate::model::ValuedResource::exposed_score].
    pub fn set_exposed_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.exposed_score = v.into();
        self
    }

    /// Sets the value of [resource_value_configs_used][crate::model::ValuedResource::resource_value_configs_used].
    pub fn set_resource_value_configs_used<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceValueConfigMetadata>,
    {
        use std::iter::Iterator;
        self.resource_value_configs_used = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValuedResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ValuedResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValuedResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __resource,
            __resource_type,
            __display_name,
            __resource_value,
            __exposed_score,
            __resource_value_configs_used,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValuedResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "resource" => Ok(__FieldTag::__resource),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "resourceValue" => Ok(__FieldTag::__resource_value),
                            "resource_value" => Ok(__FieldTag::__resource_value),
                            "exposedScore" => Ok(__FieldTag::__exposed_score),
                            "exposed_score" => Ok(__FieldTag::__exposed_score),
                            "resourceValueConfigsUsed" => {
                                Ok(__FieldTag::__resource_value_configs_used)
                            }
                            "resource_value_configs_used" => {
                                Ok(__FieldTag::__resource_value_configs_used)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValuedResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValuedResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_value => {
                            if !fields.insert(__FieldTag::__resource_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value",
                                ));
                            }
                            result.resource_value =
                                map.next_value::<std::option::Option<
                                    crate::model::valued_resource::ResourceValue,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exposed_score => {
                            if !fields.insert(__FieldTag::__exposed_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exposed_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exposed_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__resource_value_configs_used => {
                            if !fields.insert(__FieldTag::__resource_value_configs_used) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_value_configs_used",
                                ));
                            }
                            result.resource_value_configs_used = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResourceValueConfigMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValuedResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.resource_value) {
            state.serialize_entry("resourceValue", &self.resource_value)?;
        }
        if !wkt::internal::is_default(&self.exposed_score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exposedScore", &__With(&self.exposed_score))?;
        }
        if !self.resource_value_configs_used.is_empty() {
            state.serialize_entry(
                "resourceValueConfigsUsed",
                &self.resource_value_configs_used,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValuedResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValuedResource");
        debug_struct.field("name", &self.name);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("resource_value", &self.resource_value);
        debug_struct.field("exposed_score", &self.exposed_score);
        debug_struct.field(
            "resource_value_configs_used",
            &self.resource_value_configs_used,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ValuedResource].
pub mod valued_resource {
    #[allow(unused_imports)]
    use super::*;

    /// How valuable the resource is.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceValue {
        /// The resource value isn't specified.
        Unspecified,
        /// This is a low-value resource.
        Low,
        /// This is a medium-value resource.
        Medium,
        /// This is a high-value resource.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResourceValue::value] or
        /// [ResourceValue::name].
        UnknownValue(resource_value::UnknownValue),
    }

    #[doc(hidden)]
    pub mod resource_value {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResourceValue {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESOURCE_VALUE_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("RESOURCE_VALUE_LOW"),
                Self::Medium => std::option::Option::Some("RESOURCE_VALUE_MEDIUM"),
                Self::High => std::option::Option::Some("RESOURCE_VALUE_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResourceValue {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResourceValue {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResourceValue {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::Medium,
                3 => Self::High,
                _ => Self::UnknownValue(resource_value::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResourceValue {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESOURCE_VALUE_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_VALUE_LOW" => Self::Low,
                "RESOURCE_VALUE_MEDIUM" => Self::Medium,
                "RESOURCE_VALUE_HIGH" => Self::High,
                _ => Self::UnknownValue(resource_value::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResourceValue {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResourceValue {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceValue>::new(
                ".google.cloud.securitycenter.v2.ValuedResource.ResourceValue",
            ))
        }
    }
}

/// Metadata about a ResourceValueConfig. For example, id and name.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceValueConfigMetadata {
    /// Resource value config name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceValueConfigMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceValueConfigMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResourceValueConfigMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.ResourceValueConfigMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceValueConfigMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceValueConfigMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceValueConfigMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceValueConfigMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceValueConfigMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceValueConfigMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceValueConfigMetadata");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Vertex AI-related information associated with the finding.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VertexAi {
    /// Datasets associated with the finding.
    pub datasets: std::vec::Vec<crate::model::vertex_ai::Dataset>,

    /// Pipelines associated with the finding.
    pub pipelines: std::vec::Vec<crate::model::vertex_ai::Pipeline>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VertexAi {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datasets][crate::model::VertexAi::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vertex_ai::Dataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pipelines][crate::model::VertexAi::pipelines].
    pub fn set_pipelines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vertex_ai::Pipeline>,
    {
        use std::iter::Iterator;
        self.pipelines = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VertexAi {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.VertexAi"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VertexAi {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datasets,
            __pipelines,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VertexAi")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasets" => Ok(__FieldTag::__datasets),
                            "pipelines" => Ok(__FieldTag::__pipelines),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VertexAi;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VertexAi")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datasets",
                                ));
                            }
                            result.datasets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vertex_ai::Dataset>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pipelines => {
                            if !fields.insert(__FieldTag::__pipelines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pipelines",
                                ));
                            }
                            result.pipelines = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vertex_ai::Pipeline>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VertexAi {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if !self.pipelines.is_empty() {
            state.serialize_entry("pipelines", &self.pipelines)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VertexAi {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VertexAi");
        debug_struct.field("datasets", &self.datasets);
        debug_struct.field("pipelines", &self.pipelines);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VertexAi].
pub mod vertex_ai {
    #[allow(unused_imports)]
    use super::*;

    /// Vertex AI dataset associated with the finding.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Dataset {
        /// Resource name of the dataset, e.g.
        /// projects/{project}/locations/{location}/datasets/2094040236064505856
        pub name: std::string::String,

        /// The user defined display name of dataset, e.g. plants-dataset
        pub display_name: std::string::String,

        /// Data source, such as a BigQuery source URI, e.g.
        /// bq://scc-nexus-test.AIPPtest.gsod
        pub source: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Dataset {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vertex_ai::Dataset::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::vertex_ai::Dataset::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [source][crate::model::vertex_ai::Dataset::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }
    }

    impl wkt::message::Message for Dataset {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.VertexAi.Dataset"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Dataset {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __display_name,
                __source,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Dataset")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "source" => Ok(__FieldTag::__source),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Dataset;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Dataset")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__source => {
                                if !fields.insert(__FieldTag::__source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source",
                                    ));
                                }
                                result.source = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Dataset {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.source.is_empty() {
                state.serialize_entry("source", &self.source)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Dataset {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Dataset");
            debug_struct.field("name", &self.name);
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("source", &self.source);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Vertex AI training pipeline associated with the finding.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Pipeline {
        /// Resource name of the pipeline, e.g.
        /// projects/{project}/locations/{location}/trainingPipelines/5253428229225578496
        pub name: std::string::String,

        /// The user-defined display name of pipeline, e.g. plants-classification
        pub display_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Pipeline {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::vertex_ai::Pipeline::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::vertex_ai::Pipeline::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }
    }

    impl wkt::message::Message for Pipeline {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.securitycenter.v2.VertexAi.Pipeline"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Pipeline {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __display_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Pipeline")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Pipeline;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Pipeline")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Pipeline {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Pipeline {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Pipeline");
            debug_struct.field("name", &self.name);
            debug_struct.field("display_name", &self.display_name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Refers to common vulnerability fields e.g. cve, cvss, cwe etc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Vulnerability {
    /// CVE stands for Common Vulnerabilities and Exposures
    /// (<https://cve.mitre.org/about/>)
    pub cve: std::option::Option<crate::model::Cve>,

    /// The offending package is relevant to the finding.
    pub offending_package: std::option::Option<crate::model::Package>,

    /// The fixed package is relevant to the finding.
    pub fixed_package: std::option::Option<crate::model::Package>,

    /// The security bulletin is relevant to this finding.
    pub security_bulletin: std::option::Option<crate::model::SecurityBulletin>,

    /// Provider provided risk_score based on multiple factors. The higher the risk
    /// score, the more risky the vulnerability is.
    pub provider_risk_score: i64,

    /// Represents whether the vulnerability is reachable (detected via static
    /// analysis)
    pub reachable: bool,

    /// Represents one or more Common Weakness Enumeration (CWE) information on
    /// this vulnerability.
    pub cwes: std::vec::Vec<crate::model::Cwe>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Vulnerability {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cve][crate::model::Vulnerability::cve].
    pub fn set_cve<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cve>,
    {
        self.cve = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cve][crate::model::Vulnerability::cve].
    pub fn set_or_clear_cve<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cve>,
    {
        self.cve = v.map(|x| x.into());
        self
    }

    /// Sets the value of [offending_package][crate::model::Vulnerability::offending_package].
    pub fn set_offending_package<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Package>,
    {
        self.offending_package = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [offending_package][crate::model::Vulnerability::offending_package].
    pub fn set_or_clear_offending_package<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Package>,
    {
        self.offending_package = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fixed_package][crate::model::Vulnerability::fixed_package].
    pub fn set_fixed_package<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Package>,
    {
        self.fixed_package = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fixed_package][crate::model::Vulnerability::fixed_package].
    pub fn set_or_clear_fixed_package<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Package>,
    {
        self.fixed_package = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_bulletin][crate::model::Vulnerability::security_bulletin].
    pub fn set_security_bulletin<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityBulletin>,
    {
        self.security_bulletin = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_bulletin][crate::model::Vulnerability::security_bulletin].
    pub fn set_or_clear_security_bulletin<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityBulletin>,
    {
        self.security_bulletin = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provider_risk_score][crate::model::Vulnerability::provider_risk_score].
    pub fn set_provider_risk_score<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.provider_risk_score = v.into();
        self
    }

    /// Sets the value of [reachable][crate::model::Vulnerability::reachable].
    pub fn set_reachable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reachable = v.into();
        self
    }

    /// Sets the value of [cwes][crate::model::Vulnerability::cwes].
    pub fn set_cwes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cwe>,
    {
        use std::iter::Iterator;
        self.cwes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Vulnerability {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Vulnerability"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Vulnerability {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cve,
            __offending_package,
            __fixed_package,
            __security_bulletin,
            __provider_risk_score,
            __reachable,
            __cwes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Vulnerability")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cve" => Ok(__FieldTag::__cve),
                            "offendingPackage" => Ok(__FieldTag::__offending_package),
                            "offending_package" => Ok(__FieldTag::__offending_package),
                            "fixedPackage" => Ok(__FieldTag::__fixed_package),
                            "fixed_package" => Ok(__FieldTag::__fixed_package),
                            "securityBulletin" => Ok(__FieldTag::__security_bulletin),
                            "security_bulletin" => Ok(__FieldTag::__security_bulletin),
                            "providerRiskScore" => Ok(__FieldTag::__provider_risk_score),
                            "provider_risk_score" => Ok(__FieldTag::__provider_risk_score),
                            "reachable" => Ok(__FieldTag::__reachable),
                            "cwes" => Ok(__FieldTag::__cwes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Vulnerability;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Vulnerability")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cve => {
                            if !fields.insert(__FieldTag::__cve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve",
                                ));
                            }
                            result.cve =
                                map.next_value::<std::option::Option<crate::model::Cve>>()?;
                        }
                        __FieldTag::__offending_package => {
                            if !fields.insert(__FieldTag::__offending_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offending_package",
                                ));
                            }
                            result.offending_package =
                                map.next_value::<std::option::Option<crate::model::Package>>()?;
                        }
                        __FieldTag::__fixed_package => {
                            if !fields.insert(__FieldTag::__fixed_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_package",
                                ));
                            }
                            result.fixed_package =
                                map.next_value::<std::option::Option<crate::model::Package>>()?;
                        }
                        __FieldTag::__security_bulletin => {
                            if !fields.insert(__FieldTag::__security_bulletin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_bulletin",
                                ));
                            }
                            result.security_bulletin = map
                                .next_value::<std::option::Option<crate::model::SecurityBulletin>>(
                                )?;
                        }
                        __FieldTag::__provider_risk_score => {
                            if !fields.insert(__FieldTag::__provider_risk_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provider_risk_score",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.provider_risk_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__reachable => {
                            if !fields.insert(__FieldTag::__reachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reachable",
                                ));
                            }
                            result.reachable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cwes => {
                            if !fields.insert(__FieldTag::__cwes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cwes",
                                ));
                            }
                            result.cwes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cwe>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Vulnerability {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cve.is_some() {
            state.serialize_entry("cve", &self.cve)?;
        }
        if self.offending_package.is_some() {
            state.serialize_entry("offendingPackage", &self.offending_package)?;
        }
        if self.fixed_package.is_some() {
            state.serialize_entry("fixedPackage", &self.fixed_package)?;
        }
        if self.security_bulletin.is_some() {
            state.serialize_entry("securityBulletin", &self.security_bulletin)?;
        }
        if !wkt::internal::is_default(&self.provider_risk_score) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("providerRiskScore", &__With(&self.provider_risk_score))?;
        }
        if !wkt::internal::is_default(&self.reachable) {
            state.serialize_entry("reachable", &self.reachable)?;
        }
        if !self.cwes.is_empty() {
            state.serialize_entry("cwes", &self.cwes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Vulnerability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vulnerability");
        debug_struct.field("cve", &self.cve);
        debug_struct.field("offending_package", &self.offending_package);
        debug_struct.field("fixed_package", &self.fixed_package);
        debug_struct.field("security_bulletin", &self.security_bulletin);
        debug_struct.field("provider_risk_score", &self.provider_risk_score);
        debug_struct.field("reachable", &self.reachable);
        debug_struct.field("cwes", &self.cwes);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CVE stands for Common Vulnerabilities and Exposures.
/// Information from the [CVE
/// record](https://www.cve.org/ResourcesSupport/Glossary) that describes this
/// vulnerability.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cve {
    /// The unique identifier for the vulnerability. e.g. CVE-2021-34527
    pub id: std::string::String,

    /// Additional information about the CVE.
    /// e.g. <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34527>
    pub references: std::vec::Vec<crate::model::Reference>,

    /// Describe Common Vulnerability Scoring System specified at
    /// <https://www.first.org/cvss/v3.1/specification-document>
    pub cvssv3: std::option::Option<crate::model::Cvssv3>,

    /// Whether upstream fix is available for the CVE.
    pub upstream_fix_available: bool,

    /// The potential impact of the vulnerability if it was to be exploited.
    pub impact: crate::model::cve::RiskRating,

    /// The exploitation activity of the vulnerability in the wild.
    pub exploitation_activity: crate::model::cve::ExploitationActivity,

    /// Whether or not the vulnerability has been observed in the wild.
    pub observed_in_the_wild: bool,

    /// Whether or not the vulnerability was zero day when the finding was
    /// published.
    pub zero_day: bool,

    /// Date the first publicly available exploit or PoC was released.
    pub exploit_release_date: std::option::Option<wkt::Timestamp>,

    /// Date of the earliest known exploitation.
    pub first_exploitation_date: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cve {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Cve::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [references][crate::model::Cve::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Reference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cvssv3][crate::model::Cve::cvssv3].
    pub fn set_cvssv3<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cvssv3>,
    {
        self.cvssv3 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cvssv3][crate::model::Cve::cvssv3].
    pub fn set_or_clear_cvssv3<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cvssv3>,
    {
        self.cvssv3 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upstream_fix_available][crate::model::Cve::upstream_fix_available].
    pub fn set_upstream_fix_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.upstream_fix_available = v.into();
        self
    }

    /// Sets the value of [impact][crate::model::Cve::impact].
    pub fn set_impact<T: std::convert::Into<crate::model::cve::RiskRating>>(
        mut self,
        v: T,
    ) -> Self {
        self.impact = v.into();
        self
    }

    /// Sets the value of [exploitation_activity][crate::model::Cve::exploitation_activity].
    pub fn set_exploitation_activity<
        T: std::convert::Into<crate::model::cve::ExploitationActivity>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exploitation_activity = v.into();
        self
    }

    /// Sets the value of [observed_in_the_wild][crate::model::Cve::observed_in_the_wild].
    pub fn set_observed_in_the_wild<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.observed_in_the_wild = v.into();
        self
    }

    /// Sets the value of [zero_day][crate::model::Cve::zero_day].
    pub fn set_zero_day<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.zero_day = v.into();
        self
    }

    /// Sets the value of [exploit_release_date][crate::model::Cve::exploit_release_date].
    pub fn set_exploit_release_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.exploit_release_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exploit_release_date][crate::model::Cve::exploit_release_date].
    pub fn set_or_clear_exploit_release_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.exploit_release_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [first_exploitation_date][crate::model::Cve::first_exploitation_date].
    pub fn set_first_exploitation_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.first_exploitation_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [first_exploitation_date][crate::model::Cve::first_exploitation_date].
    pub fn set_or_clear_first_exploitation_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.first_exploitation_date = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Cve {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Cve"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cve {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __references,
            __cvssv3,
            __upstream_fix_available,
            __impact,
            __exploitation_activity,
            __observed_in_the_wild,
            __zero_day,
            __exploit_release_date,
            __first_exploitation_date,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cve")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "references" => Ok(__FieldTag::__references),
                            "cvssv3" => Ok(__FieldTag::__cvssv3),
                            "upstreamFixAvailable" => Ok(__FieldTag::__upstream_fix_available),
                            "upstream_fix_available" => Ok(__FieldTag::__upstream_fix_available),
                            "impact" => Ok(__FieldTag::__impact),
                            "exploitationActivity" => Ok(__FieldTag::__exploitation_activity),
                            "exploitation_activity" => Ok(__FieldTag::__exploitation_activity),
                            "observedInTheWild" => Ok(__FieldTag::__observed_in_the_wild),
                            "observed_in_the_wild" => Ok(__FieldTag::__observed_in_the_wild),
                            "zeroDay" => Ok(__FieldTag::__zero_day),
                            "zero_day" => Ok(__FieldTag::__zero_day),
                            "exploitReleaseDate" => Ok(__FieldTag::__exploit_release_date),
                            "exploit_release_date" => Ok(__FieldTag::__exploit_release_date),
                            "firstExploitationDate" => Ok(__FieldTag::__first_exploitation_date),
                            "first_exploitation_date" => Ok(__FieldTag::__first_exploitation_date),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cve;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cve")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Reference>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cvssv3 => {
                            if !fields.insert(__FieldTag::__cvssv3) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cvssv3",
                                ));
                            }
                            result.cvssv3 =
                                map.next_value::<std::option::Option<crate::model::Cvssv3>>()?;
                        }
                        __FieldTag::__upstream_fix_available => {
                            if !fields.insert(__FieldTag::__upstream_fix_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upstream_fix_available",
                                ));
                            }
                            result.upstream_fix_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__impact => {
                            if !fields.insert(__FieldTag::__impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for impact",
                                ));
                            }
                            result.impact = map
                                .next_value::<std::option::Option<crate::model::cve::RiskRating>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exploitation_activity => {
                            if !fields.insert(__FieldTag::__exploitation_activity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploitation_activity",
                                ));
                            }
                            result.exploitation_activity = map.next_value::<std::option::Option<crate::model::cve::ExploitationActivity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__observed_in_the_wild => {
                            if !fields.insert(__FieldTag::__observed_in_the_wild) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observed_in_the_wild",
                                ));
                            }
                            result.observed_in_the_wild = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zero_day => {
                            if !fields.insert(__FieldTag::__zero_day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zero_day",
                                ));
                            }
                            result.zero_day = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exploit_release_date => {
                            if !fields.insert(__FieldTag::__exploit_release_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exploit_release_date",
                                ));
                            }
                            result.exploit_release_date =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__first_exploitation_date => {
                            if !fields.insert(__FieldTag::__first_exploitation_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_exploitation_date",
                                ));
                            }
                            result.first_exploitation_date =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cve {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if self.cvssv3.is_some() {
            state.serialize_entry("cvssv3", &self.cvssv3)?;
        }
        if !wkt::internal::is_default(&self.upstream_fix_available) {
            state.serialize_entry("upstreamFixAvailable", &self.upstream_fix_available)?;
        }
        if !wkt::internal::is_default(&self.impact) {
            state.serialize_entry("impact", &self.impact)?;
        }
        if !wkt::internal::is_default(&self.exploitation_activity) {
            state.serialize_entry("exploitationActivity", &self.exploitation_activity)?;
        }
        if !wkt::internal::is_default(&self.observed_in_the_wild) {
            state.serialize_entry("observedInTheWild", &self.observed_in_the_wild)?;
        }
        if !wkt::internal::is_default(&self.zero_day) {
            state.serialize_entry("zeroDay", &self.zero_day)?;
        }
        if self.exploit_release_date.is_some() {
            state.serialize_entry("exploitReleaseDate", &self.exploit_release_date)?;
        }
        if self.first_exploitation_date.is_some() {
            state.serialize_entry("firstExploitationDate", &self.first_exploitation_date)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cve {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cve");
        debug_struct.field("id", &self.id);
        debug_struct.field("references", &self.references);
        debug_struct.field("cvssv3", &self.cvssv3);
        debug_struct.field("upstream_fix_available", &self.upstream_fix_available);
        debug_struct.field("impact", &self.impact);
        debug_struct.field("exploitation_activity", &self.exploitation_activity);
        debug_struct.field("observed_in_the_wild", &self.observed_in_the_wild);
        debug_struct.field("zero_day", &self.zero_day);
        debug_struct.field("exploit_release_date", &self.exploit_release_date);
        debug_struct.field("first_exploitation_date", &self.first_exploitation_date);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Cve].
pub mod cve {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of impact of the vulnerability if it was to be
    /// exploited.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RiskRating {
        /// Invalid or empty value.
        Unspecified,
        /// Exploitation would have little to no security impact.
        Low,
        /// Exploitation would enable attackers to perform activities, or could allow
        /// attackers to have a direct impact, but would require additional steps.
        Medium,
        /// Exploitation would enable attackers to have a notable direct impact
        /// without needing to overcome any major mitigating factors.
        High,
        /// Exploitation would fundamentally undermine the security of affected
        /// systems, enable actors to perform significant attacks with minimal
        /// effort, with little to no mitigating factors to overcome.
        Critical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RiskRating::value] or
        /// [RiskRating::name].
        UnknownValue(risk_rating::UnknownValue),
    }

    #[doc(hidden)]
    pub mod risk_rating {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RiskRating {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::Critical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RISK_RATING_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RiskRating {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RiskRating {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RiskRating {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::Medium,
                3 => Self::High,
                4 => Self::Critical,
                _ => Self::UnknownValue(risk_rating::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RiskRating {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RISK_RATING_UNSPECIFIED" => Self::Unspecified,
                "LOW" => Self::Low,
                "MEDIUM" => Self::Medium,
                "HIGH" => Self::High,
                "CRITICAL" => Self::Critical,
                _ => Self::UnknownValue(risk_rating::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RiskRating {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::Critical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RiskRating {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RiskRating>::new(
                ".google.cloud.securitycenter.v2.Cve.RiskRating",
            ))
        }
    }

    /// The possible values of exploitation activity of the vulnerability in the
    /// wild.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExploitationActivity {
        /// Invalid or empty value.
        Unspecified,
        /// Exploitation has been reported or confirmed to widely occur.
        Wide,
        /// Limited reported or confirmed exploitation activities.
        Confirmed,
        /// Exploit is publicly available.
        Available,
        /// No known exploitation activity, but has a high potential for
        /// exploitation.
        Anticipated,
        /// No known exploitation activity.
        NoKnown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExploitationActivity::value] or
        /// [ExploitationActivity::name].
        UnknownValue(exploitation_activity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod exploitation_activity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExploitationActivity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Wide => std::option::Option::Some(1),
                Self::Confirmed => std::option::Option::Some(2),
                Self::Available => std::option::Option::Some(3),
                Self::Anticipated => std::option::Option::Some(4),
                Self::NoKnown => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXPLOITATION_ACTIVITY_UNSPECIFIED"),
                Self::Wide => std::option::Option::Some("WIDE"),
                Self::Confirmed => std::option::Option::Some("CONFIRMED"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Anticipated => std::option::Option::Some("ANTICIPATED"),
                Self::NoKnown => std::option::Option::Some("NO_KNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExploitationActivity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExploitationActivity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExploitationActivity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Wide,
                2 => Self::Confirmed,
                3 => Self::Available,
                4 => Self::Anticipated,
                5 => Self::NoKnown,
                _ => Self::UnknownValue(exploitation_activity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExploitationActivity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXPLOITATION_ACTIVITY_UNSPECIFIED" => Self::Unspecified,
                "WIDE" => Self::Wide,
                "CONFIRMED" => Self::Confirmed,
                "AVAILABLE" => Self::Available,
                "ANTICIPATED" => Self::Anticipated,
                "NO_KNOWN" => Self::NoKnown,
                _ => Self::UnknownValue(exploitation_activity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExploitationActivity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Wide => serializer.serialize_i32(1),
                Self::Confirmed => serializer.serialize_i32(2),
                Self::Available => serializer.serialize_i32(3),
                Self::Anticipated => serializer.serialize_i32(4),
                Self::NoKnown => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExploitationActivity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExploitationActivity>::new(
                ".google.cloud.securitycenter.v2.Cve.ExploitationActivity",
            ))
        }
    }
}

/// Additional Links
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Reference {
    /// Source of the reference e.g. NVD
    pub source: std::string::String,

    /// Uri for the mentioned source e.g.
    /// <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34527>.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Reference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::Reference::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Reference::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for Reference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Reference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Reference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Reference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Reference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Reference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Reference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Reference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Reference");
        debug_struct.field("source", &self.source);
        debug_struct.field("uri", &self.uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Common Vulnerability Scoring System version 3.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cvssv3 {
    /// The base score is a function of the base metric scores.
    pub base_score: f64,

    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    pub attack_vector: crate::model::cvssv_3::AttackVector,

    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    pub attack_complexity: crate::model::cvssv_3::AttackComplexity,

    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    pub privileges_required: crate::model::cvssv_3::PrivilegesRequired,

    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    pub user_interaction: crate::model::cvssv_3::UserInteraction,

    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    pub scope: crate::model::cvssv_3::Scope,

    /// This metric measures the impact to the confidentiality of the information
    /// resources managed by a software component due to a successfully exploited
    /// vulnerability.
    pub confidentiality_impact: crate::model::cvssv_3::Impact,

    /// This metric measures the impact to integrity of a successfully exploited
    /// vulnerability.
    pub integrity_impact: crate::model::cvssv_3::Impact,

    /// This metric measures the impact to the availability of the impacted
    /// component resulting from a successfully exploited vulnerability.
    pub availability_impact: crate::model::cvssv_3::Impact,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cvssv3 {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_score][crate::model::Cvssv3::base_score].
    pub fn set_base_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.base_score = v.into();
        self
    }

    /// Sets the value of [attack_vector][crate::model::Cvssv3::attack_vector].
    pub fn set_attack_vector<T: std::convert::Into<crate::model::cvssv_3::AttackVector>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_vector = v.into();
        self
    }

    /// Sets the value of [attack_complexity][crate::model::Cvssv3::attack_complexity].
    pub fn set_attack_complexity<T: std::convert::Into<crate::model::cvssv_3::AttackComplexity>>(
        mut self,
        v: T,
    ) -> Self {
        self.attack_complexity = v.into();
        self
    }

    /// Sets the value of [privileges_required][crate::model::Cvssv3::privileges_required].
    pub fn set_privileges_required<
        T: std::convert::Into<crate::model::cvssv_3::PrivilegesRequired>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileges_required = v.into();
        self
    }

    /// Sets the value of [user_interaction][crate::model::Cvssv3::user_interaction].
    pub fn set_user_interaction<T: std::convert::Into<crate::model::cvssv_3::UserInteraction>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_interaction = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::Cvssv3::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::cvssv_3::Scope>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [confidentiality_impact][crate::model::Cvssv3::confidentiality_impact].
    pub fn set_confidentiality_impact<T: std::convert::Into<crate::model::cvssv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.confidentiality_impact = v.into();
        self
    }

    /// Sets the value of [integrity_impact][crate::model::Cvssv3::integrity_impact].
    pub fn set_integrity_impact<T: std::convert::Into<crate::model::cvssv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.integrity_impact = v.into();
        self
    }

    /// Sets the value of [availability_impact][crate::model::Cvssv3::availability_impact].
    pub fn set_availability_impact<T: std::convert::Into<crate::model::cvssv_3::Impact>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability_impact = v.into();
        self
    }
}

impl wkt::message::Message for Cvssv3 {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Cvssv3"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cvssv3 {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_score,
            __attack_vector,
            __attack_complexity,
            __privileges_required,
            __user_interaction,
            __scope,
            __confidentiality_impact,
            __integrity_impact,
            __availability_impact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cvssv3")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseScore" => Ok(__FieldTag::__base_score),
                            "base_score" => Ok(__FieldTag::__base_score),
                            "attackVector" => Ok(__FieldTag::__attack_vector),
                            "attack_vector" => Ok(__FieldTag::__attack_vector),
                            "attackComplexity" => Ok(__FieldTag::__attack_complexity),
                            "attack_complexity" => Ok(__FieldTag::__attack_complexity),
                            "privilegesRequired" => Ok(__FieldTag::__privileges_required),
                            "privileges_required" => Ok(__FieldTag::__privileges_required),
                            "userInteraction" => Ok(__FieldTag::__user_interaction),
                            "user_interaction" => Ok(__FieldTag::__user_interaction),
                            "scope" => Ok(__FieldTag::__scope),
                            "confidentialityImpact" => Ok(__FieldTag::__confidentiality_impact),
                            "confidentiality_impact" => Ok(__FieldTag::__confidentiality_impact),
                            "integrityImpact" => Ok(__FieldTag::__integrity_impact),
                            "integrity_impact" => Ok(__FieldTag::__integrity_impact),
                            "availabilityImpact" => Ok(__FieldTag::__availability_impact),
                            "availability_impact" => Ok(__FieldTag::__availability_impact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cvssv3;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cvssv3")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_score => {
                            if !fields.insert(__FieldTag::__base_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_score",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attack_vector => {
                            if !fields.insert(__FieldTag::__attack_vector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_vector",
                                ));
                            }
                            result.attack_vector = map.next_value::<std::option::Option<crate::model::cvssv_3::AttackVector>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attack_complexity => {
                            if !fields.insert(__FieldTag::__attack_complexity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attack_complexity",
                                ));
                            }
                            result.attack_complexity = map.next_value::<std::option::Option<crate::model::cvssv_3::AttackComplexity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__privileges_required => {
                            if !fields.insert(__FieldTag::__privileges_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileges_required",
                                ));
                            }
                            result.privileges_required = map.next_value::<std::option::Option<crate::model::cvssv_3::PrivilegesRequired>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_interaction => {
                            if !fields.insert(__FieldTag::__user_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_interaction",
                                ));
                            }
                            result.user_interaction = map.next_value::<std::option::Option<crate::model::cvssv_3::UserInteraction>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<crate::model::cvssv_3::Scope>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidentiality_impact => {
                            if !fields.insert(__FieldTag::__confidentiality_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidentiality_impact",
                                ));
                            }
                            result.confidentiality_impact = map
                                .next_value::<std::option::Option<crate::model::cvssv_3::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__integrity_impact => {
                            if !fields.insert(__FieldTag::__integrity_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integrity_impact",
                                ));
                            }
                            result.integrity_impact = map
                                .next_value::<std::option::Option<crate::model::cvssv_3::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_impact => {
                            if !fields.insert(__FieldTag::__availability_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_impact",
                                ));
                            }
                            result.availability_impact = map
                                .next_value::<std::option::Option<crate::model::cvssv_3::Impact>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cvssv3 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.base_score) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("baseScore", &__With(&self.base_score))?;
        }
        if !wkt::internal::is_default(&self.attack_vector) {
            state.serialize_entry("attackVector", &self.attack_vector)?;
        }
        if !wkt::internal::is_default(&self.attack_complexity) {
            state.serialize_entry("attackComplexity", &self.attack_complexity)?;
        }
        if !wkt::internal::is_default(&self.privileges_required) {
            state.serialize_entry("privilegesRequired", &self.privileges_required)?;
        }
        if !wkt::internal::is_default(&self.user_interaction) {
            state.serialize_entry("userInteraction", &self.user_interaction)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !wkt::internal::is_default(&self.confidentiality_impact) {
            state.serialize_entry("confidentialityImpact", &self.confidentiality_impact)?;
        }
        if !wkt::internal::is_default(&self.integrity_impact) {
            state.serialize_entry("integrityImpact", &self.integrity_impact)?;
        }
        if !wkt::internal::is_default(&self.availability_impact) {
            state.serialize_entry("availabilityImpact", &self.availability_impact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cvssv3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cvssv3");
        debug_struct.field("base_score", &self.base_score);
        debug_struct.field("attack_vector", &self.attack_vector);
        debug_struct.field("attack_complexity", &self.attack_complexity);
        debug_struct.field("privileges_required", &self.privileges_required);
        debug_struct.field("user_interaction", &self.user_interaction);
        debug_struct.field("scope", &self.scope);
        debug_struct.field("confidentiality_impact", &self.confidentiality_impact);
        debug_struct.field("integrity_impact", &self.integrity_impact);
        debug_struct.field("availability_impact", &self.availability_impact);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Cvssv3].
pub mod cvssv_3 {
    #[allow(unused_imports)]
    use super::*;

    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackVector {
        /// Invalid value.
        Unspecified,
        /// The vulnerable component is bound to the network stack and the set of
        /// possible attackers extends beyond the other options listed below, up to
        /// and including the entire Internet.
        Network,
        /// The vulnerable component is bound to the network stack, but the attack is
        /// limited at the protocol level to a logically adjacent topology.
        Adjacent,
        /// The vulnerable component is not bound to the network stack and the
        /// attacker's path is via read/write/execute capabilities.
        Local,
        /// The attack requires the attacker to physically touch or manipulate the
        /// vulnerable component.
        Physical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackVector::value] or
        /// [AttackVector::name].
        UnknownValue(attack_vector::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_vector {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackVector {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::Adjacent => std::option::Option::Some(2),
                Self::Local => std::option::Option::Some(3),
                Self::Physical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_VECTOR_UNSPECIFIED"),
                Self::Network => std::option::Option::Some("ATTACK_VECTOR_NETWORK"),
                Self::Adjacent => std::option::Option::Some("ATTACK_VECTOR_ADJACENT"),
                Self::Local => std::option::Option::Some("ATTACK_VECTOR_LOCAL"),
                Self::Physical => std::option::Option::Some("ATTACK_VECTOR_PHYSICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackVector {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackVector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackVector {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Network,
                2 => Self::Adjacent,
                3 => Self::Local,
                4 => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackVector {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_VECTOR_NETWORK" => Self::Network,
                "ATTACK_VECTOR_ADJACENT" => Self::Adjacent,
                "ATTACK_VECTOR_LOCAL" => Self::Local,
                "ATTACK_VECTOR_PHYSICAL" => Self::Physical,
                _ => Self::UnknownValue(attack_vector::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackVector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Network => serializer.serialize_i32(1),
                Self::Adjacent => serializer.serialize_i32(2),
                Self::Local => serializer.serialize_i32(3),
                Self::Physical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackVector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackVector>::new(
                ".google.cloud.securitycenter.v2.Cvssv3.AttackVector",
            ))
        }
    }

    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttackComplexity {
        /// Invalid value.
        Unspecified,
        /// Specialized access conditions or extenuating circumstances do not exist.
        /// An attacker can expect repeatable success when attacking the vulnerable
        /// component.
        Low,
        /// A successful attack depends on conditions beyond the attacker's control.
        /// That is, a successful attack cannot be accomplished at will, but requires
        /// the attacker to invest in some measurable amount of effort in preparation
        /// or execution against the vulnerable component before a successful attack
        /// can be expected.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttackComplexity::value] or
        /// [AttackComplexity::name].
        UnknownValue(attack_complexity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attack_complexity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttackComplexity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::High => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ATTACK_COMPLEXITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("ATTACK_COMPLEXITY_LOW"),
                Self::High => std::option::Option::Some("ATTACK_COMPLEXITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttackComplexity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttackComplexity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttackComplexity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttackComplexity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Self::Unspecified,
                "ATTACK_COMPLEXITY_LOW" => Self::Low,
                "ATTACK_COMPLEXITY_HIGH" => Self::High,
                _ => Self::UnknownValue(attack_complexity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttackComplexity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::High => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttackComplexity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttackComplexity>::new(
                ".google.cloud.securitycenter.v2.Cvssv3.AttackComplexity",
            ))
        }
    }

    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivilegesRequired {
        /// Invalid value.
        Unspecified,
        /// The attacker is unauthorized prior to attack, and therefore does not
        /// require any access to settings or files of the vulnerable system to
        /// carry out an attack.
        None,
        /// The attacker requires privileges that provide basic user capabilities
        /// that could normally affect only settings and files owned by a user.
        /// Alternatively, an attacker with Low privileges has the ability to access
        /// only non-sensitive resources.
        Low,
        /// The attacker requires privileges that provide significant (e.g.,
        /// administrative) control over the vulnerable component allowing access to
        /// component-wide settings and files.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivilegesRequired::value] or
        /// [PrivilegesRequired::name].
        UnknownValue(privileges_required::UnknownValue),
    }

    #[doc(hidden)]
    pub mod privileges_required {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivilegesRequired {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIVILEGES_REQUIRED_UNSPECIFIED"),
                Self::None => std::option::Option::Some("PRIVILEGES_REQUIRED_NONE"),
                Self::Low => std::option::Option::Some("PRIVILEGES_REQUIRED_LOW"),
                Self::High => std::option::Option::Some("PRIVILEGES_REQUIRED_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivilegesRequired {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivilegesRequired {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivilegesRequired {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Low,
                3 => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivilegesRequired {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Self::Unspecified,
                "PRIVILEGES_REQUIRED_NONE" => Self::None,
                "PRIVILEGES_REQUIRED_LOW" => Self::Low,
                "PRIVILEGES_REQUIRED_HIGH" => Self::High,
                _ => Self::UnknownValue(privileges_required::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivilegesRequired {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivilegesRequired {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivilegesRequired>::new(
                ".google.cloud.securitycenter.v2.Cvssv3.PrivilegesRequired",
            ))
        }
    }

    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserInteraction {
        /// Invalid value.
        Unspecified,
        /// The vulnerable system can be exploited without interaction from any user.
        None,
        /// Successful exploitation of this vulnerability requires a user to take
        /// some action before the vulnerability can be exploited.
        Required,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserInteraction::value] or
        /// [UserInteraction::name].
        UnknownValue(user_interaction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_interaction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserInteraction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Required => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_INTERACTION_UNSPECIFIED"),
                Self::None => std::option::Option::Some("USER_INTERACTION_NONE"),
                Self::Required => std::option::Option::Some("USER_INTERACTION_REQUIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserInteraction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserInteraction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserInteraction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserInteraction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Self::Unspecified,
                "USER_INTERACTION_NONE" => Self::None,
                "USER_INTERACTION_REQUIRED" => Self::Required,
                _ => Self::UnknownValue(user_interaction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Required => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserInteraction>::new(
                ".google.cloud.securitycenter.v2.Cvssv3.UserInteraction",
            ))
        }
    }

    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Invalid value.
        Unspecified,
        /// An exploited vulnerability can only affect resources managed by the same
        /// security authority.
        Unchanged,
        /// An exploited vulnerability can affect resources beyond the security scope
        /// managed by the security authority of the vulnerable component.
        Changed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unchanged => std::option::Option::Some(1),
                Self::Changed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Unchanged => std::option::Option::Some("SCOPE_UNCHANGED"),
                Self::Changed => std::option::Option::Some("SCOPE_CHANGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unchanged,
                2 => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "SCOPE_UNCHANGED" => Self::Unchanged,
                "SCOPE_CHANGED" => Self::Changed,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unchanged => serializer.serialize_i32(1),
                Self::Changed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.securitycenter.v2.Cvssv3.Scope",
            ))
        }
    }

    /// The Impact metrics capture the effects of a successfully exploited
    /// vulnerability on the component that suffers the worst outcome that is most
    /// directly and predictably associated with the attack.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Impact {
        /// Invalid value.
        Unspecified,
        /// High impact.
        High,
        /// Low impact.
        Low,
        /// No impact.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Impact::value] or
        /// [Impact::name].
        UnknownValue(impact::UnknownValue),
    }

    #[doc(hidden)]
    pub mod impact {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Impact {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPACT_UNSPECIFIED"),
                Self::High => std::option::Option::Some("IMPACT_HIGH"),
                Self::Low => std::option::Option::Some("IMPACT_LOW"),
                Self::None => std::option::Option::Some("IMPACT_NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Impact {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Impact {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Impact {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::High,
                2 => Self::Low,
                3 => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Impact {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPACT_UNSPECIFIED" => Self::Unspecified,
                "IMPACT_HIGH" => Self::High,
                "IMPACT_LOW" => Self::Low,
                "IMPACT_NONE" => Self::None,
                _ => Self::UnknownValue(impact::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Impact {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::None => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Impact {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Impact>::new(
                ".google.cloud.securitycenter.v2.Cvssv3.Impact",
            ))
        }
    }
}

/// Package is a generic definition of a package.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Package {
    /// The name of the package where the vulnerability was detected.
    pub package_name: std::string::String,

    /// The CPE URI where the vulnerability was detected.
    pub cpe_uri: std::string::String,

    /// Type of package, for example, os, maven, or go.
    pub package_type: std::string::String,

    /// The version of the package.
    pub package_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Package {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_name][crate::model::Package::package_name].
    pub fn set_package_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_name = v.into();
        self
    }

    /// Sets the value of [cpe_uri][crate::model::Package::cpe_uri].
    pub fn set_cpe_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cpe_uri = v.into();
        self
    }

    /// Sets the value of [package_type][crate::model::Package::package_type].
    pub fn set_package_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_type = v.into();
        self
    }

    /// Sets the value of [package_version][crate::model::Package::package_version].
    pub fn set_package_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_version = v.into();
        self
    }
}

impl wkt::message::Message for Package {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Package"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Package {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package_name,
            __cpe_uri,
            __package_type,
            __package_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Package")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "packageName" => Ok(__FieldTag::__package_name),
                            "package_name" => Ok(__FieldTag::__package_name),
                            "cpeUri" => Ok(__FieldTag::__cpe_uri),
                            "cpe_uri" => Ok(__FieldTag::__cpe_uri),
                            "packageType" => Ok(__FieldTag::__package_type),
                            "package_type" => Ok(__FieldTag::__package_type),
                            "packageVersion" => Ok(__FieldTag::__package_version),
                            "package_version" => Ok(__FieldTag::__package_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Package;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Package")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package_name => {
                            if !fields.insert(__FieldTag::__package_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_name",
                                ));
                            }
                            result.package_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpe_uri => {
                            if !fields.insert(__FieldTag::__cpe_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpe_uri",
                                ));
                            }
                            result.cpe_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__package_type => {
                            if !fields.insert(__FieldTag::__package_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_type",
                                ));
                            }
                            result.package_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__package_version => {
                            if !fields.insert(__FieldTag::__package_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_version",
                                ));
                            }
                            result.package_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Package {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.package_name.is_empty() {
            state.serialize_entry("packageName", &self.package_name)?;
        }
        if !self.cpe_uri.is_empty() {
            state.serialize_entry("cpeUri", &self.cpe_uri)?;
        }
        if !self.package_type.is_empty() {
            state.serialize_entry("packageType", &self.package_type)?;
        }
        if !self.package_version.is_empty() {
            state.serialize_entry("packageVersion", &self.package_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Package {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Package");
        debug_struct.field("package_name", &self.package_name);
        debug_struct.field("cpe_uri", &self.cpe_uri);
        debug_struct.field("package_type", &self.package_type);
        debug_struct.field("package_version", &self.package_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SecurityBulletin are notifications of vulnerabilities of Google products.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityBulletin {
    /// ID of the bulletin corresponding to the vulnerability.
    pub bulletin_id: std::string::String,

    /// Submission time of this Security Bulletin.
    pub submission_time: std::option::Option<wkt::Timestamp>,

    /// This represents a version that the cluster receiving this notification
    /// should be upgraded to, based on its current version. For example, 1.15.0
    pub suggested_upgrade_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityBulletin {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bulletin_id][crate::model::SecurityBulletin::bulletin_id].
    pub fn set_bulletin_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bulletin_id = v.into();
        self
    }

    /// Sets the value of [submission_time][crate::model::SecurityBulletin::submission_time].
    pub fn set_submission_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submission_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submission_time][crate::model::SecurityBulletin::submission_time].
    pub fn set_or_clear_submission_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submission_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [suggested_upgrade_version][crate::model::SecurityBulletin::suggested_upgrade_version].
    pub fn set_suggested_upgrade_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.suggested_upgrade_version = v.into();
        self
    }
}

impl wkt::message::Message for SecurityBulletin {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.SecurityBulletin"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityBulletin {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bulletin_id,
            __submission_time,
            __suggested_upgrade_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityBulletin")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bulletinId" => Ok(__FieldTag::__bulletin_id),
                            "bulletin_id" => Ok(__FieldTag::__bulletin_id),
                            "submissionTime" => Ok(__FieldTag::__submission_time),
                            "submission_time" => Ok(__FieldTag::__submission_time),
                            "suggestedUpgradeVersion" => {
                                Ok(__FieldTag::__suggested_upgrade_version)
                            }
                            "suggested_upgrade_version" => {
                                Ok(__FieldTag::__suggested_upgrade_version)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityBulletin;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityBulletin")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bulletin_id => {
                            if !fields.insert(__FieldTag::__bulletin_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bulletin_id",
                                ));
                            }
                            result.bulletin_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submission_time => {
                            if !fields.insert(__FieldTag::__submission_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submission_time",
                                ));
                            }
                            result.submission_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__suggested_upgrade_version => {
                            if !fields.insert(__FieldTag::__suggested_upgrade_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggested_upgrade_version",
                                ));
                            }
                            result.suggested_upgrade_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityBulletin {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bulletin_id.is_empty() {
            state.serialize_entry("bulletinId", &self.bulletin_id)?;
        }
        if self.submission_time.is_some() {
            state.serialize_entry("submissionTime", &self.submission_time)?;
        }
        if !self.suggested_upgrade_version.is_empty() {
            state.serialize_entry("suggestedUpgradeVersion", &self.suggested_upgrade_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecurityBulletin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityBulletin");
        debug_struct.field("bulletin_id", &self.bulletin_id);
        debug_struct.field("submission_time", &self.submission_time);
        debug_struct.field("suggested_upgrade_version", &self.suggested_upgrade_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CWE stands for Common Weakness Enumeration. Information about this weakness,
/// as described by [CWE](https://cwe.mitre.org/).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cwe {
    /// The CWE identifier, e.g. CWE-94
    pub id: std::string::String,

    /// Any reference to the details on the CWE, for example,
    /// <https://cwe.mitre.org/data/definitions/94.html>
    pub references: std::vec::Vec<crate::model::Reference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cwe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Cwe::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [references][crate::model::Cwe::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Reference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Cwe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.securitycenter.v2.Cwe"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cwe {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cwe")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "references" => Ok(__FieldTag::__references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cwe;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cwe")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__references => {
                            if !fields.insert(__FieldTag::__references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for references",
                                ));
                            }
                            result.references = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Reference>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cwe {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.references.is_empty() {
            state.serialize_entry("references", &self.references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cwe {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cwe");
        debug_struct.field("id", &self.id);
        debug_struct.field("references", &self.references);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// JobState represents the state of the job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum JobState {
    /// Unspecified represents an unknown state and should not be used.
    Unspecified,
    /// Job is scheduled and pending for run
    Pending,
    /// Job in progress
    Running,
    /// Job has completed with success
    Succeeded,
    /// Job has completed but with failure
    Failed,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [JobState::value] or
    /// [JobState::name].
    UnknownValue(job_state::UnknownValue),
}

#[doc(hidden)]
pub mod job_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl JobState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pending => std::option::Option::Some(1),
            Self::Running => std::option::Option::Some(2),
            Self::Succeeded => std::option::Option::Some(3),
            Self::Failed => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("JOB_STATE_UNSPECIFIED"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::Running => std::option::Option::Some("RUNNING"),
            Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for JobState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for JobState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for JobState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Pending,
            2 => Self::Running,
            3 => Self::Succeeded,
            4 => Self::Failed,
            _ => Self::UnknownValue(job_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for JobState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "JOB_STATE_UNSPECIFIED" => Self::Unspecified,
            "PENDING" => Self::Pending,
            "RUNNING" => Self::Running,
            "SUCCEEDED" => Self::Succeeded,
            "FAILED" => Self::Failed,
            _ => Self::UnknownValue(job_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for JobState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pending => serializer.serialize_i32(1),
            Self::Running => serializer.serialize_i32(2),
            Self::Succeeded => serializer.serialize_i32(3),
            Self::Failed => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for JobState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobState>::new(
            ".google.cloud.securitycenter.v2.JobState",
        ))
    }
}

/// The cloud provider the finding pertains to.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CloudProvider {
    /// The cloud provider is unspecified.
    Unspecified,
    /// The cloud provider is Google Cloud.
    GoogleCloudPlatform,
    /// The cloud provider is Amazon Web Services.
    AmazonWebServices,
    /// The cloud provider is Microsoft Azure.
    MicrosoftAzure,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CloudProvider::value] or
    /// [CloudProvider::name].
    UnknownValue(cloud_provider::UnknownValue),
}

#[doc(hidden)]
pub mod cloud_provider {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CloudProvider {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::GoogleCloudPlatform => std::option::Option::Some(1),
            Self::AmazonWebServices => std::option::Option::Some(2),
            Self::MicrosoftAzure => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CLOUD_PROVIDER_UNSPECIFIED"),
            Self::GoogleCloudPlatform => std::option::Option::Some("GOOGLE_CLOUD_PLATFORM"),
            Self::AmazonWebServices => std::option::Option::Some("AMAZON_WEB_SERVICES"),
            Self::MicrosoftAzure => std::option::Option::Some("MICROSOFT_AZURE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CloudProvider {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CloudProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CloudProvider {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::GoogleCloudPlatform,
            2 => Self::AmazonWebServices,
            3 => Self::MicrosoftAzure,
            _ => Self::UnknownValue(cloud_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CloudProvider {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CLOUD_PROVIDER_UNSPECIFIED" => Self::Unspecified,
            "GOOGLE_CLOUD_PLATFORM" => Self::GoogleCloudPlatform,
            "AMAZON_WEB_SERVICES" => Self::AmazonWebServices,
            "MICROSOFT_AZURE" => Self::MicrosoftAzure,
            _ => Self::UnknownValue(cloud_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CloudProvider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::GoogleCloudPlatform => serializer.serialize_i32(1),
            Self::AmazonWebServices => serializer.serialize_i32(2),
            Self::MicrosoftAzure => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CloudProvider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudProvider>::new(
            ".google.cloud.securitycenter.v2.CloudProvider",
        ))
    }
}

/// Value enum to map to a resource
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ResourceValue {
    /// Unspecific value
    Unspecified,
    /// High resource value
    High,
    /// Medium resource value
    Medium,
    /// Low resource value
    Low,
    /// No resource value, e.g. ignore these resources
    None,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ResourceValue::value] or
    /// [ResourceValue::name].
    UnknownValue(resource_value::UnknownValue),
}

#[doc(hidden)]
pub mod resource_value {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ResourceValue {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::High => std::option::Option::Some(1),
            Self::Medium => std::option::Option::Some(2),
            Self::Low => std::option::Option::Some(3),
            Self::None => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESOURCE_VALUE_UNSPECIFIED"),
            Self::High => std::option::Option::Some("HIGH"),
            Self::Medium => std::option::Option::Some("MEDIUM"),
            Self::Low => std::option::Option::Some("LOW"),
            Self::None => std::option::Option::Some("NONE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ResourceValue {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ResourceValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ResourceValue {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::High,
            2 => Self::Medium,
            3 => Self::Low,
            4 => Self::None,
            _ => Self::UnknownValue(resource_value::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ResourceValue {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESOURCE_VALUE_UNSPECIFIED" => Self::Unspecified,
            "HIGH" => Self::High,
            "MEDIUM" => Self::Medium,
            "LOW" => Self::Low,
            "NONE" => Self::None,
            _ => Self::UnknownValue(resource_value::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ResourceValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::High => serializer.serialize_i32(1),
            Self::Medium => serializer.serialize_i32(2),
            Self::Low => serializer.serialize_i32(3),
            Self::None => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ResourceValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceValue>::new(
            ".google.cloud.securitycenter.v2.ResourceValue",
        ))
    }
}
