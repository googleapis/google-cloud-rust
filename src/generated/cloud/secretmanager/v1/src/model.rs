// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A [Secret][google.cloud.secretmanager.v1.Secret] is a logical secret whose
/// value and versions can be accessed.
///
/// A [Secret][google.cloud.secretmanager.v1.Secret] is made up of zero or more
/// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] that represent
/// the secret data.
///
/// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
/// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Secret {
    /// Output only. The resource name of the
    /// [Secret][google.cloud.secretmanager.v1.Secret] in the format
    /// `projects/*/secrets/*`.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub name: std::string::String,

    /// Optional. Immutable. The replication policy of the secret data attached to
    /// the [Secret][google.cloud.secretmanager.v1.Secret].
    ///
    /// The replication policy cannot be changed after the Secret has been created.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub replication: std::option::Option<crate::model::Replication>,

    /// Output only. The time at which the
    /// [Secret][google.cloud.secretmanager.v1.Secret] was created.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The labels assigned to this Secret.
    ///
    /// Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
    /// of maximum 128 bytes, and must conform to the following PCRE regular
    /// expression: `[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}`
    ///
    /// Label values must be between 0 and 63 characters long, have a UTF-8
    /// encoding of maximum 128 bytes, and must conform to the following PCRE
    /// regular expression: `[\p{Ll}\p{Lo}\p{N}_-]{0,63}`
    ///
    /// No more than 64 labels can be assigned to a given resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A list of up to 10 Pub/Sub topics to which messages are published
    /// when control plane operations are called on the secret or its versions.
    pub topics: std::vec::Vec<crate::model::Topic>,

    /// Optional. Etag of the currently stored
    /// [Secret][google.cloud.secretmanager.v1.Secret].
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub etag: std::string::String,

    /// Optional. Rotation policy attached to the
    /// [Secret][google.cloud.secretmanager.v1.Secret]. May be excluded if there is
    /// no rotation policy.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub rotation: std::option::Option<crate::model::Rotation>,

    /// Optional. Mapping from version alias to version name.
    ///
    /// A version alias is a string with a maximum length of 63 characters and can
    /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`)
    /// and underscore ('_') characters. An alias string must start with a
    /// letter and cannot be the string 'latest' or 'NEW'.
    /// No more than 50 aliases can be assigned to a given secret.
    ///
    /// Version-Alias pairs will be viewable via GetSecret and modifiable via
    /// UpdateSecret. Access by alias is only be supported on
    /// GetSecretVersion and AccessSecretVersion.
    pub version_aliases: std::collections::HashMap<std::string::String, i64>,

    /// Optional. Custom metadata about the secret.
    ///
    /// Annotations are distinct from various forms of labels.
    /// Annotations exist to allow client tools to store their own state
    /// information without requiring a database.
    ///
    /// Annotation keys must be between 1 and 63 characters long, have a UTF-8
    /// encoding of maximum 128 bytes, begin and end with an alphanumeric character
    /// ([a-z0-9A-Z]), and may have dashes (-), underscores (_), dots (.), and
    /// alphanumerics in between these symbols.
    ///
    /// The total size of annotation keys and values must be less than 16KiB.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Secret Version TTL after destruction request
    ///
    /// This is a part of the Delayed secret version destroy feature.
    /// For secret with TTL>0, version destruction doesn't happen immediately
    /// on calling destroy instead the version goes to a disabled state and
    /// destruction happens after the TTL expires.
    pub version_destroy_ttl: std::option::Option<wkt::Duration>,

    /// Optional. The customer-managed encryption configuration of the regionalized
    /// secrets. If no configuration is provided, Google-managed default encryption
    /// is used.
    ///
    /// Updates to the [Secret][google.cloud.secretmanager.v1.Secret] encryption
    /// configuration only apply to
    /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] added
    /// afterwards. They do not apply retroactively to existing
    /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub customer_managed_encryption: std::option::Option<crate::model::CustomerManagedEncryption>,

    /// Optional. Input only. Immutable. Mapping of Tag keys/values directly bound
    /// to this resource. For example:
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    ///
    /// Tags are used to organize and group resources.
    ///
    /// Tags can be used to control policy evaluation for the resource.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Expiration policy attached to the
    /// [Secret][google.cloud.secretmanager.v1.Secret]. If specified the
    /// [Secret][google.cloud.secretmanager.v1.Secret] and all
    /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] will be
    /// automatically deleted at expiration. Expired secrets are irreversibly
    /// deleted.
    ///
    /// Expiration is *not* the recommended way to set time-based permissions. [IAM
    /// Conditions](https://cloud.google.com/secret-manager/docs/access-control#conditions)
    /// is recommended for granting time-based permissions because the operation
    /// can be reversed.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub expiration: std::option::Option<crate::model::secret::Expiration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Secret::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [replication][crate::model::Secret::replication].
    pub fn set_replication<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Replication>,
    {
        self.replication = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication][crate::model::Secret::replication].
    pub fn set_or_clear_replication<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Replication>,
    {
        self.replication = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Secret::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Secret::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Secret::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [topics][crate::model::Secret::topics].
    pub fn set_topics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Topic>,
    {
        use std::iter::Iterator;
        self.topics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Secret::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [rotation][crate::model::Secret::rotation].
    pub fn set_rotation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rotation>,
    {
        self.rotation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rotation][crate::model::Secret::rotation].
    pub fn set_or_clear_rotation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rotation>,
    {
        self.rotation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version_aliases][crate::model::Secret::version_aliases].
    pub fn set_version_aliases<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Secret::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [version_destroy_ttl][crate::model::Secret::version_destroy_ttl].
    pub fn set_version_destroy_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.version_destroy_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version_destroy_ttl][crate::model::Secret::version_destroy_ttl].
    pub fn set_or_clear_version_destroy_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.version_destroy_ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_managed_encryption][crate::model::Secret::customer_managed_encryption].
    pub fn set_customer_managed_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerManagedEncryption>,
    {
        self.customer_managed_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer_managed_encryption][crate::model::Secret::customer_managed_encryption].
    pub fn set_or_clear_customer_managed_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerManagedEncryption>,
    {
        self.customer_managed_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::Secret::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [expiration][crate::model::Secret::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::secret::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::Secret::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::secret::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Secret::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::secret::Expiration::ExpireTime(v.into()));
        self
    }

    /// The value of [expiration][crate::model::Secret::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::secret::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Secret::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::secret::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Secret"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Secret {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __replication,
            __create_time,
            __labels,
            __topics,
            __expire_time,
            __ttl,
            __etag,
            __rotation,
            __version_aliases,
            __annotations,
            __version_destroy_ttl,
            __customer_managed_encryption,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Secret")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "replication" => Ok(__FieldTag::__replication),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "topics" => Ok(__FieldTag::__topics),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "etag" => Ok(__FieldTag::__etag),
                            "rotation" => Ok(__FieldTag::__rotation),
                            "versionAliases" => Ok(__FieldTag::__version_aliases),
                            "version_aliases" => Ok(__FieldTag::__version_aliases),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "versionDestroyTtl" => Ok(__FieldTag::__version_destroy_ttl),
                            "version_destroy_ttl" => Ok(__FieldTag::__version_destroy_ttl),
                            "customerManagedEncryption" => {
                                Ok(__FieldTag::__customer_managed_encryption)
                            }
                            "customer_managed_encryption" => {
                                Ok(__FieldTag::__customer_managed_encryption)
                            }
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Secret;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Secret")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replication => {
                            if !fields.insert(__FieldTag::__replication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication",
                                ));
                            }
                            result.replication =
                                map.next_value::<std::option::Option<crate::model::Replication>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topics => {
                            if !fields.insert(__FieldTag::__topics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topics",
                                ));
                            }
                            result.topics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Topic>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.secretmanager.v1.Secret.expire_time, latest field was expireTime",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::secret::Expiration::ExpireTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.secretmanager.v1.Secret.ttl, latest field was ttl",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::secret::Expiration::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rotation => {
                            if !fields.insert(__FieldTag::__rotation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rotation",
                                ));
                            }
                            result.rotation =
                                map.next_value::<std::option::Option<crate::model::Rotation>>()?;
                        }
                        __FieldTag::__version_aliases => {
                            if !fields.insert(__FieldTag::__version_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_aliases",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.version_aliases =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_destroy_ttl => {
                            if !fields.insert(__FieldTag::__version_destroy_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_destroy_ttl",
                                ));
                            }
                            result.version_destroy_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__customer_managed_encryption => {
                            if !fields.insert(__FieldTag::__customer_managed_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_managed_encryption",
                                ));
                            }
                            result.customer_managed_encryption = map.next_value::<std::option::Option<crate::model::CustomerManagedEncryption>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Secret {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.replication.is_some() {
            state.serialize_entry("replication", &self.replication)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.topics.is_empty() {
            state.serialize_entry("topics", &self.topics)?;
        }
        if let Some(value) = self.expire_time() {
            state.serialize_entry("expireTime", value)?;
        }
        if let Some(value) = self.ttl() {
            state.serialize_entry("ttl", value)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.rotation.is_some() {
            state.serialize_entry("rotation", &self.rotation)?;
        }
        if !self.version_aliases.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("versionAliases", &__With(&self.version_aliases))?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.version_destroy_ttl.is_some() {
            state.serialize_entry("versionDestroyTtl", &self.version_destroy_ttl)?;
        }
        if self.customer_managed_encryption.is_some() {
            state.serialize_entry(
                "customerManagedEncryption",
                &self.customer_managed_encryption,
            )?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Secret].
pub mod secret {
    #[allow(unused_imports)]
    use super::*;

    /// Expiration policy attached to the
    /// [Secret][google.cloud.secretmanager.v1.Secret]. If specified the
    /// [Secret][google.cloud.secretmanager.v1.Secret] and all
    /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] will be
    /// automatically deleted at expiration. Expired secrets are irreversibly
    /// deleted.
    ///
    /// Expiration is *not* the recommended way to set time-based permissions. [IAM
    /// Conditions](https://cloud.google.com/secret-manager/docs/access-control#conditions)
    /// is recommended for granting time-based permissions because the operation
    /// can be reversed.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Expiration {
        /// Optional. Timestamp in UTC when the
        /// [Secret][google.cloud.secretmanager.v1.Secret] is scheduled to expire.
        /// This is always provided on output, regardless of what was sent on input.
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The TTL for the
        /// [Secret][google.cloud.secretmanager.v1.Secret].
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// A secret version resource in the Secret Manager API.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretVersion {
    /// Output only. The resource name of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
    /// `projects/*/secrets/*/versions/*`.
    ///
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] IDs in a
    /// [Secret][google.cloud.secretmanager.v1.Secret] start at 1 and are
    /// incremented for each subsequent version of the secret.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub name: std::string::String,

    /// Output only. The time at which the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] was created.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] was destroyed.
    /// Only present if [state][google.cloud.secretmanager.v1.SecretVersion.state]
    /// is
    /// [DESTROYED][google.cloud.secretmanager.v1.SecretVersion.State.DESTROYED].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    /// [google.cloud.secretmanager.v1.SecretVersion.State.DESTROYED]: crate::model::secret_version::State::Destroyed
    /// [google.cloud.secretmanager.v1.SecretVersion.state]: crate::model::SecretVersion::state
    pub destroy_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub state: crate::model::secret_version::State,

    /// The replication status of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub replication_status: std::option::Option<crate::model::ReplicationStatus>,

    /// Output only. Etag of the currently stored
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub etag: std::string::String,

    /// Output only. True if payload checksum specified in
    /// [SecretPayload][google.cloud.secretmanager.v1.SecretPayload] object has
    /// been received by
    /// [SecretManagerService][google.cloud.secretmanager.v1.SecretManagerService]
    /// on
    /// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretManagerService]: crate::client::SecretManagerService
    /// [google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion]: crate::client::SecretManagerService::add_secret_version
    /// [google.cloud.secretmanager.v1.SecretPayload]: crate::model::SecretPayload
    pub client_specified_payload_checksum: bool,

    /// Optional. Output only. Scheduled destroy time for secret version.
    /// This is a part of the Delayed secret version destroy feature. For a
    /// Secret with a valid version destroy TTL, when a secert version is
    /// destroyed, version is moved to disabled state and it is scheduled for
    /// destruction Version is destroyed only after the scheduled_destroy_time.
    pub scheduled_destroy_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The customer-managed encryption status of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. Only
    /// populated if customer-managed encryption is used and
    /// [Secret][google.cloud.secretmanager.v1.Secret] is a regionalized secret.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub customer_managed_encryption:
        std::option::Option<crate::model::CustomerManagedEncryptionStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SecretVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SecretVersion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SecretVersion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destroy_time][crate::model::SecretVersion::destroy_time].
    pub fn set_destroy_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.destroy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destroy_time][crate::model::SecretVersion::destroy_time].
    pub fn set_or_clear_destroy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.destroy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::SecretVersion::state].
    pub fn set_state<T: std::convert::Into<crate::model::secret_version::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [replication_status][crate::model::SecretVersion::replication_status].
    pub fn set_replication_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationStatus>,
    {
        self.replication_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replication_status][crate::model::SecretVersion::replication_status].
    pub fn set_or_clear_replication_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationStatus>,
    {
        self.replication_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::SecretVersion::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [client_specified_payload_checksum][crate::model::SecretVersion::client_specified_payload_checksum].
    pub fn set_client_specified_payload_checksum<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_specified_payload_checksum = v.into();
        self
    }

    /// Sets the value of [scheduled_destroy_time][crate::model::SecretVersion::scheduled_destroy_time].
    pub fn set_scheduled_destroy_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.scheduled_destroy_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduled_destroy_time][crate::model::SecretVersion::scheduled_destroy_time].
    pub fn set_or_clear_scheduled_destroy_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.scheduled_destroy_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_managed_encryption][crate::model::SecretVersion::customer_managed_encryption].
    pub fn set_customer_managed_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerManagedEncryptionStatus>,
    {
        self.customer_managed_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer_managed_encryption][crate::model::SecretVersion::customer_managed_encryption].
    pub fn set_or_clear_customer_managed_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerManagedEncryptionStatus>,
    {
        self.customer_managed_encryption = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SecretVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.SecretVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __destroy_time,
            __state,
            __replication_status,
            __etag,
            __client_specified_payload_checksum,
            __scheduled_destroy_time,
            __customer_managed_encryption,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "destroyTime" => Ok(__FieldTag::__destroy_time),
                            "destroy_time" => Ok(__FieldTag::__destroy_time),
                            "state" => Ok(__FieldTag::__state),
                            "replicationStatus" => Ok(__FieldTag::__replication_status),
                            "replication_status" => Ok(__FieldTag::__replication_status),
                            "etag" => Ok(__FieldTag::__etag),
                            "clientSpecifiedPayloadChecksum" => {
                                Ok(__FieldTag::__client_specified_payload_checksum)
                            }
                            "client_specified_payload_checksum" => {
                                Ok(__FieldTag::__client_specified_payload_checksum)
                            }
                            "scheduledDestroyTime" => Ok(__FieldTag::__scheduled_destroy_time),
                            "scheduled_destroy_time" => Ok(__FieldTag::__scheduled_destroy_time),
                            "customerManagedEncryption" => {
                                Ok(__FieldTag::__customer_managed_encryption)
                            }
                            "customer_managed_encryption" => {
                                Ok(__FieldTag::__customer_managed_encryption)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__destroy_time => {
                            if !fields.insert(__FieldTag::__destroy_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destroy_time",
                                ));
                            }
                            result.destroy_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::secret_version::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__replication_status => {
                            if !fields.insert(__FieldTag::__replication_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_status",
                                ));
                            }
                            result.replication_status = map
                                .next_value::<std::option::Option<crate::model::ReplicationStatus>>(
                                )?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_specified_payload_checksum => {
                            if !fields.insert(__FieldTag::__client_specified_payload_checksum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_specified_payload_checksum",
                                ));
                            }
                            result.client_specified_payload_checksum = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduled_destroy_time => {
                            if !fields.insert(__FieldTag::__scheduled_destroy_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduled_destroy_time",
                                ));
                            }
                            result.scheduled_destroy_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__customer_managed_encryption => {
                            if !fields.insert(__FieldTag::__customer_managed_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_managed_encryption",
                                ));
                            }
                            result.customer_managed_encryption = map
                                .next_value::<std::option::Option<
                                    crate::model::CustomerManagedEncryptionStatus,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.destroy_time.is_some() {
            state.serialize_entry("destroyTime", &self.destroy_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.replication_status.is_some() {
            state.serialize_entry("replicationStatus", &self.replication_status)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.client_specified_payload_checksum) {
            state.serialize_entry(
                "clientSpecifiedPayloadChecksum",
                &self.client_specified_payload_checksum,
            )?;
        }
        if self.scheduled_destroy_time.is_some() {
            state.serialize_entry("scheduledDestroyTime", &self.scheduled_destroy_time)?;
        }
        if self.customer_managed_encryption.is_some() {
            state.serialize_entry(
                "customerManagedEncryption",
                &self.customer_managed_encryption,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SecretVersion].
pub mod secret_version {
    #[allow(unused_imports)]
    use super::*;

    /// The state of a
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion], indicating if
    /// it can be accessed.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified. This value is unused and invalid.
        Unspecified,
        /// The [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] may be
        /// accessed.
        ///
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        Enabled,
        /// The [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] may not
        /// be accessed, but the secret data is still available and can be placed
        /// back into the
        /// [ENABLED][google.cloud.secretmanager.v1.SecretVersion.State.ENABLED]
        /// state.
        ///
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        /// [google.cloud.secretmanager.v1.SecretVersion.State.ENABLED]: crate::model::secret_version::State::Enabled
        Disabled,
        /// The [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] is
        /// destroyed and the secret data is no longer stored. A version may not
        /// leave this state once entered.
        ///
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        Destroyed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Destroyed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Destroyed => std::option::Option::Some("DESTROYED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Destroyed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "DESTROYED" => Self::Destroyed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Destroyed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.secretmanager.v1.SecretVersion.State",
            ))
        }
    }
}

/// A policy that defines the replication and encryption configuration of data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Replication {
    /// The replication policy for this secret.
    pub replication: std::option::Option<crate::model::replication::Replication>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Replication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replication][crate::model::Replication::replication].
    ///
    /// Note that all the setters affecting `replication` are mutually
    /// exclusive.
    pub fn set_replication<
        T: std::convert::Into<std::option::Option<crate::model::replication::Replication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication = v.into();
        self
    }

    /// The value of [replication][crate::model::Replication::replication]
    /// if it holds a `Automatic`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automatic(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::replication::Automatic>> {
        #[allow(unreachable_patterns)]
        self.replication.as_ref().and_then(|v| match v {
            crate::model::replication::Replication::Automatic(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [replication][crate::model::Replication::replication]
    /// to hold a `Automatic`.
    ///
    /// Note that all the setters affecting `replication` are
    /// mutually exclusive.
    pub fn set_automatic<
        T: std::convert::Into<std::boxed::Box<crate::model::replication::Automatic>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication =
            std::option::Option::Some(crate::model::replication::Replication::Automatic(v.into()));
        self
    }

    /// The value of [replication][crate::model::Replication::replication]
    /// if it holds a `UserManaged`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_managed(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::replication::UserManaged>> {
        #[allow(unreachable_patterns)]
        self.replication.as_ref().and_then(|v| match v {
            crate::model::replication::Replication::UserManaged(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [replication][crate::model::Replication::replication]
    /// to hold a `UserManaged`.
    ///
    /// Note that all the setters affecting `replication` are
    /// mutually exclusive.
    pub fn set_user_managed<
        T: std::convert::Into<std::boxed::Box<crate::model::replication::UserManaged>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication = std::option::Option::Some(
            crate::model::replication::Replication::UserManaged(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Replication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Replication"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Replication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __automatic,
            __user_managed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Replication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "automatic" => Ok(__FieldTag::__automatic),
                            "userManaged" => Ok(__FieldTag::__user_managed),
                            "user_managed" => Ok(__FieldTag::__user_managed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Replication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Replication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__automatic => {
                            if !fields.insert(__FieldTag::__automatic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automatic",
                                ));
                            }
                            if result.replication.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `replication`, a oneof with full ID .google.cloud.secretmanager.v1.Replication.automatic, latest field was automatic",
                                ));
                            }
                            result.replication = std::option::Option::Some(
                                crate::model::replication::Replication::Automatic(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::replication::Automatic>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__user_managed => {
                            if !fields.insert(__FieldTag::__user_managed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed",
                                ));
                            }
                            if result.replication.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `replication`, a oneof with full ID .google.cloud.secretmanager.v1.Replication.user_managed, latest field was userManaged",
                                ));
                            }
                            result.replication = std::option::Option::Some(
                                crate::model::replication::Replication::UserManaged(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::replication::UserManaged>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Replication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.automatic() {
            state.serialize_entry("automatic", value)?;
        }
        if let Some(value) = self.user_managed() {
            state.serialize_entry("userManaged", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Replication].
pub mod replication {
    #[allow(unused_imports)]
    use super::*;

    /// A replication policy that replicates the
    /// [Secret][google.cloud.secretmanager.v1.Secret] payload without any
    /// restrictions.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Automatic {
        /// Optional. The customer-managed encryption configuration of the
        /// [Secret][google.cloud.secretmanager.v1.Secret]. If no configuration is
        /// provided, Google-managed default encryption is used.
        ///
        /// Updates to the [Secret][google.cloud.secretmanager.v1.Secret] encryption
        /// configuration only apply to
        /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] added
        /// afterwards. They do not apply retroactively to existing
        /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion].
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        pub customer_managed_encryption:
            std::option::Option<crate::model::CustomerManagedEncryption>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Automatic {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [customer_managed_encryption][crate::model::replication::Automatic::customer_managed_encryption].
        pub fn set_customer_managed_encryption<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::CustomerManagedEncryption>,
        {
            self.customer_managed_encryption = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [customer_managed_encryption][crate::model::replication::Automatic::customer_managed_encryption].
        pub fn set_or_clear_customer_managed_encryption<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::CustomerManagedEncryption>,
        {
            self.customer_managed_encryption = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Automatic {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.secretmanager.v1.Replication.Automatic"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Automatic {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __customer_managed_encryption,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Automatic")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "customerManagedEncryption" => {
                                    Ok(__FieldTag::__customer_managed_encryption)
                                }
                                "customer_managed_encryption" => {
                                    Ok(__FieldTag::__customer_managed_encryption)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Automatic;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Automatic")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__customer_managed_encryption => {
                                if !fields.insert(__FieldTag::__customer_managed_encryption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_managed_encryption",
                                    ));
                                }
                                result.customer_managed_encryption =
                                    map.next_value::<std::option::Option<
                                        crate::model::CustomerManagedEncryption,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Automatic {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.customer_managed_encryption.is_some() {
                state.serialize_entry(
                    "customerManagedEncryption",
                    &self.customer_managed_encryption,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A replication policy that replicates the
    /// [Secret][google.cloud.secretmanager.v1.Secret] payload into the locations
    /// specified in
    /// [Replication.UserManaged.replicas][google.cloud.secretmanager.v1.Replication.UserManaged.replicas]
    ///
    /// [google.cloud.secretmanager.v1.Replication.UserManaged.replicas]: crate::model::replication::UserManaged::replicas
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserManaged {
        /// Required. The list of Replicas for this
        /// [Secret][google.cloud.secretmanager.v1.Secret].
        ///
        /// Cannot be empty.
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        pub replicas: std::vec::Vec<crate::model::replication::user_managed::Replica>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserManaged {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [replicas][crate::model::replication::UserManaged::replicas].
        pub fn set_replicas<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::replication::user_managed::Replica>,
        {
            use std::iter::Iterator;
            self.replicas = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for UserManaged {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.secretmanager.v1.Replication.UserManaged"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserManaged {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __replicas,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserManaged")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "replicas" => Ok(__FieldTag::__replicas),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserManaged;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserManaged")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__replicas => {
                                if !fields.insert(__FieldTag::__replicas) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replicas",
                                    ));
                                }
                                result.replicas = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::replication::user_managed::Replica,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserManaged {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.replicas.is_empty() {
                state.serialize_entry("replicas", &self.replicas)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [UserManaged].
    pub mod user_managed {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a Replica for this
        /// [Secret][google.cloud.secretmanager.v1.Secret].
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Replica {
            /// The canonical IDs of the location to replicate data.
            /// For example: `"us-east1"`.
            pub location: std::string::String,

            /// Optional. The customer-managed encryption configuration of the
            /// [User-Managed Replica][Replication.UserManaged.Replica]. If no
            /// configuration is provided, Google-managed default encryption is used.
            ///
            /// Updates to the [Secret][google.cloud.secretmanager.v1.Secret]
            /// encryption configuration only apply to
            /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] added
            /// afterwards. They do not apply retroactively to existing
            /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion].
            ///
            /// [Replication.UserManaged.Replica]: crate::model::replication::user_managed::Replica
            /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
            /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
            pub customer_managed_encryption:
                std::option::Option<crate::model::CustomerManagedEncryption>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Replica {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [location][crate::model::replication::user_managed::Replica::location].
            pub fn set_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.location = v.into();
                self
            }

            /// Sets the value of [customer_managed_encryption][crate::model::replication::user_managed::Replica::customer_managed_encryption].
            pub fn set_customer_managed_encryption<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::CustomerManagedEncryption>,
            {
                self.customer_managed_encryption = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [customer_managed_encryption][crate::model::replication::user_managed::Replica::customer_managed_encryption].
            pub fn set_or_clear_customer_managed_encryption<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<crate::model::CustomerManagedEncryption>,
            {
                self.customer_managed_encryption = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Replica {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.secretmanager.v1.Replication.UserManaged.Replica"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Replica {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __location,
                    __customer_managed_encryption,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Replica")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "location" => Ok(__FieldTag::__location),
                                    "customerManagedEncryption" => {
                                        Ok(__FieldTag::__customer_managed_encryption)
                                    }
                                    "customer_managed_encryption" => {
                                        Ok(__FieldTag::__customer_managed_encryption)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Replica;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Replica")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__location => {
                                    if !fields.insert(__FieldTag::__location) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for location",
                                            ),
                                        );
                                    }
                                    result.location = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__customer_managed_encryption => {
                                    if !fields.insert(__FieldTag::__customer_managed_encryption) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for customer_managed_encryption",
                                            ),
                                        );
                                    }
                                    result.customer_managed_encryption = map
                                        .next_value::<std::option::Option<
                                            crate::model::CustomerManagedEncryption,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Replica {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.location.is_empty() {
                    state.serialize_entry("location", &self.location)?;
                }
                if self.customer_managed_encryption.is_some() {
                    state.serialize_entry(
                        "customerManagedEncryption",
                        &self.customer_managed_encryption,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// The replication policy for this secret.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Replication {
        /// The [Secret][google.cloud.secretmanager.v1.Secret] will automatically be
        /// replicated without any restrictions.
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        Automatic(std::boxed::Box<crate::model::replication::Automatic>),
        /// The [Secret][google.cloud.secretmanager.v1.Secret] will only be
        /// replicated into the locations specified.
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        UserManaged(std::boxed::Box<crate::model::replication::UserManaged>),
    }
}

/// Configuration for encrypting secret payloads using customer-managed
/// encryption keys (CMEK).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerManagedEncryption {
    /// Required. The resource name of the Cloud KMS CryptoKey used to encrypt
    /// secret payloads.
    ///
    /// For secrets using the
    /// [UserManaged][google.cloud.secretmanager.v1.Replication.UserManaged]
    /// replication policy type, Cloud KMS CryptoKeys must reside in the same
    /// location as the [replica location][Secret.UserManaged.Replica.location].
    ///
    /// For secrets using the
    /// [Automatic][google.cloud.secretmanager.v1.Replication.Automatic]
    /// replication policy type, Cloud KMS CryptoKeys must reside in `global`.
    ///
    /// The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    ///
    /// [google.cloud.secretmanager.v1.Replication.Automatic]: crate::model::replication::Automatic
    /// [google.cloud.secretmanager.v1.Replication.UserManaged]: crate::model::replication::UserManaged
    pub kms_key_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerManagedEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::CustomerManagedEncryption::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for CustomerManagedEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.CustomerManagedEncryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomerManagedEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerManagedEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomerManagedEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerManagedEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomerManagedEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The replication status of a
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicationStatus {
    /// The replication status of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub replication_status:
        std::option::Option<crate::model::replication_status::ReplicationStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replication_status][crate::model::ReplicationStatus::replication_status].
    ///
    /// Note that all the setters affecting `replication_status` are mutually
    /// exclusive.
    pub fn set_replication_status<
        T: std::convert::Into<
                std::option::Option<crate::model::replication_status::ReplicationStatus>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_status = v.into();
        self
    }

    /// The value of [replication_status][crate::model::ReplicationStatus::replication_status]
    /// if it holds a `Automatic`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automatic(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::replication_status::AutomaticStatus>>
    {
        #[allow(unreachable_patterns)]
        self.replication_status.as_ref().and_then(|v| match v {
            crate::model::replication_status::ReplicationStatus::Automatic(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [replication_status][crate::model::ReplicationStatus::replication_status]
    /// to hold a `Automatic`.
    ///
    /// Note that all the setters affecting `replication_status` are
    /// mutually exclusive.
    pub fn set_automatic<
        T: std::convert::Into<std::boxed::Box<crate::model::replication_status::AutomaticStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_status = std::option::Option::Some(
            crate::model::replication_status::ReplicationStatus::Automatic(v.into()),
        );
        self
    }

    /// The value of [replication_status][crate::model::ReplicationStatus::replication_status]
    /// if it holds a `UserManaged`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_managed(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::replication_status::UserManagedStatus>>
    {
        #[allow(unreachable_patterns)]
        self.replication_status.as_ref().and_then(|v| match v {
            crate::model::replication_status::ReplicationStatus::UserManaged(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [replication_status][crate::model::ReplicationStatus::replication_status]
    /// to hold a `UserManaged`.
    ///
    /// Note that all the setters affecting `replication_status` are
    /// mutually exclusive.
    pub fn set_user_managed<
        T: std::convert::Into<std::boxed::Box<crate::model::replication_status::UserManagedStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_status = std::option::Option::Some(
            crate::model::replication_status::ReplicationStatus::UserManaged(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReplicationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ReplicationStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicationStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __automatic,
            __user_managed,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "automatic" => Ok(__FieldTag::__automatic),
                            "userManaged" => Ok(__FieldTag::__user_managed),
                            "user_managed" => Ok(__FieldTag::__user_managed),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicationStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__automatic => {
                            if !fields.insert(__FieldTag::__automatic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automatic",
                                ));
                            }
                            if result.replication_status.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `replication_status`, a oneof with full ID .google.cloud.secretmanager.v1.ReplicationStatus.automatic, latest field was automatic",
                                ));
                            }
                            result.replication_status = std::option::Option::Some(
                                crate::model::replication_status::ReplicationStatus::Automatic(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::replication_status::AutomaticStatus,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__user_managed => {
                            if !fields.insert(__FieldTag::__user_managed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed",
                                ));
                            }
                            if result.replication_status.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `replication_status`, a oneof with full ID .google.cloud.secretmanager.v1.ReplicationStatus.user_managed, latest field was userManaged",
                                ));
                            }
                            result.replication_status = std::option::Option::Some(
                                crate::model::replication_status::ReplicationStatus::UserManaged(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::replication_status::UserManagedStatus,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.automatic() {
            state.serialize_entry("automatic", value)?;
        }
        if let Some(value) = self.user_managed() {
            state.serialize_entry("userManaged", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReplicationStatus].
pub mod replication_status {
    #[allow(unused_imports)]
    use super::*;

    /// The replication status of a
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] using
    /// automatic replication.
    ///
    /// Only populated if the parent [Secret][google.cloud.secretmanager.v1.Secret]
    /// has an automatic replication policy.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutomaticStatus {
        /// Output only. The customer-managed encryption status of the
        /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. Only
        /// populated if customer-managed encryption is used.
        ///
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        pub customer_managed_encryption:
            std::option::Option<crate::model::CustomerManagedEncryptionStatus>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutomaticStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [customer_managed_encryption][crate::model::replication_status::AutomaticStatus::customer_managed_encryption].
        pub fn set_customer_managed_encryption<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::CustomerManagedEncryptionStatus>,
        {
            self.customer_managed_encryption = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [customer_managed_encryption][crate::model::replication_status::AutomaticStatus::customer_managed_encryption].
        pub fn set_or_clear_customer_managed_encryption<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::CustomerManagedEncryptionStatus>,
        {
            self.customer_managed_encryption = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AutomaticStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.secretmanager.v1.ReplicationStatus.AutomaticStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AutomaticStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __customer_managed_encryption,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AutomaticStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "customerManagedEncryption" => {
                                    Ok(__FieldTag::__customer_managed_encryption)
                                }
                                "customer_managed_encryption" => {
                                    Ok(__FieldTag::__customer_managed_encryption)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AutomaticStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AutomaticStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__customer_managed_encryption => {
                                if !fields.insert(__FieldTag::__customer_managed_encryption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for customer_managed_encryption",
                                    ));
                                }
                                result.customer_managed_encryption = map
                                    .next_value::<std::option::Option<
                                        crate::model::CustomerManagedEncryptionStatus,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AutomaticStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.customer_managed_encryption.is_some() {
                state.serialize_entry(
                    "customerManagedEncryption",
                    &self.customer_managed_encryption,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The replication status of a
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] using
    /// user-managed replication.
    ///
    /// Only populated if the parent [Secret][google.cloud.secretmanager.v1.Secret]
    /// has a user-managed replication policy.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserManagedStatus {
        /// Output only. The list of replica statuses for the
        /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
        ///
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        pub replicas:
            std::vec::Vec<crate::model::replication_status::user_managed_status::ReplicaStatus>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserManagedStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [replicas][crate::model::replication_status::UserManagedStatus::replicas].
        pub fn set_replicas<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::replication_status::user_managed_status::ReplicaStatus,
                >,
        {
            use std::iter::Iterator;
            self.replicas = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for UserManagedStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.secretmanager.v1.ReplicationStatus.UserManagedStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserManagedStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __replicas,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserManagedStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "replicas" => Ok(__FieldTag::__replicas),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserManagedStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserManagedStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__replicas => {
                                if !fields.insert(__FieldTag::__replicas) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replicas",
                                    ));
                                }
                                result.replicas = map.next_value::<std::option::Option<std::vec::Vec<crate::model::replication_status::user_managed_status::ReplicaStatus>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserManagedStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.replicas.is_empty() {
                state.serialize_entry("replicas", &self.replicas)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [UserManagedStatus].
    pub mod user_managed_status {
        #[allow(unused_imports)]
        use super::*;

        /// Describes the status of a user-managed replica for the
        /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
        ///
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ReplicaStatus {
            /// Output only. The canonical ID of the replica location.
            /// For example: `"us-east1"`.
            pub location: std::string::String,

            /// Output only. The customer-managed encryption status of the
            /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. Only
            /// populated if customer-managed encryption is used.
            ///
            /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
            pub customer_managed_encryption:
                std::option::Option<crate::model::CustomerManagedEncryptionStatus>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ReplicaStatus {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [location][crate::model::replication_status::user_managed_status::ReplicaStatus::location].
            pub fn set_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.location = v.into();
                self
            }

            /// Sets the value of [customer_managed_encryption][crate::model::replication_status::user_managed_status::ReplicaStatus::customer_managed_encryption].
            pub fn set_customer_managed_encryption<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::CustomerManagedEncryptionStatus>,
            {
                self.customer_managed_encryption = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [customer_managed_encryption][crate::model::replication_status::user_managed_status::ReplicaStatus::customer_managed_encryption].
            pub fn set_or_clear_customer_managed_encryption<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<crate::model::CustomerManagedEncryptionStatus>,
            {
                self.customer_managed_encryption = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for ReplicaStatus {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.secretmanager.v1.ReplicationStatus.UserManagedStatus.ReplicaStatus"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ReplicaStatus {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __location,
                    __customer_managed_encryption,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ReplicaStatus")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "location" => Ok(__FieldTag::__location),
                                    "customerManagedEncryption" => {
                                        Ok(__FieldTag::__customer_managed_encryption)
                                    }
                                    "customer_managed_encryption" => {
                                        Ok(__FieldTag::__customer_managed_encryption)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ReplicaStatus;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ReplicaStatus")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__location => {
                                    if !fields.insert(__FieldTag::__location) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for location",
                                            ),
                                        );
                                    }
                                    result.location = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__customer_managed_encryption => {
                                    if !fields.insert(__FieldTag::__customer_managed_encryption) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for customer_managed_encryption",
                                            ),
                                        );
                                    }
                                    result.customer_managed_encryption = map
                                        .next_value::<std::option::Option<
                                            crate::model::CustomerManagedEncryptionStatus,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ReplicaStatus {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.location.is_empty() {
                    state.serialize_entry("location", &self.location)?;
                }
                if self.customer_managed_encryption.is_some() {
                    state.serialize_entry(
                        "customerManagedEncryption",
                        &self.customer_managed_encryption,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// The replication status of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplicationStatus {
        /// Describes the replication status of a
        /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] with
        /// automatic replication.
        ///
        /// Only populated if the parent
        /// [Secret][google.cloud.secretmanager.v1.Secret] has an automatic
        /// replication policy.
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        Automatic(std::boxed::Box<crate::model::replication_status::AutomaticStatus>),
        /// Describes the replication status of a
        /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] with
        /// user-managed replication.
        ///
        /// Only populated if the parent
        /// [Secret][google.cloud.secretmanager.v1.Secret] has a user-managed
        /// replication policy.
        ///
        /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
        /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
        UserManaged(std::boxed::Box<crate::model::replication_status::UserManagedStatus>),
    }
}

/// Describes the status of customer-managed encryption.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerManagedEncryptionStatus {
    /// Required. The resource name of the Cloud KMS CryptoKeyVersion used to
    /// encrypt the secret payload, in the following format:
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/versions/*`.
    pub kms_key_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerManagedEncryptionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_version_name][crate::model::CustomerManagedEncryptionStatus::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }
}

impl wkt::message::Message for CustomerManagedEncryptionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.CustomerManagedEncryptionStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomerManagedEncryptionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerManagedEncryptionStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomerManagedEncryptionStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerManagedEncryptionStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomerManagedEncryptionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Pub/Sub topic which Secret Manager will publish to when control plane
/// events occur on this secret.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Topic {
    /// Identifier. The resource name of the Pub/Sub topic that will be published
    /// to, in the following format: `projects/*/topics/*`. For publication to
    /// succeed, the Secret Manager service agent must have the
    /// `pubsub.topic.publish` permission on the topic. The Pub/Sub Publisher role
    /// (`roles/pubsub.publisher`) includes this permission.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Topic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Topic::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Topic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Topic"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Topic {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Topic")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Topic;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Topic")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Topic {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The rotation time and period for a
/// [Secret][google.cloud.secretmanager.v1.Secret]. At next_rotation_time, Secret
/// Manager will send a Pub/Sub notification to the topics configured on the
/// Secret. [Secret.topics][google.cloud.secretmanager.v1.Secret.topics] must be
/// set to configure rotation.
///
/// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
/// [google.cloud.secretmanager.v1.Secret.topics]: crate::model::Secret::topics
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Rotation {
    /// Optional. Timestamp in UTC at which the
    /// [Secret][google.cloud.secretmanager.v1.Secret] is scheduled to rotate.
    /// Cannot be set to less than 300s (5 min) in the future and at most
    /// 3153600000s (100 years).
    ///
    /// [next_rotation_time][google.cloud.secretmanager.v1.Rotation.next_rotation_time]
    /// MUST  be set if
    /// [rotation_period][google.cloud.secretmanager.v1.Rotation.rotation_period]
    /// is set.
    ///
    /// [google.cloud.secretmanager.v1.Rotation.next_rotation_time]: crate::model::Rotation::next_rotation_time
    /// [google.cloud.secretmanager.v1.Rotation.rotation_period]: crate::model::Rotation::rotation_period
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub next_rotation_time: std::option::Option<wkt::Timestamp>,

    /// Input only. The Duration between rotation notifications. Must be in seconds
    /// and at least 3600s (1h) and at most 3153600000s (100 years).
    ///
    /// If
    /// [rotation_period][google.cloud.secretmanager.v1.Rotation.rotation_period]
    /// is set,
    /// [next_rotation_time][google.cloud.secretmanager.v1.Rotation.next_rotation_time]
    /// must be set.
    /// [next_rotation_time][google.cloud.secretmanager.v1.Rotation.next_rotation_time]
    /// will be advanced by this period when the service automatically sends
    /// rotation notifications.
    ///
    /// [google.cloud.secretmanager.v1.Rotation.next_rotation_time]: crate::model::Rotation::next_rotation_time
    /// [google.cloud.secretmanager.v1.Rotation.rotation_period]: crate::model::Rotation::rotation_period
    pub rotation_period: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_rotation_time][crate::model::Rotation::next_rotation_time].
    pub fn set_next_rotation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_rotation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_rotation_time][crate::model::Rotation::next_rotation_time].
    pub fn set_or_clear_next_rotation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.next_rotation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rotation_period][crate::model::Rotation::rotation_period].
    pub fn set_rotation_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.rotation_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rotation_period][crate::model::Rotation::rotation_period].
    pub fn set_or_clear_rotation_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.rotation_period = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Rotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Rotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Rotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __next_rotation_time,
            __rotation_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nextRotationTime" => Ok(__FieldTag::__next_rotation_time),
                            "next_rotation_time" => Ok(__FieldTag::__next_rotation_time),
                            "rotationPeriod" => Ok(__FieldTag::__rotation_period),
                            "rotation_period" => Ok(__FieldTag::__rotation_period),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Rotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__next_rotation_time => {
                            if !fields.insert(__FieldTag::__next_rotation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_rotation_time",
                                ));
                            }
                            result.next_rotation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__rotation_period => {
                            if !fields.insert(__FieldTag::__rotation_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rotation_period",
                                ));
                            }
                            result.rotation_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Rotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.next_rotation_time.is_some() {
            state.serialize_entry("nextRotationTime", &self.next_rotation_time)?;
        }
        if self.rotation_period.is_some() {
            state.serialize_entry("rotationPeriod", &self.rotation_period)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A secret payload resource in the Secret Manager API. This contains the
/// sensitive secret payload that is associated with a
/// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretPayload {
    /// The secret data. Must be no larger than 64KiB.
    pub data: ::bytes::Bytes,

    /// Optional. If specified,
    /// [SecretManagerService][google.cloud.secretmanager.v1.SecretManagerService]
    /// will verify the integrity of the received
    /// [data][google.cloud.secretmanager.v1.SecretPayload.data] on
    /// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion]
    /// calls using the crc32c checksum and store it to include in future
    /// [SecretManagerService.AccessSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion]
    /// responses. If a checksum is not provided in the
    /// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion]
    /// request, the
    /// [SecretManagerService][google.cloud.secretmanager.v1.SecretManagerService]
    /// will generate and store one for you.
    ///
    /// The CRC32C value is encoded as a Int64 for compatibility, and can be
    /// safely downconverted to uint32 in languages that support this type.
    /// <https://cloud.google.com/apis/design/design_patterns#integer_types>
    ///
    /// [google.cloud.secretmanager.v1.SecretManagerService]: crate::client::SecretManagerService
    /// [google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion]: crate::client::SecretManagerService::access_secret_version
    /// [google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion]: crate::client::SecretManagerService::add_secret_version
    /// [google.cloud.secretmanager.v1.SecretPayload.data]: crate::model::SecretPayload::data
    pub data_crc32c: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data][crate::model::SecretPayload::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc32c][crate::model::SecretPayload::data_crc32c].
    pub fn set_data_crc32c<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.data_crc32c = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_crc32c][crate::model::SecretPayload::data_crc32c].
    pub fn set_or_clear_data_crc32c<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.data_crc32c = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SecretPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.SecretPayload"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretPayload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data,
            __data_crc32c,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretPayload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "data" => Ok(__FieldTag::__data),
                            "dataCrc32c" => Ok(__FieldTag::__data_crc32c),
                            "data_crc32c" => Ok(__FieldTag::__data_crc32c),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretPayload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretPayload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_crc32c => {
                            if !fields.insert(__FieldTag::__data_crc32c) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_crc32c",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_crc32c = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretPayload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if self.data_crc32c.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataCrc32c", &__With(&self.data_crc32c))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.ListSecrets][google.cloud.secretmanager.v1.SecretManagerService.ListSecrets].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.ListSecrets]: crate::client::SecretManagerService::list_secrets
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSecretsRequest {
    /// Required. The resource name of the project associated with the
    /// [Secrets][google.cloud.secretmanager.v1.Secret], in the format `projects/*`
    /// or `projects/*/locations/*`
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub parent: std::string::String,

    /// Optional. The maximum number of results to be returned in a single page. If
    /// set to 0, the server decides the number of results to return. If the
    /// number is greater than 25000, it is capped at 25000.
    pub page_size: i32,

    /// Optional. Pagination token, returned earlier via
    /// [ListSecretsResponse.next_page_token][google.cloud.secretmanager.v1.ListSecretsResponse.next_page_token].
    ///
    /// [google.cloud.secretmanager.v1.ListSecretsResponse.next_page_token]: crate::model::ListSecretsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Filter string, adhering to the rules in
    /// [List-operation
    /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
    /// only secrets matching the filter. If filter is empty, all secrets are
    /// listed.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSecretsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSecretsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSecretsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSecretsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSecretsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ListSecretsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSecretsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSecretsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSecretsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSecretsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSecretsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [SecretManagerService.ListSecrets][google.cloud.secretmanager.v1.SecretManagerService.ListSecrets].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.ListSecrets]: crate::client::SecretManagerService::list_secrets
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSecretsResponse {
    /// The list of [Secrets][google.cloud.secretmanager.v1.Secret] sorted in
    /// reverse by create_time (newest first).
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub secrets: std::vec::Vec<crate::model::Secret>,

    /// A token to retrieve the next page of results. Pass this value in
    /// [ListSecretsRequest.page_token][google.cloud.secretmanager.v1.ListSecretsRequest.page_token]
    /// to retrieve the next page.
    ///
    /// [google.cloud.secretmanager.v1.ListSecretsRequest.page_token]: crate::model::ListSecretsRequest::page_token
    pub next_page_token: std::string::String,

    /// The total number of [Secrets][google.cloud.secretmanager.v1.Secret] but 0
    /// when the
    /// [ListSecretsRequest.filter][google.cloud.secretmanager.v1.ListSecretsRequest.filter]
    /// field is set.
    ///
    /// [google.cloud.secretmanager.v1.ListSecretsRequest.filter]: crate::model::ListSecretsRequest::filter
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secrets][crate::model::ListSecretsResponse::secrets].
    pub fn set_secrets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Secret>,
    {
        use std::iter::Iterator;
        self.secrets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSecretsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListSecretsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListSecretsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ListSecretsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSecretsResponse {
    type PageItem = crate::model::Secret;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.secrets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSecretsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secrets,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSecretsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secrets" => Ok(__FieldTag::__secrets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSecretsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSecretsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secrets => {
                            if !fields.insert(__FieldTag::__secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secrets",
                                ));
                            }
                            result.secrets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Secret>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSecretsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secrets.is_empty() {
            state.serialize_entry("secrets", &self.secrets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.CreateSecret][google.cloud.secretmanager.v1.SecretManagerService.CreateSecret].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.CreateSecret]: crate::client::SecretManagerService::create_secret
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSecretRequest {
    /// Required. The resource name of the project to associate with the
    /// [Secret][google.cloud.secretmanager.v1.Secret], in the format `projects/*`
    /// or `projects/*/locations/*`.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub parent: std::string::String,

    /// Required. This must be unique within the project.
    ///
    /// A secret ID is a string with a maximum length of 255 characters and can
    /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`) and
    /// underscore (`_`) characters.
    pub secret_id: std::string::String,

    /// Required. A [Secret][google.cloud.secretmanager.v1.Secret] with initial
    /// field values.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub secret: std::option::Option<crate::model::Secret>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecretRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [secret_id][crate::model::CreateSecretRequest::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::CreateSecretRequest::secret].
    pub fn set_secret<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.secret = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secret][crate::model::CreateSecretRequest::secret].
    pub fn set_or_clear_secret<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.secret = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.CreateSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __secret_id,
            __secret,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "secretId" => Ok(__FieldTag::__secret_id),
                            "secret_id" => Ok(__FieldTag::__secret_id),
                            "secret" => Ok(__FieldTag::__secret),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_id => {
                            if !fields.insert(__FieldTag::__secret_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_id",
                                ));
                            }
                            result.secret_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            result.secret =
                                map.next_value::<std::option::Option<crate::model::Secret>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.secret_id.is_empty() {
            state.serialize_entry("secretId", &self.secret_id)?;
        }
        if self.secret.is_some() {
            state.serialize_entry("secret", &self.secret)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.AddSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.AddSecretVersion]: crate::client::SecretManagerService::add_secret_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AddSecretVersionRequest {
    /// Required. The resource name of the
    /// [Secret][google.cloud.secretmanager.v1.Secret] to associate with the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
    /// `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub parent: std::string::String,

    /// Required. The secret payload of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub payload: std::option::Option<crate::model::SecretPayload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AddSecretVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::AddSecretVersionRequest::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecretPayload>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::AddSecretVersionRequest::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecretPayload>,
    {
        self.payload = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AddSecretVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.AddSecretVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddSecretVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddSecretVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "payload" => Ok(__FieldTag::__payload),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddSecretVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddSecretVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload = map
                                .next_value::<std::option::Option<crate::model::SecretPayload>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddSecretVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.GetSecret][google.cloud.secretmanager.v1.SecretManagerService.GetSecret].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.GetSecret]: crate::client::SecretManagerService::get_secret
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSecretRequest {
    /// Required. The resource name of the
    /// [Secret][google.cloud.secretmanager.v1.Secret], in the format
    /// `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSecretRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.GetSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.ListSecretVersions][google.cloud.secretmanager.v1.SecretManagerService.ListSecretVersions].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.ListSecretVersions]: crate::client::SecretManagerService::list_secret_versions
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSecretVersionsRequest {
    /// Required. The resource name of the
    /// [Secret][google.cloud.secretmanager.v1.Secret] associated with the
    /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] to list, in
    /// the format `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub parent: std::string::String,

    /// Optional. The maximum number of results to be returned in a single page. If
    /// set to 0, the server decides the number of results to return. If the
    /// number is greater than 25000, it is capped at 25000.
    pub page_size: i32,

    /// Optional. Pagination token, returned earlier via
    /// ListSecretVersionsResponse.next_page_token][].
    pub page_token: std::string::String,

    /// Optional. Filter string, adhering to the rules in
    /// [List-operation
    /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
    /// only secret versions matching the filter. If filter is empty, all secret
    /// versions are listed.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSecretVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSecretVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSecretVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSecretVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSecretVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ListSecretVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSecretVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSecretVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSecretVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSecretVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSecretVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [SecretManagerService.ListSecretVersions][google.cloud.secretmanager.v1.SecretManagerService.ListSecretVersions].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.ListSecretVersions]: crate::client::SecretManagerService::list_secret_versions
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSecretVersionsResponse {
    /// The list of [SecretVersions][google.cloud.secretmanager.v1.SecretVersion]
    /// sorted in reverse by create_time (newest first).
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub versions: std::vec::Vec<crate::model::SecretVersion>,

    /// A token to retrieve the next page of results. Pass this value in
    /// [ListSecretVersionsRequest.page_token][google.cloud.secretmanager.v1.ListSecretVersionsRequest.page_token]
    /// to retrieve the next page.
    ///
    /// [google.cloud.secretmanager.v1.ListSecretVersionsRequest.page_token]: crate::model::ListSecretVersionsRequest::page_token
    pub next_page_token: std::string::String,

    /// The total number of
    /// [SecretVersions][google.cloud.secretmanager.v1.SecretVersion] but 0 when
    /// the
    /// [ListSecretsRequest.filter][google.cloud.secretmanager.v1.ListSecretsRequest.filter]
    /// field is set.
    ///
    /// [google.cloud.secretmanager.v1.ListSecretsRequest.filter]: crate::model::ListSecretsRequest::filter
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub total_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListSecretVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretVersion>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSecretVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListSecretVersionsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListSecretVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ListSecretVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSecretVersionsResponse {
    type PageItem = crate::model::SecretVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSecretVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __versions,
            __next_page_token,
            __total_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSecretVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versions" => Ok(__FieldTag::__versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSecretVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSecretVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SecretVersion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSecretVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.GetSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.GetSecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.GetSecretVersion]: crate::client::SecretManagerService::get_secret_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSecretVersionRequest {
    /// Required. The resource name of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
    /// `projects/*/secrets/*/versions/*` or
    /// `projects/*/locations/*/secrets/*/versions/*`.
    ///
    /// `projects/*/secrets/*/versions/latest` or
    /// `projects/*/locations/*/secrets/*/versions/latest` is an alias to the most
    /// recently created
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSecretVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSecretVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.GetSecretVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSecretVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSecretVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSecretVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSecretVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSecretVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.UpdateSecret][google.cloud.secretmanager.v1.SecretManagerService.UpdateSecret].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.UpdateSecret]: crate::client::SecretManagerService::update_secret
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSecretRequest {
    /// Required. [Secret][google.cloud.secretmanager.v1.Secret] with updated field
    /// values.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub secret: std::option::Option<crate::model::Secret>,

    /// Required. Specifies the fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret][crate::model::UpdateSecretRequest::secret].
    pub fn set_secret<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.secret = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secret][crate::model::UpdateSecretRequest::secret].
    pub fn set_or_clear_secret<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Secret>,
    {
        self.secret = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSecretRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSecretRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.UpdateSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secret" => Ok(__FieldTag::__secret),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            result.secret =
                                map.next_value::<std::option::Option<crate::model::Secret>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.secret.is_some() {
            state.serialize_entry("secret", &self.secret)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.AccessSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion]: crate::client::SecretManagerService::access_secret_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessSecretVersionRequest {
    /// Required. The resource name of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
    /// `projects/*/secrets/*/versions/*` or
    /// `projects/*/locations/*/secrets/*/versions/*`.
    ///
    /// `projects/*/secrets/*/versions/latest` or
    /// `projects/*/locations/*/secrets/*/versions/latest` is an alias to the most
    /// recently created
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion].
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessSecretVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AccessSecretVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.AccessSecretVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessSecretVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessSecretVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessSecretVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessSecretVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessSecretVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [SecretManagerService.AccessSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.AccessSecretVersion]: crate::client::SecretManagerService::access_secret_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessSecretVersionResponse {
    /// The resource name of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] in the format
    /// `projects/*/secrets/*/versions/*` or
    /// `projects/*/locations/*/secrets/*/versions/*`.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub name: std::string::String,

    /// Secret payload
    pub payload: std::option::Option<crate::model::SecretPayload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessSecretVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessSecretVersionResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::AccessSecretVersionResponse::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecretPayload>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::AccessSecretVersionResponse::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecretPayload>,
    {
        self.payload = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AccessSecretVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.AccessSecretVersionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessSecretVersionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessSecretVersionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "payload" => Ok(__FieldTag::__payload),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessSecretVersionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessSecretVersionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload = map
                                .next_value::<std::option::Option<crate::model::SecretPayload>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessSecretVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.DeleteSecret][google.cloud.secretmanager.v1.SecretManagerService.DeleteSecret].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.DeleteSecret]: crate::client::SecretManagerService::delete_secret
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSecretRequest {
    /// Required. The resource name of the
    /// [Secret][google.cloud.secretmanager.v1.Secret] to delete in the format
    /// `projects/*/secrets/*`.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub name: std::string::String,

    /// Optional. Etag of the [Secret][google.cloud.secretmanager.v1.Secret]. The
    /// request succeeds if it matches the etag of the currently stored secret
    /// object. If the etag is omitted, the request succeeds.
    ///
    /// [google.cloud.secretmanager.v1.Secret]: crate::model::Secret
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSecretRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteSecretRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSecretRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.DeleteSecretRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSecretRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSecretRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSecretRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSecretRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSecretRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.DisableSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.DisableSecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.DisableSecretVersion]: crate::client::SecretManagerService::disable_secret_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableSecretVersionRequest {
    /// Required. The resource name of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to disable in
    /// the format `projects/*/secrets/*/versions/*` or
    /// `projects/*/locations/*/secrets/*/versions/*`.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub name: std::string::String,

    /// Optional. Etag of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. The request
    /// succeeds if it matches the etag of the currently stored secret version
    /// object. If the etag is omitted, the request succeeds.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableSecretVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DisableSecretVersionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DisableSecretVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.DisableSecretVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableSecretVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableSecretVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableSecretVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableSecretVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableSecretVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.EnableSecretVersion][google.cloud.secretmanager.v1.SecretManagerService.EnableSecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.EnableSecretVersion]: crate::client::SecretManagerService::enable_secret_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableSecretVersionRequest {
    /// Required. The resource name of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to enable in
    /// the format `projects/*/secrets/*/versions/*` or
    /// `projects/*/locations/*/secrets/*/versions/*`.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub name: std::string::String,

    /// Optional. Etag of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. The request
    /// succeeds if it matches the etag of the currently stored secret version
    /// object. If the etag is omitted, the request succeeds.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableSecretVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::EnableSecretVersionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for EnableSecretVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.EnableSecretVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableSecretVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableSecretVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableSecretVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableSecretVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableSecretVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [SecretManagerService.DestroySecretVersion][google.cloud.secretmanager.v1.SecretManagerService.DestroySecretVersion].
///
/// [google.cloud.secretmanager.v1.SecretManagerService.DestroySecretVersion]: crate::client::SecretManagerService::destroy_secret_version
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DestroySecretVersionRequest {
    /// Required. The resource name of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion] to destroy in
    /// the format `projects/*/secrets/*/versions/*` or
    /// `projects/*/locations/*/secrets/*/versions/*`.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub name: std::string::String,

    /// Optional. Etag of the
    /// [SecretVersion][google.cloud.secretmanager.v1.SecretVersion]. The request
    /// succeeds if it matches the etag of the currently stored secret version
    /// object. If the etag is omitted, the request succeeds.
    ///
    /// [google.cloud.secretmanager.v1.SecretVersion]: crate::model::SecretVersion
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestroySecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DestroySecretVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DestroySecretVersionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DestroySecretVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.DestroySecretVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DestroySecretVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DestroySecretVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DestroySecretVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DestroySecretVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DestroySecretVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
