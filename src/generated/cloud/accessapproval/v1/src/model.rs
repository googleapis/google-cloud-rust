// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Home office and physical location of the principal.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessLocations {
    /// The "home office" location of the principal. A two-letter country code
    /// (ISO 3166-1 alpha-2), such as "US", "DE" or "GB" or a region code. In some
    /// limited situations Google systems may refer refer to a region code instead
    /// of a country code.
    /// Possible Region Codes:
    ///
    /// * ASI: Asia
    /// * EUR: Europe
    /// * OCE: Oceania
    /// * AFR: Africa
    /// * NAM: North America
    /// * SAM: South America
    /// * ANT: Antarctica
    /// * ANY: Any location
    pub principal_office_country: std::string::String,

    /// Physical location of the principal at the time of the access. A
    /// two-letter country code (ISO 3166-1 alpha-2), such as "US", "DE" or "GB" or
    /// a region code. In some limited situations Google systems may refer refer to
    /// a region code instead of a country code.
    /// Possible Region Codes:
    ///
    /// * ASI: Asia
    /// * EUR: Europe
    /// * OCE: Oceania
    /// * AFR: Africa
    /// * NAM: North America
    /// * SAM: South America
    /// * ANT: Antarctica
    /// * ANY: Any location
    pub principal_physical_location_country: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessLocations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principal_office_country][crate::model::AccessLocations::principal_office_country].
    pub fn set_principal_office_country<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal_office_country = v.into();
        self
    }

    /// Sets the value of [principal_physical_location_country][crate::model::AccessLocations::principal_physical_location_country].
    pub fn set_principal_physical_location_country<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.principal_physical_location_country = v.into();
        self
    }
}

impl wkt::message::Message for AccessLocations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.AccessLocations"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessLocations {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __principal_office_country,
            __principal_physical_location_country,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessLocations")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "principalOfficeCountry" => Ok(__FieldTag::__principal_office_country),
                            "principal_office_country" => {
                                Ok(__FieldTag::__principal_office_country)
                            }
                            "principalPhysicalLocationCountry" => {
                                Ok(__FieldTag::__principal_physical_location_country)
                            }
                            "principal_physical_location_country" => {
                                Ok(__FieldTag::__principal_physical_location_country)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessLocations;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessLocations")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__principal_office_country => {
                            if !fields.insert(__FieldTag::__principal_office_country) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_office_country",
                                ));
                            }
                            result.principal_office_country = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__principal_physical_location_country => {
                            if !fields.insert(__FieldTag::__principal_physical_location_country) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principal_physical_location_country",
                                ));
                            }
                            result.principal_physical_location_country = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessLocations {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.principal_office_country.is_empty() {
            state.serialize_entry("principalOfficeCountry", &self.principal_office_country)?;
        }
        if !self.principal_physical_location_country.is_empty() {
            state.serialize_entry(
                "principalPhysicalLocationCountry",
                &self.principal_physical_location_country,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessReason {
    /// Type of access justification.
    pub r#type: crate::model::access_reason::Type,

    /// More detail about certain reason types. See comments for each type above.
    pub detail: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AccessReason::type].
    pub fn set_type<T: std::convert::Into<crate::model::access_reason::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::AccessReason::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for AccessReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.AccessReason"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __detail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessReason")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "detail" => Ok(__FieldTag::__detail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessReason;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessReason")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::access_reason::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccessReason].
pub mod access_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Type of access justification.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value for proto, shouldn't be used.
        Unspecified,
        /// Customer made a request or raised an issue that required the principal to
        /// access customer data. `detail` is of the form ("#####" is the issue ID):
        ///
        /// * "Feedback Report: #####"
        /// * "Case Number: #####"
        /// * "Case ID: #####"
        /// * "E-PIN Reference: #####"
        /// * "Google-#####"
        /// * "T-#####"
        CustomerInitiatedSupport,
        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services. Often this access is used to confirm that
        /// customers are not affected by a suspected service issue or to remediate a
        /// reversible system issue.
        GoogleInitiatedService,
        /// Google initiated service for security, fraud, abuse, or compliance
        /// purposes.
        GoogleInitiatedReview,
        /// The principal was compelled to access customer data in order to respond
        /// to a legal third party data request or process, including legal processes
        /// from customers themselves.
        ThirdPartyDataRequest,
        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services or a known outage.
        GoogleResponseToProductionAlert,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CustomerInitiatedSupport => std::option::Option::Some(1),
                Self::GoogleInitiatedService => std::option::Option::Some(2),
                Self::GoogleInitiatedReview => std::option::Option::Some(3),
                Self::ThirdPartyDataRequest => std::option::Option::Some(4),
                Self::GoogleResponseToProductionAlert => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::CustomerInitiatedSupport => {
                    std::option::Option::Some("CUSTOMER_INITIATED_SUPPORT")
                }
                Self::GoogleInitiatedService => {
                    std::option::Option::Some("GOOGLE_INITIATED_SERVICE")
                }
                Self::GoogleInitiatedReview => std::option::Option::Some("GOOGLE_INITIATED_REVIEW"),
                Self::ThirdPartyDataRequest => {
                    std::option::Option::Some("THIRD_PARTY_DATA_REQUEST")
                }
                Self::GoogleResponseToProductionAlert => {
                    std::option::Option::Some("GOOGLE_RESPONSE_TO_PRODUCTION_ALERT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CustomerInitiatedSupport,
                2 => Self::GoogleInitiatedService,
                3 => Self::GoogleInitiatedReview,
                4 => Self::ThirdPartyDataRequest,
                5 => Self::GoogleResponseToProductionAlert,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOMER_INITIATED_SUPPORT" => Self::CustomerInitiatedSupport,
                "GOOGLE_INITIATED_SERVICE" => Self::GoogleInitiatedService,
                "GOOGLE_INITIATED_REVIEW" => Self::GoogleInitiatedReview,
                "THIRD_PARTY_DATA_REQUEST" => Self::ThirdPartyDataRequest,
                "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT" => Self::GoogleResponseToProductionAlert,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CustomerInitiatedSupport => serializer.serialize_i32(1),
                Self::GoogleInitiatedService => serializer.serialize_i32(2),
                Self::GoogleInitiatedReview => serializer.serialize_i32(3),
                Self::ThirdPartyDataRequest => serializer.serialize_i32(4),
                Self::GoogleResponseToProductionAlert => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.accessapproval.v1.AccessReason.Type",
            ))
        }
    }
}

/// Information about the digital signature of the resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SignatureInfo {
    /// The digital signature.
    pub signature: ::bytes::Bytes,

    /// How this signature may be verified.
    pub verification_info: std::option::Option<crate::model::signature_info::VerificationInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SignatureInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signature][crate::model::SignatureInfo::signature].
    pub fn set_signature<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.signature = v.into();
        self
    }

    /// Sets the value of [verification_info][crate::model::SignatureInfo::verification_info].
    ///
    /// Note that all the setters affecting `verification_info` are mutually
    /// exclusive.
    pub fn set_verification_info<
        T: std::convert::Into<std::option::Option<crate::model::signature_info::VerificationInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.verification_info = v.into();
        self
    }

    /// The value of [verification_info][crate::model::SignatureInfo::verification_info]
    /// if it holds a `GooglePublicKeyPem`, `None` if the field is not set or
    /// holds a different branch.
    pub fn google_public_key_pem(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.verification_info.as_ref().and_then(|v| match v {
            crate::model::signature_info::VerificationInfo::GooglePublicKeyPem(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [verification_info][crate::model::SignatureInfo::verification_info]
    /// to hold a `GooglePublicKeyPem`.
    ///
    /// Note that all the setters affecting `verification_info` are
    /// mutually exclusive.
    pub fn set_google_public_key_pem<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.verification_info = std::option::Option::Some(
            crate::model::signature_info::VerificationInfo::GooglePublicKeyPem(v.into()),
        );
        self
    }

    /// The value of [verification_info][crate::model::SignatureInfo::verification_info]
    /// if it holds a `CustomerKmsKeyVersion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn customer_kms_key_version(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.verification_info.as_ref().and_then(|v| match v {
            crate::model::signature_info::VerificationInfo::CustomerKmsKeyVersion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [verification_info][crate::model::SignatureInfo::verification_info]
    /// to hold a `CustomerKmsKeyVersion`.
    ///
    /// Note that all the setters affecting `verification_info` are
    /// mutually exclusive.
    pub fn set_customer_kms_key_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.verification_info = std::option::Option::Some(
            crate::model::signature_info::VerificationInfo::CustomerKmsKeyVersion(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SignatureInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.SignatureInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SignatureInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signature,
            __google_public_key_pem,
            __customer_kms_key_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SignatureInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signature" => Ok(__FieldTag::__signature),
                            "googlePublicKeyPem" => Ok(__FieldTag::__google_public_key_pem),
                            "google_public_key_pem" => Ok(__FieldTag::__google_public_key_pem),
                            "customerKmsKeyVersion" => Ok(__FieldTag::__customer_kms_key_version),
                            "customer_kms_key_version" => {
                                Ok(__FieldTag::__customer_kms_key_version)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SignatureInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SignatureInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signature => {
                            if !fields.insert(__FieldTag::__signature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.signature = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__google_public_key_pem => {
                            if !fields.insert(__FieldTag::__google_public_key_pem) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_public_key_pem",
                                ));
                            }
                            if result.verification_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `verification_info`, a oneof with full ID .google.cloud.accessapproval.v1.SignatureInfo.google_public_key_pem, latest field was googlePublicKeyPem",
                                ));
                            }
                            result.verification_info = std::option::Option::Some(
                                crate::model::signature_info::VerificationInfo::GooglePublicKeyPem(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__customer_kms_key_version => {
                            if !fields.insert(__FieldTag::__customer_kms_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_kms_key_version",
                                ));
                            }
                            if result.verification_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `verification_info`, a oneof with full ID .google.cloud.accessapproval.v1.SignatureInfo.customer_kms_key_version, latest field was customerKmsKeyVersion",
                                ));
                            }
                            result.verification_info = std::option::Option::Some(
                                crate::model::signature_info::VerificationInfo::CustomerKmsKeyVersion(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SignatureInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.signature.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("signature", &__With(&self.signature))?;
        }
        if let Some(value) = self.google_public_key_pem() {
            state.serialize_entry("googlePublicKeyPem", value)?;
        }
        if let Some(value) = self.customer_kms_key_version() {
            state.serialize_entry("customerKmsKeyVersion", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SignatureInfo].
pub mod signature_info {
    #[allow(unused_imports)]
    use super::*;

    /// How this signature may be verified.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VerificationInfo {
        /// The public key for the Google default signing, encoded in PEM format. The
        /// signature was created using a private key which may be verified using
        /// this public key.
        GooglePublicKeyPem(std::string::String),
        /// The resource name of the customer CryptoKeyVersion used for signing.
        CustomerKmsKeyVersion(std::string::String),
    }
}

/// A decision that has been made to approve access to a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ApproveDecision {
    /// The time at which approval was granted.
    pub approve_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the approval expires.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// If set, denotes the timestamp at which the approval is invalidated.
    pub invalidate_time: std::option::Option<wkt::Timestamp>,

    /// The signature for the ApprovalRequest and details on how it was signed.
    pub signature_info: std::option::Option<crate::model::SignatureInfo>,

    /// True when the request has been auto-approved.
    pub auto_approved: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveDecision {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approve_time][crate::model::ApproveDecision::approve_time].
    pub fn set_approve_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approve_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approve_time][crate::model::ApproveDecision::approve_time].
    pub fn set_or_clear_approve_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.approve_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::ApproveDecision::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::ApproveDecision::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [invalidate_time][crate::model::ApproveDecision::invalidate_time].
    pub fn set_invalidate_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.invalidate_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invalidate_time][crate::model::ApproveDecision::invalidate_time].
    pub fn set_or_clear_invalidate_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.invalidate_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [signature_info][crate::model::ApproveDecision::signature_info].
    pub fn set_signature_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SignatureInfo>,
    {
        self.signature_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [signature_info][crate::model::ApproveDecision::signature_info].
    pub fn set_or_clear_signature_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SignatureInfo>,
    {
        self.signature_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_approved][crate::model::ApproveDecision::auto_approved].
    pub fn set_auto_approved<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_approved = v.into();
        self
    }
}

impl wkt::message::Message for ApproveDecision {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.ApproveDecision"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApproveDecision {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __approve_time,
            __expire_time,
            __invalidate_time,
            __signature_info,
            __auto_approved,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApproveDecision")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "approveTime" => Ok(__FieldTag::__approve_time),
                            "approve_time" => Ok(__FieldTag::__approve_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "invalidateTime" => Ok(__FieldTag::__invalidate_time),
                            "invalidate_time" => Ok(__FieldTag::__invalidate_time),
                            "signatureInfo" => Ok(__FieldTag::__signature_info),
                            "signature_info" => Ok(__FieldTag::__signature_info),
                            "autoApproved" => Ok(__FieldTag::__auto_approved),
                            "auto_approved" => Ok(__FieldTag::__auto_approved),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApproveDecision;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApproveDecision")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__approve_time => {
                            if !fields.insert(__FieldTag::__approve_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approve_time",
                                ));
                            }
                            result.approve_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__invalidate_time => {
                            if !fields.insert(__FieldTag::__invalidate_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invalidate_time",
                                ));
                            }
                            result.invalidate_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__signature_info => {
                            if !fields.insert(__FieldTag::__signature_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature_info",
                                ));
                            }
                            result.signature_info = map
                                .next_value::<std::option::Option<crate::model::SignatureInfo>>()?;
                        }
                        __FieldTag::__auto_approved => {
                            if !fields.insert(__FieldTag::__auto_approved) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_approved",
                                ));
                            }
                            result.auto_approved = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApproveDecision {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.approve_time.is_some() {
            state.serialize_entry("approveTime", &self.approve_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.invalidate_time.is_some() {
            state.serialize_entry("invalidateTime", &self.invalidate_time)?;
        }
        if self.signature_info.is_some() {
            state.serialize_entry("signatureInfo", &self.signature_info)?;
        }
        if !wkt::internal::is_default(&self.auto_approved) {
            state.serialize_entry("autoApproved", &self.auto_approved)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A decision that has been made to dismiss an approval request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DismissDecision {
    /// The time at which the approval request was dismissed.
    pub dismiss_time: std::option::Option<wkt::Timestamp>,

    /// This field will be true if the ApprovalRequest was implicitly dismissed due
    /// to inaction by the access approval approvers (the request is not acted
    /// on by the approvers before the exiration time).
    pub implicit: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DismissDecision {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dismiss_time][crate::model::DismissDecision::dismiss_time].
    pub fn set_dismiss_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dismiss_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dismiss_time][crate::model::DismissDecision::dismiss_time].
    pub fn set_or_clear_dismiss_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dismiss_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [implicit][crate::model::DismissDecision::implicit].
    pub fn set_implicit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.implicit = v.into();
        self
    }
}

impl wkt::message::Message for DismissDecision {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.DismissDecision"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DismissDecision {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dismiss_time,
            __implicit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DismissDecision")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dismissTime" => Ok(__FieldTag::__dismiss_time),
                            "dismiss_time" => Ok(__FieldTag::__dismiss_time),
                            "implicit" => Ok(__FieldTag::__implicit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DismissDecision;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DismissDecision")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dismiss_time => {
                            if !fields.insert(__FieldTag::__dismiss_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dismiss_time",
                                ));
                            }
                            result.dismiss_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__implicit => {
                            if !fields.insert(__FieldTag::__implicit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for implicit",
                                ));
                            }
                            result.implicit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DismissDecision {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dismiss_time.is_some() {
            state.serialize_entry("dismissTime", &self.dismiss_time)?;
        }
        if !wkt::internal::is_default(&self.implicit) {
            state.serialize_entry("implicit", &self.implicit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The properties associated with the resource of the request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceProperties {
    /// Whether an approval will exclude the descendants of the resource being
    /// requested.
    pub excludes_descendants: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [excludes_descendants][crate::model::ResourceProperties::excludes_descendants].
    pub fn set_excludes_descendants<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.excludes_descendants = v.into();
        self
    }
}

impl wkt::message::Message for ResourceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.ResourceProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __excludes_descendants,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "excludesDescendants" => Ok(__FieldTag::__excludes_descendants),
                            "excludes_descendants" => Ok(__FieldTag::__excludes_descendants),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__excludes_descendants => {
                            if !fields.insert(__FieldTag::__excludes_descendants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excludes_descendants",
                                ));
                            }
                            result.excludes_descendants = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.excludes_descendants) {
            state.serialize_entry("excludesDescendants", &self.excludes_descendants)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request for the customer to approve access to a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ApprovalRequest {
    /// The resource name of the request. Format is
    /// "{projects|folders|organizations}/{id}/approvalRequests/{approval_request}".
    pub name: std::string::String,

    /// The resource for which approval is being requested. The format of the
    /// resource name is defined at
    /// <https://cloud.google.com/apis/design/resource_names>. The resource name here
    /// may either be a "full" resource name (e.g.
    /// "//library.googleapis.com/shelves/shelf1/books/book2") or a "relative"
    /// resource name (e.g. "shelves/shelf1/books/book2") as described in the
    /// resource name specification.
    pub requested_resource_name: std::string::String,

    /// Properties related to the resource represented by requested_resource_name.
    pub requested_resource_properties: std::option::Option<crate::model::ResourceProperties>,

    /// The justification for which approval is being requested.
    pub requested_reason: std::option::Option<crate::model::AccessReason>,

    /// The locations for which approval is being requested.
    pub requested_locations: std::option::Option<crate::model::AccessLocations>,

    /// The time at which approval was requested.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The requested expiration for the approval. If the request is approved,
    /// access will be granted from the time of approval until the expiration time.
    pub requested_expiration: std::option::Option<wkt::Timestamp>,

    /// The current decision on the approval request.
    pub decision: std::option::Option<crate::model::approval_request::Decision>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApprovalRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApprovalRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [requested_resource_name][crate::model::ApprovalRequest::requested_resource_name].
    pub fn set_requested_resource_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_resource_name = v.into();
        self
    }

    /// Sets the value of [requested_resource_properties][crate::model::ApprovalRequest::requested_resource_properties].
    pub fn set_requested_resource_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceProperties>,
    {
        self.requested_resource_properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_resource_properties][crate::model::ApprovalRequest::requested_resource_properties].
    pub fn set_or_clear_requested_resource_properties<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ResourceProperties>,
    {
        self.requested_resource_properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_reason][crate::model::ApprovalRequest::requested_reason].
    pub fn set_requested_reason<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessReason>,
    {
        self.requested_reason = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_reason][crate::model::ApprovalRequest::requested_reason].
    pub fn set_or_clear_requested_reason<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessReason>,
    {
        self.requested_reason = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_locations][crate::model::ApprovalRequest::requested_locations].
    pub fn set_requested_locations<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessLocations>,
    {
        self.requested_locations = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_locations][crate::model::ApprovalRequest::requested_locations].
    pub fn set_or_clear_requested_locations<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessLocations>,
    {
        self.requested_locations = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::ApprovalRequest::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::ApprovalRequest::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_expiration][crate::model::ApprovalRequest::requested_expiration].
    pub fn set_requested_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.requested_expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_expiration][crate::model::ApprovalRequest::requested_expiration].
    pub fn set_or_clear_requested_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.requested_expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decision][crate::model::ApprovalRequest::decision].
    ///
    /// Note that all the setters affecting `decision` are mutually
    /// exclusive.
    pub fn set_decision<
        T: std::convert::Into<std::option::Option<crate::model::approval_request::Decision>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decision = v.into();
        self
    }

    /// The value of [decision][crate::model::ApprovalRequest::decision]
    /// if it holds a `Approve`, `None` if the field is not set or
    /// holds a different branch.
    pub fn approve(&self) -> std::option::Option<&std::boxed::Box<crate::model::ApproveDecision>> {
        #[allow(unreachable_patterns)]
        self.decision.as_ref().and_then(|v| match v {
            crate::model::approval_request::Decision::Approve(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decision][crate::model::ApprovalRequest::decision]
    /// to hold a `Approve`.
    ///
    /// Note that all the setters affecting `decision` are
    /// mutually exclusive.
    pub fn set_approve<T: std::convert::Into<std::boxed::Box<crate::model::ApproveDecision>>>(
        mut self,
        v: T,
    ) -> Self {
        self.decision =
            std::option::Option::Some(crate::model::approval_request::Decision::Approve(v.into()));
        self
    }

    /// The value of [decision][crate::model::ApprovalRequest::decision]
    /// if it holds a `Dismiss`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dismiss(&self) -> std::option::Option<&std::boxed::Box<crate::model::DismissDecision>> {
        #[allow(unreachable_patterns)]
        self.decision.as_ref().and_then(|v| match v {
            crate::model::approval_request::Decision::Dismiss(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decision][crate::model::ApprovalRequest::decision]
    /// to hold a `Dismiss`.
    ///
    /// Note that all the setters affecting `decision` are
    /// mutually exclusive.
    pub fn set_dismiss<T: std::convert::Into<std::boxed::Box<crate::model::DismissDecision>>>(
        mut self,
        v: T,
    ) -> Self {
        self.decision =
            std::option::Option::Some(crate::model::approval_request::Decision::Dismiss(v.into()));
        self
    }
}

impl wkt::message::Message for ApprovalRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.ApprovalRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApprovalRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __requested_resource_name,
            __requested_resource_properties,
            __requested_reason,
            __requested_locations,
            __request_time,
            __requested_expiration,
            __approve,
            __dismiss,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApprovalRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestedResourceName" => Ok(__FieldTag::__requested_resource_name),
                            "requested_resource_name" => Ok(__FieldTag::__requested_resource_name),
                            "requestedResourceProperties" => {
                                Ok(__FieldTag::__requested_resource_properties)
                            }
                            "requested_resource_properties" => {
                                Ok(__FieldTag::__requested_resource_properties)
                            }
                            "requestedReason" => Ok(__FieldTag::__requested_reason),
                            "requested_reason" => Ok(__FieldTag::__requested_reason),
                            "requestedLocations" => Ok(__FieldTag::__requested_locations),
                            "requested_locations" => Ok(__FieldTag::__requested_locations),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "requestedExpiration" => Ok(__FieldTag::__requested_expiration),
                            "requested_expiration" => Ok(__FieldTag::__requested_expiration),
                            "approve" => Ok(__FieldTag::__approve),
                            "dismiss" => Ok(__FieldTag::__dismiss),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApprovalRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApprovalRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_resource_name => {
                            if !fields.insert(__FieldTag::__requested_resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_resource_name",
                                ));
                            }
                            result.requested_resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_resource_properties => {
                            if !fields.insert(__FieldTag::__requested_resource_properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_resource_properties",
                                ));
                            }
                            result.requested_resource_properties = map.next_value::<std::option::Option<crate::model::ResourceProperties>>()?
                                ;
                        }
                        __FieldTag::__requested_reason => {
                            if !fields.insert(__FieldTag::__requested_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_reason",
                                ));
                            }
                            result.requested_reason = map
                                .next_value::<std::option::Option<crate::model::AccessReason>>()?;
                        }
                        __FieldTag::__requested_locations => {
                            if !fields.insert(__FieldTag::__requested_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_locations",
                                ));
                            }
                            result.requested_locations = map
                                .next_value::<std::option::Option<crate::model::AccessLocations>>(
                                )?;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__requested_expiration => {
                            if !fields.insert(__FieldTag::__requested_expiration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_expiration",
                                ));
                            }
                            result.requested_expiration =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__approve => {
                            if !fields.insert(__FieldTag::__approve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approve",
                                ));
                            }
                            if result.decision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decision`, a oneof with full ID .google.cloud.accessapproval.v1.ApprovalRequest.approve, latest field was approve",
                                ));
                            }
                            result.decision = std::option::Option::Some(
                                crate::model::approval_request::Decision::Approve(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ApproveDecision>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dismiss => {
                            if !fields.insert(__FieldTag::__dismiss) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dismiss",
                                ));
                            }
                            if result.decision.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decision`, a oneof with full ID .google.cloud.accessapproval.v1.ApprovalRequest.dismiss, latest field was dismiss",
                                ));
                            }
                            result.decision = std::option::Option::Some(
                                crate::model::approval_request::Decision::Dismiss(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DismissDecision>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApprovalRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.requested_resource_name.is_empty() {
            state.serialize_entry("requestedResourceName", &self.requested_resource_name)?;
        }
        if self.requested_resource_properties.is_some() {
            state.serialize_entry(
                "requestedResourceProperties",
                &self.requested_resource_properties,
            )?;
        }
        if self.requested_reason.is_some() {
            state.serialize_entry("requestedReason", &self.requested_reason)?;
        }
        if self.requested_locations.is_some() {
            state.serialize_entry("requestedLocations", &self.requested_locations)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.requested_expiration.is_some() {
            state.serialize_entry("requestedExpiration", &self.requested_expiration)?;
        }
        if let Some(value) = self.approve() {
            state.serialize_entry("approve", value)?;
        }
        if let Some(value) = self.dismiss() {
            state.serialize_entry("dismiss", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ApprovalRequest].
pub mod approval_request {
    #[allow(unused_imports)]
    use super::*;

    /// The current decision on the approval request.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Decision {
        /// Access was approved.
        Approve(std::boxed::Box<crate::model::ApproveDecision>),
        /// The request was dismissed.
        Dismiss(std::boxed::Box<crate::model::DismissDecision>),
    }
}

/// Represents the enrollment of a cloud resource into a specific service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnrolledService {
    /// The product for which Access Approval will be enrolled. Allowed values are
    /// listed below (case-sensitive):
    ///
    /// * all
    /// * GA
    /// * App Engine
    /// * BigQuery
    /// * Cloud Bigtable
    /// * Cloud Key Management Service
    /// * Compute Engine
    /// * Cloud Dataflow
    /// * Cloud Dataproc
    /// * Cloud DLP
    /// * Cloud EKM
    /// * Cloud HSM
    /// * Cloud Identity and Access Management
    /// * Cloud Logging
    /// * Cloud Pub/Sub
    /// * Cloud Spanner
    /// * Cloud SQL
    /// * Cloud Storage
    /// * Google Kubernetes Engine
    /// * Organization Policy Serivice
    /// * Persistent Disk
    /// * Resource Manager
    /// * Secret Manager
    /// * Speaker ID
    ///
    /// Note: These values are supported as input for legacy purposes, but will not
    /// be returned from the API.
    ///
    /// * all
    /// * ga-only
    /// * appengine.googleapis.com
    /// * bigquery.googleapis.com
    /// * bigtable.googleapis.com
    /// * container.googleapis.com
    /// * cloudkms.googleapis.com
    /// * cloudresourcemanager.googleapis.com
    /// * cloudsql.googleapis.com
    /// * compute.googleapis.com
    /// * dataflow.googleapis.com
    /// * dataproc.googleapis.com
    /// * dlp.googleapis.com
    /// * iam.googleapis.com
    /// * logging.googleapis.com
    /// * orgpolicy.googleapis.com
    /// * pubsub.googleapis.com
    /// * spanner.googleapis.com
    /// * secretmanager.googleapis.com
    /// * speakerid.googleapis.com
    /// * storage.googleapis.com
    ///
    /// Calls to UpdateAccessApprovalSettings using 'all' or any of the
    /// XXX.googleapis.com will be translated to the associated product name
    /// ('all', 'App Engine', etc.).
    ///
    /// Note: 'all' will enroll the resource in all products supported at both 'GA'
    /// and 'Preview' levels.
    ///
    /// More information about levels of support is available at
    /// <https://cloud.google.com/access-approval/docs/supported-services>
    pub cloud_product: std::string::String,

    /// The enrollment level of the service.
    pub enrollment_level: crate::model::EnrollmentLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnrolledService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_product][crate::model::EnrolledService::cloud_product].
    pub fn set_cloud_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_product = v.into();
        self
    }

    /// Sets the value of [enrollment_level][crate::model::EnrolledService::enrollment_level].
    pub fn set_enrollment_level<T: std::convert::Into<crate::model::EnrollmentLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.enrollment_level = v.into();
        self
    }
}

impl wkt::message::Message for EnrolledService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.EnrolledService"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnrolledService {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_product,
            __enrollment_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnrolledService")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudProduct" => Ok(__FieldTag::__cloud_product),
                            "cloud_product" => Ok(__FieldTag::__cloud_product),
                            "enrollmentLevel" => Ok(__FieldTag::__enrollment_level),
                            "enrollment_level" => Ok(__FieldTag::__enrollment_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnrolledService;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnrolledService")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_product => {
                            if !fields.insert(__FieldTag::__cloud_product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_product",
                                ));
                            }
                            result.cloud_product = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enrollment_level => {
                            if !fields.insert(__FieldTag::__enrollment_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrollment_level",
                                ));
                            }
                            result.enrollment_level = map
                                .next_value::<std::option::Option<crate::model::EnrollmentLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnrolledService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_product.is_empty() {
            state.serialize_entry("cloudProduct", &self.cloud_product)?;
        }
        if !wkt::internal::is_default(&self.enrollment_level) {
            state.serialize_entry("enrollmentLevel", &self.enrollment_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings on a Project/Folder/Organization related to Access Approval.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessApprovalSettings {
    /// The resource name of the settings. Format is one of:
    ///
    /// * "projects/{project}/accessApprovalSettings"
    /// * "folders/{folder}/accessApprovalSettings"
    /// * "organizations/{organization}/accessApprovalSettings"
    pub name: std::string::String,

    /// A list of email addresses to which notifications relating to approval
    /// requests should be sent. Notifications relating to a resource will be sent
    /// to all emails in the settings of ancestor resources of that resource. A
    /// maximum of 50 email addresses are allowed.
    pub notification_emails: std::vec::Vec<std::string::String>,

    /// A list of Google Cloud Services for which the given resource has Access
    /// Approval enrolled. Access requests for the resource given by name against
    /// any of these services contained here will be required to have explicit
    /// approval. If name refers to an organization, enrollment can be done for
    /// individual services. If name refers to a folder or project, enrollment can
    /// only be done on an all or nothing basis.
    ///
    /// If a cloud_product is repeated in this list, the first entry will be
    /// honored and all following entries will be discarded. A maximum of 10
    /// enrolled services will be enforced, to be expanded as the set of supported
    /// services is expanded.
    pub enrolled_services: std::vec::Vec<crate::model::EnrolledService>,

    /// Output only. This field is read only (not settable via
    /// UpdateAccessApprovalSettings method). If the field is true, that
    /// indicates that at least one service is enrolled for Access Approval in one
    /// or more ancestors of the Project or Folder (this field will always be
    /// unset for the organization since organizations do not have ancestors).
    pub enrolled_ancestor: bool,

    /// The asymmetric crypto key version to use for signing approval requests.
    /// Empty active_key_version indicates that a Google-managed key should be used
    /// for signing. This property will be ignored if set by an ancestor of this
    /// resource, and new non-empty values may not be set.
    pub active_key_version: std::string::String,

    /// Output only. This field is read only (not settable via UpdateAccessApprovalSettings
    /// method). If the field is true, that indicates that an ancestor of this
    /// Project or Folder has set active_key_version (this field will always be
    /// unset for the organization since organizations do not have ancestors).
    pub ancestor_has_active_key_version: bool,

    /// Output only. This field is read only (not settable via UpdateAccessApprovalSettings
    /// method). If the field is true, that indicates that there is some
    /// configuration issue with the active_key_version configured at this level in
    /// the resource hierarchy (e.g. it doesn't exist or the Access Approval
    /// service account doesn't have the correct permissions on it, etc.) This key
    /// version is not necessarily the effective key version at this level, as key
    /// versions are inherited top-down.
    pub invalid_key_version: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessApprovalSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessApprovalSettings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [notification_emails][crate::model::AccessApprovalSettings::notification_emails].
    pub fn set_notification_emails<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.notification_emails = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enrolled_services][crate::model::AccessApprovalSettings::enrolled_services].
    pub fn set_enrolled_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnrolledService>,
    {
        use std::iter::Iterator;
        self.enrolled_services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enrolled_ancestor][crate::model::AccessApprovalSettings::enrolled_ancestor].
    pub fn set_enrolled_ancestor<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enrolled_ancestor = v.into();
        self
    }

    /// Sets the value of [active_key_version][crate::model::AccessApprovalSettings::active_key_version].
    pub fn set_active_key_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.active_key_version = v.into();
        self
    }

    /// Sets the value of [ancestor_has_active_key_version][crate::model::AccessApprovalSettings::ancestor_has_active_key_version].
    pub fn set_ancestor_has_active_key_version<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.ancestor_has_active_key_version = v.into();
        self
    }

    /// Sets the value of [invalid_key_version][crate::model::AccessApprovalSettings::invalid_key_version].
    pub fn set_invalid_key_version<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invalid_key_version = v.into();
        self
    }
}

impl wkt::message::Message for AccessApprovalSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.AccessApprovalSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessApprovalSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __notification_emails,
            __enrolled_services,
            __enrolled_ancestor,
            __active_key_version,
            __ancestor_has_active_key_version,
            __invalid_key_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessApprovalSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "notificationEmails" => Ok(__FieldTag::__notification_emails),
                            "notification_emails" => Ok(__FieldTag::__notification_emails),
                            "enrolledServices" => Ok(__FieldTag::__enrolled_services),
                            "enrolled_services" => Ok(__FieldTag::__enrolled_services),
                            "enrolledAncestor" => Ok(__FieldTag::__enrolled_ancestor),
                            "enrolled_ancestor" => Ok(__FieldTag::__enrolled_ancestor),
                            "activeKeyVersion" => Ok(__FieldTag::__active_key_version),
                            "active_key_version" => Ok(__FieldTag::__active_key_version),
                            "ancestorHasActiveKeyVersion" => {
                                Ok(__FieldTag::__ancestor_has_active_key_version)
                            }
                            "ancestor_has_active_key_version" => {
                                Ok(__FieldTag::__ancestor_has_active_key_version)
                            }
                            "invalidKeyVersion" => Ok(__FieldTag::__invalid_key_version),
                            "invalid_key_version" => Ok(__FieldTag::__invalid_key_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessApprovalSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessApprovalSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notification_emails => {
                            if !fields.insert(__FieldTag::__notification_emails) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_emails",
                                ));
                            }
                            result.notification_emails = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enrolled_services => {
                            if !fields.insert(__FieldTag::__enrolled_services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrolled_services",
                                ));
                            }
                            result.enrolled_services =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EnrolledService>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enrolled_ancestor => {
                            if !fields.insert(__FieldTag::__enrolled_ancestor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enrolled_ancestor",
                                ));
                            }
                            result.enrolled_ancestor = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active_key_version => {
                            if !fields.insert(__FieldTag::__active_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_key_version",
                                ));
                            }
                            result.active_key_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ancestor_has_active_key_version => {
                            if !fields.insert(__FieldTag::__ancestor_has_active_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ancestor_has_active_key_version",
                                ));
                            }
                            result.ancestor_has_active_key_version = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invalid_key_version => {
                            if !fields.insert(__FieldTag::__invalid_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invalid_key_version",
                                ));
                            }
                            result.invalid_key_version = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessApprovalSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.notification_emails.is_empty() {
            state.serialize_entry("notificationEmails", &self.notification_emails)?;
        }
        if !self.enrolled_services.is_empty() {
            state.serialize_entry("enrolledServices", &self.enrolled_services)?;
        }
        if !wkt::internal::is_default(&self.enrolled_ancestor) {
            state.serialize_entry("enrolledAncestor", &self.enrolled_ancestor)?;
        }
        if !self.active_key_version.is_empty() {
            state.serialize_entry("activeKeyVersion", &self.active_key_version)?;
        }
        if !wkt::internal::is_default(&self.ancestor_has_active_key_version) {
            state.serialize_entry(
                "ancestorHasActiveKeyVersion",
                &self.ancestor_has_active_key_version,
            )?;
        }
        if !wkt::internal::is_default(&self.invalid_key_version) {
            state.serialize_entry("invalidKeyVersion", &self.invalid_key_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Access Approval service account related to a project/folder/organization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessApprovalServiceAccount {
    /// The resource name of the Access Approval service account. Format is one of:
    ///
    /// * "projects/{project}/serviceAccount"
    /// * "folders/{folder}/serviceAccount"
    /// * "organizations/{organization}/serviceAccount"
    pub name: std::string::String,

    /// Email address of the service account.
    pub account_email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessApprovalServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessApprovalServiceAccount::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [account_email][crate::model::AccessApprovalServiceAccount::account_email].
    pub fn set_account_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.account_email = v.into();
        self
    }
}

impl wkt::message::Message for AccessApprovalServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.AccessApprovalServiceAccount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessApprovalServiceAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __account_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessApprovalServiceAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "accountEmail" => Ok(__FieldTag::__account_email),
                            "account_email" => Ok(__FieldTag::__account_email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessApprovalServiceAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessApprovalServiceAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account_email => {
                            if !fields.insert(__FieldTag::__account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account_email",
                                ));
                            }
                            result.account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessApprovalServiceAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.account_email.is_empty() {
            state.serialize_entry("accountEmail", &self.account_email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list approval requests.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListApprovalRequestsMessage {
    /// The parent resource. This may be "projects/{project}",
    /// "folders/{folder}", or "organizations/{organization}".
    pub parent: std::string::String,

    /// A filter on the type of approval requests to retrieve. Must be one of the
    /// following values:
    ///
    /// * [not set]: Requests that are pending or have active approvals.
    /// * ALL: All requests.
    /// * PENDING: Only pending requests.
    /// * ACTIVE: Only active (i.e. currently approved) requests.
    /// * DISMISSED: Only requests that have been dismissed, or requests that
    ///   are not approved and past expiration.
    /// * EXPIRED: Only requests that have been approved, and the approval has
    ///   expired.
    /// * HISTORY: Active, dismissed and expired requests.
    pub filter: std::string::String,

    /// Requested page size.
    pub page_size: i32,

    /// A token identifying the page of results to return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListApprovalRequestsMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListApprovalRequestsMessage::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListApprovalRequestsMessage::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListApprovalRequestsMessage::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListApprovalRequestsMessage::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListApprovalRequestsMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.ListApprovalRequestsMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListApprovalRequestsMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListApprovalRequestsMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListApprovalRequestsMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListApprovalRequestsMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListApprovalRequestsMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response to listing of ApprovalRequest objects.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListApprovalRequestsResponse {
    /// Approval request details.
    pub approval_requests: std::vec::Vec<crate::model::ApprovalRequest>,

    /// Token to retrieve the next page of results, or empty if there are no more.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListApprovalRequestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approval_requests][crate::model::ListApprovalRequestsResponse::approval_requests].
    pub fn set_approval_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ApprovalRequest>,
    {
        use std::iter::Iterator;
        self.approval_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListApprovalRequestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListApprovalRequestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.ListApprovalRequestsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListApprovalRequestsResponse {
    type PageItem = crate::model::ApprovalRequest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.approval_requests
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListApprovalRequestsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __approval_requests,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListApprovalRequestsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "approvalRequests" => Ok(__FieldTag::__approval_requests),
                            "approval_requests" => Ok(__FieldTag::__approval_requests),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListApprovalRequestsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListApprovalRequestsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__approval_requests => {
                            if !fields.insert(__FieldTag::__approval_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_requests",
                                ));
                            }
                            result.approval_requests =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ApprovalRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListApprovalRequestsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.approval_requests.is_empty() {
            state.serialize_entry("approvalRequests", &self.approval_requests)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get an approval request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetApprovalRequestMessage {
    /// The name of the approval request to retrieve.
    /// Format:
    /// "{projects|folders|organizations}/{id}/approvalRequests/{approval_request}"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetApprovalRequestMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetApprovalRequestMessage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetApprovalRequestMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.GetApprovalRequestMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetApprovalRequestMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetApprovalRequestMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetApprovalRequestMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetApprovalRequestMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetApprovalRequestMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to approve an ApprovalRequest.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ApproveApprovalRequestMessage {
    /// Name of the approval request to approve.
    pub name: std::string::String,

    /// The expiration time of this approval.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveApprovalRequestMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveApprovalRequestMessage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::ApproveApprovalRequestMessage::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::ApproveApprovalRequestMessage::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ApproveApprovalRequestMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.ApproveApprovalRequestMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApproveApprovalRequestMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApproveApprovalRequestMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApproveApprovalRequestMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApproveApprovalRequestMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApproveApprovalRequestMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to dismiss an approval request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DismissApprovalRequestMessage {
    /// Name of the ApprovalRequest to dismiss.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DismissApprovalRequestMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DismissApprovalRequestMessage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DismissApprovalRequestMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.DismissApprovalRequestMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DismissApprovalRequestMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DismissApprovalRequestMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DismissApprovalRequestMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DismissApprovalRequestMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DismissApprovalRequestMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to invalidate an existing approval.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InvalidateApprovalRequestMessage {
    /// Name of the ApprovalRequest to invalidate.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InvalidateApprovalRequestMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InvalidateApprovalRequestMessage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for InvalidateApprovalRequestMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.InvalidateApprovalRequestMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InvalidateApprovalRequestMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InvalidateApprovalRequestMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InvalidateApprovalRequestMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InvalidateApprovalRequestMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InvalidateApprovalRequestMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get access approval settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAccessApprovalSettingsMessage {
    /// The name of the AccessApprovalSettings to retrieve.
    /// Format: "{projects|folders|organizations}/{id}/accessApprovalSettings"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAccessApprovalSettingsMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAccessApprovalSettingsMessage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAccessApprovalSettingsMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.GetAccessApprovalSettingsMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAccessApprovalSettingsMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAccessApprovalSettingsMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAccessApprovalSettingsMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAccessApprovalSettingsMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAccessApprovalSettingsMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to update access approval settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAccessApprovalSettingsMessage {
    /// The new AccessApprovalSettings.
    pub settings: std::option::Option<crate::model::AccessApprovalSettings>,

    /// The update mask applies to the settings. Only the top level fields of
    /// AccessApprovalSettings (notification_emails & enrolled_services) are
    /// supported. For each field, if it is included, the currently stored value
    /// will be entirely overwritten with the value of the field passed in this
    /// request.
    ///
    /// For the `FieldMask` definition, see
    /// <https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask>
    /// If this field is left unset, only the notification_emails field will be
    /// updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAccessApprovalSettingsMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [settings][crate::model::UpdateAccessApprovalSettingsMessage::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessApprovalSettings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::UpdateAccessApprovalSettingsMessage::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessApprovalSettings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAccessApprovalSettingsMessage::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAccessApprovalSettingsMessage::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAccessApprovalSettingsMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.UpdateAccessApprovalSettingsMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAccessApprovalSettingsMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __settings,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAccessApprovalSettingsMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "settings" => Ok(__FieldTag::__settings),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAccessApprovalSettingsMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAccessApprovalSettingsMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__settings => {
                            if !fields.insert(__FieldTag::__settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings",
                                ));
                            }
                            result.settings = map.next_value::<std::option::Option<crate::model::AccessApprovalSettings>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAccessApprovalSettingsMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.settings.is_some() {
            state.serialize_entry("settings", &self.settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to delete access approval settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAccessApprovalSettingsMessage {
    /// Name of the AccessApprovalSettings to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAccessApprovalSettingsMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAccessApprovalSettingsMessage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAccessApprovalSettingsMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.DeleteAccessApprovalSettingsMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAccessApprovalSettingsMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAccessApprovalSettingsMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAccessApprovalSettingsMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAccessApprovalSettingsMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAccessApprovalSettingsMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get an Access Approval service account.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAccessApprovalServiceAccountMessage {
    /// Name of the AccessApprovalServiceAccount to retrieve.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAccessApprovalServiceAccountMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAccessApprovalServiceAccountMessage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAccessApprovalServiceAccountMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.accessapproval.v1.GetAccessApprovalServiceAccountMessage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAccessApprovalServiceAccountMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GetAccessApprovalServiceAccountMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAccessApprovalServiceAccountMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAccessApprovalServiceAccountMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAccessApprovalServiceAccountMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the type of enrollment for a given service to Access Approval.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EnrollmentLevel {
    /// Default value for proto, shouldn't be used.
    Unspecified,
    /// Service is enrolled in Access Approval for all requests
    BlockAll,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EnrollmentLevel::value] or
    /// [EnrollmentLevel::name].
    UnknownValue(enrollment_level::UnknownValue),
}

#[doc(hidden)]
pub mod enrollment_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EnrollmentLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BlockAll => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENROLLMENT_LEVEL_UNSPECIFIED"),
            Self::BlockAll => std::option::Option::Some("BLOCK_ALL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EnrollmentLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EnrollmentLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EnrollmentLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::BlockAll,
            _ => Self::UnknownValue(enrollment_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EnrollmentLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENROLLMENT_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "BLOCK_ALL" => Self::BlockAll,
            _ => Self::UnknownValue(enrollment_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EnrollmentLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BlockAll => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EnrollmentLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EnrollmentLevel>::new(
            ".google.cloud.accessapproval.v1.EnrollmentLevel",
        ))
    }
}
