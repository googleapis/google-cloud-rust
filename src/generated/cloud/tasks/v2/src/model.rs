// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for
/// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues].
///
/// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQueuesRequest {
    /// Required. The location name.
    /// For example: `projects/PROJECT_ID/locations/LOCATION_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// `filter` can be used to specify a subset of queues. Any
    /// [Queue][google.cloud.tasks.v2.Queue] field can be used as a filter and
    /// several operators as supported. For example: `<=, <, >=, >, !=, =, :`. The
    /// filter syntax is the same as described in [Stackdriver's Advanced Logs
    /// Filters](https://cloud.google.com/logging/docs/view/advanced_filters).
    ///
    /// Sample filter "state: PAUSED".
    ///
    /// Note that using filters might cause fewer queues than the
    /// requested page_size to be returned.
    ///
    /// [google.cloud.tasks.v2.Queue]: crate::model::Queue
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Requested page size.
    ///
    /// The maximum page size is 9800. If unspecified, the page size will
    /// be the maximum. Fewer queues than requested might be returned,
    /// even if more queues exist; use the
    /// [next_page_token][google.cloud.tasks.v2.ListQueuesResponse.next_page_token]
    /// in the response to determine if more queues exist.
    ///
    /// [google.cloud.tasks.v2.ListQueuesResponse.next_page_token]: crate::model::ListQueuesResponse::next_page_token
    pub page_size: i32,

    /// A token identifying the page of results to return.
    ///
    /// To request the first page results, page_token must be empty. To
    /// request the next page of results, page_token must be the value of
    /// [next_page_token][google.cloud.tasks.v2.ListQueuesResponse.next_page_token]
    /// returned from the previous call to
    /// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues] method. It is an
    /// error to switch the value of the
    /// [filter][google.cloud.tasks.v2.ListQueuesRequest.filter] while iterating
    /// through pages.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
    /// [google.cloud.tasks.v2.ListQueuesRequest.filter]: crate::model::ListQueuesRequest::filter
    /// [google.cloud.tasks.v2.ListQueuesResponse.next_page_token]: crate::model::ListQueuesResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListQueuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQueuesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQueuesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQueuesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQueuesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQueuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListQueuesRequest"
    }
}

/// Response message for
/// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues].
///
/// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQueuesResponse {
    /// The list of queues.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub queues: std::vec::Vec<crate::model::Queue>,

    /// A token to retrieve next page of results.
    ///
    /// To return the next page of results, call
    /// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues] with this value
    /// as the [page_token][google.cloud.tasks.v2.ListQueuesRequest.page_token].
    ///
    /// If the next_page_token is empty, there are no more results.
    ///
    /// The page token is valid for only 2 hours.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
    /// [google.cloud.tasks.v2.ListQueuesRequest.page_token]: crate::model::ListQueuesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListQueuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListQueuesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [queues][crate::model::ListQueuesResponse::queues].
    pub fn set_queues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Queue>,
    {
        use std::iter::Iterator;
        self.queues = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListQueuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListQueuesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListQueuesResponse {
    type PageItem = crate::model::Queue;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.queues
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for [GetQueue][google.cloud.tasks.v2.CloudTasks.GetQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.GetQueue]: crate::client::CloudTasks::get_queue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetQueueRequest {
    /// Required. The resource name of the queue. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.GetQueueRequest"
    }
}

/// Request message for
/// [CreateQueue][google.cloud.tasks.v2.CloudTasks.CreateQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.CreateQueue]: crate::client::CloudTasks::create_queue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateQueueRequest {
    /// Required. The location name in which the queue will be created.
    /// For example: `projects/PROJECT_ID/locations/LOCATION_ID`
    ///
    /// The list of allowed locations can be obtained by calling Cloud
    /// Tasks' implementation of
    /// [ListLocations][google.cloud.location.Locations.ListLocations].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The queue to create.
    ///
    /// [Queue's name][google.cloud.tasks.v2.Queue.name] cannot be the same as an
    /// existing queue.
    ///
    /// [google.cloud.tasks.v2.Queue.name]: crate::model::Queue::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub queue: std::option::Option<crate::model::Queue>,
}

impl CreateQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQueueRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [queue][crate::model::CreateQueueRequest::queue].
    pub fn set_queue<T: std::convert::Into<std::option::Option<crate::model::Queue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queue = v.into();
        self
    }
}

impl wkt::message::Message for CreateQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.CreateQueueRequest"
    }
}

/// Request message for
/// [UpdateQueue][google.cloud.tasks.v2.CloudTasks.UpdateQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.UpdateQueue]: crate::client::CloudTasks::update_queue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateQueueRequest {
    /// Required. The queue to create or update.
    ///
    /// The queue's [name][google.cloud.tasks.v2.Queue.name] must be specified.
    ///
    /// Output only fields cannot be modified using UpdateQueue.
    /// Any value specified for an output only field will be ignored.
    /// The queue's [name][google.cloud.tasks.v2.Queue.name] cannot be changed.
    ///
    /// [google.cloud.tasks.v2.Queue.name]: crate::model::Queue::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub queue: std::option::Option<crate::model::Queue>,

    /// A mask used to specify which fields of the queue are being updated.
    ///
    /// If empty, then all fields will be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [queue][crate::model::UpdateQueueRequest::queue].
    pub fn set_queue<T: std::convert::Into<std::option::Option<crate::model::Queue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queue = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateQueueRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.UpdateQueueRequest"
    }
}

/// Request message for
/// [DeleteQueue][google.cloud.tasks.v2.CloudTasks.DeleteQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.DeleteQueue]: crate::client::CloudTasks::delete_queue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.DeleteQueueRequest"
    }
}

/// Request message for
/// [PurgeQueue][google.cloud.tasks.v2.CloudTasks.PurgeQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.PurgeQueue]: crate::client::CloudTasks::purge_queue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl PurgeQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PurgeQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PurgeQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.PurgeQueueRequest"
    }
}

/// Request message for
/// [PauseQueue][google.cloud.tasks.v2.CloudTasks.PauseQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.PauseQueue]: crate::client::CloudTasks::pause_queue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl PauseQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.PauseQueueRequest"
    }
}

/// Request message for
/// [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.ResumeQueue]: crate::client::CloudTasks::resume_queue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ResumeQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ResumeQueueRequest"
    }
}

/// Request message for listing tasks using
/// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks].
///
/// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTasksRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::view::BASIC
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::view::FULL
    pub response_view: crate::model::task::View,

    /// Maximum page size.
    ///
    /// Fewer tasks than requested might be returned, even if more tasks exist; use
    /// [next_page_token][google.cloud.tasks.v2.ListTasksResponse.next_page_token]
    /// in the response to determine if more tasks exist.
    ///
    /// The maximum page size is 1000. If unspecified, the page size will be the
    /// maximum.
    ///
    /// [google.cloud.tasks.v2.ListTasksResponse.next_page_token]: crate::model::ListTasksResponse::next_page_token
    pub page_size: i32,

    /// A token identifying the page of results to return.
    ///
    /// To request the first page results, page_token must be empty. To
    /// request the next page of results, page_token must be the value of
    /// [next_page_token][google.cloud.tasks.v2.ListTasksResponse.next_page_token]
    /// returned from the previous call to
    /// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks] method.
    ///
    /// The page token is valid for only 2 hours.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
    /// [google.cloud.tasks.v2.ListTasksResponse.next_page_token]: crate::model::ListTasksResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListTasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [response_view][crate::model::ListTasksRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListTasksRequest"
    }
}

/// Response message for listing tasks using
/// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks].
///
/// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTasksResponse {
    /// The list of tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tasks: std::vec::Vec<crate::model::Task>,

    /// A token to retrieve next page of results.
    ///
    /// To return the next page of results, call
    /// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks] with this value as
    /// the [page_token][google.cloud.tasks.v2.ListTasksRequest.page_token].
    ///
    /// If the next_page_token is empty, there are no more results.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
    /// [google.cloud.tasks.v2.ListTasksRequest.page_token]: crate::model::ListTasksRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tasks][crate::model::ListTasksResponse::tasks].
    pub fn set_tasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Task>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListTasksResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTasksResponse {
    type PageItem = crate::model::Task;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tasks
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for getting a task using
/// [GetTask][google.cloud.tasks.v2.CloudTasks.GetTask].
///
/// [google.cloud.tasks.v2.CloudTasks.GetTask]: crate::client::CloudTasks::get_task
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTaskRequest {
    /// Required. The task name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::view::BASIC
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::view::FULL
    pub response_view: crate::model::task::View,
}

impl GetTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [response_view][crate::model::GetTaskRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }
}

impl wkt::message::Message for GetTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.GetTaskRequest"
    }
}

/// Request message for
/// [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask].
///
/// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTaskRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    ///
    /// The queue must already exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The task to add.
    ///
    /// Task names have the following format:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`.
    /// The user can optionally specify a task
    /// [name][google.cloud.tasks.v2.Task.name]. If a name is not specified then
    /// the system will generate a random unique task id, which will be set in the
    /// task returned in the [response][google.cloud.tasks.v2.Task.name].
    ///
    /// If [schedule_time][google.cloud.tasks.v2.Task.schedule_time] is not set or
    /// is in the past then Cloud Tasks will set it to the current time.
    ///
    /// Task De-duplication:
    ///
    /// Explicitly specifying a task ID enables task de-duplication.  If
    /// a task's ID is identical to that of an existing task or a task
    /// that was deleted or executed recently then the call will fail
    /// with [ALREADY_EXISTS][google.rpc.Code.ALREADY_EXISTS].
    /// If the task's queue was created using Cloud Tasks, then another task with
    /// the same name can't be created for ~1hour after the original task was
    /// deleted or executed. If the task's queue was created using queue.yaml or
    /// queue.xml, then another task with the same name can't be created
    /// for ~9days after the original task was deleted or executed.
    ///
    /// Because there is an extra lookup cost to identify duplicate task
    /// names, these [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask]
    /// calls have significantly increased latency. Using hashed strings for the
    /// task id or for the prefix of the task id is recommended. Choosing task ids
    /// that are sequential or have sequential prefixes, for example using a
    /// timestamp, causes an increase in latency and error rates in all
    /// task commands. The infrastructure relies on an approximately
    /// uniform distribution of task ids to store and serve tasks
    /// efficiently.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
    /// [google.cloud.tasks.v2.Task.name]: crate::model::Task::name
    /// [google.cloud.tasks.v2.Task.schedule_time]: crate::model::Task::schedule_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub task: std::option::Option<crate::model::Task>,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::view::BASIC
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::view::FULL
    pub response_view: crate::model::task::View,
}

impl CreateTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTaskRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [task][crate::model::CreateTaskRequest::task].
    pub fn set_task<T: std::convert::Into<std::option::Option<crate::model::Task>>>(
        mut self,
        v: T,
    ) -> Self {
        self.task = v.into();
        self
    }

    /// Sets the value of [response_view][crate::model::CreateTaskRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }
}

impl wkt::message::Message for CreateTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.CreateTaskRequest"
    }
}

/// Request message for deleting a task using
/// [DeleteTask][google.cloud.tasks.v2.CloudTasks.DeleteTask].
///
/// [google.cloud.tasks.v2.CloudTasks.DeleteTask]: crate::client::CloudTasks::delete_task
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTaskRequest {
    /// Required. The task name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.DeleteTaskRequest"
    }
}

/// Request message for forcing a task to run now using
/// [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask].
///
/// [google.cloud.tasks.v2.CloudTasks.RunTask]: crate::client::CloudTasks::run_task
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunTaskRequest {
    /// Required. The task name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::view::BASIC
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::view::FULL
    pub response_view: crate::model::task::View,
}

impl RunTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [response_view][crate::model::RunTaskRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }
}

impl wkt::message::Message for RunTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.RunTaskRequest"
    }
}

/// A queue is a container of related tasks. Queues are configured to manage
/// how those tasks are dispatched. Configurable properties include rate limits,
/// retry options, queue types, and others.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Queue {
    /// Caller-specified and required in
    /// [CreateQueue][google.cloud.tasks.v2.CloudTasks.CreateQueue], after which it
    /// becomes output only.
    ///
    /// The queue name.
    ///
    /// The queue name must have the following format:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    ///
    /// * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), colons (:), or periods (.).
    ///   For more information, see
    ///   [Identifying
    ///   projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
    /// * `LOCATION_ID` is the canonical ID for the queue's location.
    ///   The list of available locations can be obtained by calling
    ///   [ListLocations][google.cloud.location.Locations.ListLocations].
    ///   For more information, see <https://cloud.google.com/about/locations/>.
    /// * `QUEUE_ID` can contain letters ([A-Za-z]), numbers ([0-9]), or
    ///   hyphens (-). The maximum length is 100 characters.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.CreateQueue]: crate::client::CloudTasks::create_queue
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Overrides for
    /// [task-level
    /// app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
    /// These settings apply only to
    /// [App Engine tasks][google.cloud.tasks.v2.AppEngineHttpRequest] in this
    /// queue. [Http tasks][google.cloud.tasks.v2.HttpRequest] are not affected.
    ///
    /// If set, `app_engine_routing_override` is used for all
    /// [App Engine tasks][google.cloud.tasks.v2.AppEngineHttpRequest] in the
    /// queue, no matter what the setting is for the [task-level
    /// app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
    /// [google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing]: crate::model::AppEngineHttpRequest::app_engine_routing
    /// [google.cloud.tasks.v2.HttpRequest]: crate::model::HttpRequest
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub app_engine_routing_override: std::option::Option<crate::model::AppEngineRouting>,

    /// Rate limits for task dispatches.
    ///
    /// [rate_limits][google.cloud.tasks.v2.Queue.rate_limits] and
    /// [retry_config][google.cloud.tasks.v2.Queue.retry_config] are related
    /// because they both control task attempts. However they control task attempts
    /// in different ways:
    ///
    /// * [rate_limits][google.cloud.tasks.v2.Queue.rate_limits] controls the total
    ///   rate of
    ///   dispatches from a queue (i.e. all traffic dispatched from the
    ///   queue, regardless of whether the dispatch is from a first
    ///   attempt or a retry).
    /// * [retry_config][google.cloud.tasks.v2.Queue.retry_config] controls what
    ///   happens to
    ///   particular a task after its first attempt fails. That is,
    ///   [retry_config][google.cloud.tasks.v2.Queue.retry_config] controls task
    ///   retries (the second attempt, third attempt, etc).
    ///
    /// The queue's actual dispatch rate is the result of:
    ///
    /// * Number of tasks in the queue
    /// * User-specified throttling:
    ///   [rate_limits][google.cloud.tasks.v2.Queue.rate_limits],
    ///   [retry_config][google.cloud.tasks.v2.Queue.retry_config], and the
    ///   [queue's state][google.cloud.tasks.v2.Queue.state].
    /// * System throttling due to `429` (Too Many Requests) or `503` (Service
    ///   Unavailable) responses from the worker, high error rates, or to smooth
    ///   sudden large traffic spikes.
    ///
    /// [google.cloud.tasks.v2.Queue.rate_limits]: crate::model::Queue::rate_limits
    /// [google.cloud.tasks.v2.Queue.retry_config]: crate::model::Queue::retry_config
    /// [google.cloud.tasks.v2.Queue.state]: crate::model::Queue::state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rate_limits: std::option::Option<crate::model::RateLimits>,

    /// Settings that determine the retry behavior.
    ///
    /// * For tasks created using Cloud Tasks: the queue-level retry settings
    ///   apply to all tasks in the queue that were created using Cloud Tasks.
    ///   Retry settings cannot be set on individual tasks.
    /// * For tasks created using the App Engine SDK: the queue-level retry
    ///   settings apply to all tasks in the queue which do not have retry settings
    ///   explicitly set on the task and were created by the App Engine SDK. See
    ///   [App Engine
    ///   documentation](https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/retrying-tasks).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retry_config: std::option::Option<crate::model::RetryConfig>,

    /// Output only. The state of the queue.
    ///
    /// `state` can only be changed by calling
    /// [PauseQueue][google.cloud.tasks.v2.CloudTasks.PauseQueue],
    /// [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue], or uploading
    /// [queue.yaml/xml](https://cloud.google.com/appengine/docs/python/config/queueref).
    /// [UpdateQueue][google.cloud.tasks.v2.CloudTasks.UpdateQueue] cannot be used
    /// to change `state`.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.PauseQueue]: crate::client::CloudTasks::pause_queue
    /// [google.cloud.tasks.v2.CloudTasks.ResumeQueue]: crate::client::CloudTasks::resume_queue
    /// [google.cloud.tasks.v2.CloudTasks.UpdateQueue]: crate::client::CloudTasks::update_queue
    pub state: crate::model::queue::State,

    /// Output only. The last time this queue was purged.
    ///
    /// All tasks that were [created][google.cloud.tasks.v2.Task.create_time]
    /// before this time were purged.
    ///
    /// A queue can be purged using
    /// [PurgeQueue][google.cloud.tasks.v2.CloudTasks.PurgeQueue], the [App Engine
    /// Task Queue SDK, or the Cloud
    /// Console](https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/deleting-tasks-and-queues#purging_all_tasks_from_a_queue).
    ///
    /// Purge time will be truncated to the nearest microsecond. Purge
    /// time will be unset if the queue has never been purged.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.PurgeQueue]: crate::client::CloudTasks::purge_queue
    /// [google.cloud.tasks.v2.Task.create_time]: crate::model::Task::create_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub purge_time: std::option::Option<wkt::Timestamp>,

    /// Configuration options for writing logs to
    /// [Stackdriver Logging](https://cloud.google.com/logging/docs/). If this
    /// field is unset, then no logs are written.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stackdriver_logging_config: std::option::Option<crate::model::StackdriverLoggingConfig>,
}

impl Queue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Queue::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [app_engine_routing_override][crate::model::Queue::app_engine_routing_override].
    pub fn set_app_engine_routing_override<
        T: std::convert::Into<std::option::Option<crate::model::AppEngineRouting>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_routing_override = v.into();
        self
    }

    /// Sets the value of [rate_limits][crate::model::Queue::rate_limits].
    pub fn set_rate_limits<T: std::convert::Into<std::option::Option<crate::model::RateLimits>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rate_limits = v.into();
        self
    }

    /// Sets the value of [retry_config][crate::model::Queue::retry_config].
    pub fn set_retry_config<
        T: std::convert::Into<std::option::Option<crate::model::RetryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retry_config = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Queue::state].
    pub fn set_state<T: std::convert::Into<crate::model::queue::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [purge_time][crate::model::Queue::purge_time].
    pub fn set_purge_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.purge_time = v.into();
        self
    }

    /// Sets the value of [stackdriver_logging_config][crate::model::Queue::stackdriver_logging_config].
    pub fn set_stackdriver_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::StackdriverLoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.stackdriver_logging_config = v.into();
        self
    }
}

impl wkt::message::Message for Queue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.Queue"
    }
}

/// Defines additional types related to Queue
pub mod queue {
    #[allow(unused_imports)]
    use super::*;

    /// State of the queue.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The queue is running. Tasks can be dispatched.
        ///
        /// If the queue was created using Cloud Tasks and the queue has
        /// had no activity (method calls or task dispatches) for 30 days,
        /// the queue may take a few minutes to re-activate. Some method
        /// calls may return [NOT_FOUND][google.rpc.Code.NOT_FOUND] and
        /// tasks may not be dispatched for a few minutes until the queue
        /// has been re-activated.
        pub const RUNNING: State = State::new(1);

        /// Tasks are paused by the user. If the queue is paused then Cloud
        /// Tasks will stop delivering tasks from it, but more tasks can
        /// still be added to it by the user.
        pub const PAUSED: State = State::new(2);

        /// The queue is disabled.
        ///
        /// A queue becomes `DISABLED` when
        /// [queue.yaml](https://cloud.google.com/appengine/docs/python/config/queueref)
        /// or
        /// [queue.xml](https://cloud.google.com/appengine/docs/standard/java/config/queueref)
        /// is uploaded which does not contain the queue. You cannot directly disable
        /// a queue.
        ///
        /// When a queue is disabled, tasks can still be added to a queue
        /// but the tasks are not dispatched.
        ///
        /// To permanently delete this queue and all of its tasks, call
        /// [DeleteQueue][google.cloud.tasks.v2.CloudTasks.DeleteQueue].
        ///
        /// [google.cloud.tasks.v2.CloudTasks.DeleteQueue]: crate::client::CloudTasks::delete_queue
        pub const DISABLED: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("PAUSED"),
                3 => std::borrow::Cow::Borrowed("DISABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "PAUSED" => std::option::Option::Some(Self::PAUSED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Rate limits.
///
/// This message determines the maximum rate that tasks can be dispatched by a
/// queue, regardless of whether the dispatch is a first task attempt or a retry.
///
/// Note: The debugging command,
/// [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask], will run a task even if
/// the queue has reached its [RateLimits][google.cloud.tasks.v2.RateLimits].
///
/// [google.cloud.tasks.v2.CloudTasks.RunTask]: crate::client::CloudTasks::run_task
/// [google.cloud.tasks.v2.RateLimits]: crate::model::RateLimits
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RateLimits {
    /// The maximum rate at which tasks are dispatched from this queue.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// * The maximum allowed value is 500.
    ///
    /// This field has the same meaning as
    /// [rate in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#rate).
    pub max_dispatches_per_second: f64,

    /// Output only. The max burst size.
    ///
    /// Max burst size limits how fast tasks in queue are processed when
    /// many tasks are in the queue and the rate is high. This field
    /// allows the queue to have a high rate so processing starts shortly
    /// after a task is enqueued, but still limits resource usage when
    /// many tasks are enqueued in a short period of time.
    ///
    /// The [token bucket](https://wikipedia.org/wiki/Token_Bucket)
    /// algorithm is used to control the rate of task dispatches. Each
    /// queue has a token bucket that holds tokens, up to the maximum
    /// specified by `max_burst_size`. Each time a task is dispatched, a
    /// token is removed from the bucket. Tasks will be dispatched until
    /// the queue's bucket runs out of tokens. The bucket will be
    /// continuously refilled with new tokens based on
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second].
    ///
    /// Cloud Tasks will pick the value of `max_burst_size` based on the
    /// value of
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second].
    ///
    /// For queues that were created or updated using
    /// `queue.yaml/xml`, `max_burst_size` is equal to
    /// [bucket_size](https://cloud.google.com/appengine/docs/standard/python/config/queueref#bucket_size).
    /// Since `max_burst_size` is output only, if
    /// [UpdateQueue][google.cloud.tasks.v2.CloudTasks.UpdateQueue] is called on a
    /// queue created by `queue.yaml/xml`, `max_burst_size` will be reset based on
    /// the value of
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second],
    /// regardless of whether
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second]
    /// is updated.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.UpdateQueue]: crate::client::CloudTasks::update_queue
    /// [google.cloud.tasks.v2.RateLimits.max_dispatches_per_second]: crate::model::RateLimits::max_dispatches_per_second
    pub max_burst_size: i32,

    /// The maximum number of concurrent tasks that Cloud Tasks allows
    /// to be dispatched for this queue. After this threshold has been
    /// reached, Cloud Tasks stops dispatching tasks until the number of
    /// concurrent requests decreases.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// The maximum allowed value is 5,000.
    ///
    /// This field has the same meaning as
    /// [max_concurrent_requests in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#max_concurrent_requests).
    pub max_concurrent_dispatches: i32,
}

impl RateLimits {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_dispatches_per_second][crate::model::RateLimits::max_dispatches_per_second].
    pub fn set_max_dispatches_per_second<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max_dispatches_per_second = v.into();
        self
    }

    /// Sets the value of [max_burst_size][crate::model::RateLimits::max_burst_size].
    pub fn set_max_burst_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_burst_size = v.into();
        self
    }

    /// Sets the value of [max_concurrent_dispatches][crate::model::RateLimits::max_concurrent_dispatches].
    pub fn set_max_concurrent_dispatches<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_dispatches = v.into();
        self
    }
}

impl wkt::message::Message for RateLimits {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.RateLimits"
    }
}

/// Retry config.
///
/// These settings determine when a failed task attempt is retried.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RetryConfig {
    /// Number of attempts per task.
    ///
    /// Cloud Tasks will attempt the task `max_attempts` times (that is, if the
    /// first attempt fails, then there will be `max_attempts - 1` retries). Must
    /// be >= -1.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// -1 indicates unlimited attempts.
    ///
    /// This field has the same meaning as
    /// [task_retry_limit in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    pub max_attempts: i32,

    /// If positive, `max_retry_duration` specifies the time limit for
    /// retrying a failed task, measured from when the task was first
    /// attempted. Once `max_retry_duration` time has passed *and* the
    /// task has been attempted
    /// [max_attempts][google.cloud.tasks.v2.RetryConfig.max_attempts] times, no
    /// further attempts will be made and the task will be deleted.
    ///
    /// If zero, then the task age is unlimited.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// `max_retry_duration` will be truncated to the nearest second.
    ///
    /// This field has the same meaning as
    /// [task_age_limit in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig.max_attempts]: crate::model::RetryConfig::max_attempts
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_retry_duration: std::option::Option<wkt::Duration>,

    /// A task will be [scheduled][google.cloud.tasks.v2.Task.schedule_time] for
    /// retry between [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff]
    /// and [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] duration
    /// after it fails, if the queue's
    /// [RetryConfig][google.cloud.tasks.v2.RetryConfig] specifies that the task
    /// should be retried.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// `min_backoff` will be truncated to the nearest second.
    ///
    /// This field has the same meaning as
    /// [min_backoff_seconds in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig]: crate::model::RetryConfig
    /// [google.cloud.tasks.v2.RetryConfig.max_backoff]: crate::model::RetryConfig::max_backoff
    /// [google.cloud.tasks.v2.RetryConfig.min_backoff]: crate::model::RetryConfig::min_backoff
    /// [google.cloud.tasks.v2.Task.schedule_time]: crate::model::Task::schedule_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_backoff: std::option::Option<wkt::Duration>,

    /// A task will be [scheduled][google.cloud.tasks.v2.Task.schedule_time] for
    /// retry between [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff]
    /// and [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] duration
    /// after it fails, if the queue's
    /// [RetryConfig][google.cloud.tasks.v2.RetryConfig] specifies that the task
    /// should be retried.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// `max_backoff` will be truncated to the nearest second.
    ///
    /// This field has the same meaning as
    /// [max_backoff_seconds in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig]: crate::model::RetryConfig
    /// [google.cloud.tasks.v2.RetryConfig.max_backoff]: crate::model::RetryConfig::max_backoff
    /// [google.cloud.tasks.v2.RetryConfig.min_backoff]: crate::model::RetryConfig::min_backoff
    /// [google.cloud.tasks.v2.Task.schedule_time]: crate::model::Task::schedule_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_backoff: std::option::Option<wkt::Duration>,

    /// The time between retries will double `max_doublings` times.
    ///
    /// A task's retry interval starts at
    /// [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff], then doubles
    /// `max_doublings` times, then increases linearly, and finally
    /// retries at intervals of
    /// [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] up to
    /// [max_attempts][google.cloud.tasks.v2.RetryConfig.max_attempts] times.
    ///
    /// For example, if
    /// [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff] is 10s,
    /// [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] is 300s, and
    /// `max_doublings` is 3, then the a task will first be retried in
    /// 10s. The retry interval will double three times, and then
    /// increase linearly by 2^3 * 10s.  Finally, the task will retry at
    /// intervals of [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff]
    /// until the task has been attempted
    /// [max_attempts][google.cloud.tasks.v2.RetryConfig.max_attempts] times. Thus,
    /// the requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s, 300s, ....
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// This field has the same meaning as
    /// [max_doublings in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig.max_attempts]: crate::model::RetryConfig::max_attempts
    /// [google.cloud.tasks.v2.RetryConfig.max_backoff]: crate::model::RetryConfig::max_backoff
    /// [google.cloud.tasks.v2.RetryConfig.min_backoff]: crate::model::RetryConfig::min_backoff
    pub max_doublings: i32,
}

impl RetryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_attempts][crate::model::RetryConfig::max_attempts].
    pub fn set_max_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_attempts = v.into();
        self
    }

    /// Sets the value of [max_retry_duration][crate::model::RetryConfig::max_retry_duration].
    pub fn set_max_retry_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_retry_duration = v.into();
        self
    }

    /// Sets the value of [min_backoff][crate::model::RetryConfig::min_backoff].
    pub fn set_min_backoff<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_backoff = v.into();
        self
    }

    /// Sets the value of [max_backoff][crate::model::RetryConfig::max_backoff].
    pub fn set_max_backoff<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_backoff = v.into();
        self
    }

    /// Sets the value of [max_doublings][crate::model::RetryConfig::max_doublings].
    pub fn set_max_doublings<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_doublings = v.into();
        self
    }
}

impl wkt::message::Message for RetryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.RetryConfig"
    }
}

/// Configuration options for writing logs to
/// [Stackdriver Logging](https://cloud.google.com/logging/docs/).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StackdriverLoggingConfig {
    /// Specifies the fraction of operations to write to
    /// [Stackdriver Logging](https://cloud.google.com/logging/docs/).
    /// This field may contain any value between 0.0 and 1.0, inclusive.
    /// 0.0 is the default and means that no operations are logged.
    pub sampling_ratio: f64,
}

impl StackdriverLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sampling_ratio][crate::model::StackdriverLoggingConfig::sampling_ratio].
    pub fn set_sampling_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.sampling_ratio = v.into();
        self
    }
}

impl wkt::message::Message for StackdriverLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.StackdriverLoggingConfig"
    }
}

/// HTTP request.
///
/// The task will be pushed to the worker as an HTTP request. If the worker
/// or the redirected worker acknowledges the task by returning a successful HTTP
/// response code ([`200` - `299`]), the task will be removed from the queue. If
/// any other HTTP response code is returned or no response is received, the
/// task will be retried according to the following:
///
/// * User-specified throttling: [retry
///   configuration][google.cloud.tasks.v2.Queue.retry_config],
///   [rate limits][google.cloud.tasks.v2.Queue.rate_limits], and the [queue's
///   state][google.cloud.tasks.v2.Queue.state].
///
/// * System throttling: To prevent the worker from overloading, Cloud Tasks may
///   temporarily reduce the queue's effective rate. User-specified settings
///   will not be changed.
///
///
/// System throttling happens because:
///
/// * Cloud Tasks backs off on all errors. Normally the backoff specified in
///   [rate limits][google.cloud.tasks.v2.Queue.rate_limits] will be used. But
///   if the worker returns `429` (Too Many Requests), `503` (Service
///   Unavailable), or the rate of errors is high, Cloud Tasks will use a
///   higher backoff rate. The retry specified in the `Retry-After` HTTP
///   response header is considered.
///
/// * To prevent traffic spikes and to smooth sudden increases in traffic,
///   dispatches ramp up slowly when the queue is newly created or idle and
///   if large numbers of tasks suddenly become available to dispatch (due to
///   spikes in create task rates, the queue being unpaused, or many tasks
///   that are scheduled at the same time).
///
///
/// [google.cloud.tasks.v2.Queue.rate_limits]: crate::model::Queue::rate_limits
/// [google.cloud.tasks.v2.Queue.retry_config]: crate::model::Queue::retry_config
/// [google.cloud.tasks.v2.Queue.state]: crate::model::Queue::state
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpRequest {
    /// Required. The full url path that the request will be sent to.
    ///
    /// This string must begin with either "http://" or "https://". Some examples
    /// are: `<http://acme.com>` and `<https://acme.com/sales:8080>`. Cloud Tasks will
    /// encode some characters for safety and compatibility. The maximum allowed
    /// URL length is 2083 characters after encoding.
    ///
    /// The `Location` header response from a redirect response [`300` - `399`]
    /// may be followed. The redirect is not counted as a separate attempt.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub url: std::string::String,

    /// The HTTP method to use for the request. The default is POST.
    pub http_method: crate::model::HttpMethod,

    /// HTTP request headers.
    ///
    /// This map contains the header field names and values.
    /// Headers can be set when the
    /// [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
    ///
    /// These headers represent a subset of the headers that will accompany the
    /// task's HTTP request. Some HTTP request headers will be ignored or replaced.
    ///
    /// A partial list of headers that will be ignored or replaced is:
    ///
    /// * Host: This will be computed by Cloud Tasks and derived from
    ///   [HttpRequest.url][google.cloud.tasks.v2.HttpRequest.url].
    /// * Content-Length: This will be computed by Cloud Tasks.
    /// * User-Agent: This will be set to `"Google-Cloud-Tasks"`.
    /// * `X-Google-*`: Google use only.
    /// * `X-AppEngine-*`: Google use only.
    ///
    /// `Content-Type` won't be set by Cloud Tasks. You can explicitly set
    /// `Content-Type` to a media type when the
    /// [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
    /// For example, `Content-Type` can be set to `"application/octet-stream"` or
    /// `"application/json"`.
    ///
    /// Headers which can have multiple values (according to RFC2616) can be
    /// specified using comma-separated values.
    ///
    /// The size of the headers must be less than 80KB.
    ///
    /// [google.cloud.tasks.v2.HttpRequest.url]: crate::model::HttpRequest::url
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// HTTP request body.
    ///
    /// A request body is allowed only if the
    /// [HTTP method][google.cloud.tasks.v2.HttpRequest.http_method] is POST, PUT,
    /// or PATCH. It is an error to set body on a task with an incompatible
    /// [HttpMethod][google.cloud.tasks.v2.HttpMethod].
    ///
    /// [google.cloud.tasks.v2.HttpMethod]: crate::model::HttpMethod
    /// [google.cloud.tasks.v2.HttpRequest.http_method]: crate::model::HttpRequest::http_method
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub body: ::bytes::Bytes,

    /// The mode for generating an `Authorization` header for HTTP requests.
    ///
    /// If specified, all `Authorization` headers in the
    /// [HttpRequest.headers][google.cloud.tasks.v2.HttpRequest.headers] field will
    /// be overridden.
    ///
    /// [google.cloud.tasks.v2.HttpRequest.headers]: crate::model::HttpRequest::headers
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub authorization_header: std::option::Option<crate::model::http_request::AuthorizationHeader>,
}

impl HttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::HttpRequest::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [http_method][crate::model::HttpRequest::http_method].
    pub fn set_http_method<T: std::convert::Into<crate::model::HttpMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [body][crate::model::HttpRequest::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpRequest::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `authorization_header`.
    pub fn set_authorization_header<
        T: std::convert::Into<std::option::Option<crate::model::http_request::AuthorizationHeader>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = v.into();
        self
    }

    /// The value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// if it holds a `OauthToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_oauth_token(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OAuthToken>> {
        #[allow(unreachable_patterns)]
        self.authorization_header.as_ref().and_then(|v| match v {
            crate::model::http_request::AuthorizationHeader::OauthToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// if it holds a `OidcToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_oidc_token(&self) -> std::option::Option<&std::boxed::Box<crate::model::OidcToken>> {
        #[allow(unreachable_patterns)]
        self.authorization_header.as_ref().and_then(|v| match v {
            crate::model::http_request::AuthorizationHeader::OidcToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// to hold a `OauthToken`.
    ///
    /// Note that all the setters affecting `authorization_header` are
    /// mutually exclusive.
    pub fn set_oauth_token<T: std::convert::Into<std::boxed::Box<crate::model::OAuthToken>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = std::option::Option::Some(
            crate::model::http_request::AuthorizationHeader::OauthToken(v.into()),
        );
        self
    }

    /// Sets the value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// to hold a `OidcToken`.
    ///
    /// Note that all the setters affecting `authorization_header` are
    /// mutually exclusive.
    pub fn set_oidc_token<T: std::convert::Into<std::boxed::Box<crate::model::OidcToken>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = std::option::Option::Some(
            crate::model::http_request::AuthorizationHeader::OidcToken(v.into()),
        );
        self
    }
}

impl wkt::message::Message for HttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.HttpRequest"
    }
}

/// Defines additional types related to HttpRequest
pub mod http_request {
    #[allow(unused_imports)]
    use super::*;

    /// The mode for generating an `Authorization` header for HTTP requests.
    ///
    /// If specified, all `Authorization` headers in the
    /// [HttpRequest.headers][google.cloud.tasks.v2.HttpRequest.headers] field will
    /// be overridden.
    ///
    /// [google.cloud.tasks.v2.HttpRequest.headers]: crate::model::HttpRequest::headers
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthorizationHeader {
        /// If specified, an
        /// [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
        /// will be generated and attached as an `Authorization` header in the HTTP
        /// request.
        ///
        /// This type of authorization should generally only be used when calling
        /// Google APIs hosted on *.googleapis.com.
        OauthToken(std::boxed::Box<crate::model::OAuthToken>),
        /// If specified, an
        /// [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
        /// token will be generated and attached as an `Authorization` header in the
        /// HTTP request.
        ///
        /// This type of authorization can be used for many scenarios, including
        /// calling Cloud Run, or endpoints where you intend to validate the token
        /// yourself.
        OidcToken(std::boxed::Box<crate::model::OidcToken>),
    }
}

/// App Engine HTTP request.
///
/// The message defines the HTTP request that is sent to an App Engine app when
/// the task is dispatched.
///
/// Using [AppEngineHttpRequest][google.cloud.tasks.v2.AppEngineHttpRequest]
/// requires
/// [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
/// Google IAM permission for the project
/// and the following scope:
///
/// `<https://www.googleapis.com/auth/cloud-platform>`
///
/// The task will be delivered to the App Engine app which belongs to the same
/// project as the queue. For more information, see
/// [How Requests are
/// Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
/// and how routing is affected by
/// [dispatch
/// files](https://cloud.google.com/appengine/docs/python/config/dispatchref).
/// Traffic is encrypted during transport and never leaves Google datacenters.
/// Because this traffic is carried over a communication mechanism internal to
/// Google, you cannot explicitly set the protocol (for example, HTTP or HTTPS).
/// The request to the handler, however, will appear to have used the HTTP
/// protocol.
///
/// The [AppEngineRouting][google.cloud.tasks.v2.AppEngineRouting] used to
/// construct the URL that the task is delivered to can be set at the queue-level
/// or task-level:
///
/// * If [app_engine_routing_override is set on the
///   queue][google.cloud.tasks.v2.Queue.app_engine_routing_override], this value
///   is used for all tasks in the queue, no matter what the setting is for the
///   [task-level
///   app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
///
/// The `url` that the task will be sent to is:
///
/// * `url =` [host][google.cloud.tasks.v2.AppEngineRouting.host] `+`
///   [relative_uri][google.cloud.tasks.v2.AppEngineHttpRequest.relative_uri]
///
/// Tasks can be dispatched to secure app handlers, unsecure app handlers, and
/// URIs restricted with
/// [`login:
/// admin`](https://cloud.google.com/appengine/docs/standard/python/config/appref).
/// Because tasks are not run as any user, they cannot be dispatched to URIs
/// restricted with
/// [`login:
/// required`](https://cloud.google.com/appengine/docs/standard/python/config/appref)
/// Task dispatches also do not follow redirects.
///
/// The task attempt has succeeded if the app's request handler returns an HTTP
/// response code in the range [`200` - `299`]. The task attempt has failed if
/// the app's handler returns a non-2xx response code or Cloud Tasks does
/// not receive response before the
/// [deadline][google.cloud.tasks.v2.Task.dispatch_deadline]. Failed tasks will
/// be retried according to the [retry
/// configuration][google.cloud.tasks.v2.Queue.retry_config]. `503` (Service
/// Unavailable) is considered an App Engine system error instead of an
/// application error and will cause Cloud Tasks' traffic congestion control to
/// temporarily throttle the queue's dispatches. Unlike other types of task
/// targets, a `429` (Too Many Requests) response from an app handler does not
/// cause traffic congestion control to throttle the queue.
///
/// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
/// [google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing]: crate::model::AppEngineHttpRequest::app_engine_routing
/// [google.cloud.tasks.v2.AppEngineHttpRequest.relative_uri]: crate::model::AppEngineHttpRequest::relative_uri
/// [google.cloud.tasks.v2.AppEngineRouting]: crate::model::AppEngineRouting
/// [google.cloud.tasks.v2.AppEngineRouting.host]: crate::model::AppEngineRouting::host
/// [google.cloud.tasks.v2.Queue.app_engine_routing_override]: crate::model::Queue::app_engine_routing_override
/// [google.cloud.tasks.v2.Queue.retry_config]: crate::model::Queue::retry_config
/// [google.cloud.tasks.v2.Task.dispatch_deadline]: crate::model::Task::dispatch_deadline
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppEngineHttpRequest {
    /// The HTTP method to use for the request. The default is POST.
    ///
    /// The app's request handler for the task's target URL must be able to handle
    /// HTTP requests with this http_method, otherwise the task attempt fails with
    /// error code 405 (Method Not Allowed). See [Writing a push task request
    /// handler](https://cloud.google.com/appengine/docs/java/taskqueue/push/creating-handlers#writing_a_push_task_request_handler)
    /// and the App Engine documentation for your runtime on [How Requests are
    /// Handled](https://cloud.google.com/appengine/docs/standard/python3/how-requests-are-handled).
    pub http_method: crate::model::HttpMethod,

    /// Task-level setting for App Engine routing.
    ///
    /// * If [app_engine_routing_override is set on the
    ///   queue][google.cloud.tasks.v2.Queue.app_engine_routing_override], this
    ///   value is used for all tasks in the queue, no matter what the setting is
    ///   for the [task-level
    ///   app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing]: crate::model::AppEngineHttpRequest::app_engine_routing
    /// [google.cloud.tasks.v2.Queue.app_engine_routing_override]: crate::model::Queue::app_engine_routing_override
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub app_engine_routing: std::option::Option<crate::model::AppEngineRouting>,

    /// The relative URI.
    ///
    /// The relative URI must begin with "/" and must be a valid HTTP relative URI.
    /// It can contain a path and query string arguments.
    /// If the relative URI is empty, then the root path "/" will be used.
    /// No spaces are allowed, and the maximum length allowed is 2083 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relative_uri: std::string::String,

    /// HTTP request headers.
    ///
    /// This map contains the header field names and values.
    /// Headers can be set when the
    /// [task is created][google.cloud.tasks.v2.CloudTasks.CreateTask].
    /// Repeated headers are not supported but a header value can contain commas.
    ///
    /// Cloud Tasks sets some headers to default values:
    ///
    /// * `User-Agent`: By default, this header is
    ///   `"AppEngine-Google; (+<http://code.google.com/appengine>)"`.
    ///   This header can be modified, but Cloud Tasks will append
    ///   `"AppEngine-Google; (+<http://code.google.com/appengine>)"` to the
    ///   modified `User-Agent`.
    ///
    /// If the task has a [body][google.cloud.tasks.v2.AppEngineHttpRequest.body],
    /// Cloud Tasks sets the following headers:
    ///
    /// * `Content-Type`: By default, the `Content-Type` header is set to
    ///   `"application/octet-stream"`. The default can be overridden by explicitly
    ///   setting `Content-Type` to a particular media type when the
    ///   [task is created][google.cloud.tasks.v2.CloudTasks.CreateTask].
    ///   For example, `Content-Type` can be set to `"application/json"`.
    /// * `Content-Length`: This is computed by Cloud Tasks. This value is
    ///   output only.   It cannot be changed.
    ///
    /// The headers below cannot be set or overridden:
    ///
    /// * `Host`
    /// * `X-Google-*`
    /// * `X-AppEngine-*`
    ///
    /// In addition, Cloud Tasks sets some headers when the task is dispatched,
    /// such as headers containing information about the task; see
    /// [request
    /// headers](https://cloud.google.com/tasks/docs/creating-appengine-handlers#reading_request_headers).
    /// These headers are set only when the task is dispatched, so they are not
    /// visible when the task is returned in a Cloud Tasks response.
    ///
    /// Although there is no specific limit for the maximum number of headers or
    /// the size, there is a limit on the maximum size of the
    /// [Task][google.cloud.tasks.v2.Task]. For more information, see the
    /// [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask] documentation.
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest.body]: crate::model::AppEngineHttpRequest::body
    /// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// HTTP request body.
    ///
    /// A request body is allowed only if the HTTP method is POST or PUT. It is
    /// an error to set a body on a task with an incompatible
    /// [HttpMethod][google.cloud.tasks.v2.HttpMethod].
    ///
    /// [google.cloud.tasks.v2.HttpMethod]: crate::model::HttpMethod
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub body: ::bytes::Bytes,
}

impl AppEngineHttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_method][crate::model::AppEngineHttpRequest::http_method].
    pub fn set_http_method<T: std::convert::Into<crate::model::HttpMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [app_engine_routing][crate::model::AppEngineHttpRequest::app_engine_routing].
    pub fn set_app_engine_routing<
        T: std::convert::Into<std::option::Option<crate::model::AppEngineRouting>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.app_engine_routing = v.into();
        self
    }

    /// Sets the value of [relative_uri][crate::model::AppEngineHttpRequest::relative_uri].
    pub fn set_relative_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_uri = v.into();
        self
    }

    /// Sets the value of [body][crate::model::AppEngineHttpRequest::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::AppEngineHttpRequest::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AppEngineHttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.AppEngineHttpRequest"
    }
}

/// App Engine Routing.
///
/// Defines routing characteristics specific to App Engine - service, version,
/// and instance.
///
/// For more information about services, versions, and instances see
/// [An Overview of App
/// Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
/// [Microservices Architecture on Google App
/// Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
/// [App Engine Standard request
/// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
/// and [App Engine Flex request
/// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
///
/// Using [AppEngineRouting][google.cloud.tasks.v2.AppEngineRouting] requires
/// [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
/// Google IAM permission for the project
/// and the following scope:
///
/// `<https://www.googleapis.com/auth/cloud-platform>`
///
/// [google.cloud.tasks.v2.AppEngineRouting]: crate::model::AppEngineRouting
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppEngineRouting {
    /// App service.
    ///
    /// By default, the task is sent to the service which is the default
    /// service when the task is attempted.
    ///
    /// For some queues or tasks which were created using the App Engine
    /// Task Queue API, [host][google.cloud.tasks.v2.AppEngineRouting.host] is not
    /// parsable into [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. For example,
    /// some tasks which were created using the App Engine SDK use a custom domain
    /// name; custom domains are not parsed by Cloud Tasks. If
    /// [host][google.cloud.tasks.v2.AppEngineRouting.host] is not parsable, then
    /// [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance] are the empty
    /// string.
    ///
    /// [google.cloud.tasks.v2.AppEngineRouting.host]: crate::model::AppEngineRouting::host
    /// [google.cloud.tasks.v2.AppEngineRouting.instance]: crate::model::AppEngineRouting::instance
    /// [google.cloud.tasks.v2.AppEngineRouting.service]: crate::model::AppEngineRouting::service
    /// [google.cloud.tasks.v2.AppEngineRouting.version]: crate::model::AppEngineRouting::version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    /// App version.
    ///
    /// By default, the task is sent to the version which is the default
    /// version when the task is attempted.
    ///
    /// For some queues or tasks which were created using the App Engine
    /// Task Queue API, [host][google.cloud.tasks.v2.AppEngineRouting.host] is not
    /// parsable into [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. For example,
    /// some tasks which were created using the App Engine SDK use a custom domain
    /// name; custom domains are not parsed by Cloud Tasks. If
    /// [host][google.cloud.tasks.v2.AppEngineRouting.host] is not parsable, then
    /// [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance] are the empty
    /// string.
    ///
    /// [google.cloud.tasks.v2.AppEngineRouting.host]: crate::model::AppEngineRouting::host
    /// [google.cloud.tasks.v2.AppEngineRouting.instance]: crate::model::AppEngineRouting::instance
    /// [google.cloud.tasks.v2.AppEngineRouting.service]: crate::model::AppEngineRouting::service
    /// [google.cloud.tasks.v2.AppEngineRouting.version]: crate::model::AppEngineRouting::version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// App instance.
    ///
    /// By default, the task is sent to an instance which is available when
    /// the task is attempted.
    ///
    /// Requests can only be sent to a specific instance if
    /// [manual scaling is used in App Engine
    /// Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?hl=en_US#scaling_types_and_instance_classes).
    /// App Engine Flex does not support instances. For more information, see
    /// [App Engine Standard request
    /// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
    /// and [App Engine Flex request
    /// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Output only. The host that the task is sent to.
    ///
    /// The host is constructed from the domain name of the app associated with
    /// the queue's project ID (for example \<app-id\>.appspot.com), and the
    /// [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. Tasks which
    /// were created using the App Engine SDK might have a custom domain name.
    ///
    /// For more information, see
    /// [How Requests are
    /// Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
    ///
    /// [google.cloud.tasks.v2.AppEngineRouting.instance]: crate::model::AppEngineRouting::instance
    /// [google.cloud.tasks.v2.AppEngineRouting.service]: crate::model::AppEngineRouting::service
    /// [google.cloud.tasks.v2.AppEngineRouting.version]: crate::model::AppEngineRouting::version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,
}

impl AppEngineRouting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::AppEngineRouting::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AppEngineRouting::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::AppEngineRouting::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [host][crate::model::AppEngineRouting::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for AppEngineRouting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.AppEngineRouting"
    }
}

/// Contains information needed for generating an
/// [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
/// This type of authorization should generally only be used when calling Google
/// APIs hosted on *.googleapis.com.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OAuthToken {
    /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
    /// to be used for generating OAuth token.
    /// The service account must be within the same project as the queue. The
    /// caller must have iam.serviceAccounts.actAs permission for the service
    /// account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email: std::string::String,

    /// OAuth scope to be used for generating OAuth access token.
    /// If not specified, `https://www.googleapis.com/auth/cloud-platform`
    /// will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub scope: std::string::String,
}

impl OAuthToken {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_email][crate::model::OAuthToken::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::OAuthToken::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for OAuthToken {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.OAuthToken"
    }
}

/// Contains information needed for generating an
/// [OpenID Connect
/// token](https://developers.google.com/identity/protocols/OpenIDConnect).
/// This type of authorization can be used for many scenarios, including
/// calling Cloud Run, or endpoints where you intend to validate the token
/// yourself.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OidcToken {
    /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
    /// to be used for generating OIDC token.
    /// The service account must be within the same project as the queue. The
    /// caller must have iam.serviceAccounts.actAs permission for the service
    /// account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account_email: std::string::String,

    /// Audience to be used when generating OIDC token. If not specified, the URI
    /// specified in target will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub audience: std::string::String,
}

impl OidcToken {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_email][crate::model::OidcToken::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::OidcToken::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }
}

impl wkt::message::Message for OidcToken {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.OidcToken"
    }
}

/// A unit of scheduled work.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Task {
    /// Optionally caller-specified in
    /// [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask].
    ///
    /// The task name.
    ///
    /// The task name must have the following format:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    ///
    /// * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), colons (:), or periods (.).
    ///   For more information, see
    ///   [Identifying
    ///   projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
    /// * `LOCATION_ID` is the canonical ID for the task's location.
    ///   The list of available locations can be obtained by calling
    ///   [ListLocations][google.cloud.location.Locations.ListLocations].
    ///   For more information, see <https://cloud.google.com/about/locations/>.
    /// * `QUEUE_ID` can contain letters ([A-Za-z]), numbers ([0-9]), or
    ///   hyphens (-). The maximum length is 100 characters.
    /// * `TASK_ID` can contain only letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), or underscores (_). The maximum length is 500 characters.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time when the task is scheduled to be attempted or retried.
    ///
    /// `schedule_time` will be truncated to the nearest microsecond.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that the task was created.
    ///
    /// `create_time` will be truncated to the nearest second.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The deadline for requests sent to the worker. If the worker does not
    /// respond by this deadline then the request is cancelled and the attempt
    /// is marked as a `DEADLINE_EXCEEDED` failure. Cloud Tasks will retry the
    /// task according to the [RetryConfig][google.cloud.tasks.v2.RetryConfig].
    ///
    /// Note that when the request is cancelled, Cloud Tasks will stop listening
    /// for the response, but whether the worker stops processing depends on the
    /// worker. For example, if the worker is stuck, it may not react to cancelled
    /// requests.
    ///
    /// The default and maximum values depend on the type of request:
    ///
    /// * For [HTTP tasks][google.cloud.tasks.v2.HttpRequest], the default is 10
    ///   minutes. The deadline
    ///   must be in the interval [15 seconds, 30 minutes].
    ///
    /// * For [App Engine tasks][google.cloud.tasks.v2.AppEngineHttpRequest], 0
    ///   indicates that the
    ///   request has the default deadline. The default deadline depends on the
    ///   [scaling
    ///   type](https://cloud.google.com/appengine/docs/standard/go/how-instances-are-managed#instance_scaling)
    ///   of the service: 10 minutes for standard apps with automatic scaling, 24
    ///   hours for standard apps with manual and basic scaling, and 60 minutes for
    ///   flex apps. If the request deadline is set, it must be in the interval [15
    ///   seconds, 24 hours 15 seconds]. Regardless of the task's
    ///   `dispatch_deadline`, the app handler will not run for longer than than
    ///   the service's timeout. We recommend setting the `dispatch_deadline` to
    ///   at most a few seconds more than the app handler's timeout. For more
    ///   information see
    ///   [Timeouts](https://cloud.google.com/tasks/docs/creating-appengine-handlers#timeouts).
    ///
    ///
    /// `dispatch_deadline` will be truncated to the nearest millisecond. The
    /// deadline is an approximate deadline.
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
    /// [google.cloud.tasks.v2.HttpRequest]: crate::model::HttpRequest
    /// [google.cloud.tasks.v2.RetryConfig]: crate::model::RetryConfig
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dispatch_deadline: std::option::Option<wkt::Duration>,

    /// Output only. The number of attempts dispatched.
    ///
    /// This count includes attempts which have been dispatched but haven't
    /// received a response.
    pub dispatch_count: i32,

    /// Output only. The number of attempts which have received a response.
    pub response_count: i32,

    /// Output only. The status of the task's first attempt.
    ///
    /// Only [dispatch_time][google.cloud.tasks.v2.Attempt.dispatch_time] will be
    /// set. The other [Attempt][google.cloud.tasks.v2.Attempt] information is not
    /// retained by Cloud Tasks.
    ///
    /// [google.cloud.tasks.v2.Attempt]: crate::model::Attempt
    /// [google.cloud.tasks.v2.Attempt.dispatch_time]: crate::model::Attempt::dispatch_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub first_attempt: std::option::Option<crate::model::Attempt>,

    /// Output only. The status of the task's last attempt.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_attempt: std::option::Option<crate::model::Attempt>,

    /// Output only. The view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] has been returned.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    pub view: crate::model::task::View,

    /// Required. The message to send to the worker.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub message_type: std::option::Option<crate::model::task::MessageType>,
}

impl Task {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Task::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schedule_time][crate::model::Task::schedule_time].
    pub fn set_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_time = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Task::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [dispatch_deadline][crate::model::Task::dispatch_deadline].
    pub fn set_dispatch_deadline<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dispatch_deadline = v.into();
        self
    }

    /// Sets the value of [dispatch_count][crate::model::Task::dispatch_count].
    pub fn set_dispatch_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.dispatch_count = v.into();
        self
    }

    /// Sets the value of [response_count][crate::model::Task::response_count].
    pub fn set_response_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.response_count = v.into();
        self
    }

    /// Sets the value of [first_attempt][crate::model::Task::first_attempt].
    pub fn set_first_attempt<T: std::convert::Into<std::option::Option<crate::model::Attempt>>>(
        mut self,
        v: T,
    ) -> Self {
        self.first_attempt = v.into();
        self
    }

    /// Sets the value of [last_attempt][crate::model::Task::last_attempt].
    pub fn set_last_attempt<T: std::convert::Into<std::option::Option<crate::model::Attempt>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_attempt = v.into();
        self
    }

    /// Sets the value of [view][crate::model::Task::view].
    pub fn set_view<T: std::convert::Into<crate::model::task::View>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of `message_type`.
    pub fn set_message_type<
        T: std::convert::Into<std::option::Option<crate::model::task::MessageType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = v.into();
        self
    }

    /// The value of [message_type][crate::model::Task::message_type]
    /// if it holds a `AppEngineHttpRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_app_engine_http_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AppEngineHttpRequest>> {
        #[allow(unreachable_patterns)]
        self.message_type.as_ref().and_then(|v| match v {
            crate::model::task::MessageType::AppEngineHttpRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [message_type][crate::model::Task::message_type]
    /// if it holds a `HttpRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_http_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::HttpRequest>> {
        #[allow(unreachable_patterns)]
        self.message_type.as_ref().and_then(|v| match v {
            crate::model::task::MessageType::HttpRequest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message_type][crate::model::Task::message_type]
    /// to hold a `AppEngineHttpRequest`.
    ///
    /// Note that all the setters affecting `message_type` are
    /// mutually exclusive.
    pub fn set_app_engine_http_request<
        T: std::convert::Into<std::boxed::Box<crate::model::AppEngineHttpRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = std::option::Option::Some(
            crate::model::task::MessageType::AppEngineHttpRequest(v.into()),
        );
        self
    }

    /// Sets the value of [message_type][crate::model::Task::message_type]
    /// to hold a `HttpRequest`.
    ///
    /// Note that all the setters affecting `message_type` are
    /// mutually exclusive.
    pub fn set_http_request<T: std::convert::Into<std::boxed::Box<crate::model::HttpRequest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message_type =
            std::option::Option::Some(crate::model::task::MessageType::HttpRequest(v.into()));
        self
    }
}

impl wkt::message::Message for Task {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.Task"
    }
}

/// Defines additional types related to Task
pub mod task {
    #[allow(unused_imports)]
    use super::*;

    /// The view specifies a subset of [Task][google.cloud.tasks.v2.Task] data.
    ///
    /// When a task is returned in a response, not all
    /// information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct View(i32);

    impl View {
        /// Unspecified. Defaults to BASIC.
        pub const VIEW_UNSPECIFIED: View = View::new(0);

        /// The basic view omits fields which can be large or can contain
        /// sensitive data.
        ///
        /// This view does not include the
        /// [body in
        /// AppEngineHttpRequest][google.cloud.tasks.v2.AppEngineHttpRequest.body].
        /// Bodies are desirable to return only when needed, because they
        /// can be large and because of the sensitivity of the data that you
        /// choose to store in it.
        ///
        /// [google.cloud.tasks.v2.AppEngineHttpRequest.body]: crate::model::AppEngineHttpRequest::body
        pub const BASIC: View = View::new(1);

        /// All information is returned.
        ///
        /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
        /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
        /// permission on the [Queue][google.cloud.tasks.v2.Queue] resource.
        ///
        /// [google.cloud.tasks.v2.Queue]: crate::model::Queue
        /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::view::FULL
        pub const FULL: View = View::new(2);

        /// Creates a new View instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("VIEW_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("BASIC"),
                2 => std::borrow::Cow::Borrowed("FULL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "VIEW_UNSPECIFIED" => std::option::Option::Some(Self::VIEW_UNSPECIFIED),
                "BASIC" => std::option::Option::Some(Self::BASIC),
                "FULL" => std::option::Option::Some(Self::FULL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for View {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for View {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Required. The message to send to the worker.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MessageType {
        /// HTTP request that is sent to the App Engine app handler.
        ///
        /// An App Engine task is a task that has
        /// [AppEngineHttpRequest][google.cloud.tasks.v2.AppEngineHttpRequest] set.
        ///
        /// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
        AppEngineHttpRequest(std::boxed::Box<crate::model::AppEngineHttpRequest>),
        /// HTTP request that is sent to the worker.
        ///
        /// An HTTP task is a task that has
        /// [HttpRequest][google.cloud.tasks.v2.HttpRequest] set.
        ///
        /// [google.cloud.tasks.v2.HttpRequest]: crate::model::HttpRequest
        HttpRequest(std::boxed::Box<crate::model::HttpRequest>),
    }
}

/// The status of a task attempt.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Attempt {
    /// Output only. The time that this attempt was scheduled.
    ///
    /// `schedule_time` will be truncated to the nearest microsecond.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that this attempt was dispatched.
    ///
    /// `dispatch_time` will be truncated to the nearest microsecond.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dispatch_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that this attempt response was received.
    ///
    /// `response_time` will be truncated to the nearest microsecond.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The response from the worker for this attempt.
    ///
    /// If `response_time` is unset, then the task has not been attempted or is
    /// currently running and the `response_status` field is meaningless.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_status: std::option::Option<rpc::model::Status>,
}

impl Attempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule_time][crate::model::Attempt::schedule_time].
    pub fn set_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_time = v.into();
        self
    }

    /// Sets the value of [dispatch_time][crate::model::Attempt::dispatch_time].
    pub fn set_dispatch_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dispatch_time = v.into();
        self
    }

    /// Sets the value of [response_time][crate::model::Attempt::response_time].
    pub fn set_response_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_time = v.into();
        self
    }

    /// Sets the value of [response_status][crate::model::Attempt::response_status].
    pub fn set_response_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_status = v.into();
        self
    }
}

impl wkt::message::Message for Attempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.Attempt"
    }
}

/// The HTTP method used to deliver the task.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct HttpMethod(i32);

impl HttpMethod {
    /// HTTP method unspecified
    pub const HTTP_METHOD_UNSPECIFIED: HttpMethod = HttpMethod::new(0);

    /// HTTP POST
    pub const POST: HttpMethod = HttpMethod::new(1);

    /// HTTP GET
    pub const GET: HttpMethod = HttpMethod::new(2);

    /// HTTP HEAD
    pub const HEAD: HttpMethod = HttpMethod::new(3);

    /// HTTP PUT
    pub const PUT: HttpMethod = HttpMethod::new(4);

    /// HTTP DELETE
    pub const DELETE: HttpMethod = HttpMethod::new(5);

    /// HTTP PATCH
    pub const PATCH: HttpMethod = HttpMethod::new(6);

    /// HTTP OPTIONS
    pub const OPTIONS: HttpMethod = HttpMethod::new(7);

    /// Creates a new HttpMethod instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("HTTP_METHOD_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("POST"),
            2 => std::borrow::Cow::Borrowed("GET"),
            3 => std::borrow::Cow::Borrowed("HEAD"),
            4 => std::borrow::Cow::Borrowed("PUT"),
            5 => std::borrow::Cow::Borrowed("DELETE"),
            6 => std::borrow::Cow::Borrowed("PATCH"),
            7 => std::borrow::Cow::Borrowed("OPTIONS"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "HTTP_METHOD_UNSPECIFIED" => std::option::Option::Some(Self::HTTP_METHOD_UNSPECIFIED),
            "POST" => std::option::Option::Some(Self::POST),
            "GET" => std::option::Option::Some(Self::GET),
            "HEAD" => std::option::Option::Some(Self::HEAD),
            "PUT" => std::option::Option::Some(Self::PUT),
            "DELETE" => std::option::Option::Some(Self::DELETE),
            "PATCH" => std::option::Option::Some(Self::PATCH),
            "OPTIONS" => std::option::Option::Some(Self::OPTIONS),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for HttpMethod {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for HttpMethod {
    fn default() -> Self {
        Self::new(0)
    }
}
