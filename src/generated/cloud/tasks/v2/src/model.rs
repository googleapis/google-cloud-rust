// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for
/// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues].
///
/// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQueuesRequest {
    /// Required. The location name.
    /// For example: `projects/PROJECT_ID/locations/LOCATION_ID`
    pub parent: std::string::String,

    /// `filter` can be used to specify a subset of queues. Any
    /// [Queue][google.cloud.tasks.v2.Queue] field can be used as a filter and
    /// several operators as supported. For example: `<=, <, >=, >, !=, =, :`. The
    /// filter syntax is the same as described in [Stackdriver's Advanced Logs
    /// Filters](https://cloud.google.com/logging/docs/view/advanced_filters).
    ///
    /// Sample filter "state: PAUSED".
    ///
    /// Note that using filters might cause fewer queues than the
    /// requested page_size to be returned.
    ///
    /// [google.cloud.tasks.v2.Queue]: crate::model::Queue
    pub filter: std::string::String,

    /// Requested page size.
    ///
    /// The maximum page size is 9800. If unspecified, the page size will
    /// be the maximum. Fewer queues than requested might be returned,
    /// even if more queues exist; use the
    /// [next_page_token][google.cloud.tasks.v2.ListQueuesResponse.next_page_token]
    /// in the response to determine if more queues exist.
    ///
    /// [google.cloud.tasks.v2.ListQueuesResponse.next_page_token]: crate::model::ListQueuesResponse::next_page_token
    pub page_size: i32,

    /// A token identifying the page of results to return.
    ///
    /// To request the first page results, page_token must be empty. To
    /// request the next page of results, page_token must be the value of
    /// [next_page_token][google.cloud.tasks.v2.ListQueuesResponse.next_page_token]
    /// returned from the previous call to
    /// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues] method. It is an
    /// error to switch the value of the
    /// [filter][google.cloud.tasks.v2.ListQueuesRequest.filter] while iterating
    /// through pages.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
    /// [google.cloud.tasks.v2.ListQueuesRequest.filter]: crate::model::ListQueuesRequest::filter
    /// [google.cloud.tasks.v2.ListQueuesResponse.next_page_token]: crate::model::ListQueuesResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQueuesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQueuesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQueuesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQueuesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQueuesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQueuesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListQueuesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQueuesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQueuesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQueuesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQueuesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQueuesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQueuesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQueuesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues].
///
/// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQueuesResponse {
    /// The list of queues.
    pub queues: std::vec::Vec<crate::model::Queue>,

    /// A token to retrieve next page of results.
    ///
    /// To return the next page of results, call
    /// [ListQueues][google.cloud.tasks.v2.CloudTasks.ListQueues] with this value
    /// as the [page_token][google.cloud.tasks.v2.ListQueuesRequest.page_token].
    ///
    /// If the next_page_token is empty, there are no more results.
    ///
    /// The page token is valid for only 2 hours.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListQueues]: crate::client::CloudTasks::list_queues
    /// [google.cloud.tasks.v2.ListQueuesRequest.page_token]: crate::model::ListQueuesRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQueuesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [queues][crate::model::ListQueuesResponse::queues].
    pub fn set_queues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Queue>,
    {
        use std::iter::Iterator;
        self.queues = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQueuesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQueuesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListQueuesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQueuesResponse {
    type PageItem = crate::model::Queue;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.queues
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQueuesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __queues,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQueuesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queues" => Ok(__FieldTag::__queues),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQueuesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQueuesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__queues => {
                            if !fields.insert(__FieldTag::__queues) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queues",
                                ));
                            }
                            result.queues = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Queue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQueuesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.queues.is_empty() {
            state.serialize_entry("queues", &self.queues)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListQueuesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListQueuesResponse");
        debug_struct.field("queues", &self.queues);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for [GetQueue][google.cloud.tasks.v2.CloudTasks.GetQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.GetQueue]: crate::client::CloudTasks::get_queue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetQueueRequest {
    /// Required. The resource name of the queue. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.GetQueueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetQueueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQueueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetQueueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQueueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetQueueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetQueueRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [CreateQueue][google.cloud.tasks.v2.CloudTasks.CreateQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.CreateQueue]: crate::client::CloudTasks::create_queue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateQueueRequest {
    /// Required. The location name in which the queue will be created.
    /// For example: `projects/PROJECT_ID/locations/LOCATION_ID`
    ///
    /// The list of allowed locations can be obtained by calling Cloud
    /// Tasks' implementation of
    /// [ListLocations][google.cloud.location.Locations.ListLocations].
    pub parent: std::string::String,

    /// Required. The queue to create.
    ///
    /// [Queue's name][google.cloud.tasks.v2.Queue.name] cannot be the same as an
    /// existing queue.
    ///
    /// [google.cloud.tasks.v2.Queue.name]: crate::model::Queue::name
    pub queue: std::option::Option<crate::model::Queue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQueueRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [queue][crate::model::CreateQueueRequest::queue].
    pub fn set_queue<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Queue>,
    {
        self.queue = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queue][crate::model::CreateQueueRequest::queue].
    pub fn set_or_clear_queue<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Queue>,
    {
        self.queue = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.CreateQueueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateQueueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __queue,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateQueueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "queue" => Ok(__FieldTag::__queue),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateQueueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateQueueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__queue => {
                            if !fields.insert(__FieldTag::__queue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queue",
                                ));
                            }
                            result.queue =
                                map.next_value::<std::option::Option<crate::model::Queue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateQueueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.queue.is_some() {
            state.serialize_entry("queue", &self.queue)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateQueueRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("queue", &self.queue);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [UpdateQueue][google.cloud.tasks.v2.CloudTasks.UpdateQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.UpdateQueue]: crate::client::CloudTasks::update_queue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateQueueRequest {
    /// Required. The queue to create or update.
    ///
    /// The queue's [name][google.cloud.tasks.v2.Queue.name] must be specified.
    ///
    /// Output only fields cannot be modified using UpdateQueue.
    /// Any value specified for an output only field will be ignored.
    /// The queue's [name][google.cloud.tasks.v2.Queue.name] cannot be changed.
    ///
    /// [google.cloud.tasks.v2.Queue.name]: crate::model::Queue::name
    pub queue: std::option::Option<crate::model::Queue>,

    /// A mask used to specify which fields of the queue are being updated.
    ///
    /// If empty, then all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [queue][crate::model::UpdateQueueRequest::queue].
    pub fn set_queue<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Queue>,
    {
        self.queue = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queue][crate::model::UpdateQueueRequest::queue].
    pub fn set_or_clear_queue<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Queue>,
    {
        self.queue = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateQueueRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateQueueRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.UpdateQueueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateQueueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __queue,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateQueueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queue" => Ok(__FieldTag::__queue),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateQueueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateQueueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__queue => {
                            if !fields.insert(__FieldTag::__queue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queue",
                                ));
                            }
                            result.queue =
                                map.next_value::<std::option::Option<crate::model::Queue>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateQueueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.queue.is_some() {
            state.serialize_entry("queue", &self.queue)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateQueueRequest");
        debug_struct.field("queue", &self.queue);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [DeleteQueue][google.cloud.tasks.v2.CloudTasks.DeleteQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.DeleteQueue]: crate::client::CloudTasks::delete_queue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.DeleteQueueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteQueueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteQueueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteQueueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteQueueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteQueueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteQueueRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [PurgeQueue][google.cloud.tasks.v2.CloudTasks.PurgeQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.PurgeQueue]: crate::client::CloudTasks::purge_queue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PurgeQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PurgeQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.PurgeQueueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeQueueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeQueueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeQueueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeQueueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeQueueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeQueueRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [PauseQueue][google.cloud.tasks.v2.CloudTasks.PauseQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.PauseQueue]: crate::client::CloudTasks::pause_queue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.PauseQueueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseQueueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseQueueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseQueueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseQueueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseQueueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PauseQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseQueueRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue].
///
/// [google.cloud.tasks.v2.CloudTasks.ResumeQueue]: crate::client::CloudTasks::resume_queue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeQueueRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/location/LOCATION_ID/queues/QUEUE_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeQueueRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeQueueRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeQueueRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ResumeQueueRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeQueueRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeQueueRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeQueueRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeQueueRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeQueueRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeQueueRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for listing tasks using
/// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks].
///
/// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTasksRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    pub parent: std::string::String,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::View::Basic
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::View::Full
    pub response_view: crate::model::task::View,

    /// Maximum page size.
    ///
    /// Fewer tasks than requested might be returned, even if more tasks exist; use
    /// [next_page_token][google.cloud.tasks.v2.ListTasksResponse.next_page_token]
    /// in the response to determine if more tasks exist.
    ///
    /// The maximum page size is 1000. If unspecified, the page size will be the
    /// maximum.
    ///
    /// [google.cloud.tasks.v2.ListTasksResponse.next_page_token]: crate::model::ListTasksResponse::next_page_token
    pub page_size: i32,

    /// A token identifying the page of results to return.
    ///
    /// To request the first page results, page_token must be empty. To
    /// request the next page of results, page_token must be the value of
    /// [next_page_token][google.cloud.tasks.v2.ListTasksResponse.next_page_token]
    /// returned from the previous call to
    /// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks] method.
    ///
    /// The page token is valid for only 2 hours.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
    /// [google.cloud.tasks.v2.ListTasksResponse.next_page_token]: crate::model::ListTasksResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [response_view][crate::model::ListTasksRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListTasksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTasksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __response_view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTasksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "responseView" => Ok(__FieldTag::__response_view),
                            "response_view" => Ok(__FieldTag::__response_view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTasksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTasksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_view => {
                            if !fields.insert(__FieldTag::__response_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_view",
                                ));
                            }
                            result.response_view = map
                                .next_value::<std::option::Option<crate::model::task::View>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTasksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.response_view) {
            state.serialize_entry("responseView", &self.response_view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTasksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTasksRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("response_view", &self.response_view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for listing tasks using
/// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks].
///
/// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTasksResponse {
    /// The list of tasks.
    pub tasks: std::vec::Vec<crate::model::Task>,

    /// A token to retrieve next page of results.
    ///
    /// To return the next page of results, call
    /// [ListTasks][google.cloud.tasks.v2.CloudTasks.ListTasks] with this value as
    /// the [page_token][google.cloud.tasks.v2.ListTasksRequest.page_token].
    ///
    /// If the next_page_token is empty, there are no more results.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.ListTasks]: crate::client::CloudTasks::list_tasks
    /// [google.cloud.tasks.v2.ListTasksRequest.page_token]: crate::model::ListTasksRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tasks][crate::model::ListTasksResponse::tasks].
    pub fn set_tasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Task>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.ListTasksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTasksResponse {
    type PageItem = crate::model::Task;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tasks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTasksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tasks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTasksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tasks" => Ok(__FieldTag::__tasks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTasksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTasksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tasks => {
                            if !fields.insert(__FieldTag::__tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tasks",
                                ));
                            }
                            result.tasks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Task>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTasksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tasks.is_empty() {
            state.serialize_entry("tasks", &self.tasks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTasksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTasksResponse");
        debug_struct.field("tasks", &self.tasks);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for getting a task using
/// [GetTask][google.cloud.tasks.v2.CloudTasks.GetTask].
///
/// [google.cloud.tasks.v2.CloudTasks.GetTask]: crate::client::CloudTasks::get_task
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTaskRequest {
    /// Required. The task name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    pub name: std::string::String,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::View::Basic
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::View::Full
    pub response_view: crate::model::task::View,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [response_view][crate::model::GetTaskRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }
}

impl wkt::message::Message for GetTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.GetTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __response_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "responseView" => Ok(__FieldTag::__response_view),
                            "response_view" => Ok(__FieldTag::__response_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_view => {
                            if !fields.insert(__FieldTag::__response_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_view",
                                ));
                            }
                            result.response_view = map
                                .next_value::<std::option::Option<crate::model::task::View>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.response_view) {
            state.serialize_entry("responseView", &self.response_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTaskRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTaskRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("response_view", &self.response_view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask].
///
/// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTaskRequest {
    /// Required. The queue name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    ///
    /// The queue must already exist.
    pub parent: std::string::String,

    /// Required. The task to add.
    ///
    /// Task names have the following format:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`.
    /// The user can optionally specify a task
    /// [name][google.cloud.tasks.v2.Task.name]. If a name is not specified then
    /// the system will generate a random unique task id, which will be set in the
    /// task returned in the [response][google.cloud.tasks.v2.Task.name].
    ///
    /// If [schedule_time][google.cloud.tasks.v2.Task.schedule_time] is not set or
    /// is in the past then Cloud Tasks will set it to the current time.
    ///
    /// Task De-duplication:
    ///
    /// Explicitly specifying a task ID enables task de-duplication.  If
    /// a task's ID is identical to that of an existing task or a task
    /// that was deleted or executed recently then the call will fail
    /// with [ALREADY_EXISTS][google.rpc.Code.ALREADY_EXISTS].
    /// If the task's queue was created using Cloud Tasks, then another task with
    /// the same name can't be created for ~1hour after the original task was
    /// deleted or executed. If the task's queue was created using queue.yaml or
    /// queue.xml, then another task with the same name can't be created
    /// for ~9days after the original task was deleted or executed.
    ///
    /// Because there is an extra lookup cost to identify duplicate task
    /// names, these [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask]
    /// calls have significantly increased latency. Using hashed strings for the
    /// task id or for the prefix of the task id is recommended. Choosing task ids
    /// that are sequential or have sequential prefixes, for example using a
    /// timestamp, causes an increase in latency and error rates in all
    /// task commands. The infrastructure relies on an approximately
    /// uniform distribution of task ids to store and serve tasks
    /// efficiently.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
    /// [google.cloud.tasks.v2.Task.name]: crate::model::Task::name
    /// [google.cloud.tasks.v2.Task.schedule_time]: crate::model::Task::schedule_time
    pub task: std::option::Option<crate::model::Task>,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::View::Basic
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::View::Full
    pub response_view: crate::model::task::View,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTaskRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [task][crate::model::CreateTaskRequest::task].
    pub fn set_task<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Task>,
    {
        self.task = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [task][crate::model::CreateTaskRequest::task].
    pub fn set_or_clear_task<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Task>,
    {
        self.task = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response_view][crate::model::CreateTaskRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }
}

impl wkt::message::Message for CreateTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.CreateTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __task,
            __response_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "task" => Ok(__FieldTag::__task),
                            "responseView" => Ok(__FieldTag::__response_view),
                            "response_view" => Ok(__FieldTag::__response_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__task => {
                            if !fields.insert(__FieldTag::__task) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task",
                                ));
                            }
                            result.task =
                                map.next_value::<std::option::Option<crate::model::Task>>()?;
                        }
                        __FieldTag::__response_view => {
                            if !fields.insert(__FieldTag::__response_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_view",
                                ));
                            }
                            result.response_view = map
                                .next_value::<std::option::Option<crate::model::task::View>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.task.is_some() {
            state.serialize_entry("task", &self.task)?;
        }
        if !wkt::internal::is_default(&self.response_view) {
            state.serialize_entry("responseView", &self.response_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTaskRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTaskRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("task", &self.task);
        debug_struct.field("response_view", &self.response_view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for deleting a task using
/// [DeleteTask][google.cloud.tasks.v2.CloudTasks.DeleteTask].
///
/// [google.cloud.tasks.v2.CloudTasks.DeleteTask]: crate::client::CloudTasks::delete_task
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTaskRequest {
    /// Required. The task name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.DeleteTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTaskRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTaskRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for forcing a task to run now using
/// [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask].
///
/// [google.cloud.tasks.v2.CloudTasks.RunTask]: crate::client::CloudTasks::run_task
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunTaskRequest {
    /// Required. The task name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    pub name: std::string::String,

    /// The response_view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] will be returned.
    ///
    /// By default response_view is [BASIC][google.cloud.tasks.v2.Task.View.BASIC];
    /// not all information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
    /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
    /// permission on the [Task][google.cloud.tasks.v2.Task] resource.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    /// [google.cloud.tasks.v2.Task.View.BASIC]: crate::model::task::View::Basic
    /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::View::Full
    pub response_view: crate::model::task::View,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [response_view][crate::model::RunTaskRequest::response_view].
    pub fn set_response_view<T: std::convert::Into<crate::model::task::View>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_view = v.into();
        self
    }
}

impl wkt::message::Message for RunTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.RunTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __response_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "responseView" => Ok(__FieldTag::__response_view),
                            "response_view" => Ok(__FieldTag::__response_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_view => {
                            if !fields.insert(__FieldTag::__response_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_view",
                                ));
                            }
                            result.response_view = map
                                .next_value::<std::option::Option<crate::model::task::View>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.response_view) {
            state.serialize_entry("responseView", &self.response_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunTaskRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunTaskRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("response_view", &self.response_view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A queue is a container of related tasks. Queues are configured to manage
/// how those tasks are dispatched. Configurable properties include rate limits,
/// retry options, queue types, and others.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Queue {
    /// Caller-specified and required in
    /// [CreateQueue][google.cloud.tasks.v2.CloudTasks.CreateQueue], after which it
    /// becomes output only.
    ///
    /// The queue name.
    ///
    /// The queue name must have the following format:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
    ///
    /// * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), colons (:), or periods (.).
    ///   For more information, see
    ///   [Identifying
    ///   projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
    /// * `LOCATION_ID` is the canonical ID for the queue's location.
    ///   The list of available locations can be obtained by calling
    ///   [ListLocations][google.cloud.location.Locations.ListLocations].
    ///   For more information, see <https://cloud.google.com/about/locations/>.
    /// * `QUEUE_ID` can contain letters ([A-Za-z]), numbers ([0-9]), or
    ///   hyphens (-). The maximum length is 100 characters.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.CreateQueue]: crate::client::CloudTasks::create_queue
    pub name: std::string::String,

    /// Overrides for
    /// [task-level
    /// app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
    /// These settings apply only to
    /// [App Engine tasks][google.cloud.tasks.v2.AppEngineHttpRequest] in this
    /// queue. [Http tasks][google.cloud.tasks.v2.HttpRequest] are not affected.
    ///
    /// If set, `app_engine_routing_override` is used for all
    /// [App Engine tasks][google.cloud.tasks.v2.AppEngineHttpRequest] in the
    /// queue, no matter what the setting is for the [task-level
    /// app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
    /// [google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing]: crate::model::AppEngineHttpRequest::app_engine_routing
    /// [google.cloud.tasks.v2.HttpRequest]: crate::model::HttpRequest
    pub app_engine_routing_override: std::option::Option<crate::model::AppEngineRouting>,

    /// Rate limits for task dispatches.
    ///
    /// [rate_limits][google.cloud.tasks.v2.Queue.rate_limits] and
    /// [retry_config][google.cloud.tasks.v2.Queue.retry_config] are related
    /// because they both control task attempts. However they control task attempts
    /// in different ways:
    ///
    /// * [rate_limits][google.cloud.tasks.v2.Queue.rate_limits] controls the total
    ///   rate of
    ///   dispatches from a queue (i.e. all traffic dispatched from the
    ///   queue, regardless of whether the dispatch is from a first
    ///   attempt or a retry).
    /// * [retry_config][google.cloud.tasks.v2.Queue.retry_config] controls what
    ///   happens to
    ///   particular a task after its first attempt fails. That is,
    ///   [retry_config][google.cloud.tasks.v2.Queue.retry_config] controls task
    ///   retries (the second attempt, third attempt, etc).
    ///
    /// The queue's actual dispatch rate is the result of:
    ///
    /// * Number of tasks in the queue
    /// * User-specified throttling:
    ///   [rate_limits][google.cloud.tasks.v2.Queue.rate_limits],
    ///   [retry_config][google.cloud.tasks.v2.Queue.retry_config], and the
    ///   [queue's state][google.cloud.tasks.v2.Queue.state].
    /// * System throttling due to `429` (Too Many Requests) or `503` (Service
    ///   Unavailable) responses from the worker, high error rates, or to smooth
    ///   sudden large traffic spikes.
    ///
    /// [google.cloud.tasks.v2.Queue.rate_limits]: crate::model::Queue::rate_limits
    /// [google.cloud.tasks.v2.Queue.retry_config]: crate::model::Queue::retry_config
    /// [google.cloud.tasks.v2.Queue.state]: crate::model::Queue::state
    pub rate_limits: std::option::Option<crate::model::RateLimits>,

    /// Settings that determine the retry behavior.
    ///
    /// * For tasks created using Cloud Tasks: the queue-level retry settings
    ///   apply to all tasks in the queue that were created using Cloud Tasks.
    ///   Retry settings cannot be set on individual tasks.
    /// * For tasks created using the App Engine SDK: the queue-level retry
    ///   settings apply to all tasks in the queue which do not have retry settings
    ///   explicitly set on the task and were created by the App Engine SDK. See
    ///   [App Engine
    ///   documentation](https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/retrying-tasks).
    pub retry_config: std::option::Option<crate::model::RetryConfig>,

    /// Output only. The state of the queue.
    ///
    /// `state` can only be changed by calling
    /// [PauseQueue][google.cloud.tasks.v2.CloudTasks.PauseQueue],
    /// [ResumeQueue][google.cloud.tasks.v2.CloudTasks.ResumeQueue], or uploading
    /// [queue.yaml/xml](https://cloud.google.com/appengine/docs/python/config/queueref).
    /// [UpdateQueue][google.cloud.tasks.v2.CloudTasks.UpdateQueue] cannot be used
    /// to change `state`.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.PauseQueue]: crate::client::CloudTasks::pause_queue
    /// [google.cloud.tasks.v2.CloudTasks.ResumeQueue]: crate::client::CloudTasks::resume_queue
    /// [google.cloud.tasks.v2.CloudTasks.UpdateQueue]: crate::client::CloudTasks::update_queue
    pub state: crate::model::queue::State,

    /// Output only. The last time this queue was purged.
    ///
    /// All tasks that were [created][google.cloud.tasks.v2.Task.create_time]
    /// before this time were purged.
    ///
    /// A queue can be purged using
    /// [PurgeQueue][google.cloud.tasks.v2.CloudTasks.PurgeQueue], the [App Engine
    /// Task Queue SDK, or the Cloud
    /// Console](https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/deleting-tasks-and-queues#purging_all_tasks_from_a_queue).
    ///
    /// Purge time will be truncated to the nearest microsecond. Purge
    /// time will be unset if the queue has never been purged.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.PurgeQueue]: crate::client::CloudTasks::purge_queue
    /// [google.cloud.tasks.v2.Task.create_time]: crate::model::Task::create_time
    pub purge_time: std::option::Option<wkt::Timestamp>,

    /// Configuration options for writing logs to
    /// [Stackdriver Logging](https://cloud.google.com/logging/docs/). If this
    /// field is unset, then no logs are written.
    pub stackdriver_logging_config: std::option::Option<crate::model::StackdriverLoggingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Queue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Queue::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [app_engine_routing_override][crate::model::Queue::app_engine_routing_override].
    pub fn set_app_engine_routing_override<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppEngineRouting>,
    {
        self.app_engine_routing_override = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_engine_routing_override][crate::model::Queue::app_engine_routing_override].
    pub fn set_or_clear_app_engine_routing_override<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppEngineRouting>,
    {
        self.app_engine_routing_override = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rate_limits][crate::model::Queue::rate_limits].
    pub fn set_rate_limits<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RateLimits>,
    {
        self.rate_limits = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rate_limits][crate::model::Queue::rate_limits].
    pub fn set_or_clear_rate_limits<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RateLimits>,
    {
        self.rate_limits = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retry_config][crate::model::Queue::retry_config].
    pub fn set_retry_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RetryConfig>,
    {
        self.retry_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retry_config][crate::model::Queue::retry_config].
    pub fn set_or_clear_retry_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RetryConfig>,
    {
        self.retry_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Queue::state].
    pub fn set_state<T: std::convert::Into<crate::model::queue::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [purge_time][crate::model::Queue::purge_time].
    pub fn set_purge_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.purge_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [purge_time][crate::model::Queue::purge_time].
    pub fn set_or_clear_purge_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.purge_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stackdriver_logging_config][crate::model::Queue::stackdriver_logging_config].
    pub fn set_stackdriver_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StackdriverLoggingConfig>,
    {
        self.stackdriver_logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stackdriver_logging_config][crate::model::Queue::stackdriver_logging_config].
    pub fn set_or_clear_stackdriver_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StackdriverLoggingConfig>,
    {
        self.stackdriver_logging_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Queue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.Queue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Queue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __app_engine_routing_override,
            __rate_limits,
            __retry_config,
            __state,
            __purge_time,
            __stackdriver_logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Queue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "appEngineRoutingOverride" => {
                                Ok(__FieldTag::__app_engine_routing_override)
                            }
                            "app_engine_routing_override" => {
                                Ok(__FieldTag::__app_engine_routing_override)
                            }
                            "rateLimits" => Ok(__FieldTag::__rate_limits),
                            "rate_limits" => Ok(__FieldTag::__rate_limits),
                            "retryConfig" => Ok(__FieldTag::__retry_config),
                            "retry_config" => Ok(__FieldTag::__retry_config),
                            "state" => Ok(__FieldTag::__state),
                            "purgeTime" => Ok(__FieldTag::__purge_time),
                            "purge_time" => Ok(__FieldTag::__purge_time),
                            "stackdriverLoggingConfig" => {
                                Ok(__FieldTag::__stackdriver_logging_config)
                            }
                            "stackdriver_logging_config" => {
                                Ok(__FieldTag::__stackdriver_logging_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Queue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Queue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_engine_routing_override => {
                            if !fields.insert(__FieldTag::__app_engine_routing_override) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_routing_override",
                                ));
                            }
                            result.app_engine_routing_override = map
                                .next_value::<std::option::Option<crate::model::AppEngineRouting>>(
                                )?;
                        }
                        __FieldTag::__rate_limits => {
                            if !fields.insert(__FieldTag::__rate_limits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rate_limits",
                                ));
                            }
                            result.rate_limits =
                                map.next_value::<std::option::Option<crate::model::RateLimits>>()?;
                        }
                        __FieldTag::__retry_config => {
                            if !fields.insert(__FieldTag::__retry_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_config",
                                ));
                            }
                            result.retry_config =
                                map.next_value::<std::option::Option<crate::model::RetryConfig>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::queue::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__purge_time => {
                            if !fields.insert(__FieldTag::__purge_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for purge_time",
                                ));
                            }
                            result.purge_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__stackdriver_logging_config => {
                            if !fields.insert(__FieldTag::__stackdriver_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stackdriver_logging_config",
                                ));
                            }
                            result.stackdriver_logging_config = map.next_value::<std::option::Option<crate::model::StackdriverLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Queue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.app_engine_routing_override.is_some() {
            state.serialize_entry(
                "appEngineRoutingOverride",
                &self.app_engine_routing_override,
            )?;
        }
        if self.rate_limits.is_some() {
            state.serialize_entry("rateLimits", &self.rate_limits)?;
        }
        if self.retry_config.is_some() {
            state.serialize_entry("retryConfig", &self.retry_config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.purge_time.is_some() {
            state.serialize_entry("purgeTime", &self.purge_time)?;
        }
        if self.stackdriver_logging_config.is_some() {
            state.serialize_entry("stackdriverLoggingConfig", &self.stackdriver_logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Queue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Queue");
        debug_struct.field("name", &self.name);
        debug_struct.field(
            "app_engine_routing_override",
            &self.app_engine_routing_override,
        );
        debug_struct.field("rate_limits", &self.rate_limits);
        debug_struct.field("retry_config", &self.retry_config);
        debug_struct.field("state", &self.state);
        debug_struct.field("purge_time", &self.purge_time);
        debug_struct.field(
            "stackdriver_logging_config",
            &self.stackdriver_logging_config,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Queue].
pub mod queue {
    #[allow(unused_imports)]
    use super::*;

    /// State of the queue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// The queue is running. Tasks can be dispatched.
        ///
        /// If the queue was created using Cloud Tasks and the queue has
        /// had no activity (method calls or task dispatches) for 30 days,
        /// the queue may take a few minutes to re-activate. Some method
        /// calls may return [NOT_FOUND][google.rpc.Code.NOT_FOUND] and
        /// tasks may not be dispatched for a few minutes until the queue
        /// has been re-activated.
        Running,
        /// Tasks are paused by the user. If the queue is paused then Cloud
        /// Tasks will stop delivering tasks from it, but more tasks can
        /// still be added to it by the user.
        Paused,
        /// The queue is disabled.
        ///
        /// A queue becomes `DISABLED` when
        /// [queue.yaml](https://cloud.google.com/appengine/docs/python/config/queueref)
        /// or
        /// [queue.xml](https://cloud.google.com/appengine/docs/standard/java/config/queueref)
        /// is uploaded which does not contain the queue. You cannot directly disable
        /// a queue.
        ///
        /// When a queue is disabled, tasks can still be added to a queue
        /// but the tasks are not dispatched.
        ///
        /// To permanently delete this queue and all of its tasks, call
        /// [DeleteQueue][google.cloud.tasks.v2.CloudTasks.DeleteQueue].
        ///
        /// [google.cloud.tasks.v2.CloudTasks.DeleteQueue]: crate::client::CloudTasks::delete_queue
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Disabled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Paused,
                3 => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Disabled => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.tasks.v2.Queue.State",
            ))
        }
    }
}

/// Rate limits.
///
/// This message determines the maximum rate that tasks can be dispatched by a
/// queue, regardless of whether the dispatch is a first task attempt or a retry.
///
/// Note: The debugging command,
/// [RunTask][google.cloud.tasks.v2.CloudTasks.RunTask], will run a task even if
/// the queue has reached its [RateLimits][google.cloud.tasks.v2.RateLimits].
///
/// [google.cloud.tasks.v2.CloudTasks.RunTask]: crate::client::CloudTasks::run_task
/// [google.cloud.tasks.v2.RateLimits]: crate::model::RateLimits
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RateLimits {
    /// The maximum rate at which tasks are dispatched from this queue.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// * The maximum allowed value is 500.
    ///
    /// This field has the same meaning as
    /// [rate in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#rate).
    pub max_dispatches_per_second: f64,

    /// Output only. The max burst size.
    ///
    /// Max burst size limits how fast tasks in queue are processed when
    /// many tasks are in the queue and the rate is high. This field
    /// allows the queue to have a high rate so processing starts shortly
    /// after a task is enqueued, but still limits resource usage when
    /// many tasks are enqueued in a short period of time.
    ///
    /// The [token bucket](https://wikipedia.org/wiki/Token_Bucket)
    /// algorithm is used to control the rate of task dispatches. Each
    /// queue has a token bucket that holds tokens, up to the maximum
    /// specified by `max_burst_size`. Each time a task is dispatched, a
    /// token is removed from the bucket. Tasks will be dispatched until
    /// the queue's bucket runs out of tokens. The bucket will be
    /// continuously refilled with new tokens based on
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second].
    ///
    /// Cloud Tasks will pick the value of `max_burst_size` based on the
    /// value of
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second].
    ///
    /// For queues that were created or updated using
    /// `queue.yaml/xml`, `max_burst_size` is equal to
    /// [bucket_size](https://cloud.google.com/appengine/docs/standard/python/config/queueref#bucket_size).
    /// Since `max_burst_size` is output only, if
    /// [UpdateQueue][google.cloud.tasks.v2.CloudTasks.UpdateQueue] is called on a
    /// queue created by `queue.yaml/xml`, `max_burst_size` will be reset based on
    /// the value of
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second],
    /// regardless of whether
    /// [max_dispatches_per_second][google.cloud.tasks.v2.RateLimits.max_dispatches_per_second]
    /// is updated.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.UpdateQueue]: crate::client::CloudTasks::update_queue
    /// [google.cloud.tasks.v2.RateLimits.max_dispatches_per_second]: crate::model::RateLimits::max_dispatches_per_second
    pub max_burst_size: i32,

    /// The maximum number of concurrent tasks that Cloud Tasks allows
    /// to be dispatched for this queue. After this threshold has been
    /// reached, Cloud Tasks stops dispatching tasks until the number of
    /// concurrent requests decreases.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// The maximum allowed value is 5,000.
    ///
    /// This field has the same meaning as
    /// [max_concurrent_requests in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#max_concurrent_requests).
    pub max_concurrent_dispatches: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RateLimits {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_dispatches_per_second][crate::model::RateLimits::max_dispatches_per_second].
    pub fn set_max_dispatches_per_second<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max_dispatches_per_second = v.into();
        self
    }

    /// Sets the value of [max_burst_size][crate::model::RateLimits::max_burst_size].
    pub fn set_max_burst_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_burst_size = v.into();
        self
    }

    /// Sets the value of [max_concurrent_dispatches][crate::model::RateLimits::max_concurrent_dispatches].
    pub fn set_max_concurrent_dispatches<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_concurrent_dispatches = v.into();
        self
    }
}

impl wkt::message::Message for RateLimits {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.RateLimits"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RateLimits {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_dispatches_per_second,
            __max_burst_size,
            __max_concurrent_dispatches,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RateLimits")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxDispatchesPerSecond" => Ok(__FieldTag::__max_dispatches_per_second),
                            "max_dispatches_per_second" => {
                                Ok(__FieldTag::__max_dispatches_per_second)
                            }
                            "maxBurstSize" => Ok(__FieldTag::__max_burst_size),
                            "max_burst_size" => Ok(__FieldTag::__max_burst_size),
                            "maxConcurrentDispatches" => {
                                Ok(__FieldTag::__max_concurrent_dispatches)
                            }
                            "max_concurrent_dispatches" => {
                                Ok(__FieldTag::__max_concurrent_dispatches)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RateLimits;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RateLimits")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_dispatches_per_second => {
                            if !fields.insert(__FieldTag::__max_dispatches_per_second) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_dispatches_per_second",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_dispatches_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_burst_size => {
                            if !fields.insert(__FieldTag::__max_burst_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_burst_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_burst_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_concurrent_dispatches => {
                            if !fields.insert(__FieldTag::__max_concurrent_dispatches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_concurrent_dispatches",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_concurrent_dispatches =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RateLimits {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_dispatches_per_second) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxDispatchesPerSecond",
                &__With(&self.max_dispatches_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.max_burst_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxBurstSize", &__With(&self.max_burst_size))?;
        }
        if !wkt::internal::is_default(&self.max_concurrent_dispatches) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxConcurrentDispatches",
                &__With(&self.max_concurrent_dispatches),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RateLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RateLimits");
        debug_struct.field("max_dispatches_per_second", &self.max_dispatches_per_second);
        debug_struct.field("max_burst_size", &self.max_burst_size);
        debug_struct.field("max_concurrent_dispatches", &self.max_concurrent_dispatches);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Retry config.
///
/// These settings determine when a failed task attempt is retried.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryConfig {
    /// Number of attempts per task.
    ///
    /// Cloud Tasks will attempt the task `max_attempts` times (that is, if the
    /// first attempt fails, then there will be `max_attempts - 1` retries). Must
    /// be >= -1.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// -1 indicates unlimited attempts.
    ///
    /// This field has the same meaning as
    /// [task_retry_limit in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    pub max_attempts: i32,

    /// If positive, `max_retry_duration` specifies the time limit for
    /// retrying a failed task, measured from when the task was first
    /// attempted. Once `max_retry_duration` time has passed *and* the
    /// task has been attempted
    /// [max_attempts][google.cloud.tasks.v2.RetryConfig.max_attempts] times, no
    /// further attempts will be made and the task will be deleted.
    ///
    /// If zero, then the task age is unlimited.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// `max_retry_duration` will be truncated to the nearest second.
    ///
    /// This field has the same meaning as
    /// [task_age_limit in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig.max_attempts]: crate::model::RetryConfig::max_attempts
    pub max_retry_duration: std::option::Option<wkt::Duration>,

    /// A task will be [scheduled][google.cloud.tasks.v2.Task.schedule_time] for
    /// retry between [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff]
    /// and [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] duration
    /// after it fails, if the queue's
    /// [RetryConfig][google.cloud.tasks.v2.RetryConfig] specifies that the task
    /// should be retried.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// `min_backoff` will be truncated to the nearest second.
    ///
    /// This field has the same meaning as
    /// [min_backoff_seconds in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig]: crate::model::RetryConfig
    /// [google.cloud.tasks.v2.RetryConfig.max_backoff]: crate::model::RetryConfig::max_backoff
    /// [google.cloud.tasks.v2.RetryConfig.min_backoff]: crate::model::RetryConfig::min_backoff
    /// [google.cloud.tasks.v2.Task.schedule_time]: crate::model::Task::schedule_time
    pub min_backoff: std::option::Option<wkt::Duration>,

    /// A task will be [scheduled][google.cloud.tasks.v2.Task.schedule_time] for
    /// retry between [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff]
    /// and [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] duration
    /// after it fails, if the queue's
    /// [RetryConfig][google.cloud.tasks.v2.RetryConfig] specifies that the task
    /// should be retried.
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// `max_backoff` will be truncated to the nearest second.
    ///
    /// This field has the same meaning as
    /// [max_backoff_seconds in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig]: crate::model::RetryConfig
    /// [google.cloud.tasks.v2.RetryConfig.max_backoff]: crate::model::RetryConfig::max_backoff
    /// [google.cloud.tasks.v2.RetryConfig.min_backoff]: crate::model::RetryConfig::min_backoff
    /// [google.cloud.tasks.v2.Task.schedule_time]: crate::model::Task::schedule_time
    pub max_backoff: std::option::Option<wkt::Duration>,

    /// The time between retries will double `max_doublings` times.
    ///
    /// A task's retry interval starts at
    /// [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff], then doubles
    /// `max_doublings` times, then increases linearly, and finally
    /// retries at intervals of
    /// [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] up to
    /// [max_attempts][google.cloud.tasks.v2.RetryConfig.max_attempts] times.
    ///
    /// For example, if
    /// [min_backoff][google.cloud.tasks.v2.RetryConfig.min_backoff] is 10s,
    /// [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff] is 300s, and
    /// `max_doublings` is 3, then the a task will first be retried in
    /// 10s. The retry interval will double three times, and then
    /// increase linearly by 2^3 * 10s.  Finally, the task will retry at
    /// intervals of [max_backoff][google.cloud.tasks.v2.RetryConfig.max_backoff]
    /// until the task has been attempted
    /// [max_attempts][google.cloud.tasks.v2.RetryConfig.max_attempts] times. Thus,
    /// the requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s, 300s, ....
    ///
    /// If unspecified when the queue is created, Cloud Tasks will pick the
    /// default.
    ///
    /// This field has the same meaning as
    /// [max_doublings in
    /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
    ///
    /// [google.cloud.tasks.v2.RetryConfig.max_attempts]: crate::model::RetryConfig::max_attempts
    /// [google.cloud.tasks.v2.RetryConfig.max_backoff]: crate::model::RetryConfig::max_backoff
    /// [google.cloud.tasks.v2.RetryConfig.min_backoff]: crate::model::RetryConfig::min_backoff
    pub max_doublings: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_attempts][crate::model::RetryConfig::max_attempts].
    pub fn set_max_attempts<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_attempts = v.into();
        self
    }

    /// Sets the value of [max_retry_duration][crate::model::RetryConfig::max_retry_duration].
    pub fn set_max_retry_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_retry_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_retry_duration][crate::model::RetryConfig::max_retry_duration].
    pub fn set_or_clear_max_retry_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_retry_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_backoff][crate::model::RetryConfig::min_backoff].
    pub fn set_min_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_backoff][crate::model::RetryConfig::min_backoff].
    pub fn set_or_clear_min_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_backoff = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_backoff][crate::model::RetryConfig::max_backoff].
    pub fn set_max_backoff<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_backoff = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_backoff][crate::model::RetryConfig::max_backoff].
    pub fn set_or_clear_max_backoff<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_backoff = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_doublings][crate::model::RetryConfig::max_doublings].
    pub fn set_max_doublings<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_doublings = v.into();
        self
    }
}

impl wkt::message::Message for RetryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.RetryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_attempts,
            __max_retry_duration,
            __min_backoff,
            __max_backoff,
            __max_doublings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxAttempts" => Ok(__FieldTag::__max_attempts),
                            "max_attempts" => Ok(__FieldTag::__max_attempts),
                            "maxRetryDuration" => Ok(__FieldTag::__max_retry_duration),
                            "max_retry_duration" => Ok(__FieldTag::__max_retry_duration),
                            "minBackoff" => Ok(__FieldTag::__min_backoff),
                            "min_backoff" => Ok(__FieldTag::__min_backoff),
                            "maxBackoff" => Ok(__FieldTag::__max_backoff),
                            "max_backoff" => Ok(__FieldTag::__max_backoff),
                            "maxDoublings" => Ok(__FieldTag::__max_doublings),
                            "max_doublings" => Ok(__FieldTag::__max_doublings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_attempts => {
                            if !fields.insert(__FieldTag::__max_attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_attempts",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_attempts = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_retry_duration => {
                            if !fields.insert(__FieldTag::__max_retry_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_retry_duration",
                                ));
                            }
                            result.max_retry_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__min_backoff => {
                            if !fields.insert(__FieldTag::__min_backoff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_backoff",
                                ));
                            }
                            result.min_backoff =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_backoff => {
                            if !fields.insert(__FieldTag::__max_backoff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_backoff",
                                ));
                            }
                            result.max_backoff =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_doublings => {
                            if !fields.insert(__FieldTag::__max_doublings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_doublings",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_doublings =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_attempts) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxAttempts", &__With(&self.max_attempts))?;
        }
        if self.max_retry_duration.is_some() {
            state.serialize_entry("maxRetryDuration", &self.max_retry_duration)?;
        }
        if self.min_backoff.is_some() {
            state.serialize_entry("minBackoff", &self.min_backoff)?;
        }
        if self.max_backoff.is_some() {
            state.serialize_entry("maxBackoff", &self.max_backoff)?;
        }
        if !wkt::internal::is_default(&self.max_doublings) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxDoublings", &__With(&self.max_doublings))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RetryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RetryConfig");
        debug_struct.field("max_attempts", &self.max_attempts);
        debug_struct.field("max_retry_duration", &self.max_retry_duration);
        debug_struct.field("min_backoff", &self.min_backoff);
        debug_struct.field("max_backoff", &self.max_backoff);
        debug_struct.field("max_doublings", &self.max_doublings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for writing logs to
/// [Stackdriver Logging](https://cloud.google.com/logging/docs/).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StackdriverLoggingConfig {
    /// Specifies the fraction of operations to write to
    /// [Stackdriver Logging](https://cloud.google.com/logging/docs/).
    /// This field may contain any value between 0.0 and 1.0, inclusive.
    /// 0.0 is the default and means that no operations are logged.
    pub sampling_ratio: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StackdriverLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sampling_ratio][crate::model::StackdriverLoggingConfig::sampling_ratio].
    pub fn set_sampling_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.sampling_ratio = v.into();
        self
    }
}

impl wkt::message::Message for StackdriverLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.StackdriverLoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StackdriverLoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sampling_ratio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StackdriverLoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "samplingRatio" => Ok(__FieldTag::__sampling_ratio),
                            "sampling_ratio" => Ok(__FieldTag::__sampling_ratio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StackdriverLoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StackdriverLoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sampling_ratio => {
                            if !fields.insert(__FieldTag::__sampling_ratio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sampling_ratio",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sampling_ratio =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StackdriverLoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.sampling_ratio) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("samplingRatio", &__With(&self.sampling_ratio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StackdriverLoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StackdriverLoggingConfig");
        debug_struct.field("sampling_ratio", &self.sampling_ratio);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// HTTP request.
///
/// The task will be pushed to the worker as an HTTP request. If the worker
/// or the redirected worker acknowledges the task by returning a successful HTTP
/// response code ([`200` - `299`]), the task will be removed from the queue. If
/// any other HTTP response code is returned or no response is received, the
/// task will be retried according to the following:
///
/// * User-specified throttling: [retry
///   configuration][google.cloud.tasks.v2.Queue.retry_config],
///   [rate limits][google.cloud.tasks.v2.Queue.rate_limits], and the [queue's
///   state][google.cloud.tasks.v2.Queue.state].
///
/// * System throttling: To prevent the worker from overloading, Cloud Tasks may
///   temporarily reduce the queue's effective rate. User-specified settings
///   will not be changed.
///
///
/// System throttling happens because:
///
/// * Cloud Tasks backs off on all errors. Normally the backoff specified in
///   [rate limits][google.cloud.tasks.v2.Queue.rate_limits] will be used. But
///   if the worker returns `429` (Too Many Requests), `503` (Service
///   Unavailable), or the rate of errors is high, Cloud Tasks will use a
///   higher backoff rate. The retry specified in the `Retry-After` HTTP
///   response header is considered.
///
/// * To prevent traffic spikes and to smooth sudden increases in traffic,
///   dispatches ramp up slowly when the queue is newly created or idle and
///   if large numbers of tasks suddenly become available to dispatch (due to
///   spikes in create task rates, the queue being unpaused, or many tasks
///   that are scheduled at the same time).
///
///
/// [google.cloud.tasks.v2.Queue.rate_limits]: crate::model::Queue::rate_limits
/// [google.cloud.tasks.v2.Queue.retry_config]: crate::model::Queue::retry_config
/// [google.cloud.tasks.v2.Queue.state]: crate::model::Queue::state
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpRequest {
    /// Required. The full url path that the request will be sent to.
    ///
    /// This string must begin with either "http://" or "https://". Some examples
    /// are: `<http://acme.com>` and `<https://acme.com/sales:8080>`. Cloud Tasks will
    /// encode some characters for safety and compatibility. The maximum allowed
    /// URL length is 2083 characters after encoding.
    ///
    /// The `Location` header response from a redirect response [`300` - `399`]
    /// may be followed. The redirect is not counted as a separate attempt.
    pub url: std::string::String,

    /// The HTTP method to use for the request. The default is POST.
    pub http_method: crate::model::HttpMethod,

    /// HTTP request headers.
    ///
    /// This map contains the header field names and values.
    /// Headers can be set when the
    /// [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
    ///
    /// These headers represent a subset of the headers that will accompany the
    /// task's HTTP request. Some HTTP request headers will be ignored or replaced.
    ///
    /// A partial list of headers that will be ignored or replaced is:
    ///
    /// * Host: This will be computed by Cloud Tasks and derived from
    ///   [HttpRequest.url][google.cloud.tasks.v2.HttpRequest.url].
    /// * Content-Length: This will be computed by Cloud Tasks.
    /// * User-Agent: This will be set to `"Google-Cloud-Tasks"`.
    /// * `X-Google-*`: Google use only.
    /// * `X-AppEngine-*`: Google use only.
    ///
    /// `Content-Type` won't be set by Cloud Tasks. You can explicitly set
    /// `Content-Type` to a media type when the
    /// [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
    /// For example, `Content-Type` can be set to `"application/octet-stream"` or
    /// `"application/json"`.
    ///
    /// Headers which can have multiple values (according to RFC2616) can be
    /// specified using comma-separated values.
    ///
    /// The size of the headers must be less than 80KB.
    ///
    /// [google.cloud.tasks.v2.HttpRequest.url]: crate::model::HttpRequest::url
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// HTTP request body.
    ///
    /// A request body is allowed only if the
    /// [HTTP method][google.cloud.tasks.v2.HttpRequest.http_method] is POST, PUT,
    /// or PATCH. It is an error to set body on a task with an incompatible
    /// [HttpMethod][google.cloud.tasks.v2.HttpMethod].
    ///
    /// [google.cloud.tasks.v2.HttpMethod]: crate::model::HttpMethod
    /// [google.cloud.tasks.v2.HttpRequest.http_method]: crate::model::HttpRequest::http_method
    pub body: ::bytes::Bytes,

    /// The mode for generating an `Authorization` header for HTTP requests.
    ///
    /// If specified, all `Authorization` headers in the
    /// [HttpRequest.headers][google.cloud.tasks.v2.HttpRequest.headers] field will
    /// be overridden.
    ///
    /// [google.cloud.tasks.v2.HttpRequest.headers]: crate::model::HttpRequest::headers
    pub authorization_header: std::option::Option<crate::model::http_request::AuthorizationHeader>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [url][crate::model::HttpRequest::url].
    pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.url = v.into();
        self
    }

    /// Sets the value of [http_method][crate::model::HttpRequest::http_method].
    pub fn set_http_method<T: std::convert::Into<crate::model::HttpMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpRequest::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [body][crate::model::HttpRequest::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [authorization_header][crate::model::HttpRequest::authorization_header].
    ///
    /// Note that all the setters affecting `authorization_header` are mutually
    /// exclusive.
    pub fn set_authorization_header<
        T: std::convert::Into<std::option::Option<crate::model::http_request::AuthorizationHeader>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = v.into();
        self
    }

    /// The value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// if it holds a `OauthToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth_token(&self) -> std::option::Option<&std::boxed::Box<crate::model::OAuthToken>> {
        #[allow(unreachable_patterns)]
        self.authorization_header.as_ref().and_then(|v| match v {
            crate::model::http_request::AuthorizationHeader::OauthToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// to hold a `OauthToken`.
    ///
    /// Note that all the setters affecting `authorization_header` are
    /// mutually exclusive.
    pub fn set_oauth_token<T: std::convert::Into<std::boxed::Box<crate::model::OAuthToken>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = std::option::Option::Some(
            crate::model::http_request::AuthorizationHeader::OauthToken(v.into()),
        );
        self
    }

    /// The value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// if it holds a `OidcToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oidc_token(&self) -> std::option::Option<&std::boxed::Box<crate::model::OidcToken>> {
        #[allow(unreachable_patterns)]
        self.authorization_header.as_ref().and_then(|v| match v {
            crate::model::http_request::AuthorizationHeader::OidcToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authorization_header][crate::model::HttpRequest::authorization_header]
    /// to hold a `OidcToken`.
    ///
    /// Note that all the setters affecting `authorization_header` are
    /// mutually exclusive.
    pub fn set_oidc_token<T: std::convert::Into<std::boxed::Box<crate::model::OidcToken>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = std::option::Option::Some(
            crate::model::http_request::AuthorizationHeader::OidcToken(v.into()),
        );
        self
    }
}

impl wkt::message::Message for HttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.HttpRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __url,
            __http_method,
            __headers,
            __body,
            __oauth_token,
            __oidc_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "url" => Ok(__FieldTag::__url),
                            "httpMethod" => Ok(__FieldTag::__http_method),
                            "http_method" => Ok(__FieldTag::__http_method),
                            "headers" => Ok(__FieldTag::__headers),
                            "body" => Ok(__FieldTag::__body),
                            "oauthToken" => Ok(__FieldTag::__oauth_token),
                            "oauth_token" => Ok(__FieldTag::__oauth_token),
                            "oidcToken" => Ok(__FieldTag::__oidc_token),
                            "oidc_token" => Ok(__FieldTag::__oidc_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__url => {
                            if !fields.insert(__FieldTag::__url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for url",
                                ));
                            }
                            result.url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__http_method => {
                            if !fields.insert(__FieldTag::__http_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_method",
                                ));
                            }
                            result.http_method = map
                                .next_value::<std::option::Option<crate::model::HttpMethod>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.body = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oauth_token => {
                            if !fields.insert(__FieldTag::__oauth_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_token",
                                ));
                            }
                            if result.authorization_header.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authorization_header`, a oneof with full ID .google.cloud.tasks.v2.HttpRequest.oauth_token, latest field was oauthToken",
                                ));
                            }
                            result.authorization_header = std::option::Option::Some(
                                crate::model::http_request::AuthorizationHeader::OauthToken(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OAuthToken>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oidc_token => {
                            if !fields.insert(__FieldTag::__oidc_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oidc_token",
                                ));
                            }
                            if result.authorization_header.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authorization_header`, a oneof with full ID .google.cloud.tasks.v2.HttpRequest.oidc_token, latest field was oidcToken",
                                ));
                            }
                            result.authorization_header = std::option::Option::Some(
                                crate::model::http_request::AuthorizationHeader::OidcToken(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OidcToken>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url.is_empty() {
            state.serialize_entry("url", &self.url)?;
        }
        if !wkt::internal::is_default(&self.http_method) {
            state.serialize_entry("httpMethod", &self.http_method)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.body.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("body", &__With(&self.body))?;
        }
        if let Some(value) = self.oauth_token() {
            state.serialize_entry("oauthToken", value)?;
        }
        if let Some(value) = self.oidc_token() {
            state.serialize_entry("oidcToken", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HttpRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpRequest");
        debug_struct.field("url", &self.url);
        debug_struct.field("http_method", &self.http_method);
        debug_struct.field("headers", &self.headers);
        debug_struct.field("body", &self.body);
        debug_struct.field("authorization_header", &self.authorization_header);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [HttpRequest].
pub mod http_request {
    #[allow(unused_imports)]
    use super::*;

    /// The mode for generating an `Authorization` header for HTTP requests.
    ///
    /// If specified, all `Authorization` headers in the
    /// [HttpRequest.headers][google.cloud.tasks.v2.HttpRequest.headers] field will
    /// be overridden.
    ///
    /// [google.cloud.tasks.v2.HttpRequest.headers]: crate::model::HttpRequest::headers
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthorizationHeader {
        /// If specified, an
        /// [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
        /// will be generated and attached as an `Authorization` header in the HTTP
        /// request.
        ///
        /// This type of authorization should generally only be used when calling
        /// Google APIs hosted on *.googleapis.com.
        OauthToken(std::boxed::Box<crate::model::OAuthToken>),
        /// If specified, an
        /// [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
        /// token will be generated and attached as an `Authorization` header in the
        /// HTTP request.
        ///
        /// This type of authorization can be used for many scenarios, including
        /// calling Cloud Run, or endpoints where you intend to validate the token
        /// yourself.
        OidcToken(std::boxed::Box<crate::model::OidcToken>),
    }
}

/// App Engine HTTP request.
///
/// The message defines the HTTP request that is sent to an App Engine app when
/// the task is dispatched.
///
/// Using [AppEngineHttpRequest][google.cloud.tasks.v2.AppEngineHttpRequest]
/// requires
/// [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
/// Google IAM permission for the project
/// and the following scope:
///
/// `<https://www.googleapis.com/auth/cloud-platform>`
///
/// The task will be delivered to the App Engine app which belongs to the same
/// project as the queue. For more information, see
/// [How Requests are
/// Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
/// and how routing is affected by
/// [dispatch
/// files](https://cloud.google.com/appengine/docs/python/config/dispatchref).
/// Traffic is encrypted during transport and never leaves Google datacenters.
/// Because this traffic is carried over a communication mechanism internal to
/// Google, you cannot explicitly set the protocol (for example, HTTP or HTTPS).
/// The request to the handler, however, will appear to have used the HTTP
/// protocol.
///
/// The [AppEngineRouting][google.cloud.tasks.v2.AppEngineRouting] used to
/// construct the URL that the task is delivered to can be set at the queue-level
/// or task-level:
///
/// * If [app_engine_routing_override is set on the
///   queue][google.cloud.tasks.v2.Queue.app_engine_routing_override], this value
///   is used for all tasks in the queue, no matter what the setting is for the
///   [task-level
///   app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
///
/// The `url` that the task will be sent to is:
///
/// * `url =` [host][google.cloud.tasks.v2.AppEngineRouting.host] `+`
///   [relative_uri][google.cloud.tasks.v2.AppEngineHttpRequest.relative_uri]
///
/// Tasks can be dispatched to secure app handlers, unsecure app handlers, and
/// URIs restricted with
/// [`login:
/// admin`](https://cloud.google.com/appengine/docs/standard/python/config/appref).
/// Because tasks are not run as any user, they cannot be dispatched to URIs
/// restricted with
/// [`login:
/// required`](https://cloud.google.com/appengine/docs/standard/python/config/appref)
/// Task dispatches also do not follow redirects.
///
/// The task attempt has succeeded if the app's request handler returns an HTTP
/// response code in the range [`200` - `299`]. The task attempt has failed if
/// the app's handler returns a non-2xx response code or Cloud Tasks does
/// not receive response before the
/// [deadline][google.cloud.tasks.v2.Task.dispatch_deadline]. Failed tasks will
/// be retried according to the [retry
/// configuration][google.cloud.tasks.v2.Queue.retry_config]. `503` (Service
/// Unavailable) is considered an App Engine system error instead of an
/// application error and will cause Cloud Tasks' traffic congestion control to
/// temporarily throttle the queue's dispatches. Unlike other types of task
/// targets, a `429` (Too Many Requests) response from an app handler does not
/// cause traffic congestion control to throttle the queue.
///
/// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
/// [google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing]: crate::model::AppEngineHttpRequest::app_engine_routing
/// [google.cloud.tasks.v2.AppEngineHttpRequest.relative_uri]: crate::model::AppEngineHttpRequest::relative_uri
/// [google.cloud.tasks.v2.AppEngineRouting]: crate::model::AppEngineRouting
/// [google.cloud.tasks.v2.AppEngineRouting.host]: crate::model::AppEngineRouting::host
/// [google.cloud.tasks.v2.Queue.app_engine_routing_override]: crate::model::Queue::app_engine_routing_override
/// [google.cloud.tasks.v2.Queue.retry_config]: crate::model::Queue::retry_config
/// [google.cloud.tasks.v2.Task.dispatch_deadline]: crate::model::Task::dispatch_deadline
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppEngineHttpRequest {
    /// The HTTP method to use for the request. The default is POST.
    ///
    /// The app's request handler for the task's target URL must be able to handle
    /// HTTP requests with this http_method, otherwise the task attempt fails with
    /// error code 405 (Method Not Allowed). See [Writing a push task request
    /// handler](https://cloud.google.com/appengine/docs/java/taskqueue/push/creating-handlers#writing_a_push_task_request_handler)
    /// and the App Engine documentation for your runtime on [How Requests are
    /// Handled](https://cloud.google.com/appengine/docs/standard/python3/how-requests-are-handled).
    pub http_method: crate::model::HttpMethod,

    /// Task-level setting for App Engine routing.
    ///
    /// * If [app_engine_routing_override is set on the
    ///   queue][google.cloud.tasks.v2.Queue.app_engine_routing_override], this
    ///   value is used for all tasks in the queue, no matter what the setting is
    ///   for the [task-level
    ///   app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing]: crate::model::AppEngineHttpRequest::app_engine_routing
    /// [google.cloud.tasks.v2.Queue.app_engine_routing_override]: crate::model::Queue::app_engine_routing_override
    pub app_engine_routing: std::option::Option<crate::model::AppEngineRouting>,

    /// The relative URI.
    ///
    /// The relative URI must begin with "/" and must be a valid HTTP relative URI.
    /// It can contain a path and query string arguments.
    /// If the relative URI is empty, then the root path "/" will be used.
    /// No spaces are allowed, and the maximum length allowed is 2083 characters.
    pub relative_uri: std::string::String,

    /// HTTP request headers.
    ///
    /// This map contains the header field names and values.
    /// Headers can be set when the
    /// [task is created][google.cloud.tasks.v2.CloudTasks.CreateTask].
    /// Repeated headers are not supported but a header value can contain commas.
    ///
    /// Cloud Tasks sets some headers to default values:
    ///
    /// * `User-Agent`: By default, this header is
    ///   `"AppEngine-Google; (+<http://code.google.com/appengine>)"`.
    ///   This header can be modified, but Cloud Tasks will append
    ///   `"AppEngine-Google; (+<http://code.google.com/appengine>)"` to the
    ///   modified `User-Agent`.
    ///
    /// If the task has a [body][google.cloud.tasks.v2.AppEngineHttpRequest.body],
    /// Cloud Tasks sets the following headers:
    ///
    /// * `Content-Type`: By default, the `Content-Type` header is set to
    ///   `"application/octet-stream"`. The default can be overridden by explicitly
    ///   setting `Content-Type` to a particular media type when the
    ///   [task is created][google.cloud.tasks.v2.CloudTasks.CreateTask].
    ///   For example, `Content-Type` can be set to `"application/json"`.
    /// * `Content-Length`: This is computed by Cloud Tasks. This value is
    ///   output only.   It cannot be changed.
    ///
    /// The headers below cannot be set or overridden:
    ///
    /// * `Host`
    /// * `X-Google-*`
    /// * `X-AppEngine-*`
    ///
    /// In addition, Cloud Tasks sets some headers when the task is dispatched,
    /// such as headers containing information about the task; see
    /// [request
    /// headers](https://cloud.google.com/tasks/docs/creating-appengine-handlers#reading_request_headers).
    /// These headers are set only when the task is dispatched, so they are not
    /// visible when the task is returned in a Cloud Tasks response.
    ///
    /// Although there is no specific limit for the maximum number of headers or
    /// the size, there is a limit on the maximum size of the
    /// [Task][google.cloud.tasks.v2.Task]. For more information, see the
    /// [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask] documentation.
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest.body]: crate::model::AppEngineHttpRequest::body
    /// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// HTTP request body.
    ///
    /// A request body is allowed only if the HTTP method is POST or PUT. It is
    /// an error to set a body on a task with an incompatible
    /// [HttpMethod][google.cloud.tasks.v2.HttpMethod].
    ///
    /// [google.cloud.tasks.v2.HttpMethod]: crate::model::HttpMethod
    pub body: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppEngineHttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_method][crate::model::AppEngineHttpRequest::http_method].
    pub fn set_http_method<T: std::convert::Into<crate::model::HttpMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [app_engine_routing][crate::model::AppEngineHttpRequest::app_engine_routing].
    pub fn set_app_engine_routing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppEngineRouting>,
    {
        self.app_engine_routing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_engine_routing][crate::model::AppEngineHttpRequest::app_engine_routing].
    pub fn set_or_clear_app_engine_routing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppEngineRouting>,
    {
        self.app_engine_routing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [relative_uri][crate::model::AppEngineHttpRequest::relative_uri].
    pub fn set_relative_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_uri = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::AppEngineHttpRequest::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [body][crate::model::AppEngineHttpRequest::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for AppEngineHttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.AppEngineHttpRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppEngineHttpRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_method,
            __app_engine_routing,
            __relative_uri,
            __headers,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineHttpRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpMethod" => Ok(__FieldTag::__http_method),
                            "http_method" => Ok(__FieldTag::__http_method),
                            "appEngineRouting" => Ok(__FieldTag::__app_engine_routing),
                            "app_engine_routing" => Ok(__FieldTag::__app_engine_routing),
                            "relativeUri" => Ok(__FieldTag::__relative_uri),
                            "relative_uri" => Ok(__FieldTag::__relative_uri),
                            "headers" => Ok(__FieldTag::__headers),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppEngineHttpRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineHttpRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_method => {
                            if !fields.insert(__FieldTag::__http_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_method",
                                ));
                            }
                            result.http_method = map
                                .next_value::<std::option::Option<crate::model::HttpMethod>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_engine_routing => {
                            if !fields.insert(__FieldTag::__app_engine_routing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_routing",
                                ));
                            }
                            result.app_engine_routing = map
                                .next_value::<std::option::Option<crate::model::AppEngineRouting>>(
                                )?;
                        }
                        __FieldTag::__relative_uri => {
                            if !fields.insert(__FieldTag::__relative_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_uri",
                                ));
                            }
                            result.relative_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.body = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppEngineHttpRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.http_method) {
            state.serialize_entry("httpMethod", &self.http_method)?;
        }
        if self.app_engine_routing.is_some() {
            state.serialize_entry("appEngineRouting", &self.app_engine_routing)?;
        }
        if !self.relative_uri.is_empty() {
            state.serialize_entry("relativeUri", &self.relative_uri)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.body.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("body", &__With(&self.body))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AppEngineHttpRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AppEngineHttpRequest");
        debug_struct.field("http_method", &self.http_method);
        debug_struct.field("app_engine_routing", &self.app_engine_routing);
        debug_struct.field("relative_uri", &self.relative_uri);
        debug_struct.field("headers", &self.headers);
        debug_struct.field("body", &self.body);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// App Engine Routing.
///
/// Defines routing characteristics specific to App Engine - service, version,
/// and instance.
///
/// For more information about services, versions, and instances see
/// [An Overview of App
/// Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
/// [Microservices Architecture on Google App
/// Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
/// [App Engine Standard request
/// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
/// and [App Engine Flex request
/// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
///
/// Using [AppEngineRouting][google.cloud.tasks.v2.AppEngineRouting] requires
/// [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
/// Google IAM permission for the project
/// and the following scope:
///
/// `<https://www.googleapis.com/auth/cloud-platform>`
///
/// [google.cloud.tasks.v2.AppEngineRouting]: crate::model::AppEngineRouting
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppEngineRouting {
    /// App service.
    ///
    /// By default, the task is sent to the service which is the default
    /// service when the task is attempted.
    ///
    /// For some queues or tasks which were created using the App Engine
    /// Task Queue API, [host][google.cloud.tasks.v2.AppEngineRouting.host] is not
    /// parsable into [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. For example,
    /// some tasks which were created using the App Engine SDK use a custom domain
    /// name; custom domains are not parsed by Cloud Tasks. If
    /// [host][google.cloud.tasks.v2.AppEngineRouting.host] is not parsable, then
    /// [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance] are the empty
    /// string.
    ///
    /// [google.cloud.tasks.v2.AppEngineRouting.host]: crate::model::AppEngineRouting::host
    /// [google.cloud.tasks.v2.AppEngineRouting.instance]: crate::model::AppEngineRouting::instance
    /// [google.cloud.tasks.v2.AppEngineRouting.service]: crate::model::AppEngineRouting::service
    /// [google.cloud.tasks.v2.AppEngineRouting.version]: crate::model::AppEngineRouting::version
    pub service: std::string::String,

    /// App version.
    ///
    /// By default, the task is sent to the version which is the default
    /// version when the task is attempted.
    ///
    /// For some queues or tasks which were created using the App Engine
    /// Task Queue API, [host][google.cloud.tasks.v2.AppEngineRouting.host] is not
    /// parsable into [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. For example,
    /// some tasks which were created using the App Engine SDK use a custom domain
    /// name; custom domains are not parsed by Cloud Tasks. If
    /// [host][google.cloud.tasks.v2.AppEngineRouting.host] is not parsable, then
    /// [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance] are the empty
    /// string.
    ///
    /// [google.cloud.tasks.v2.AppEngineRouting.host]: crate::model::AppEngineRouting::host
    /// [google.cloud.tasks.v2.AppEngineRouting.instance]: crate::model::AppEngineRouting::instance
    /// [google.cloud.tasks.v2.AppEngineRouting.service]: crate::model::AppEngineRouting::service
    /// [google.cloud.tasks.v2.AppEngineRouting.version]: crate::model::AppEngineRouting::version
    pub version: std::string::String,

    /// App instance.
    ///
    /// By default, the task is sent to an instance which is available when
    /// the task is attempted.
    ///
    /// Requests can only be sent to a specific instance if
    /// [manual scaling is used in App Engine
    /// Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?hl=en_US#scaling_types_and_instance_classes).
    /// App Engine Flex does not support instances. For more information, see
    /// [App Engine Standard request
    /// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
    /// and [App Engine Flex request
    /// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
    pub instance: std::string::String,

    /// Output only. The host that the task is sent to.
    ///
    /// The host is constructed from the domain name of the app associated with
    /// the queue's project ID (for example \<app-id\>.appspot.com), and the
    /// [service][google.cloud.tasks.v2.AppEngineRouting.service],
    /// [version][google.cloud.tasks.v2.AppEngineRouting.version], and
    /// [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. Tasks which
    /// were created using the App Engine SDK might have a custom domain name.
    ///
    /// For more information, see
    /// [How Requests are
    /// Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
    ///
    /// [google.cloud.tasks.v2.AppEngineRouting.instance]: crate::model::AppEngineRouting::instance
    /// [google.cloud.tasks.v2.AppEngineRouting.service]: crate::model::AppEngineRouting::service
    /// [google.cloud.tasks.v2.AppEngineRouting.version]: crate::model::AppEngineRouting::version
    pub host: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppEngineRouting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::AppEngineRouting::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AppEngineRouting::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::AppEngineRouting::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [host][crate::model::AppEngineRouting::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for AppEngineRouting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.AppEngineRouting"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppEngineRouting {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __version,
            __instance,
            __host,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineRouting")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "version" => Ok(__FieldTag::__version),
                            "instance" => Ok(__FieldTag::__instance),
                            "host" => Ok(__FieldTag::__host),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppEngineRouting;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineRouting")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppEngineRouting {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AppEngineRouting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AppEngineRouting");
        debug_struct.field("service", &self.service);
        debug_struct.field("version", &self.version);
        debug_struct.field("instance", &self.instance);
        debug_struct.field("host", &self.host);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information needed for generating an
/// [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
/// This type of authorization should generally only be used when calling Google
/// APIs hosted on *.googleapis.com.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OAuthToken {
    /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
    /// to be used for generating OAuth token.
    /// The service account must be within the same project as the queue. The
    /// caller must have iam.serviceAccounts.actAs permission for the service
    /// account.
    pub service_account_email: std::string::String,

    /// OAuth scope to be used for generating OAuth access token.
    /// If not specified, `https://www.googleapis.com/auth/cloud-platform`
    /// will be used.
    pub scope: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OAuthToken {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_email][crate::model::OAuthToken::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::OAuthToken::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for OAuthToken {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.OAuthToken"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OAuthToken {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account_email,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OAuthToken")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OAuthToken;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OAuthToken")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OAuthToken {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account_email.is_empty() {
            state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OAuthToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OAuthToken");
        debug_struct.field("service_account_email", &self.service_account_email);
        debug_struct.field("scope", &self.scope);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information needed for generating an
/// [OpenID Connect
/// token](https://developers.google.com/identity/protocols/OpenIDConnect).
/// This type of authorization can be used for many scenarios, including
/// calling Cloud Run, or endpoints where you intend to validate the token
/// yourself.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OidcToken {
    /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
    /// to be used for generating OIDC token.
    /// The service account must be within the same project as the queue. The
    /// caller must have iam.serviceAccounts.actAs permission for the service
    /// account.
    pub service_account_email: std::string::String,

    /// Audience to be used when generating OIDC token. If not specified, the URI
    /// specified in target will be used.
    pub audience: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OidcToken {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_email][crate::model::OidcToken::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::OidcToken::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }
}

impl wkt::message::Message for OidcToken {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.OidcToken"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OidcToken {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account_email,
            __audience,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OidcToken")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            "audience" => Ok(__FieldTag::__audience),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OidcToken;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OidcToken")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audience",
                                ));
                            }
                            result.audience = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OidcToken {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account_email.is_empty() {
            state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
        }
        if !self.audience.is_empty() {
            state.serialize_entry("audience", &self.audience)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OidcToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OidcToken");
        debug_struct.field("service_account_email", &self.service_account_email);
        debug_struct.field("audience", &self.audience);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A unit of scheduled work.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Task {
    /// Optionally caller-specified in
    /// [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask].
    ///
    /// The task name.
    ///
    /// The task name must have the following format:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID/tasks/TASK_ID`
    ///
    /// * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), colons (:), or periods (.).
    ///   For more information, see
    ///   [Identifying
    ///   projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
    /// * `LOCATION_ID` is the canonical ID for the task's location.
    ///   The list of available locations can be obtained by calling
    ///   [ListLocations][google.cloud.location.Locations.ListLocations].
    ///   For more information, see <https://cloud.google.com/about/locations/>.
    /// * `QUEUE_ID` can contain letters ([A-Za-z]), numbers ([0-9]), or
    ///   hyphens (-). The maximum length is 100 characters.
    /// * `TASK_ID` can contain only letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), or underscores (_). The maximum length is 500 characters.
    ///
    /// [google.cloud.tasks.v2.CloudTasks.CreateTask]: crate::client::CloudTasks::create_task
    pub name: std::string::String,

    /// The time when the task is scheduled to be attempted or retried.
    ///
    /// `schedule_time` will be truncated to the nearest microsecond.
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that the task was created.
    ///
    /// `create_time` will be truncated to the nearest second.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The deadline for requests sent to the worker. If the worker does not
    /// respond by this deadline then the request is cancelled and the attempt
    /// is marked as a `DEADLINE_EXCEEDED` failure. Cloud Tasks will retry the
    /// task according to the [RetryConfig][google.cloud.tasks.v2.RetryConfig].
    ///
    /// Note that when the request is cancelled, Cloud Tasks will stop listening
    /// for the response, but whether the worker stops processing depends on the
    /// worker. For example, if the worker is stuck, it may not react to cancelled
    /// requests.
    ///
    /// The default and maximum values depend on the type of request:
    ///
    /// * For [HTTP tasks][google.cloud.tasks.v2.HttpRequest], the default is 10
    ///   minutes. The deadline
    ///   must be in the interval [15 seconds, 30 minutes].
    ///
    /// * For [App Engine tasks][google.cloud.tasks.v2.AppEngineHttpRequest], 0
    ///   indicates that the
    ///   request has the default deadline. The default deadline depends on the
    ///   [scaling
    ///   type](https://cloud.google.com/appengine/docs/standard/go/how-instances-are-managed#instance_scaling)
    ///   of the service: 10 minutes for standard apps with automatic scaling, 24
    ///   hours for standard apps with manual and basic scaling, and 60 minutes for
    ///   flex apps. If the request deadline is set, it must be in the interval [15
    ///   seconds, 24 hours 15 seconds]. Regardless of the task's
    ///   `dispatch_deadline`, the app handler will not run for longer than than
    ///   the service's timeout. We recommend setting the `dispatch_deadline` to
    ///   at most a few seconds more than the app handler's timeout. For more
    ///   information see
    ///   [Timeouts](https://cloud.google.com/tasks/docs/creating-appengine-handlers#timeouts).
    ///
    ///
    /// `dispatch_deadline` will be truncated to the nearest millisecond. The
    /// deadline is an approximate deadline.
    ///
    /// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
    /// [google.cloud.tasks.v2.HttpRequest]: crate::model::HttpRequest
    /// [google.cloud.tasks.v2.RetryConfig]: crate::model::RetryConfig
    pub dispatch_deadline: std::option::Option<wkt::Duration>,

    /// Output only. The number of attempts dispatched.
    ///
    /// This count includes attempts which have been dispatched but haven't
    /// received a response.
    pub dispatch_count: i32,

    /// Output only. The number of attempts which have received a response.
    pub response_count: i32,

    /// Output only. The status of the task's first attempt.
    ///
    /// Only [dispatch_time][google.cloud.tasks.v2.Attempt.dispatch_time] will be
    /// set. The other [Attempt][google.cloud.tasks.v2.Attempt] information is not
    /// retained by Cloud Tasks.
    ///
    /// [google.cloud.tasks.v2.Attempt]: crate::model::Attempt
    /// [google.cloud.tasks.v2.Attempt.dispatch_time]: crate::model::Attempt::dispatch_time
    pub first_attempt: std::option::Option<crate::model::Attempt>,

    /// Output only. The status of the task's last attempt.
    pub last_attempt: std::option::Option<crate::model::Attempt>,

    /// Output only. The view specifies which subset of the
    /// [Task][google.cloud.tasks.v2.Task] has been returned.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    pub view: crate::model::task::View,

    /// Required. The message to send to the worker.
    pub message_type: std::option::Option<crate::model::task::MessageType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Task {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Task::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schedule_time][crate::model::Task::schedule_time].
    pub fn set_schedule_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_time][crate::model::Task::schedule_time].
    pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Task::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Task::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dispatch_deadline][crate::model::Task::dispatch_deadline].
    pub fn set_dispatch_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.dispatch_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dispatch_deadline][crate::model::Task::dispatch_deadline].
    pub fn set_or_clear_dispatch_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.dispatch_deadline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dispatch_count][crate::model::Task::dispatch_count].
    pub fn set_dispatch_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.dispatch_count = v.into();
        self
    }

    /// Sets the value of [response_count][crate::model::Task::response_count].
    pub fn set_response_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.response_count = v.into();
        self
    }

    /// Sets the value of [first_attempt][crate::model::Task::first_attempt].
    pub fn set_first_attempt<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Attempt>,
    {
        self.first_attempt = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [first_attempt][crate::model::Task::first_attempt].
    pub fn set_or_clear_first_attempt<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Attempt>,
    {
        self.first_attempt = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_attempt][crate::model::Task::last_attempt].
    pub fn set_last_attempt<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Attempt>,
    {
        self.last_attempt = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_attempt][crate::model::Task::last_attempt].
    pub fn set_or_clear_last_attempt<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Attempt>,
    {
        self.last_attempt = v.map(|x| x.into());
        self
    }

    /// Sets the value of [view][crate::model::Task::view].
    pub fn set_view<T: std::convert::Into<crate::model::task::View>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [message_type][crate::model::Task::message_type].
    ///
    /// Note that all the setters affecting `message_type` are mutually
    /// exclusive.
    pub fn set_message_type<
        T: std::convert::Into<std::option::Option<crate::model::task::MessageType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = v.into();
        self
    }

    /// The value of [message_type][crate::model::Task::message_type]
    /// if it holds a `AppEngineHttpRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn app_engine_http_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AppEngineHttpRequest>> {
        #[allow(unreachable_patterns)]
        self.message_type.as_ref().and_then(|v| match v {
            crate::model::task::MessageType::AppEngineHttpRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message_type][crate::model::Task::message_type]
    /// to hold a `AppEngineHttpRequest`.
    ///
    /// Note that all the setters affecting `message_type` are
    /// mutually exclusive.
    pub fn set_app_engine_http_request<
        T: std::convert::Into<std::boxed::Box<crate::model::AppEngineHttpRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = std::option::Option::Some(
            crate::model::task::MessageType::AppEngineHttpRequest(v.into()),
        );
        self
    }

    /// The value of [message_type][crate::model::Task::message_type]
    /// if it holds a `HttpRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_request(&self) -> std::option::Option<&std::boxed::Box<crate::model::HttpRequest>> {
        #[allow(unreachable_patterns)]
        self.message_type.as_ref().and_then(|v| match v {
            crate::model::task::MessageType::HttpRequest(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message_type][crate::model::Task::message_type]
    /// to hold a `HttpRequest`.
    ///
    /// Note that all the setters affecting `message_type` are
    /// mutually exclusive.
    pub fn set_http_request<T: std::convert::Into<std::boxed::Box<crate::model::HttpRequest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message_type =
            std::option::Option::Some(crate::model::task::MessageType::HttpRequest(v.into()));
        self
    }
}

impl wkt::message::Message for Task {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.Task"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Task {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __app_engine_http_request,
            __http_request,
            __schedule_time,
            __create_time,
            __dispatch_deadline,
            __dispatch_count,
            __response_count,
            __first_attempt,
            __last_attempt,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Task")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "appEngineHttpRequest" => Ok(__FieldTag::__app_engine_http_request),
                            "app_engine_http_request" => Ok(__FieldTag::__app_engine_http_request),
                            "httpRequest" => Ok(__FieldTag::__http_request),
                            "http_request" => Ok(__FieldTag::__http_request),
                            "scheduleTime" => Ok(__FieldTag::__schedule_time),
                            "schedule_time" => Ok(__FieldTag::__schedule_time),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "dispatchDeadline" => Ok(__FieldTag::__dispatch_deadline),
                            "dispatch_deadline" => Ok(__FieldTag::__dispatch_deadline),
                            "dispatchCount" => Ok(__FieldTag::__dispatch_count),
                            "dispatch_count" => Ok(__FieldTag::__dispatch_count),
                            "responseCount" => Ok(__FieldTag::__response_count),
                            "response_count" => Ok(__FieldTag::__response_count),
                            "firstAttempt" => Ok(__FieldTag::__first_attempt),
                            "first_attempt" => Ok(__FieldTag::__first_attempt),
                            "lastAttempt" => Ok(__FieldTag::__last_attempt),
                            "last_attempt" => Ok(__FieldTag::__last_attempt),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Task;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Task")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_engine_http_request => {
                            if !fields.insert(__FieldTag::__app_engine_http_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_http_request",
                                ));
                            }
                            if result.message_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message_type`, a oneof with full ID .google.cloud.tasks.v2.Task.app_engine_http_request, latest field was appEngineHttpRequest",
                                ));
                            }
                            result.message_type = std::option::Option::Some(
                                crate::model::task::MessageType::AppEngineHttpRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AppEngineHttpRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__http_request => {
                            if !fields.insert(__FieldTag::__http_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_request",
                                ));
                            }
                            if result.message_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message_type`, a oneof with full ID .google.cloud.tasks.v2.Task.http_request, latest field was httpRequest",
                                ));
                            }
                            result.message_type = std::option::Option::Some(
                                crate::model::task::MessageType::HttpRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__schedule_time => {
                            if !fields.insert(__FieldTag::__schedule_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_time",
                                ));
                            }
                            result.schedule_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__dispatch_deadline => {
                            if !fields.insert(__FieldTag::__dispatch_deadline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dispatch_deadline",
                                ));
                            }
                            result.dispatch_deadline =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__dispatch_count => {
                            if !fields.insert(__FieldTag::__dispatch_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dispatch_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.dispatch_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__response_count => {
                            if !fields.insert(__FieldTag::__response_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.response_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__first_attempt => {
                            if !fields.insert(__FieldTag::__first_attempt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_attempt",
                                ));
                            }
                            result.first_attempt =
                                map.next_value::<std::option::Option<crate::model::Attempt>>()?;
                        }
                        __FieldTag::__last_attempt => {
                            if !fields.insert(__FieldTag::__last_attempt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_attempt",
                                ));
                            }
                            result.last_attempt =
                                map.next_value::<std::option::Option<crate::model::Attempt>>()?;
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::task::View>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Task {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.app_engine_http_request() {
            state.serialize_entry("appEngineHttpRequest", value)?;
        }
        if let Some(value) = self.http_request() {
            state.serialize_entry("httpRequest", value)?;
        }
        if self.schedule_time.is_some() {
            state.serialize_entry("scheduleTime", &self.schedule_time)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.dispatch_deadline.is_some() {
            state.serialize_entry("dispatchDeadline", &self.dispatch_deadline)?;
        }
        if !wkt::internal::is_default(&self.dispatch_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dispatchCount", &__With(&self.dispatch_count))?;
        }
        if !wkt::internal::is_default(&self.response_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("responseCount", &__With(&self.response_count))?;
        }
        if self.first_attempt.is_some() {
            state.serialize_entry("firstAttempt", &self.first_attempt)?;
        }
        if self.last_attempt.is_some() {
            state.serialize_entry("lastAttempt", &self.last_attempt)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Task {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Task");
        debug_struct.field("name", &self.name);
        debug_struct.field("schedule_time", &self.schedule_time);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("dispatch_deadline", &self.dispatch_deadline);
        debug_struct.field("dispatch_count", &self.dispatch_count);
        debug_struct.field("response_count", &self.response_count);
        debug_struct.field("first_attempt", &self.first_attempt);
        debug_struct.field("last_attempt", &self.last_attempt);
        debug_struct.field("view", &self.view);
        debug_struct.field("message_type", &self.message_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Task].
pub mod task {
    #[allow(unused_imports)]
    use super::*;

    /// The view specifies a subset of [Task][google.cloud.tasks.v2.Task] data.
    ///
    /// When a task is returned in a response, not all
    /// information is retrieved by default because some data, such as
    /// payloads, might be desirable to return only when needed because
    /// of its large size or because of the sensitivity of data that it
    /// contains.
    ///
    /// [google.cloud.tasks.v2.Task]: crate::model::Task
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum View {
        /// Unspecified. Defaults to BASIC.
        Unspecified,
        /// The basic view omits fields which can be large or can contain
        /// sensitive data.
        ///
        /// This view does not include the
        /// [body in
        /// AppEngineHttpRequest][google.cloud.tasks.v2.AppEngineHttpRequest.body].
        /// Bodies are desirable to return only when needed, because they
        /// can be large and because of the sensitivity of the data that you
        /// choose to store in it.
        ///
        /// [google.cloud.tasks.v2.AppEngineHttpRequest.body]: crate::model::AppEngineHttpRequest::body
        Basic,
        /// All information is returned.
        ///
        /// Authorization for [FULL][google.cloud.tasks.v2.Task.View.FULL] requires
        /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
        /// permission on the [Queue][google.cloud.tasks.v2.Queue] resource.
        ///
        /// [google.cloud.tasks.v2.Queue]: crate::model::Queue
        /// [google.cloud.tasks.v2.Task.View.FULL]: crate::model::task::View::Full
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [View::value] or
        /// [View::name].
        UnknownValue(view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl View {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for View {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for View {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for View {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::Full,
                _ => Self::UnknownValue(view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for View {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for View {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for View {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<View>::new(
                ".google.cloud.tasks.v2.Task.View",
            ))
        }
    }

    /// Required. The message to send to the worker.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MessageType {
        /// HTTP request that is sent to the App Engine app handler.
        ///
        /// An App Engine task is a task that has
        /// [AppEngineHttpRequest][google.cloud.tasks.v2.AppEngineHttpRequest] set.
        ///
        /// [google.cloud.tasks.v2.AppEngineHttpRequest]: crate::model::AppEngineHttpRequest
        AppEngineHttpRequest(std::boxed::Box<crate::model::AppEngineHttpRequest>),
        /// HTTP request that is sent to the worker.
        ///
        /// An HTTP task is a task that has
        /// [HttpRequest][google.cloud.tasks.v2.HttpRequest] set.
        ///
        /// [google.cloud.tasks.v2.HttpRequest]: crate::model::HttpRequest
        HttpRequest(std::boxed::Box<crate::model::HttpRequest>),
    }
}

/// The status of a task attempt.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Attempt {
    /// Output only. The time that this attempt was scheduled.
    ///
    /// `schedule_time` will be truncated to the nearest microsecond.
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that this attempt was dispatched.
    ///
    /// `dispatch_time` will be truncated to the nearest microsecond.
    pub dispatch_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time that this attempt response was received.
    ///
    /// `response_time` will be truncated to the nearest microsecond.
    pub response_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The response from the worker for this attempt.
    ///
    /// If `response_time` is unset, then the task has not been attempted or is
    /// currently running and the `response_status` field is meaningless.
    pub response_status: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Attempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schedule_time][crate::model::Attempt::schedule_time].
    pub fn set_schedule_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_time][crate::model::Attempt::schedule_time].
    pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dispatch_time][crate::model::Attempt::dispatch_time].
    pub fn set_dispatch_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dispatch_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dispatch_time][crate::model::Attempt::dispatch_time].
    pub fn set_or_clear_dispatch_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dispatch_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response_time][crate::model::Attempt::response_time].
    pub fn set_response_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.response_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [response_time][crate::model::Attempt::response_time].
    pub fn set_or_clear_response_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.response_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response_status][crate::model::Attempt::response_status].
    pub fn set_response_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.response_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [response_status][crate::model::Attempt::response_status].
    pub fn set_or_clear_response_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.response_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Attempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.tasks.v2.Attempt"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Attempt {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __schedule_time,
            __dispatch_time,
            __response_time,
            __response_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Attempt")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scheduleTime" => Ok(__FieldTag::__schedule_time),
                            "schedule_time" => Ok(__FieldTag::__schedule_time),
                            "dispatchTime" => Ok(__FieldTag::__dispatch_time),
                            "dispatch_time" => Ok(__FieldTag::__dispatch_time),
                            "responseTime" => Ok(__FieldTag::__response_time),
                            "response_time" => Ok(__FieldTag::__response_time),
                            "responseStatus" => Ok(__FieldTag::__response_status),
                            "response_status" => Ok(__FieldTag::__response_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Attempt;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Attempt")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__schedule_time => {
                            if !fields.insert(__FieldTag::__schedule_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_time",
                                ));
                            }
                            result.schedule_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__dispatch_time => {
                            if !fields.insert(__FieldTag::__dispatch_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dispatch_time",
                                ));
                            }
                            result.dispatch_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__response_time => {
                            if !fields.insert(__FieldTag::__response_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_time",
                                ));
                            }
                            result.response_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__response_status => {
                            if !fields.insert(__FieldTag::__response_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_status",
                                ));
                            }
                            result.response_status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Attempt {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.schedule_time.is_some() {
            state.serialize_entry("scheduleTime", &self.schedule_time)?;
        }
        if self.dispatch_time.is_some() {
            state.serialize_entry("dispatchTime", &self.dispatch_time)?;
        }
        if self.response_time.is_some() {
            state.serialize_entry("responseTime", &self.response_time)?;
        }
        if self.response_status.is_some() {
            state.serialize_entry("responseStatus", &self.response_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Attempt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Attempt");
        debug_struct.field("schedule_time", &self.schedule_time);
        debug_struct.field("dispatch_time", &self.dispatch_time);
        debug_struct.field("response_time", &self.response_time);
        debug_struct.field("response_status", &self.response_status);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The HTTP method used to deliver the task.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum HttpMethod {
    /// HTTP method unspecified
    Unspecified,
    /// HTTP POST
    Post,
    /// HTTP GET
    Get,
    /// HTTP HEAD
    Head,
    /// HTTP PUT
    Put,
    /// HTTP DELETE
    Delete,
    /// HTTP PATCH
    Patch,
    /// HTTP OPTIONS
    Options,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [HttpMethod::value] or
    /// [HttpMethod::name].
    UnknownValue(http_method::UnknownValue),
}

#[doc(hidden)]
pub mod http_method {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl HttpMethod {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Post => std::option::Option::Some(1),
            Self::Get => std::option::Option::Some(2),
            Self::Head => std::option::Option::Some(3),
            Self::Put => std::option::Option::Some(4),
            Self::Delete => std::option::Option::Some(5),
            Self::Patch => std::option::Option::Some(6),
            Self::Options => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("HTTP_METHOD_UNSPECIFIED"),
            Self::Post => std::option::Option::Some("POST"),
            Self::Get => std::option::Option::Some("GET"),
            Self::Head => std::option::Option::Some("HEAD"),
            Self::Put => std::option::Option::Some("PUT"),
            Self::Delete => std::option::Option::Some("DELETE"),
            Self::Patch => std::option::Option::Some("PATCH"),
            Self::Options => std::option::Option::Some("OPTIONS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for HttpMethod {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for HttpMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for HttpMethod {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Post,
            2 => Self::Get,
            3 => Self::Head,
            4 => Self::Put,
            5 => Self::Delete,
            6 => Self::Patch,
            7 => Self::Options,
            _ => Self::UnknownValue(http_method::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for HttpMethod {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "HTTP_METHOD_UNSPECIFIED" => Self::Unspecified,
            "POST" => Self::Post,
            "GET" => Self::Get,
            "HEAD" => Self::Head,
            "PUT" => Self::Put,
            "DELETE" => Self::Delete,
            "PATCH" => Self::Patch,
            "OPTIONS" => Self::Options,
            _ => Self::UnknownValue(http_method::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for HttpMethod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Post => serializer.serialize_i32(1),
            Self::Get => serializer.serialize_i32(2),
            Self::Head => serializer.serialize_i32(3),
            Self::Put => serializer.serialize_i32(4),
            Self::Delete => serializer.serialize_i32(5),
            Self::Patch => serializer.serialize_i32(6),
            Self::Options => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for HttpMethod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<HttpMethod>::new(
            ".google.cloud.tasks.v2.HttpMethod",
        ))
    }
}
