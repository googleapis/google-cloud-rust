// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::broken_intra_doc_links)]

use crate::Result;
use std::sync::Arc;

/// An implementation of [crate::stubs::Folders] to make requests with.
///
/// `Folders` has various configuration parameters, but the defaults
/// are set to work with most applications.
///
/// `Folders` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Folders` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
///
/// Manages Cloud Platform folder resources.
/// Folders can be used to organize the resources under an
/// organization and to control the policies applied to groups of resources.
#[derive(Clone, Debug)]
pub struct Folders {
    inner: Arc<dyn crate::stubs::dynamic::Folders>,
}

impl Folders {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::Folders + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::Folders>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::Folders> {
        crate::transport::Folders::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::Folders> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::Folders::new)
    }

    /// Retrieves a folder identified by the supplied resource name.
    /// Valid folder resource names have the format `folders/{folder_id}`
    /// (for example, `folders/1234`).
    /// The caller must have `resourcemanager.folders.get` permission on the
    /// identified folder.
    pub fn get_folder(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::folders::GetFolder {
        crate::builders::folders::GetFolder::new(self.inner.clone()).set_name(name.into())
    }

    /// Lists the folders that are direct descendants of supplied parent resource.
    /// `list()` provides a strongly consistent view of the folders underneath
    /// the specified parent resource.
    /// `list()` returns folders sorted based upon the (ascending) lexical ordering
    /// of their display_name.
    /// The caller must have `resourcemanager.folders.list` permission on the
    /// identified parent.
    pub fn list_folders(&self) -> crate::builders::folders::ListFolders {
        crate::builders::folders::ListFolders::new(self.inner.clone())
    }

    /// Search for folders that match specific filter criteria.
    /// `search()` provides an eventually consistent view of the folders a user has
    /// access to which meet the specified filter criteria.
    ///
    /// This will only return folders on which the caller has the
    /// permission `resourcemanager.folders.get`.
    pub fn search_folders(&self) -> crate::builders::folders::SearchFolders {
        crate::builders::folders::SearchFolders::new(self.inner.clone())
    }

    /// Creates a folder in the resource hierarchy.
    /// Returns an `Operation` which can be used to track the progress of the
    /// folder creation workflow.
    /// Upon success, the `Operation.response` field will be populated with the
    /// created Folder.
    ///
    /// In order to succeed, the addition of this new folder must not violate
    /// the folder naming, height, or fanout constraints.
    ///
    /// + The folder's `display_name` must be distinct from all other folders that
    ///   share its parent.
    /// + The addition of the folder must not cause the active folder hierarchy
    ///   to exceed a height of 10. Note, the full active + deleted folder hierarchy
    ///   is allowed to reach a height of 20; this provides additional headroom when
    ///   moving folders that contain deleted folders.
    /// + The addition of the folder must not cause the total number of folders
    ///   under its parent to exceed 300.
    ///
    /// If the operation fails due to a folder constraint violation, some errors
    /// may be returned by the `CreateFolder` request, with status code
    /// `FAILED_PRECONDITION` and an error description. Other folder constraint
    /// violations will be communicated in the `Operation`, with the specific
    /// `PreconditionFailure` returned in the details list in the `Operation.error`
    /// field.
    ///
    /// The caller must have `resourcemanager.folders.create` permission on the
    /// identified parent.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::CreateFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::CreateFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Folder] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::CreateFolderMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::folders::CreateFolder::send
    /// [poller()]: crate::builders::folders::CreateFolder::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn create_folder(&self) -> crate::builders::folders::CreateFolder {
        crate::builders::folders::CreateFolder::new(self.inner.clone())
    }

    /// Updates a folder, changing its `display_name`.
    /// Changes to the folder `display_name` will be rejected if they violate
    /// either the `display_name` formatting rules or the naming constraints
    /// described in the
    /// [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
    /// documentation.
    ///
    /// The folder's `display_name` must start and end with a letter or digit,
    /// may contain letters, digits, spaces, hyphens and underscores and can be
    /// between 3 and 30 characters. This is captured by the regular expression:
    /// `[\p{L}\p{N}][\p{L}\p{N}_- ]{1,28}[\p{L}\p{N}]`.
    /// The caller must have `resourcemanager.folders.update` permission on the
    /// identified folder.
    ///
    /// If the update fails due to the unique name constraint then a
    /// `PreconditionFailure` explaining this violation will be returned
    /// in the Status.details field.
    ///
    /// [google.cloud.resourcemanager.v3.Folders.CreateFolder]: crate::client::Folders::create_folder
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::UpdateFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::UpdateFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Folder] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::UpdateFolderMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::folders::UpdateFolder::send
    /// [poller()]: crate::builders::folders::UpdateFolder::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn update_folder(
        &self,
        folder: impl Into<crate::model::Folder>,
    ) -> crate::builders::folders::UpdateFolder {
        crate::builders::folders::UpdateFolder::new(self.inner.clone()).set_folder(folder.into())
    }

    /// Moves a folder under a new resource parent.
    /// Returns an `Operation` which can be used to track the progress of the
    /// folder move workflow.
    /// Upon success, the `Operation.response` field will be populated with the
    /// moved folder.
    /// Upon failure, a `FolderOperationError` categorizing the failure cause will
    /// be returned - if the failure occurs synchronously then the
    /// `FolderOperationError` will be returned in the `Status.details` field.
    /// If it occurs asynchronously, then the FolderOperation will be returned
    /// in the `Operation.error` field.
    /// In addition, the `Operation.metadata` field will be populated with a
    /// `FolderOperation` message as an aid to stateless clients.
    /// Folder moves will be rejected if they violate either the naming, height,
    /// or fanout constraints described in the
    /// [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
    /// documentation. The caller must have `resourcemanager.folders.move`
    /// permission on the folder's current and proposed new parent.
    ///
    /// [google.cloud.resourcemanager.v3.Folders.CreateFolder]: crate::client::Folders::create_folder
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::MoveFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::MoveFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Folder] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::MoveFolderMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::folders::MoveFolder::send
    /// [poller()]: crate::builders::folders::MoveFolder::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn move_folder(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::folders::MoveFolder {
        crate::builders::folders::MoveFolder::new(self.inner.clone()).set_name(name.into())
    }

    /// Requests deletion of a folder. The folder is moved into the
    /// [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
    /// state immediately, and is deleted approximately 30 days later. This method
    /// may only be called on an empty folder, where a folder is empty if it
    /// doesn't contain any folders or projects in the
    /// [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. If
    /// called on a folder in
    /// [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
    /// state the operation will result in a no-op success.
    /// The caller must have `resourcemanager.folders.delete` permission on the
    /// identified folder.
    ///
    /// [google.cloud.resourcemanager.v3.Folder.State.ACTIVE]: crate::model::folder::state::ACTIVE
    /// [google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]: crate::model::folder::state::DELETE_REQUESTED
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::DeleteFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::DeleteFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Folder] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::DeleteFolderMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::folders::DeleteFolder::send
    /// [poller()]: crate::builders::folders::DeleteFolder::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn delete_folder(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::folders::DeleteFolder {
        crate::builders::folders::DeleteFolder::new(self.inner.clone()).set_name(name.into())
    }

    /// Cancels the deletion request for a folder. This method may be called on a
    /// folder in any state. If the folder is in the
    /// [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state the
    /// result will be a no-op success. In order to succeed, the folder's parent
    /// must be in the
    /// [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. In
    /// addition, reintroducing the folder into the tree must not violate folder
    /// naming, height, and fanout constraints described in the
    /// [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
    /// documentation. The caller must have `resourcemanager.folders.undelete`
    /// permission on the identified folder.
    ///
    /// [google.cloud.resourcemanager.v3.Folder.State.ACTIVE]: crate::model::folder::state::ACTIVE
    /// [google.cloud.resourcemanager.v3.Folders.CreateFolder]: crate::client::Folders::create_folder
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::UndeleteFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Folder, model::UndeleteFolderMetadata>
    /// ) -> Result<model::Folder> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Folder] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::UndeleteFolderMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::folders::UndeleteFolder::send
    /// [poller()]: crate::builders::folders::UndeleteFolder::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn undelete_folder(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::folders::UndeleteFolder {
        crate::builders::folders::UndeleteFolder::new(self.inner.clone()).set_name(name.into())
    }

    /// Gets the access control policy for a folder. The returned policy may be
    /// empty if no such policy or resource exists. The `resource` field should
    /// be the folder's resource name, for example: "folders/1234".
    /// The caller must have `resourcemanager.folders.getIamPolicy` permission
    /// on the identified folder.
    pub fn get_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::folders::GetIamPolicy {
        crate::builders::folders::GetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Sets the access control policy on a folder, replacing any existing policy.
    /// The `resource` field should be the folder's resource name, for example:
    /// "folders/1234".
    /// The caller must have `resourcemanager.folders.setIamPolicy` permission
    /// on the identified folder.
    pub fn set_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::folders::SetIamPolicy {
        crate::builders::folders::SetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Returns permissions that a caller has on the specified folder.
    /// The `resource` field should be the folder's resource name,
    /// for example: "folders/1234".
    ///
    /// There are no permissions required for making this API call.
    pub fn test_iam_permissions(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::folders::TestIamPermissions {
        crate::builders::folders::TestIamPermissions::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::folders::GetOperation {
        crate::builders::folders::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// An implementation of [crate::stubs::Organizations] to make requests with.
///
/// `Organizations` has various configuration parameters, but the defaults
/// are set to work with most applications.
///
/// `Organizations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Organizations` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
///
/// Allows users to manage their organization resources.
#[derive(Clone, Debug)]
pub struct Organizations {
    inner: Arc<dyn crate::stubs::dynamic::Organizations>,
}

impl Organizations {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::Organizations + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::Organizations>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::Organizations> {
        crate::transport::Organizations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::Organizations> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::Organizations::new)
    }

    /// Fetches an organization resource identified by the specified resource name.
    pub fn get_organization(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::organizations::GetOrganization {
        crate::builders::organizations::GetOrganization::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Searches organization resources that are visible to the user and satisfy
    /// the specified filter. This method returns organizations in an unspecified
    /// order. New organizations do not necessarily appear at the end of the
    /// results, and may take a small amount of time to appear.
    ///
    /// Search will only return organizations on which the user has the permission
    /// `resourcemanager.organizations.get`
    pub fn search_organizations(&self) -> crate::builders::organizations::SearchOrganizations {
        crate::builders::organizations::SearchOrganizations::new(self.inner.clone())
    }

    /// Gets the access control policy for an organization resource. The policy may
    /// be empty if no such policy or resource exists. The `resource` field should
    /// be the organization's resource name, for example: "organizations/123".
    ///
    /// Authorization requires the IAM permission
    /// `resourcemanager.organizations.getIamPolicy` on the specified organization.
    pub fn get_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::organizations::GetIamPolicy {
        crate::builders::organizations::GetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Sets the access control policy on an organization resource. Replaces any
    /// existing policy. The `resource` field should be the organization's resource
    /// name, for example: "organizations/123".
    ///
    /// Authorization requires the IAM permission
    /// `resourcemanager.organizations.setIamPolicy` on the specified organization.
    pub fn set_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::organizations::SetIamPolicy {
        crate::builders::organizations::SetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Returns the permissions that a caller has on the specified organization.
    /// The `resource` field should be the organization's resource name,
    /// for example: "organizations/123".
    ///
    /// There are no permissions required for making this API call.
    pub fn test_iam_permissions(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::organizations::TestIamPermissions {
        crate::builders::organizations::TestIamPermissions::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::organizations::GetOperation {
        crate::builders::organizations::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// An implementation of [crate::stubs::Projects] to make requests with.
///
/// `Projects` has various configuration parameters, but the defaults
/// are set to work with most applications.
///
/// `Projects` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Projects` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
///
/// Manages Google Cloud Projects.
#[derive(Clone, Debug)]
pub struct Projects {
    inner: Arc<dyn crate::stubs::dynamic::Projects>,
}

impl Projects {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::Projects + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::Projects>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::Projects> {
        crate::transport::Projects::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::Projects> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::Projects::new)
    }

    /// Retrieves the project identified by the specified `name` (for example,
    /// `projects/415104041262`).
    ///
    /// The caller must have `resourcemanager.projects.get` permission
    /// for this project.
    pub fn get_project(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::projects::GetProject {
        crate::builders::projects::GetProject::new(self.inner.clone()).set_name(name.into())
    }

    /// Lists projects that are direct children of the specified folder or
    /// organization resource. `list()` provides a strongly consistent view of the
    /// projects underneath the specified parent resource. `list()` returns
    /// projects sorted based upon the (ascending) lexical ordering of their
    /// `display_name`. The caller must have `resourcemanager.projects.list`
    /// permission on the identified parent.
    pub fn list_projects(&self) -> crate::builders::projects::ListProjects {
        crate::builders::projects::ListProjects::new(self.inner.clone())
    }

    /// Search for projects that the caller has both `resourcemanager.projects.get`
    /// permission on, and also satisfy the specified query.
    ///
    /// This method returns projects in an unspecified order.
    ///
    /// This method is eventually consistent with project mutations; this means
    /// that a newly created project may not appear in the results or recent
    /// updates to an existing project may not be reflected in the results. To
    /// retrieve the latest state of a project, use the
    /// [GetProject][google.cloud.resourcemanager.v3.Projects.GetProject] method.
    ///
    /// [google.cloud.resourcemanager.v3.Projects.GetProject]: crate::client::Projects::get_project
    pub fn search_projects(&self) -> crate::builders::projects::SearchProjects {
        crate::builders::projects::SearchProjects::new(self.inner.clone())
    }

    /// Request that a new project be created. The result is an `Operation` which
    /// can be used to track the creation process. This process usually takes a few
    /// seconds, but can sometimes take much longer. The tracking `Operation` is
    /// automatically deleted after a few hours, so there is no need to call
    /// `DeleteOperation`.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::CreateProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::CreateProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Project] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::CreateProjectMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::projects::CreateProject::send
    /// [poller()]: crate::builders::projects::CreateProject::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn create_project(&self) -> crate::builders::projects::CreateProject {
        crate::builders::projects::CreateProject::new(self.inner.clone())
    }

    /// Updates the `display_name` and labels of the project identified by the
    /// specified `name` (for example, `projects/415104041262`). Deleting all
    /// labels requires an update mask for labels field.
    ///
    /// The caller must have `resourcemanager.projects.update` permission for this
    /// project.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::UpdateProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::UpdateProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Project] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::UpdateProjectMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::projects::UpdateProject::send
    /// [poller()]: crate::builders::projects::UpdateProject::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn update_project(
        &self,
        project: impl Into<crate::model::Project>,
    ) -> crate::builders::projects::UpdateProject {
        crate::builders::projects::UpdateProject::new(self.inner.clone())
            .set_project(project.into())
    }

    /// Move a project to another place in your resource hierarchy, under a new
    /// resource parent.
    ///
    /// Returns an operation which can be used to track the process of the project
    /// move workflow.
    /// Upon success, the `Operation.response` field will be populated with the
    /// moved project.
    ///
    /// The caller must have `resourcemanager.projects.move` permission on the
    /// project, on the project's current and proposed new parent.
    ///
    /// If project has no current parent, or it currently does not have an
    /// associated organization resource, you will also need the
    /// `resourcemanager.projects.setIamPolicy` permission in the project.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::MoveProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::MoveProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Project] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::MoveProjectMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::projects::MoveProject::send
    /// [poller()]: crate::builders::projects::MoveProject::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn move_project(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::projects::MoveProject {
        crate::builders::projects::MoveProject::new(self.inner.clone()).set_name(name.into())
    }

    /// Marks the project identified by the specified
    /// `name` (for example, `projects/415104041262`) for deletion.
    ///
    /// This method will only affect the project if it has a lifecycle state of
    /// [ACTIVE][google.cloud.resourcemanager.v3.Project.State.ACTIVE].
    ///
    /// This method changes the Project's lifecycle state from
    /// [ACTIVE][google.cloud.resourcemanager.v3.Project.State.ACTIVE]
    /// to
    /// [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Project.State.DELETE_REQUESTED].
    /// The deletion starts at an unspecified time,
    /// at which point the Project is no longer accessible.
    ///
    /// Until the deletion completes, you can check the lifecycle state
    /// checked by retrieving the project with [GetProject]
    /// [google.cloud.resourcemanager.v3.Projects.GetProject],
    /// and the project remains visible to [ListProjects]
    /// [google.cloud.resourcemanager.v3.Projects.ListProjects].
    /// However, you cannot update the project.
    ///
    /// After the deletion completes, the project is not retrievable by
    /// the  [GetProject]
    /// [google.cloud.resourcemanager.v3.Projects.GetProject],
    /// [ListProjects]
    /// [google.cloud.resourcemanager.v3.Projects.ListProjects], and
    /// [SearchProjects][google.cloud.resourcemanager.v3.Projects.SearchProjects]
    /// methods.
    ///
    /// This method behaves idempotently, such that deleting a `DELETE_REQUESTED`
    /// project will not cause an error, but also won't do anything.
    ///
    /// The caller must have `resourcemanager.projects.delete` permissions for this
    /// project.
    ///
    /// [google.cloud.resourcemanager.v3.Project.State.ACTIVE]: crate::model::project::state::ACTIVE
    /// [google.cloud.resourcemanager.v3.Project.State.DELETE_REQUESTED]: crate::model::project::state::DELETE_REQUESTED
    /// [google.cloud.resourcemanager.v3.Projects.SearchProjects]: crate::client::Projects::search_projects
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::DeleteProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::DeleteProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Project] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::DeleteProjectMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::projects::DeleteProject::send
    /// [poller()]: crate::builders::projects::DeleteProject::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn delete_project(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::projects::DeleteProject {
        crate::builders::projects::DeleteProject::new(self.inner.clone()).set_name(name.into())
    }

    /// Restores the project identified by the specified
    /// `name` (for example, `projects/415104041262`).
    /// You can only use this method for a project that has a lifecycle state of
    /// [DELETE_REQUESTED]
    /// [Projects.State.DELETE_REQUESTED].
    /// After deletion starts, the project cannot be restored.
    ///
    /// The caller must have `resourcemanager.projects.undelete` permission for
    /// this project.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::UndeleteProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Project, model::UndeleteProjectMetadata>
    /// ) -> Result<model::Project> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Project] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::UndeleteProjectMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::projects::UndeleteProject::send
    /// [poller()]: crate::builders::projects::UndeleteProject::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn undelete_project(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::projects::UndeleteProject {
        crate::builders::projects::UndeleteProject::new(self.inner.clone()).set_name(name.into())
    }

    /// Returns the IAM access control policy for the specified project, in the
    /// format `projects/{ProjectIdOrNumber}` e.g. projects/123.
    /// Permission is denied if the policy or the resource do not exist.
    pub fn get_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::projects::GetIamPolicy {
        crate::builders::projects::GetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Sets the IAM access control policy for the specified project, in the
    /// format `projects/{ProjectIdOrNumber}` e.g. projects/123.
    ///
    /// CAUTION: This method will replace the existing policy, and cannot be used
    /// to append additional IAM settings.
    ///
    /// Note: Removing service accounts from policies or changing their roles can
    /// render services completely inoperable. It is important to understand how
    /// the service account is being used before removing or updating its roles.
    ///
    /// The following constraints apply when using `setIamPolicy()`:
    ///
    /// + Project does not support `allUsers` and `allAuthenticatedUsers` as
    ///   `members` in a `Binding` of a `Policy`.
    ///
    /// + The owner role can be granted to a `user`, `serviceAccount`, or a group
    ///   that is part of an organization. For example,
    ///   group@myownpersonaldomain.com could be added as an owner to a project in
    ///   the myownpersonaldomain.com organization, but not the examplepetstore.com
    ///   organization.
    ///
    /// + Service accounts can be made owners of a project directly
    ///   without any restrictions. However, to be added as an owner, a user must be
    ///   invited using the Cloud Platform console and must accept the invitation.
    ///
    /// + A user cannot be granted the owner role using `setIamPolicy()`. The user
    ///   must be granted the owner role using the Cloud Platform Console and must
    ///   explicitly accept the invitation.
    ///
    /// + Invitations to grant the owner role cannot be sent using
    ///   `setIamPolicy()`;
    ///   they must be sent only using the Cloud Platform Console.
    ///
    /// + If the project is not part of an organization, there must be at least
    ///   one owner who has accepted the Terms of Service (ToS) agreement in the
    ///   policy. Calling `setIamPolicy()` to remove the last ToS-accepted owner
    ///   from the policy will fail. This restriction also applies to legacy
    ///   projects that no longer have owners who have accepted the ToS. Edits to
    ///   IAM policies will be rejected until the lack of a ToS-accepting owner is
    ///   rectified. If the project is part of an organization, you can remove all
    ///   owners, potentially making the organization inaccessible.
    ///
    pub fn set_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::projects::SetIamPolicy {
        crate::builders::projects::SetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Returns permissions that a caller has on the specified project, in the
    /// format `projects/{ProjectIdOrNumber}` e.g. projects/123..
    pub fn test_iam_permissions(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::projects::TestIamPermissions {
        crate::builders::projects::TestIamPermissions::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::projects::GetOperation {
        crate::builders::projects::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// An implementation of [crate::stubs::TagBindings] to make requests with.
///
/// `TagBindings` has various configuration parameters, but the defaults
/// are set to work with most applications.
///
/// `TagBindings` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TagBindings` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
///
/// Allow users to create and manage TagBindings between TagValues and
/// different Google Cloud resources throughout the GCP resource hierarchy.
#[derive(Clone, Debug)]
pub struct TagBindings {
    inner: Arc<dyn crate::stubs::dynamic::TagBindings>,
}

impl TagBindings {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::TagBindings + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::TagBindings>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagBindings> {
        crate::transport::TagBindings::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagBindings> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::TagBindings::new)
    }

    /// Lists the TagBindings for the given Google Cloud resource, as specified
    /// with `parent`.
    ///
    /// NOTE: The `parent` field is expected to be a full resource name:
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    pub fn list_tag_bindings(&self) -> crate::builders::tag_bindings::ListTagBindings {
        crate::builders::tag_bindings::ListTagBindings::new(self.inner.clone())
    }

    /// Creates a TagBinding between a TagValue and a Google Cloud resource.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagBinding, model::CreateTagBindingMetadata>
    /// ) -> Result<model::TagBinding> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagBinding, model::CreateTagBindingMetadata>
    /// ) -> Result<model::TagBinding> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagBinding] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::CreateTagBindingMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_bindings::CreateTagBinding::send
    /// [poller()]: crate::builders::tag_bindings::CreateTagBinding::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn create_tag_binding(&self) -> crate::builders::tag_bindings::CreateTagBinding {
        crate::builders::tag_bindings::CreateTagBinding::new(self.inner.clone())
    }

    /// Deletes a TagBinding.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<wkt::Empty, model::DeleteTagBindingMetadata>
    /// ) -> Result<wkt::Empty> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<wkt::Empty, model::DeleteTagBindingMetadata>
    /// ) -> Result<wkt::Empty> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [wkt::Empty] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::DeleteTagBindingMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_bindings::DeleteTagBinding::send
    /// [poller()]: crate::builders::tag_bindings::DeleteTagBinding::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn delete_tag_binding(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_bindings::DeleteTagBinding {
        crate::builders::tag_bindings::DeleteTagBinding::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Return a list of effective tags for the given Google Cloud resource, as
    /// specified in `parent`.
    pub fn list_effective_tags(&self) -> crate::builders::tag_bindings::ListEffectiveTags {
        crate::builders::tag_bindings::ListEffectiveTags::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_bindings::GetOperation {
        crate::builders::tag_bindings::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// An implementation of [crate::stubs::TagHolds] to make requests with.
///
/// `TagHolds` has various configuration parameters, but the defaults
/// are set to work with most applications.
///
/// `TagHolds` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TagHolds` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
///
/// Allow users to create and manage TagHolds for TagValues. TagHolds represent
/// the use of a Tag Value that is not captured by TagBindings but
/// should still block TagValue deletion (such as a reference in a policy
/// condition). This service provides isolated failure domains by cloud location
/// so that TagHolds can be managed in the same location as their usage.
#[derive(Clone, Debug)]
pub struct TagHolds {
    inner: Arc<dyn crate::stubs::dynamic::TagHolds>,
}

impl TagHolds {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::TagHolds + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::TagHolds>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagHolds> {
        crate::transport::TagHolds::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagHolds> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::TagHolds::new)
    }

    /// Creates a TagHold. Returns ALREADY_EXISTS if a TagHold with the same
    /// resource and origin exists under the same TagValue.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagHold, model::CreateTagHoldMetadata>
    /// ) -> Result<model::TagHold> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagHold, model::CreateTagHoldMetadata>
    /// ) -> Result<model::TagHold> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagHold] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::CreateTagHoldMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_holds::CreateTagHold::send
    /// [poller()]: crate::builders::tag_holds::CreateTagHold::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn create_tag_hold(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::tag_holds::CreateTagHold {
        crate::builders::tag_holds::CreateTagHold::new(self.inner.clone()).set_parent(parent.into())
    }

    /// Deletes a TagHold.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<wkt::Empty, model::DeleteTagHoldMetadata>
    /// ) -> Result<wkt::Empty> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<wkt::Empty, model::DeleteTagHoldMetadata>
    /// ) -> Result<wkt::Empty> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [wkt::Empty] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::DeleteTagHoldMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_holds::DeleteTagHold::send
    /// [poller()]: crate::builders::tag_holds::DeleteTagHold::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn delete_tag_hold(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_holds::DeleteTagHold {
        crate::builders::tag_holds::DeleteTagHold::new(self.inner.clone()).set_name(name.into())
    }

    /// Lists TagHolds under a TagValue.
    pub fn list_tag_holds(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::tag_holds::ListTagHolds {
        crate::builders::tag_holds::ListTagHolds::new(self.inner.clone()).set_parent(parent.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_holds::GetOperation {
        crate::builders::tag_holds::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// An implementation of [crate::stubs::TagKeys] to make requests with.
///
/// `TagKeys` has various configuration parameters, but the defaults
/// are set to work with most applications.
///
/// `TagKeys` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TagKeys` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
///
/// Allow users to create and manage tag keys.
#[derive(Clone, Debug)]
pub struct TagKeys {
    inner: Arc<dyn crate::stubs::dynamic::TagKeys>,
}

impl TagKeys {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::TagKeys + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::TagKeys>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagKeys> {
        crate::transport::TagKeys::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagKeys> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::TagKeys::new)
    }

    /// Lists all TagKeys for a parent resource.
    pub fn list_tag_keys(&self) -> crate::builders::tag_keys::ListTagKeys {
        crate::builders::tag_keys::ListTagKeys::new(self.inner.clone())
    }

    /// Retrieves a TagKey. This method will return `PERMISSION_DENIED` if the
    /// key does not exist or the user does not have permission to view it.
    pub fn get_tag_key(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_keys::GetTagKey {
        crate::builders::tag_keys::GetTagKey::new(self.inner.clone()).set_name(name.into())
    }

    /// Retrieves a TagKey by its namespaced name.
    /// This method will return `PERMISSION_DENIED` if the key does not exist
    /// or the user does not have permission to view it.
    pub fn get_namespaced_tag_key(&self) -> crate::builders::tag_keys::GetNamespacedTagKey {
        crate::builders::tag_keys::GetNamespacedTagKey::new(self.inner.clone())
    }

    /// Creates a new TagKey. If another request with the same parameters is
    /// sent while the original request is in process, the second request
    /// will receive an error. A maximum of 1000 TagKeys can exist under a parent
    /// at any given time.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagKey, model::CreateTagKeyMetadata>
    /// ) -> Result<model::TagKey> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagKey, model::CreateTagKeyMetadata>
    /// ) -> Result<model::TagKey> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagKey] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::CreateTagKeyMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_keys::CreateTagKey::send
    /// [poller()]: crate::builders::tag_keys::CreateTagKey::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn create_tag_key(&self) -> crate::builders::tag_keys::CreateTagKey {
        crate::builders::tag_keys::CreateTagKey::new(self.inner.clone())
    }

    /// Updates the attributes of the TagKey resource.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagKey, model::UpdateTagKeyMetadata>
    /// ) -> Result<model::TagKey> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagKey, model::UpdateTagKeyMetadata>
    /// ) -> Result<model::TagKey> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagKey] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::UpdateTagKeyMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_keys::UpdateTagKey::send
    /// [poller()]: crate::builders::tag_keys::UpdateTagKey::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn update_tag_key(
        &self,
        tag_key: impl Into<crate::model::TagKey>,
    ) -> crate::builders::tag_keys::UpdateTagKey {
        crate::builders::tag_keys::UpdateTagKey::new(self.inner.clone()).set_tag_key(tag_key.into())
    }

    /// Deletes a TagKey. The TagKey cannot be deleted if it has any child
    /// TagValues.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagKey, model::DeleteTagKeyMetadata>
    /// ) -> Result<model::TagKey> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagKey, model::DeleteTagKeyMetadata>
    /// ) -> Result<model::TagKey> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagKey] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::DeleteTagKeyMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_keys::DeleteTagKey::send
    /// [poller()]: crate::builders::tag_keys::DeleteTagKey::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn delete_tag_key(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_keys::DeleteTagKey {
        crate::builders::tag_keys::DeleteTagKey::new(self.inner.clone()).set_name(name.into())
    }

    /// Gets the access control policy for a TagKey. The returned policy may be
    /// empty if no such policy or resource exists. The `resource` field should
    /// be the TagKey's resource name. For example, "tagKeys/1234".
    /// The caller must have
    /// `cloudresourcemanager.googleapis.com/tagKeys.getIamPolicy` permission on
    /// the specified TagKey.
    pub fn get_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::tag_keys::GetIamPolicy {
        crate::builders::tag_keys::GetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Sets the access control policy on a TagKey, replacing any existing
    /// policy. The `resource` field should be the TagKey's resource name.
    /// For example, "tagKeys/1234".
    /// The caller must have `resourcemanager.tagKeys.setIamPolicy` permission
    /// on the identified tagValue.
    pub fn set_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::tag_keys::SetIamPolicy {
        crate::builders::tag_keys::SetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Returns permissions that a caller has on the specified TagKey.
    /// The `resource` field should be the TagKey's resource name.
    /// For example, "tagKeys/1234".
    ///
    /// There are no permissions required for making this API call.
    pub fn test_iam_permissions(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::tag_keys::TestIamPermissions {
        crate::builders::tag_keys::TestIamPermissions::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_keys::GetOperation {
        crate::builders::tag_keys::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// An implementation of [crate::stubs::TagValues] to make requests with.
///
/// `TagValues` has various configuration parameters, but the defaults
/// are set to work with most applications.
///
/// `TagValues` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TagValues` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
///
/// Allow users to create and manage tag values.
#[derive(Clone, Debug)]
pub struct TagValues {
    inner: Arc<dyn crate::stubs::dynamic::TagValues>,
}

impl TagValues {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::TagValues + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::TagValues>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagValues> {
        crate::transport::TagValues::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::TagValues> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::TagValues::new)
    }

    /// Lists all TagValues for a specific TagKey.
    pub fn list_tag_values(&self) -> crate::builders::tag_values::ListTagValues {
        crate::builders::tag_values::ListTagValues::new(self.inner.clone())
    }

    /// Retrieves a TagValue. This method will return `PERMISSION_DENIED` if the
    /// value does not exist or the user does not have permission to view it.
    pub fn get_tag_value(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_values::GetTagValue {
        crate::builders::tag_values::GetTagValue::new(self.inner.clone()).set_name(name.into())
    }

    /// Retrieves a TagValue by its namespaced name.
    /// This method will return `PERMISSION_DENIED` if the value does not exist
    /// or the user does not have permission to view it.
    pub fn get_namespaced_tag_value(&self) -> crate::builders::tag_values::GetNamespacedTagValue {
        crate::builders::tag_values::GetNamespacedTagValue::new(self.inner.clone())
    }

    /// Creates a TagValue as a child of the specified TagKey. If a another
    /// request with the same parameters is sent while the original request is in
    /// process the second request will receive an error. A maximum of 1000
    /// TagValues can exist under a TagKey at any given time.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagValue, model::CreateTagValueMetadata>
    /// ) -> Result<model::TagValue> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagValue, model::CreateTagValueMetadata>
    /// ) -> Result<model::TagValue> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagValue] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::CreateTagValueMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_values::CreateTagValue::send
    /// [poller()]: crate::builders::tag_values::CreateTagValue::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn create_tag_value(&self) -> crate::builders::tag_values::CreateTagValue {
        crate::builders::tag_values::CreateTagValue::new(self.inner.clone())
    }

    /// Updates the attributes of the TagValue resource.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagValue, model::UpdateTagValueMetadata>
    /// ) -> Result<model::TagValue> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagValue, model::UpdateTagValueMetadata>
    /// ) -> Result<model::TagValue> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagValue] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::UpdateTagValueMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_values::UpdateTagValue::send
    /// [poller()]: crate::builders::tag_values::UpdateTagValue::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn update_tag_value(
        &self,
        tag_value: impl Into<crate::model::TagValue>,
    ) -> crate::builders::tag_values::UpdateTagValue {
        crate::builders::tag_values::UpdateTagValue::new(self.inner.clone())
            .set_tag_value(tag_value.into())
    }

    /// Deletes a TagValue. The TagValue cannot have any bindings when it is
    /// deleted.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagValue, model::DeleteTagValueMetadata>
    /// ) -> Result<model::TagValue> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use gcp_sdk_resourcemanager_v3::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TagValue, model::DeleteTagValueMetadata>
    /// ) -> Result<model::TagValue> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TagValue] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::DeleteTagValueMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::tag_values::DeleteTagValue::send
    /// [poller()]: crate::builders::tag_values::DeleteTagValue::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn delete_tag_value(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_values::DeleteTagValue {
        crate::builders::tag_values::DeleteTagValue::new(self.inner.clone()).set_name(name.into())
    }

    /// Gets the access control policy for a TagValue. The returned policy may be
    /// empty if no such policy or resource exists. The `resource` field should
    /// be the TagValue's resource name. For example: `tagValues/1234`.
    /// The caller must have the
    /// `cloudresourcemanager.googleapis.com/tagValues.getIamPolicy` permission on
    /// the identified TagValue to get the access control policy.
    pub fn get_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::tag_values::GetIamPolicy {
        crate::builders::tag_values::GetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Sets the access control policy on a TagValue, replacing any existing
    /// policy. The `resource` field should be the TagValue's resource name.
    /// For example: `tagValues/1234`.
    /// The caller must have `resourcemanager.tagValues.setIamPolicy` permission
    /// on the identified tagValue.
    pub fn set_iam_policy(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::tag_values::SetIamPolicy {
        crate::builders::tag_values::SetIamPolicy::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Returns permissions that a caller has on the specified TagValue.
    /// The `resource` field should be the TagValue's resource name. For example:
    /// `tagValues/1234`.
    ///
    /// There are no permissions required for making this API call.
    pub fn test_iam_permissions(
        &self,
        resource: impl Into<std::string::String>,
    ) -> crate::builders::tag_values::TestIamPermissions {
        crate::builders::tag_values::TestIamPermissions::new(self.inner.clone())
            .set_resource(resource.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::tag_values::GetOperation {
        crate::builders::tag_values::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}
