// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Encodes the detailed information of a barcode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Barcode {
    /// Format of a barcode.
    /// The supported formats are:
    ///
    /// - `CODE_128`: Code 128 type.
    /// - `CODE_39`: Code 39 type.
    /// - `CODE_93`: Code 93 type.
    /// - `CODABAR`: Codabar type.
    /// - `DATA_MATRIX`: 2D Data Matrix type.
    /// - `ITF`: ITF type.
    /// - `EAN_13`: EAN-13 type.
    /// - `EAN_8`: EAN-8 type.
    /// - `QR_CODE`: 2D QR code type.
    /// - `UPC_A`: UPC-A type.
    /// - `UPC_E`: UPC-E type.
    /// - `PDF417`: PDF417 type.
    /// - `AZTEC`: 2D Aztec code type.
    /// - `DATABAR`: GS1 DataBar code type.
    pub format: std::string::String,

    /// Value format describes the format of the value that a barcode
    /// encodes.
    /// The supported formats are:
    ///
    /// - `CONTACT_INFO`: Contact information.
    /// - `EMAIL`: Email address.
    /// - `ISBN`: ISBN identifier.
    /// - `PHONE`: Phone number.
    /// - `PRODUCT`: Product.
    /// - `SMS`: SMS message.
    /// - `TEXT`: Text string.
    /// - `URL`: URL address.
    /// - `WIFI`: Wifi information.
    /// - `GEO`: Geo-localization.
    /// - `CALENDAR_EVENT`: Calendar event.
    /// - `DRIVER_LICENSE`: Driver's license.
    pub value_format: std::string::String,

    /// Raw value encoded in the barcode.
    /// For example: `'MEBKM:TITLE:Google;URL:<https://www.google.com>;;'`.
    pub raw_value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Barcode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::Barcode::format].
    pub fn set_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [value_format][crate::model::Barcode::value_format].
    pub fn set_value_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value_format = v.into();
        self
    }

    /// Sets the value of [raw_value][crate::model::Barcode::raw_value].
    pub fn set_raw_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.raw_value = v.into();
        self
    }
}

impl wkt::message::Message for Barcode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.Barcode"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Barcode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __format,
            __value_format,
            __raw_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Barcode")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "format" => Ok(__FieldTag::__format),
                            "valueFormat" => Ok(__FieldTag::__value_format),
                            "value_format" => Ok(__FieldTag::__value_format),
                            "rawValue" => Ok(__FieldTag::__raw_value),
                            "raw_value" => Ok(__FieldTag::__raw_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Barcode;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Barcode")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value_format => {
                            if !fields.insert(__FieldTag::__value_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_format",
                                ));
                            }
                            result.value_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__raw_value => {
                            if !fields.insert(__FieldTag::__raw_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_value",
                                ));
                            }
                            result.raw_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Barcode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.format.is_empty() {
            state.serialize_entry("format", &self.format)?;
        }
        if !self.value_format.is_empty() {
            state.serialize_entry("valueFormat", &self.value_format)?;
        }
        if !self.raw_value.is_empty() {
            state.serialize_entry("rawValue", &self.raw_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Barcode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Barcode");
        debug_struct.field("format", &self.format);
        debug_struct.field("value_format", &self.value_format);
        debug_struct.field("raw_value", &self.raw_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Document represents the canonical document resource in Document AI. It is an
/// interchange format that provides insights into documents and allows for
/// collaboration between users and Document AI to iterate and optimize for
/// quality.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Document {
    /// Optional. An internal identifier for document. Should be loggable (no PII).
    pub docid: std::string::String,

    /// An IANA published [media type (MIME
    /// type)](https://www.iana.org/assignments/media-types/media-types.xhtml).
    pub mime_type: std::string::String,

    /// Optional. UTF-8 encoded text in reading order from the document.
    pub text: std::string::String,

    /// Styles for the [Document.text][google.cloud.documentai.v1.Document.text].
    ///
    /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
    #[deprecated]
    pub text_styles: std::vec::Vec<crate::model::document::Style>,

    /// Visual page layout for the [Document][google.cloud.documentai.v1.Document].
    ///
    /// [google.cloud.documentai.v1.Document]: crate::model::Document
    pub pages: std::vec::Vec<crate::model::document::Page>,

    /// A list of entities detected on
    /// [Document.text][google.cloud.documentai.v1.Document.text]. For document
    /// shards, entities in this list may cross shard boundaries.
    ///
    /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
    pub entities: std::vec::Vec<crate::model::document::Entity>,

    /// Placeholder.  Relationship among
    /// [Document.entities][google.cloud.documentai.v1.Document.entities].
    ///
    /// [google.cloud.documentai.v1.Document.entities]: crate::model::Document::entities
    pub entity_relations: std::vec::Vec<crate::model::document::EntityRelation>,

    /// Placeholder.  A list of text corrections made to
    /// [Document.text][google.cloud.documentai.v1.Document.text].  This is usually
    /// used for annotating corrections to OCR mistakes.  Text changes for a given
    /// revision may not overlap with each other.
    ///
    /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
    pub text_changes: std::vec::Vec<crate::model::document::TextChange>,

    /// Information about the sharding if this document is sharded part of a larger
    /// document. If the document is not sharded, this message is not specified.
    pub shard_info: std::option::Option<crate::model::document::ShardInfo>,

    /// Any error that occurred while processing this document.
    pub error: std::option::Option<rpc::model::Status>,

    /// Placeholder. Revision history of this document.
    pub revisions: std::vec::Vec<crate::model::document::Revision>,

    /// Parsed layout of the document.
    pub document_layout: std::option::Option<crate::model::document::DocumentLayout>,

    /// Document chunked based on chunking config.
    pub chunked_document: std::option::Option<crate::model::document::ChunkedDocument>,

    /// Original source document from the user.
    pub source: std::option::Option<crate::model::document::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Document {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [docid][crate::model::Document::docid].
    pub fn set_docid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.docid = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::Document::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [text][crate::model::Document::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [text_styles][crate::model::Document::text_styles].
    #[deprecated]
    pub fn set_text_styles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::Style>,
    {
        use std::iter::Iterator;
        self.text_styles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pages][crate::model::Document::pages].
    pub fn set_pages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::Page>,
    {
        use std::iter::Iterator;
        self.pages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entities][crate::model::Document::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_relations][crate::model::Document::entity_relations].
    pub fn set_entity_relations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::EntityRelation>,
    {
        use std::iter::Iterator;
        self.entity_relations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [text_changes][crate::model::Document::text_changes].
    pub fn set_text_changes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::TextChange>,
    {
        use std::iter::Iterator;
        self.text_changes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [shard_info][crate::model::Document::shard_info].
    pub fn set_shard_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document::ShardInfo>,
    {
        self.shard_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shard_info][crate::model::Document::shard_info].
    pub fn set_or_clear_shard_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document::ShardInfo>,
    {
        self.shard_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::Document::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Document::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revisions][crate::model::Document::revisions].
    pub fn set_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::Revision>,
    {
        use std::iter::Iterator;
        self.revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [document_layout][crate::model::Document::document_layout].
    pub fn set_document_layout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document::DocumentLayout>,
    {
        self.document_layout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_layout][crate::model::Document::document_layout].
    pub fn set_or_clear_document_layout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document::DocumentLayout>,
    {
        self.document_layout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [chunked_document][crate::model::Document::chunked_document].
    pub fn set_chunked_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document::ChunkedDocument>,
    {
        self.chunked_document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [chunked_document][crate::model::Document::chunked_document].
    pub fn set_or_clear_chunked_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document::ChunkedDocument>,
    {
        self.chunked_document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::Document::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::Uri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(crate::model::document::Source::Uri(v.into()));
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(crate::model::document::Source::Content(v.into()));
        self
    }
}

impl wkt::message::Message for Document {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.Document"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Document {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __content,
            __docid,
            __mime_type,
            __text,
            __text_styles,
            __pages,
            __entities,
            __entity_relations,
            __text_changes,
            __shard_info,
            __error,
            __revisions,
            __document_layout,
            __chunked_document,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Document")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "content" => Ok(__FieldTag::__content),
                            "docid" => Ok(__FieldTag::__docid),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "text" => Ok(__FieldTag::__text),
                            "textStyles" => Ok(__FieldTag::__text_styles),
                            "text_styles" => Ok(__FieldTag::__text_styles),
                            "pages" => Ok(__FieldTag::__pages),
                            "entities" => Ok(__FieldTag::__entities),
                            "entityRelations" => Ok(__FieldTag::__entity_relations),
                            "entity_relations" => Ok(__FieldTag::__entity_relations),
                            "textChanges" => Ok(__FieldTag::__text_changes),
                            "text_changes" => Ok(__FieldTag::__text_changes),
                            "shardInfo" => Ok(__FieldTag::__shard_info),
                            "shard_info" => Ok(__FieldTag::__shard_info),
                            "error" => Ok(__FieldTag::__error),
                            "revisions" => Ok(__FieldTag::__revisions),
                            "documentLayout" => Ok(__FieldTag::__document_layout),
                            "document_layout" => Ok(__FieldTag::__document_layout),
                            "chunkedDocument" => Ok(__FieldTag::__chunked_document),
                            "chunked_document" => Ok(__FieldTag::__chunked_document),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Document;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Document")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.Document.uri, latest field was uri",
                                ));
                            }
                            result.source =
                                std::option::Option::Some(crate::model::document::Source::Uri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.Document.content, latest field was content",
                                ));
                            }
                            result.source =
                                std::option::Option::Some(crate::model::document::Source::Content(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__docid => {
                            if !fields.insert(__FieldTag::__docid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for docid",
                                ));
                            }
                            result.docid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_styles => {
                            if !fields.insert(__FieldTag::__text_styles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_styles",
                                ));
                            }
                            result.text_styles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::Style>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pages => {
                            if !fields.insert(__FieldTag::__pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pages",
                                ));
                            }
                            result.pages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::Page>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::Entity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_relations => {
                            if !fields.insert(__FieldTag::__entity_relations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_relations",
                                ));
                            }
                            result.entity_relations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::EntityRelation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_changes => {
                            if !fields.insert(__FieldTag::__text_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_changes",
                                ));
                            }
                            result.text_changes = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::TextChange>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shard_info => {
                            if !fields.insert(__FieldTag::__shard_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shard_info",
                                ));
                            }
                            result.shard_info = map.next_value::<std::option::Option<crate::model::document::ShardInfo>>()?
                                ;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__revisions => {
                            if !fields.insert(__FieldTag::__revisions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revisions",
                                ));
                            }
                            result.revisions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::Revision>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_layout => {
                            if !fields.insert(__FieldTag::__document_layout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_layout",
                                ));
                            }
                            result.document_layout = map.next_value::<std::option::Option<crate::model::document::DocumentLayout>>()?
                                ;
                        }
                        __FieldTag::__chunked_document => {
                            if !fields.insert(__FieldTag::__chunked_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for chunked_document",
                                ));
                            }
                            result.chunked_document = map.next_value::<std::option::Option<crate::model::document::ChunkedDocument>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Document {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if let Some(value) = self.content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(value))?;
        }
        if !self.docid.is_empty() {
            state.serialize_entry("docid", &self.docid)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.text_styles.is_empty() {
            state.serialize_entry("textStyles", &self.text_styles)?;
        }
        if !self.pages.is_empty() {
            state.serialize_entry("pages", &self.pages)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.entity_relations.is_empty() {
            state.serialize_entry("entityRelations", &self.entity_relations)?;
        }
        if !self.text_changes.is_empty() {
            state.serialize_entry("textChanges", &self.text_changes)?;
        }
        if self.shard_info.is_some() {
            state.serialize_entry("shardInfo", &self.shard_info)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.revisions.is_empty() {
            state.serialize_entry("revisions", &self.revisions)?;
        }
        if self.document_layout.is_some() {
            state.serialize_entry("documentLayout", &self.document_layout)?;
        }
        if self.chunked_document.is_some() {
            state.serialize_entry("chunkedDocument", &self.chunked_document)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Document {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Document");
        debug_struct.field("docid", &self.docid);
        debug_struct.field("mime_type", &self.mime_type);
        debug_struct.field("text", &self.text);
        debug_struct.field("text_styles", &self.text_styles);
        debug_struct.field("pages", &self.pages);
        debug_struct.field("entities", &self.entities);
        debug_struct.field("entity_relations", &self.entity_relations);
        debug_struct.field("text_changes", &self.text_changes);
        debug_struct.field("shard_info", &self.shard_info);
        debug_struct.field("error", &self.error);
        debug_struct.field("revisions", &self.revisions);
        debug_struct.field("document_layout", &self.document_layout);
        debug_struct.field("chunked_document", &self.chunked_document);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Document].
pub mod document {
    #[allow(unused_imports)]
    use super::*;

    /// For a large document, sharding may be performed to produce several
    /// document shards. Each document shard contains this field to detail which
    /// shard it is.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ShardInfo {
        /// The 0-based index of this shard.
        pub shard_index: i64,

        /// Total number of shards.
        pub shard_count: i64,

        /// The index of the first character in
        /// [Document.text][google.cloud.documentai.v1.Document.text] in the overall
        /// document global text.
        ///
        /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
        pub text_offset: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ShardInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [shard_index][crate::model::document::ShardInfo::shard_index].
        pub fn set_shard_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.shard_index = v.into();
            self
        }

        /// Sets the value of [shard_count][crate::model::document::ShardInfo::shard_count].
        pub fn set_shard_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.shard_count = v.into();
            self
        }

        /// Sets the value of [text_offset][crate::model::document::ShardInfo::text_offset].
        pub fn set_text_offset<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.text_offset = v.into();
            self
        }
    }

    impl wkt::message::Message for ShardInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.ShardInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ShardInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __shard_index,
                __shard_count,
                __text_offset,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ShardInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "shardIndex" => Ok(__FieldTag::__shard_index),
                                "shard_index" => Ok(__FieldTag::__shard_index),
                                "shardCount" => Ok(__FieldTag::__shard_count),
                                "shard_count" => Ok(__FieldTag::__shard_count),
                                "textOffset" => Ok(__FieldTag::__text_offset),
                                "text_offset" => Ok(__FieldTag::__text_offset),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ShardInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ShardInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__shard_index => {
                                if !fields.insert(__FieldTag::__shard_index) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for shard_index",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.shard_index =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__shard_count => {
                                if !fields.insert(__FieldTag::__shard_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for shard_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.shard_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__text_offset => {
                                if !fields.insert(__FieldTag::__text_offset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_offset",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.text_offset =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ShardInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.shard_index) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("shardIndex", &__With(&self.shard_index))?;
            }
            if !wkt::internal::is_default(&self.shard_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("shardCount", &__With(&self.shard_count))?;
            }
            if !wkt::internal::is_default(&self.text_offset) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("textOffset", &__With(&self.text_offset))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ShardInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ShardInfo");
            debug_struct.field("shard_index", &self.shard_index);
            debug_struct.field("shard_count", &self.shard_count);
            debug_struct.field("text_offset", &self.text_offset);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Annotation for common text style attributes. This adheres to CSS
    /// conventions as much as possible.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Style {
        /// Text anchor indexing into the
        /// [Document.text][google.cloud.documentai.v1.Document.text].
        ///
        /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
        pub text_anchor: std::option::Option<crate::model::document::TextAnchor>,

        /// Text color.
        pub color: std::option::Option<gtype::model::Color>,

        /// Text background color.
        pub background_color: std::option::Option<gtype::model::Color>,

        /// [Font weight](https://www.w3schools.com/cssref/pr_font_weight.asp).
        /// Possible values are `normal`, `bold`, `bolder`, and `lighter`.
        pub font_weight: std::string::String,

        /// [Text style](https://www.w3schools.com/cssref/pr_font_font-style.asp).
        /// Possible values are `normal`, `italic`, and `oblique`.
        pub text_style: std::string::String,

        /// [Text
        /// decoration](https://www.w3schools.com/cssref/pr_text_text-decoration.asp).
        /// Follows CSS standard. \<text-decoration-line\> \<text-decoration-color\>
        /// \<text-decoration-style\>
        pub text_decoration: std::string::String,

        /// Font size.
        pub font_size: std::option::Option<crate::model::document::style::FontSize>,

        /// Font family such as `Arial`, `Times New Roman`.
        /// <https://www.w3schools.com/cssref/pr_font_font-family.asp>
        pub font_family: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Style {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text_anchor][crate::model::document::Style::text_anchor].
        pub fn set_text_anchor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::TextAnchor>,
        {
            self.text_anchor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [text_anchor][crate::model::document::Style::text_anchor].
        pub fn set_or_clear_text_anchor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::TextAnchor>,
        {
            self.text_anchor = v.map(|x| x.into());
            self
        }

        /// Sets the value of [color][crate::model::document::Style::color].
        pub fn set_color<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Color>,
        {
            self.color = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [color][crate::model::document::Style::color].
        pub fn set_or_clear_color<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Color>,
        {
            self.color = v.map(|x| x.into());
            self
        }

        /// Sets the value of [background_color][crate::model::document::Style::background_color].
        pub fn set_background_color<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Color>,
        {
            self.background_color = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [background_color][crate::model::document::Style::background_color].
        pub fn set_or_clear_background_color<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Color>,
        {
            self.background_color = v.map(|x| x.into());
            self
        }

        /// Sets the value of [font_weight][crate::model::document::Style::font_weight].
        pub fn set_font_weight<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.font_weight = v.into();
            self
        }

        /// Sets the value of [text_style][crate::model::document::Style::text_style].
        pub fn set_text_style<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text_style = v.into();
            self
        }

        /// Sets the value of [text_decoration][crate::model::document::Style::text_decoration].
        pub fn set_text_decoration<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.text_decoration = v.into();
            self
        }

        /// Sets the value of [font_size][crate::model::document::Style::font_size].
        pub fn set_font_size<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::style::FontSize>,
        {
            self.font_size = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [font_size][crate::model::document::Style::font_size].
        pub fn set_or_clear_font_size<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::style::FontSize>,
        {
            self.font_size = v.map(|x| x.into());
            self
        }

        /// Sets the value of [font_family][crate::model::document::Style::font_family].
        pub fn set_font_family<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.font_family = v.into();
            self
        }
    }

    impl wkt::message::Message for Style {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.Style"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Style {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text_anchor,
                __color,
                __background_color,
                __font_weight,
                __text_style,
                __text_decoration,
                __font_size,
                __font_family,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Style")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "textAnchor" => Ok(__FieldTag::__text_anchor),
                                "text_anchor" => Ok(__FieldTag::__text_anchor),
                                "color" => Ok(__FieldTag::__color),
                                "backgroundColor" => Ok(__FieldTag::__background_color),
                                "background_color" => Ok(__FieldTag::__background_color),
                                "fontWeight" => Ok(__FieldTag::__font_weight),
                                "font_weight" => Ok(__FieldTag::__font_weight),
                                "textStyle" => Ok(__FieldTag::__text_style),
                                "text_style" => Ok(__FieldTag::__text_style),
                                "textDecoration" => Ok(__FieldTag::__text_decoration),
                                "text_decoration" => Ok(__FieldTag::__text_decoration),
                                "fontSize" => Ok(__FieldTag::__font_size),
                                "font_size" => Ok(__FieldTag::__font_size),
                                "fontFamily" => Ok(__FieldTag::__font_family),
                                "font_family" => Ok(__FieldTag::__font_family),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Style;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Style")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text_anchor => {
                                if !fields.insert(__FieldTag::__text_anchor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_anchor",
                                    ));
                                }
                                result.text_anchor = map.next_value::<std::option::Option<crate::model::document::TextAnchor>>()?
                                    ;
                            }
                            __FieldTag::__color => {
                                if !fields.insert(__FieldTag::__color) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for color",
                                    ));
                                }
                                result.color =
                                    map.next_value::<std::option::Option<gtype::model::Color>>()?;
                            }
                            __FieldTag::__background_color => {
                                if !fields.insert(__FieldTag::__background_color) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for background_color",
                                    ));
                                }
                                result.background_color =
                                    map.next_value::<std::option::Option<gtype::model::Color>>()?;
                            }
                            __FieldTag::__font_weight => {
                                if !fields.insert(__FieldTag::__font_weight) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for font_weight",
                                    ));
                                }
                                result.font_weight = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text_style => {
                                if !fields.insert(__FieldTag::__text_style) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_style",
                                    ));
                                }
                                result.text_style = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text_decoration => {
                                if !fields.insert(__FieldTag::__text_decoration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_decoration",
                                    ));
                                }
                                result.text_decoration = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__font_size => {
                                if !fields.insert(__FieldTag::__font_size) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for font_size",
                                    ));
                                }
                                result.font_size =
                                    map.next_value::<std::option::Option<
                                        crate::model::document::style::FontSize,
                                    >>()?;
                            }
                            __FieldTag::__font_family => {
                                if !fields.insert(__FieldTag::__font_family) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for font_family",
                                    ));
                                }
                                result.font_family = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Style {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.text_anchor.is_some() {
                state.serialize_entry("textAnchor", &self.text_anchor)?;
            }
            if self.color.is_some() {
                state.serialize_entry("color", &self.color)?;
            }
            if self.background_color.is_some() {
                state.serialize_entry("backgroundColor", &self.background_color)?;
            }
            if !self.font_weight.is_empty() {
                state.serialize_entry("fontWeight", &self.font_weight)?;
            }
            if !self.text_style.is_empty() {
                state.serialize_entry("textStyle", &self.text_style)?;
            }
            if !self.text_decoration.is_empty() {
                state.serialize_entry("textDecoration", &self.text_decoration)?;
            }
            if self.font_size.is_some() {
                state.serialize_entry("fontSize", &self.font_size)?;
            }
            if !self.font_family.is_empty() {
                state.serialize_entry("fontFamily", &self.font_family)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Style {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Style");
            debug_struct.field("text_anchor", &self.text_anchor);
            debug_struct.field("color", &self.color);
            debug_struct.field("background_color", &self.background_color);
            debug_struct.field("font_weight", &self.font_weight);
            debug_struct.field("text_style", &self.text_style);
            debug_struct.field("text_decoration", &self.text_decoration);
            debug_struct.field("font_size", &self.font_size);
            debug_struct.field("font_family", &self.font_family);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Style].
    pub mod style {
        #[allow(unused_imports)]
        use super::*;

        /// Font size with unit.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FontSize {
            /// Font size for the text.
            pub size: f32,

            /// Unit for the font size. Follows CSS naming (such as `in`, `px`, and
            /// `pt`).
            pub unit: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FontSize {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [size][crate::model::document::style::FontSize::size].
            pub fn set_size<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.size = v.into();
                self
            }

            /// Sets the value of [unit][crate::model::document::style::FontSize::unit].
            pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.unit = v.into();
                self
            }
        }

        impl wkt::message::Message for FontSize {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Style.FontSize"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FontSize {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __size,
                    __unit,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FontSize")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "size" => Ok(__FieldTag::__size),
                                    "unit" => Ok(__FieldTag::__unit),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FontSize;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FontSize")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__size => {
                                    if !fields.insert(__FieldTag::__size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for size"),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.size = map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__unit => {
                                    if !fields.insert(__FieldTag::__unit) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for unit"),
                                        );
                                    }
                                    result.unit = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for FontSize {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.size) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("size", &__With(&self.size))?;
                }
                if !self.unit.is_empty() {
                    state.serialize_entry("unit", &self.unit)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for FontSize {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("FontSize");
                debug_struct.field("size", &self.size);
                debug_struct.field("unit", &self.unit);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// A page in a [Document][google.cloud.documentai.v1.Document].
    ///
    /// [google.cloud.documentai.v1.Document]: crate::model::Document
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Page {
        /// 1-based index for current
        /// [Page][google.cloud.documentai.v1.Document.Page] in a parent
        /// [Document][google.cloud.documentai.v1.Document]. Useful when a page is
        /// taken out of a [Document][google.cloud.documentai.v1.Document] for
        /// individual processing.
        ///
        /// [google.cloud.documentai.v1.Document]: crate::model::Document
        /// [google.cloud.documentai.v1.Document.Page]: crate::model::document::Page
        pub page_number: i32,

        /// Rendered image for this page. This image is preprocessed to remove any
        /// skew, rotation, and distortions such that the annotation bounding boxes
        /// can be upright and axis-aligned.
        pub image: std::option::Option<crate::model::document::page::Image>,

        /// Transformation matrices that were applied to the original document image
        /// to produce [Page.image][google.cloud.documentai.v1.Document.Page.image].
        ///
        /// [google.cloud.documentai.v1.Document.Page.image]: crate::model::document::Page::image
        pub transforms: std::vec::Vec<crate::model::document::page::Matrix>,

        /// Physical dimension of the page.
        pub dimension: std::option::Option<crate::model::document::page::Dimension>,

        /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for the page.
        ///
        /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
        pub layout: std::option::Option<crate::model::document::page::Layout>,

        /// A list of detected languages together with confidence.
        pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

        /// A list of visually detected text blocks on the page.
        /// A block has a set of lines (collected into paragraphs) that have a common
        /// line-spacing and orientation.
        pub blocks: std::vec::Vec<crate::model::document::page::Block>,

        /// A list of visually detected text paragraphs on the page.
        /// A collection of lines that a human would perceive as a paragraph.
        pub paragraphs: std::vec::Vec<crate::model::document::page::Paragraph>,

        /// A list of visually detected text lines on the page.
        /// A collection of tokens that a human would perceive as a line.
        pub lines: std::vec::Vec<crate::model::document::page::Line>,

        /// A list of visually detected tokens on the page.
        pub tokens: std::vec::Vec<crate::model::document::page::Token>,

        /// A list of detected non-text visual elements e.g. checkbox,
        /// signature etc. on the page.
        pub visual_elements: std::vec::Vec<crate::model::document::page::VisualElement>,

        /// A list of visually detected tables on the page.
        pub tables: std::vec::Vec<crate::model::document::page::Table>,

        /// A list of visually detected form fields on the page.
        pub form_fields: std::vec::Vec<crate::model::document::page::FormField>,

        /// A list of visually detected symbols on the page.
        pub symbols: std::vec::Vec<crate::model::document::page::Symbol>,

        /// A list of detected barcodes.
        pub detected_barcodes: std::vec::Vec<crate::model::document::page::DetectedBarcode>,

        /// Image quality scores.
        pub image_quality_scores:
            std::option::Option<crate::model::document::page::ImageQualityScores>,

        /// The history of this page.
        #[deprecated]
        pub provenance: std::option::Option<crate::model::document::Provenance>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Page {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [page_number][crate::model::document::Page::page_number].
        pub fn set_page_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.page_number = v.into();
            self
        }

        /// Sets the value of [image][crate::model::document::Page::image].
        pub fn set_image<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::page::Image>,
        {
            self.image = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [image][crate::model::document::Page::image].
        pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::page::Image>,
        {
            self.image = v.map(|x| x.into());
            self
        }

        /// Sets the value of [transforms][crate::model::document::Page::transforms].
        pub fn set_transforms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::Matrix>,
        {
            use std::iter::Iterator;
            self.transforms = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dimension][crate::model::document::Page::dimension].
        pub fn set_dimension<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::page::Dimension>,
        {
            self.dimension = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [dimension][crate::model::document::Page::dimension].
        pub fn set_or_clear_dimension<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::page::Dimension>,
        {
            self.dimension = v.map(|x| x.into());
            self
        }

        /// Sets the value of [layout][crate::model::document::Page::layout].
        pub fn set_layout<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::page::Layout>,
        {
            self.layout = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [layout][crate::model::document::Page::layout].
        pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::page::Layout>,
        {
            self.layout = v.map(|x| x.into());
            self
        }

        /// Sets the value of [detected_languages][crate::model::document::Page::detected_languages].
        pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
        {
            use std::iter::Iterator;
            self.detected_languages = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [blocks][crate::model::document::Page::blocks].
        pub fn set_blocks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::Block>,
        {
            use std::iter::Iterator;
            self.blocks = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [paragraphs][crate::model::document::Page::paragraphs].
        pub fn set_paragraphs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::Paragraph>,
        {
            use std::iter::Iterator;
            self.paragraphs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [lines][crate::model::document::Page::lines].
        pub fn set_lines<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::Line>,
        {
            use std::iter::Iterator;
            self.lines = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [tokens][crate::model::document::Page::tokens].
        pub fn set_tokens<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::Token>,
        {
            use std::iter::Iterator;
            self.tokens = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [visual_elements][crate::model::document::Page::visual_elements].
        pub fn set_visual_elements<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::VisualElement>,
        {
            use std::iter::Iterator;
            self.visual_elements = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [tables][crate::model::document::Page::tables].
        pub fn set_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::Table>,
        {
            use std::iter::Iterator;
            self.tables = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [form_fields][crate::model::document::Page::form_fields].
        pub fn set_form_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::FormField>,
        {
            use std::iter::Iterator;
            self.form_fields = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [symbols][crate::model::document::Page::symbols].
        pub fn set_symbols<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::Symbol>,
        {
            use std::iter::Iterator;
            self.symbols = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [detected_barcodes][crate::model::document::Page::detected_barcodes].
        pub fn set_detected_barcodes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page::DetectedBarcode>,
        {
            use std::iter::Iterator;
            self.detected_barcodes = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [image_quality_scores][crate::model::document::Page::image_quality_scores].
        pub fn set_image_quality_scores<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::page::ImageQualityScores>,
        {
            self.image_quality_scores = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [image_quality_scores][crate::model::document::Page::image_quality_scores].
        pub fn set_or_clear_image_quality_scores<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::page::ImageQualityScores>,
        {
            self.image_quality_scores = v.map(|x| x.into());
            self
        }

        /// Sets the value of [provenance][crate::model::document::Page::provenance].
        #[deprecated]
        pub fn set_provenance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::Provenance>,
        {
            self.provenance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [provenance][crate::model::document::Page::provenance].
        #[deprecated]
        pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::Provenance>,
        {
            self.provenance = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Page {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.Page"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Page {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __page_number,
                __image,
                __transforms,
                __dimension,
                __layout,
                __detected_languages,
                __blocks,
                __paragraphs,
                __lines,
                __tokens,
                __visual_elements,
                __tables,
                __form_fields,
                __symbols,
                __detected_barcodes,
                __image_quality_scores,
                __provenance,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Page")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pageNumber" => Ok(__FieldTag::__page_number),
                                "page_number" => Ok(__FieldTag::__page_number),
                                "image" => Ok(__FieldTag::__image),
                                "transforms" => Ok(__FieldTag::__transforms),
                                "dimension" => Ok(__FieldTag::__dimension),
                                "layout" => Ok(__FieldTag::__layout),
                                "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                "detected_languages" => Ok(__FieldTag::__detected_languages),
                                "blocks" => Ok(__FieldTag::__blocks),
                                "paragraphs" => Ok(__FieldTag::__paragraphs),
                                "lines" => Ok(__FieldTag::__lines),
                                "tokens" => Ok(__FieldTag::__tokens),
                                "visualElements" => Ok(__FieldTag::__visual_elements),
                                "visual_elements" => Ok(__FieldTag::__visual_elements),
                                "tables" => Ok(__FieldTag::__tables),
                                "formFields" => Ok(__FieldTag::__form_fields),
                                "form_fields" => Ok(__FieldTag::__form_fields),
                                "symbols" => Ok(__FieldTag::__symbols),
                                "detectedBarcodes" => Ok(__FieldTag::__detected_barcodes),
                                "detected_barcodes" => Ok(__FieldTag::__detected_barcodes),
                                "imageQualityScores" => Ok(__FieldTag::__image_quality_scores),
                                "image_quality_scores" => Ok(__FieldTag::__image_quality_scores),
                                "provenance" => Ok(__FieldTag::__provenance),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Page;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Page")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__page_number => {
                                if !fields.insert(__FieldTag::__page_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for page_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.page_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__image => {
                                if !fields.insert(__FieldTag::__image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for image",
                                    ));
                                }
                                result.image = map.next_value::<std::option::Option<crate::model::document::page::Image>>()?
                                    ;
                            }
                            __FieldTag::__transforms => {
                                if !fields.insert(__FieldTag::__transforms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for transforms",
                                    ));
                                }
                                result.transforms = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::Matrix>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dimension => {
                                if !fields.insert(__FieldTag::__dimension) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dimension",
                                    ));
                                }
                                result.dimension =
                                    map.next_value::<std::option::Option<
                                        crate::model::document::page::Dimension,
                                    >>()?;
                            }
                            __FieldTag::__layout => {
                                if !fields.insert(__FieldTag::__layout) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for layout",
                                    ));
                                }
                                result.layout = map.next_value::<std::option::Option<crate::model::document::page::Layout>>()?
                                    ;
                            }
                            __FieldTag::__detected_languages => {
                                if !fields.insert(__FieldTag::__detected_languages) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detected_languages",
                                    ));
                                }
                                result.detected_languages = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::document::page::DetectedLanguage,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__blocks => {
                                if !fields.insert(__FieldTag::__blocks) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for blocks",
                                    ));
                                }
                                result.blocks = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::Block>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__paragraphs => {
                                if !fields.insert(__FieldTag::__paragraphs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for paragraphs",
                                    ));
                                }
                                result.paragraphs = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::Paragraph>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__lines => {
                                if !fields.insert(__FieldTag::__lines) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lines",
                                    ));
                                }
                                result.lines = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::Line>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tokens => {
                                if !fields.insert(__FieldTag::__tokens) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tokens",
                                    ));
                                }
                                result.tokens = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::Token>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__visual_elements => {
                                if !fields.insert(__FieldTag::__visual_elements) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for visual_elements",
                                    ));
                                }
                                result.visual_elements = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::VisualElement>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tables => {
                                if !fields.insert(__FieldTag::__tables) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tables",
                                    ));
                                }
                                result.tables = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::Table>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__form_fields => {
                                if !fields.insert(__FieldTag::__form_fields) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for form_fields",
                                    ));
                                }
                                result.form_fields = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::FormField>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__symbols => {
                                if !fields.insert(__FieldTag::__symbols) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for symbols",
                                    ));
                                }
                                result.symbols = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page::Symbol>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__detected_barcodes => {
                                if !fields.insert(__FieldTag::__detected_barcodes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detected_barcodes",
                                    ));
                                }
                                result.detected_barcodes = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::document::page::DetectedBarcode,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__image_quality_scores => {
                                if !fields.insert(__FieldTag::__image_quality_scores) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for image_quality_scores",
                                    ));
                                }
                                result.image_quality_scores = map
                                    .next_value::<std::option::Option<
                                        crate::model::document::page::ImageQualityScores,
                                    >>()?;
                            }
                            __FieldTag::__provenance => {
                                if !fields.insert(__FieldTag::__provenance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for provenance",
                                    ));
                                }
                                result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Page {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.page_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("pageNumber", &__With(&self.page_number))?;
            }
            if self.image.is_some() {
                state.serialize_entry("image", &self.image)?;
            }
            if !self.transforms.is_empty() {
                state.serialize_entry("transforms", &self.transforms)?;
            }
            if self.dimension.is_some() {
                state.serialize_entry("dimension", &self.dimension)?;
            }
            if self.layout.is_some() {
                state.serialize_entry("layout", &self.layout)?;
            }
            if !self.detected_languages.is_empty() {
                state.serialize_entry("detectedLanguages", &self.detected_languages)?;
            }
            if !self.blocks.is_empty() {
                state.serialize_entry("blocks", &self.blocks)?;
            }
            if !self.paragraphs.is_empty() {
                state.serialize_entry("paragraphs", &self.paragraphs)?;
            }
            if !self.lines.is_empty() {
                state.serialize_entry("lines", &self.lines)?;
            }
            if !self.tokens.is_empty() {
                state.serialize_entry("tokens", &self.tokens)?;
            }
            if !self.visual_elements.is_empty() {
                state.serialize_entry("visualElements", &self.visual_elements)?;
            }
            if !self.tables.is_empty() {
                state.serialize_entry("tables", &self.tables)?;
            }
            if !self.form_fields.is_empty() {
                state.serialize_entry("formFields", &self.form_fields)?;
            }
            if !self.symbols.is_empty() {
                state.serialize_entry("symbols", &self.symbols)?;
            }
            if !self.detected_barcodes.is_empty() {
                state.serialize_entry("detectedBarcodes", &self.detected_barcodes)?;
            }
            if self.image_quality_scores.is_some() {
                state.serialize_entry("imageQualityScores", &self.image_quality_scores)?;
            }
            if self.provenance.is_some() {
                state.serialize_entry("provenance", &self.provenance)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Page {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Page");
            debug_struct.field("page_number", &self.page_number);
            debug_struct.field("image", &self.image);
            debug_struct.field("transforms", &self.transforms);
            debug_struct.field("dimension", &self.dimension);
            debug_struct.field("layout", &self.layout);
            debug_struct.field("detected_languages", &self.detected_languages);
            debug_struct.field("blocks", &self.blocks);
            debug_struct.field("paragraphs", &self.paragraphs);
            debug_struct.field("lines", &self.lines);
            debug_struct.field("tokens", &self.tokens);
            debug_struct.field("visual_elements", &self.visual_elements);
            debug_struct.field("tables", &self.tables);
            debug_struct.field("form_fields", &self.form_fields);
            debug_struct.field("symbols", &self.symbols);
            debug_struct.field("detected_barcodes", &self.detected_barcodes);
            debug_struct.field("image_quality_scores", &self.image_quality_scores);
            debug_struct.field("provenance", &self.provenance);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Page].
    pub mod page {
        #[allow(unused_imports)]
        use super::*;

        /// Dimension for the page.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Dimension {
            /// Page width.
            pub width: f32,

            /// Page height.
            pub height: f32,

            /// Dimension unit.
            pub unit: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Dimension {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [width][crate::model::document::page::Dimension::width].
            pub fn set_width<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.width = v.into();
                self
            }

            /// Sets the value of [height][crate::model::document::page::Dimension::height].
            pub fn set_height<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.height = v.into();
                self
            }

            /// Sets the value of [unit][crate::model::document::page::Dimension::unit].
            pub fn set_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.unit = v.into();
                self
            }
        }

        impl wkt::message::Message for Dimension {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Dimension"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Dimension {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __width,
                    __height,
                    __unit,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Dimension")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "width" => Ok(__FieldTag::__width),
                                    "height" => Ok(__FieldTag::__height),
                                    "unit" => Ok(__FieldTag::__unit),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Dimension;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Dimension")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__width => {
                                    if !fields.insert(__FieldTag::__width) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for width"),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.width =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__height => {
                                    if !fields.insert(__FieldTag::__height) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for height"),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.height =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__unit => {
                                    if !fields.insert(__FieldTag::__unit) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for unit"),
                                        );
                                    }
                                    result.unit = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Dimension {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.width) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("width", &__With(&self.width))?;
                }
                if !wkt::internal::is_default(&self.height) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("height", &__With(&self.height))?;
                }
                if !self.unit.is_empty() {
                    state.serialize_entry("unit", &self.unit)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Dimension {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Dimension");
                debug_struct.field("width", &self.width);
                debug_struct.field("height", &self.height);
                debug_struct.field("unit", &self.unit);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Rendered image contents for this page.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Image {
            /// Raw byte content of the image.
            pub content: ::bytes::Bytes,

            /// Encoding [media type (MIME
            /// type)](https://www.iana.org/assignments/media-types/media-types.xhtml)
            /// for the image.
            pub mime_type: std::string::String,

            /// Width of the image in pixels.
            pub width: i32,

            /// Height of the image in pixels.
            pub height: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Image {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [content][crate::model::document::page::Image::content].
            pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
                self.content = v.into();
                self
            }

            /// Sets the value of [mime_type][crate::model::document::page::Image::mime_type].
            pub fn set_mime_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.mime_type = v.into();
                self
            }

            /// Sets the value of [width][crate::model::document::page::Image::width].
            pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.width = v.into();
                self
            }

            /// Sets the value of [height][crate::model::document::page::Image::height].
            pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.height = v.into();
                self
            }
        }

        impl wkt::message::Message for Image {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Image"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Image {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __content,
                    __mime_type,
                    __width,
                    __height,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Image")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "content" => Ok(__FieldTag::__content),
                                    "mimeType" => Ok(__FieldTag::__mime_type),
                                    "mime_type" => Ok(__FieldTag::__mime_type),
                                    "width" => Ok(__FieldTag::__width),
                                    "height" => Ok(__FieldTag::__height),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Image;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Image")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__content => {
                                    if !fields.insert(__FieldTag::__content) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for content",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<::bytes::Bytes>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<serde_with::base64::Base64>,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.content =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__mime_type => {
                                    if !fields.insert(__FieldTag::__mime_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for mime_type",
                                            ),
                                        );
                                    }
                                    result.mime_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__width => {
                                    if !fields.insert(__FieldTag::__width) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for width"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.width =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__height => {
                                    if !fields.insert(__FieldTag::__height) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for height"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.height =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Image {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.content.is_empty() {
                    struct __With<'a>(&'a ::bytes::Bytes);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<serde_with::base64::Base64>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("content", &__With(&self.content))?;
                }
                if !self.mime_type.is_empty() {
                    state.serialize_entry("mimeType", &self.mime_type)?;
                }
                if !wkt::internal::is_default(&self.width) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("width", &__With(&self.width))?;
                }
                if !wkt::internal::is_default(&self.height) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("height", &__With(&self.height))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Image {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Image");
                debug_struct.field("content", &self.content);
                debug_struct.field("mime_type", &self.mime_type);
                debug_struct.field("width", &self.width);
                debug_struct.field("height", &self.height);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Representation for transformation matrix, intended to be compatible and
        /// used with OpenCV format for image manipulation.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Matrix {
            /// Number of rows in the matrix.
            pub rows: i32,

            /// Number of columns in the matrix.
            pub cols: i32,

            /// This encodes information about what data type the matrix uses.
            /// For example, 0 (CV_8U) is an unsigned 8-bit image. For the full list
            /// of OpenCV primitive data types, please refer to
            /// <https://docs.opencv.org/4.3.0/d1/d1b/group__core__hal__interface.html>
            pub r#type: i32,

            /// The matrix data.
            pub data: ::bytes::Bytes,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Matrix {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [rows][crate::model::document::page::Matrix::rows].
            pub fn set_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.rows = v.into();
                self
            }

            /// Sets the value of [cols][crate::model::document::page::Matrix::cols].
            pub fn set_cols<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cols = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::document::page::Matrix::type].
            pub fn set_type<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [data][crate::model::document::page::Matrix::data].
            pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
                self.data = v.into();
                self
            }
        }

        impl wkt::message::Message for Matrix {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Matrix"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Matrix {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __rows,
                    __cols,
                    __type,
                    __data,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Matrix")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "rows" => Ok(__FieldTag::__rows),
                                    "cols" => Ok(__FieldTag::__cols),
                                    "type" => Ok(__FieldTag::__type),
                                    "data" => Ok(__FieldTag::__data),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Matrix;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Matrix")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__rows => {
                                    if !fields.insert(__FieldTag::__rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for rows"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.rows = map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__cols => {
                                    if !fields.insert(__FieldTag::__cols) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for cols"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.cols = map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.r#type =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__data => {
                                    if !fields.insert(__FieldTag::__data) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for data"),
                                        );
                                    }
                                    struct __With(std::option::Option<::bytes::Bytes>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<serde_with::base64::Base64>,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Matrix {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.rows) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("rows", &__With(&self.rows))?;
                }
                if !wkt::internal::is_default(&self.cols) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("cols", &__With(&self.cols))?;
                }
                if !wkt::internal::is_default(&self.r#type) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("type", &__With(&self.r#type))?;
                }
                if !self.data.is_empty() {
                    struct __With<'a>(&'a ::bytes::Bytes);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<serde_with::base64::Base64>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("data", &__With(&self.data))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Matrix {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Matrix");
                debug_struct.field("rows", &self.rows);
                debug_struct.field("cols", &self.cols);
                debug_struct.field("r#type", &self.r#type);
                debug_struct.field("data", &self.data);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Visual element describing a layout unit on a page.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Layout {
            /// Text anchor indexing into the
            /// [Document.text][google.cloud.documentai.v1.Document.text].
            ///
            /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
            pub text_anchor: std::option::Option<crate::model::document::TextAnchor>,

            /// Confidence of the current
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] within
            /// context of the object this layout is for. e.g. confidence can be for a
            /// single token, a table, a visual element, etc. depending on context.
            /// Range `[0, 1]`.
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            pub confidence: f32,

            /// The bounding polygon for the
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

            /// Detected orientation for the
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            pub orientation: crate::model::document::page::layout::Orientation,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Layout {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [text_anchor][crate::model::document::page::Layout::text_anchor].
            pub fn set_text_anchor<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::TextAnchor>,
            {
                self.text_anchor = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [text_anchor][crate::model::document::page::Layout::text_anchor].
            pub fn set_or_clear_text_anchor<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::TextAnchor>,
            {
                self.text_anchor = v.map(|x| x.into());
                self
            }

            /// Sets the value of [confidence][crate::model::document::page::Layout::confidence].
            pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.confidence = v.into();
                self
            }

            /// Sets the value of [bounding_poly][crate::model::document::page::Layout::bounding_poly].
            pub fn set_bounding_poly<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::BoundingPoly>,
            {
                self.bounding_poly = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [bounding_poly][crate::model::document::page::Layout::bounding_poly].
            pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::BoundingPoly>,
            {
                self.bounding_poly = v.map(|x| x.into());
                self
            }

            /// Sets the value of [orientation][crate::model::document::page::Layout::orientation].
            pub fn set_orientation<
                T: std::convert::Into<crate::model::document::page::layout::Orientation>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.orientation = v.into();
                self
            }
        }

        impl wkt::message::Message for Layout {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Layout"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Layout {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text_anchor,
                    __confidence,
                    __bounding_poly,
                    __orientation,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Layout")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "textAnchor" => Ok(__FieldTag::__text_anchor),
                                    "text_anchor" => Ok(__FieldTag::__text_anchor),
                                    "confidence" => Ok(__FieldTag::__confidence),
                                    "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                                    "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                                    "orientation" => Ok(__FieldTag::__orientation),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Layout;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Layout")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text_anchor => {
                                    if !fields.insert(__FieldTag::__text_anchor) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for text_anchor",
                                            ),
                                        );
                                    }
                                    result.text_anchor = map.next_value::<std::option::Option<crate::model::document::TextAnchor>>()?
                                        ;
                                }
                                __FieldTag::__confidence => {
                                    if !fields.insert(__FieldTag::__confidence) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidence",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.confidence =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__bounding_poly => {
                                    if !fields.insert(__FieldTag::__bounding_poly) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bounding_poly",
                                            ),
                                        );
                                    }
                                    result.bounding_poly = map.next_value::<std::option::Option<crate::model::BoundingPoly>>()?
                                        ;
                                }
                                __FieldTag::__orientation => {
                                    if !fields.insert(__FieldTag::__orientation) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for orientation",
                                            ),
                                        );
                                    }
                                    result.orientation = map
                                        .next_value::<std::option::Option<
                                            crate::model::document::page::layout::Orientation,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Layout {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.text_anchor.is_some() {
                    state.serialize_entry("textAnchor", &self.text_anchor)?;
                }
                if !wkt::internal::is_default(&self.confidence) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("confidence", &__With(&self.confidence))?;
                }
                if self.bounding_poly.is_some() {
                    state.serialize_entry("boundingPoly", &self.bounding_poly)?;
                }
                if !wkt::internal::is_default(&self.orientation) {
                    state.serialize_entry("orientation", &self.orientation)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Layout {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Layout");
                debug_struct.field("text_anchor", &self.text_anchor);
                debug_struct.field("confidence", &self.confidence);
                debug_struct.field("bounding_poly", &self.bounding_poly);
                debug_struct.field("orientation", &self.orientation);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Layout].
        pub mod layout {
            #[allow(unused_imports)]
            use super::*;

            /// Detected human reading orientation.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Orientation {
                /// Unspecified orientation.
                Unspecified,
                /// Orientation is aligned with page up.
                PageUp,
                /// Orientation is aligned with page right.
                /// Turn the head 90 degrees clockwise from upright to read.
                PageRight,
                /// Orientation is aligned with page down.
                /// Turn the head 180 degrees from upright to read.
                PageDown,
                /// Orientation is aligned with page left.
                /// Turn the head 90 degrees counterclockwise from upright to read.
                PageLeft,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Orientation::value] or
                /// [Orientation::name].
                UnknownValue(orientation::UnknownValue),
            }

            #[doc(hidden)]
            pub mod orientation {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Orientation {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::PageUp => std::option::Option::Some(1),
                        Self::PageRight => std::option::Option::Some(2),
                        Self::PageDown => std::option::Option::Some(3),
                        Self::PageLeft => std::option::Option::Some(4),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("ORIENTATION_UNSPECIFIED"),
                        Self::PageUp => std::option::Option::Some("PAGE_UP"),
                        Self::PageRight => std::option::Option::Some("PAGE_RIGHT"),
                        Self::PageDown => std::option::Option::Some("PAGE_DOWN"),
                        Self::PageLeft => std::option::Option::Some("PAGE_LEFT"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Orientation {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Orientation {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Orientation {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::PageUp,
                        2 => Self::PageRight,
                        3 => Self::PageDown,
                        4 => Self::PageLeft,
                        _ => Self::UnknownValue(orientation::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Orientation {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "ORIENTATION_UNSPECIFIED" => Self::Unspecified,
                        "PAGE_UP" => Self::PageUp,
                        "PAGE_RIGHT" => Self::PageRight,
                        "PAGE_DOWN" => Self::PageDown,
                        "PAGE_LEFT" => Self::PageLeft,
                        _ => Self::UnknownValue(orientation::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Orientation {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::PageUp => serializer.serialize_i32(1),
                        Self::PageRight => serializer.serialize_i32(2),
                        Self::PageDown => serializer.serialize_i32(3),
                        Self::PageLeft => serializer.serialize_i32(4),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Orientation {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Orientation>::new(
                        ".google.cloud.documentai.v1.Document.Page.Layout.Orientation",
                    ))
                }
            }
        }

        /// A block has a set of lines (collected into paragraphs) that have a
        /// common line-spacing and orientation.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Block {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [Block][google.cloud.documentai.v1.Document.Page.Block].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Block]: crate::model::document::page::Block
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// A list of detected languages together with confidence.
            pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            /// The history of this annotation.
            #[deprecated]
            pub provenance: std::option::Option<crate::model::document::Provenance>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Block {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::Block::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::Block::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [detected_languages][crate::model::document::page::Block::detected_languages].
            pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [provenance][crate::model::document::page::Block::provenance].
            #[deprecated]
            pub fn set_provenance<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [provenance][crate::model::document::page::Block::provenance].
            #[deprecated]
            pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Block {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Block"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Block {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __detected_languages,
                    __provenance,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Block")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                    "detected_languages" => Ok(__FieldTag::__detected_languages),
                                    "provenance" => Ok(__FieldTag::__provenance),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Block;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Block")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__detected_languages => {
                                    if !fields.insert(__FieldTag::__detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_languages",
                                            ),
                                        );
                                    }
                                    result.detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__provenance => {
                                    if !fields.insert(__FieldTag::__provenance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for provenance",
                                            ),
                                        );
                                    }
                                    result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Block {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if !self.detected_languages.is_empty() {
                    state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                }
                if self.provenance.is_some() {
                    state.serialize_entry("provenance", &self.provenance)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Block {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Block");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("detected_languages", &self.detected_languages);
                debug_struct.field("provenance", &self.provenance);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// A collection of lines that a human would perceive as a paragraph.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Paragraph {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [Paragraph][google.cloud.documentai.v1.Document.Page.Paragraph].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            /// [google.cloud.documentai.v1.Document.Page.Paragraph]: crate::model::document::page::Paragraph
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// A list of detected languages together with confidence.
            pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            /// The  history of this annotation.
            #[deprecated]
            pub provenance: std::option::Option<crate::model::document::Provenance>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Paragraph {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::Paragraph::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::Paragraph::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [detected_languages][crate::model::document::page::Paragraph::detected_languages].
            pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [provenance][crate::model::document::page::Paragraph::provenance].
            #[deprecated]
            pub fn set_provenance<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [provenance][crate::model::document::page::Paragraph::provenance].
            #[deprecated]
            pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Paragraph {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Paragraph"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Paragraph {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __detected_languages,
                    __provenance,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Paragraph")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                    "detected_languages" => Ok(__FieldTag::__detected_languages),
                                    "provenance" => Ok(__FieldTag::__provenance),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Paragraph;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Paragraph")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__detected_languages => {
                                    if !fields.insert(__FieldTag::__detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_languages",
                                            ),
                                        );
                                    }
                                    result.detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__provenance => {
                                    if !fields.insert(__FieldTag::__provenance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for provenance",
                                            ),
                                        );
                                    }
                                    result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Paragraph {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if !self.detected_languages.is_empty() {
                    state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                }
                if self.provenance.is_some() {
                    state.serialize_entry("provenance", &self.provenance)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Paragraph {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Paragraph");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("detected_languages", &self.detected_languages);
                debug_struct.field("provenance", &self.provenance);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// A collection of tokens that a human would perceive as a line.
        /// Does not cross column boundaries, can be horizontal, vertical, etc.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Line {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [Line][google.cloud.documentai.v1.Document.Page.Line].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            /// [google.cloud.documentai.v1.Document.Page.Line]: crate::model::document::page::Line
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// A list of detected languages together with confidence.
            pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            /// The  history of this annotation.
            #[deprecated]
            pub provenance: std::option::Option<crate::model::document::Provenance>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Line {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::Line::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::Line::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [detected_languages][crate::model::document::page::Line::detected_languages].
            pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [provenance][crate::model::document::page::Line::provenance].
            #[deprecated]
            pub fn set_provenance<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [provenance][crate::model::document::page::Line::provenance].
            #[deprecated]
            pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Line {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Line"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Line {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __detected_languages,
                    __provenance,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Line")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                    "detected_languages" => Ok(__FieldTag::__detected_languages),
                                    "provenance" => Ok(__FieldTag::__provenance),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Line;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Line")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__detected_languages => {
                                    if !fields.insert(__FieldTag::__detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_languages",
                                            ),
                                        );
                                    }
                                    result.detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__provenance => {
                                    if !fields.insert(__FieldTag::__provenance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for provenance",
                                            ),
                                        );
                                    }
                                    result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Line {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if !self.detected_languages.is_empty() {
                    state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                }
                if self.provenance.is_some() {
                    state.serialize_entry("provenance", &self.provenance)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Line {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Line");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("detected_languages", &self.detected_languages);
                debug_struct.field("provenance", &self.provenance);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// A detected token.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Token {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [Token][google.cloud.documentai.v1.Document.Page.Token].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            /// [google.cloud.documentai.v1.Document.Page.Token]: crate::model::document::page::Token
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// Detected break at the end of a
            /// [Token][google.cloud.documentai.v1.Document.Page.Token].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Token]: crate::model::document::page::Token
            pub detected_break:
                std::option::Option<crate::model::document::page::token::DetectedBreak>,

            /// A list of detected languages together with confidence.
            pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            /// The history of this annotation.
            #[deprecated]
            pub provenance: std::option::Option<crate::model::document::Provenance>,

            /// Text style attributes.
            pub style_info: std::option::Option<crate::model::document::page::token::StyleInfo>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Token {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::Token::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::Token::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [detected_break][crate::model::document::page::Token::detected_break].
            pub fn set_detected_break<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::token::DetectedBreak>,
            {
                self.detected_break = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [detected_break][crate::model::document::page::Token::detected_break].
            pub fn set_or_clear_detected_break<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::token::DetectedBreak>,
            {
                self.detected_break = v.map(|x| x.into());
                self
            }

            /// Sets the value of [detected_languages][crate::model::document::page::Token::detected_languages].
            pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [provenance][crate::model::document::page::Token::provenance].
            #[deprecated]
            pub fn set_provenance<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [provenance][crate::model::document::page::Token::provenance].
            #[deprecated]
            pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = v.map(|x| x.into());
                self
            }

            /// Sets the value of [style_info][crate::model::document::page::Token::style_info].
            pub fn set_style_info<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::token::StyleInfo>,
            {
                self.style_info = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [style_info][crate::model::document::page::Token::style_info].
            pub fn set_or_clear_style_info<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::token::StyleInfo>,
            {
                self.style_info = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Token {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Token"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Token {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __detected_break,
                    __detected_languages,
                    __provenance,
                    __style_info,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Token")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "detectedBreak" => Ok(__FieldTag::__detected_break),
                                    "detected_break" => Ok(__FieldTag::__detected_break),
                                    "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                    "detected_languages" => Ok(__FieldTag::__detected_languages),
                                    "provenance" => Ok(__FieldTag::__provenance),
                                    "styleInfo" => Ok(__FieldTag::__style_info),
                                    "style_info" => Ok(__FieldTag::__style_info),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Token;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Token")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__detected_break => {
                                    if !fields.insert(__FieldTag::__detected_break) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_break",
                                            ),
                                        );
                                    }
                                    result.detected_break = map
                                        .next_value::<std::option::Option<
                                            crate::model::document::page::token::DetectedBreak,
                                        >>()?;
                                }
                                __FieldTag::__detected_languages => {
                                    if !fields.insert(__FieldTag::__detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_languages",
                                            ),
                                        );
                                    }
                                    result.detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__provenance => {
                                    if !fields.insert(__FieldTag::__provenance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for provenance",
                                            ),
                                        );
                                    }
                                    result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                        ;
                                }
                                __FieldTag::__style_info => {
                                    if !fields.insert(__FieldTag::__style_info) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for style_info",
                                            ),
                                        );
                                    }
                                    result.style_info = map
                                        .next_value::<std::option::Option<
                                            crate::model::document::page::token::StyleInfo,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Token {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if self.detected_break.is_some() {
                    state.serialize_entry("detectedBreak", &self.detected_break)?;
                }
                if !self.detected_languages.is_empty() {
                    state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                }
                if self.provenance.is_some() {
                    state.serialize_entry("provenance", &self.provenance)?;
                }
                if self.style_info.is_some() {
                    state.serialize_entry("styleInfo", &self.style_info)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Token {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Token");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("detected_break", &self.detected_break);
                debug_struct.field("detected_languages", &self.detected_languages);
                debug_struct.field("provenance", &self.provenance);
                debug_struct.field("style_info", &self.style_info);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Token].
        pub mod token {
            #[allow(unused_imports)]
            use super::*;

            /// Detected break at the end of a
            /// [Token][google.cloud.documentai.v1.Document.Page.Token].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Token]: crate::model::document::page::Token
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct DetectedBreak {
                /// Detected break type.
                pub r#type: crate::model::document::page::token::detected_break::Type,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DetectedBreak {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [r#type][crate::model::document::page::token::DetectedBreak::type].
                pub fn set_type<
                    T: std::convert::Into<crate::model::document::page::token::detected_break::Type>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.r#type = v.into();
                    self
                }
            }

            impl wkt::message::Message for DetectedBreak {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Token.DetectedBreak"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for DetectedBreak {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __type,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for DetectedBreak")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "type" => Ok(__FieldTag::__type),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = DetectedBreak;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct DetectedBreak")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__type => {
                                        if !fields.insert(__FieldTag::__type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for type",
                                                ),
                                            );
                                        }
                                        result.r#type = map.next_value::<std::option::Option<crate::model::document::page::token::detected_break::Type>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for DetectedBreak {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.r#type) {
                        state.serialize_entry("type", &self.r#type)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for DetectedBreak {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("DetectedBreak");
                    debug_struct.field("r#type", &self.r#type);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Defines additional types related to [DetectedBreak].
            pub mod detected_break {
                #[allow(unused_imports)]
                use super::*;

                /// Enum to denote the type of break found.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Type {
                    /// Unspecified break type.
                    Unspecified,
                    /// A single whitespace.
                    Space,
                    /// A wider whitespace.
                    WideSpace,
                    /// A hyphen that indicates that a token has been split across lines.
                    Hyphen,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [Type::value] or
                    /// [Type::name].
                    UnknownValue(r#type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod r#type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl Type {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Space => std::option::Option::Some(1),
                            Self::WideSpace => std::option::Option::Some(2),
                            Self::Hyphen => std::option::Option::Some(3),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                            Self::Space => std::option::Option::Some("SPACE"),
                            Self::WideSpace => std::option::Option::Some("WIDE_SPACE"),
                            Self::Hyphen => std::option::Option::Some("HYPHEN"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for Type {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for Type {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for Type {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Space,
                            2 => Self::WideSpace,
                            3 => Self::Hyphen,
                            _ => Self::UnknownValue(r#type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for Type {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "TYPE_UNSPECIFIED" => Self::Unspecified,
                            "SPACE" => Self::Space,
                            "WIDE_SPACE" => Self::WideSpace,
                            "HYPHEN" => Self::Hyphen,
                            _ => Self::UnknownValue(r#type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for Type {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Space => serializer.serialize_i32(1),
                            Self::WideSpace => serializer.serialize_i32(2),
                            Self::Hyphen => serializer.serialize_i32(3),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for Type {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                            ".google.cloud.documentai.v1.Document.Page.Token.DetectedBreak.Type",
                        ))
                    }
                }
            }

            /// Font and other text style attributes.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct StyleInfo {
                /// Font size in points (`1` point is `` inches).
                pub font_size: i32,

                /// Font size in pixels, equal to _unrounded
                /// [font_size][google.cloud.documentai.v1.Document.Page.Token.StyleInfo.font_size]_
                ///
                /// * _resolution_  `72.0`.
                ///
                /// [google.cloud.documentai.v1.Document.Page.Token.StyleInfo.font_size]: crate::model::document::page::token::StyleInfo::font_size
                pub pixel_font_size: f64,

                /// Letter spacing in points.
                pub letter_spacing: f64,

                /// Name or style of the font.
                pub font_type: std::string::String,

                /// Whether the text is bold (equivalent to
                /// [font_weight][google.cloud.documentai.v1.Document.Page.Token.StyleInfo.font_weight]
                /// is at least `700`).
                ///
                /// [google.cloud.documentai.v1.Document.Page.Token.StyleInfo.font_weight]: crate::model::document::page::token::StyleInfo::font_weight
                pub bold: bool,

                /// Whether the text is italic.
                pub italic: bool,

                /// Whether the text is underlined.
                pub underlined: bool,

                /// Whether the text is strikethrough. This feature is not supported yet.
                pub strikeout: bool,

                /// Whether the text is a subscript. This feature is not supported yet.
                pub subscript: bool,

                /// Whether the text is a superscript. This feature is not supported yet.
                pub superscript: bool,

                /// Whether the text is in small caps. This feature is not supported yet.
                pub smallcaps: bool,

                /// TrueType weight on a scale `100` (thin) to `1000` (ultra-heavy).
                /// Normal is `400`, bold is `700`.
                pub font_weight: i32,

                /// Whether the text is handwritten.
                pub handwritten: bool,

                /// Color of the text.
                pub text_color: std::option::Option<gtype::model::Color>,

                /// Color of the background.
                pub background_color: std::option::Option<gtype::model::Color>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl StyleInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [font_size][crate::model::document::page::token::StyleInfo::font_size].
                pub fn set_font_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.font_size = v.into();
                    self
                }

                /// Sets the value of [pixel_font_size][crate::model::document::page::token::StyleInfo::pixel_font_size].
                pub fn set_pixel_font_size<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                    self.pixel_font_size = v.into();
                    self
                }

                /// Sets the value of [letter_spacing][crate::model::document::page::token::StyleInfo::letter_spacing].
                pub fn set_letter_spacing<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                    self.letter_spacing = v.into();
                    self
                }

                /// Sets the value of [font_type][crate::model::document::page::token::StyleInfo::font_type].
                pub fn set_font_type<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.font_type = v.into();
                    self
                }

                /// Sets the value of [bold][crate::model::document::page::token::StyleInfo::bold].
                pub fn set_bold<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.bold = v.into();
                    self
                }

                /// Sets the value of [italic][crate::model::document::page::token::StyleInfo::italic].
                pub fn set_italic<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.italic = v.into();
                    self
                }

                /// Sets the value of [underlined][crate::model::document::page::token::StyleInfo::underlined].
                pub fn set_underlined<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.underlined = v.into();
                    self
                }

                /// Sets the value of [strikeout][crate::model::document::page::token::StyleInfo::strikeout].
                pub fn set_strikeout<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.strikeout = v.into();
                    self
                }

                /// Sets the value of [subscript][crate::model::document::page::token::StyleInfo::subscript].
                pub fn set_subscript<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.subscript = v.into();
                    self
                }

                /// Sets the value of [superscript][crate::model::document::page::token::StyleInfo::superscript].
                pub fn set_superscript<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.superscript = v.into();
                    self
                }

                /// Sets the value of [smallcaps][crate::model::document::page::token::StyleInfo::smallcaps].
                pub fn set_smallcaps<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.smallcaps = v.into();
                    self
                }

                /// Sets the value of [font_weight][crate::model::document::page::token::StyleInfo::font_weight].
                pub fn set_font_weight<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.font_weight = v.into();
                    self
                }

                /// Sets the value of [handwritten][crate::model::document::page::token::StyleInfo::handwritten].
                pub fn set_handwritten<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.handwritten = v.into();
                    self
                }

                /// Sets the value of [text_color][crate::model::document::page::token::StyleInfo::text_color].
                pub fn set_text_color<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<gtype::model::Color>,
                {
                    self.text_color = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [text_color][crate::model::document::page::token::StyleInfo::text_color].
                pub fn set_or_clear_text_color<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<gtype::model::Color>,
                {
                    self.text_color = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [background_color][crate::model::document::page::token::StyleInfo::background_color].
                pub fn set_background_color<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<gtype::model::Color>,
                {
                    self.background_color = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [background_color][crate::model::document::page::token::StyleInfo::background_color].
                pub fn set_or_clear_background_color<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<gtype::model::Color>,
                {
                    self.background_color = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for StyleInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Token.StyleInfo"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for StyleInfo {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __font_size,
                        __pixel_font_size,
                        __letter_spacing,
                        __font_type,
                        __bold,
                        __italic,
                        __underlined,
                        __strikeout,
                        __subscript,
                        __superscript,
                        __smallcaps,
                        __font_weight,
                        __handwritten,
                        __text_color,
                        __background_color,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for StyleInfo")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "fontSize" => Ok(__FieldTag::__font_size),
                                        "font_size" => Ok(__FieldTag::__font_size),
                                        "pixelFontSize" => Ok(__FieldTag::__pixel_font_size),
                                        "pixel_font_size" => Ok(__FieldTag::__pixel_font_size),
                                        "letterSpacing" => Ok(__FieldTag::__letter_spacing),
                                        "letter_spacing" => Ok(__FieldTag::__letter_spacing),
                                        "fontType" => Ok(__FieldTag::__font_type),
                                        "font_type" => Ok(__FieldTag::__font_type),
                                        "bold" => Ok(__FieldTag::__bold),
                                        "italic" => Ok(__FieldTag::__italic),
                                        "underlined" => Ok(__FieldTag::__underlined),
                                        "strikeout" => Ok(__FieldTag::__strikeout),
                                        "subscript" => Ok(__FieldTag::__subscript),
                                        "superscript" => Ok(__FieldTag::__superscript),
                                        "smallcaps" => Ok(__FieldTag::__smallcaps),
                                        "fontWeight" => Ok(__FieldTag::__font_weight),
                                        "font_weight" => Ok(__FieldTag::__font_weight),
                                        "handwritten" => Ok(__FieldTag::__handwritten),
                                        "textColor" => Ok(__FieldTag::__text_color),
                                        "text_color" => Ok(__FieldTag::__text_color),
                                        "backgroundColor" => Ok(__FieldTag::__background_color),
                                        "background_color" => Ok(__FieldTag::__background_color),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = StyleInfo;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct StyleInfo")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__font_size => {
                                        if !fields.insert(__FieldTag::__font_size) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for font_size",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.font_size =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__pixel_font_size => {
                                        if !fields.insert(__FieldTag::__pixel_font_size) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for pixel_font_size",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.pixel_font_size =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__letter_spacing => {
                                        if !fields.insert(__FieldTag::__letter_spacing) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for letter_spacing",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.letter_spacing =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__font_type => {
                                        if !fields.insert(__FieldTag::__font_type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for font_type",
                                                ),
                                            );
                                        }
                                        result.font_type = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__bold => {
                                        if !fields.insert(__FieldTag::__bold) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for bold",
                                                ),
                                            );
                                        }
                                        result.bold = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__italic => {
                                        if !fields.insert(__FieldTag::__italic) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for italic",
                                                ),
                                            );
                                        }
                                        result.italic = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__underlined => {
                                        if !fields.insert(__FieldTag::__underlined) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for underlined",
                                                ),
                                            );
                                        }
                                        result.underlined = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__strikeout => {
                                        if !fields.insert(__FieldTag::__strikeout) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for strikeout",
                                                ),
                                            );
                                        }
                                        result.strikeout = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__subscript => {
                                        if !fields.insert(__FieldTag::__subscript) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for subscript",
                                                ),
                                            );
                                        }
                                        result.subscript = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__superscript => {
                                        if !fields.insert(__FieldTag::__superscript) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for superscript",
                                                ),
                                            );
                                        }
                                        result.superscript = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__smallcaps => {
                                        if !fields.insert(__FieldTag::__smallcaps) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for smallcaps",
                                                ),
                                            );
                                        }
                                        result.smallcaps = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__font_weight => {
                                        if !fields.insert(__FieldTag::__font_weight) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for font_weight",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.font_weight =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__handwritten => {
                                        if !fields.insert(__FieldTag::__handwritten) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for handwritten",
                                                ),
                                            );
                                        }
                                        result.handwritten = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__text_color => {
                                        if !fields.insert(__FieldTag::__text_color) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for text_color",
                                                ),
                                            );
                                        }
                                        result.text_color = map
                                            .next_value::<std::option::Option<gtype::model::Color>>(
                                            )?;
                                    }
                                    __FieldTag::__background_color => {
                                        if !fields.insert(__FieldTag::__background_color) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for background_color",
                                                ),
                                            );
                                        }
                                        result.background_color = map
                                            .next_value::<std::option::Option<gtype::model::Color>>(
                                            )?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for StyleInfo {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.font_size) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("fontSize", &__With(&self.font_size))?;
                    }
                    if !wkt::internal::is_default(&self.pixel_font_size) {
                        struct __With<'a>(&'a f64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("pixelFontSize", &__With(&self.pixel_font_size))?;
                    }
                    if !wkt::internal::is_default(&self.letter_spacing) {
                        struct __With<'a>(&'a f64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("letterSpacing", &__With(&self.letter_spacing))?;
                    }
                    if !self.font_type.is_empty() {
                        state.serialize_entry("fontType", &self.font_type)?;
                    }
                    if !wkt::internal::is_default(&self.bold) {
                        state.serialize_entry("bold", &self.bold)?;
                    }
                    if !wkt::internal::is_default(&self.italic) {
                        state.serialize_entry("italic", &self.italic)?;
                    }
                    if !wkt::internal::is_default(&self.underlined) {
                        state.serialize_entry("underlined", &self.underlined)?;
                    }
                    if !wkt::internal::is_default(&self.strikeout) {
                        state.serialize_entry("strikeout", &self.strikeout)?;
                    }
                    if !wkt::internal::is_default(&self.subscript) {
                        state.serialize_entry("subscript", &self.subscript)?;
                    }
                    if !wkt::internal::is_default(&self.superscript) {
                        state.serialize_entry("superscript", &self.superscript)?;
                    }
                    if !wkt::internal::is_default(&self.smallcaps) {
                        state.serialize_entry("smallcaps", &self.smallcaps)?;
                    }
                    if !wkt::internal::is_default(&self.font_weight) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("fontWeight", &__With(&self.font_weight))?;
                    }
                    if !wkt::internal::is_default(&self.handwritten) {
                        state.serialize_entry("handwritten", &self.handwritten)?;
                    }
                    if self.text_color.is_some() {
                        state.serialize_entry("textColor", &self.text_color)?;
                    }
                    if self.background_color.is_some() {
                        state.serialize_entry("backgroundColor", &self.background_color)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for StyleInfo {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("StyleInfo");
                    debug_struct.field("font_size", &self.font_size);
                    debug_struct.field("pixel_font_size", &self.pixel_font_size);
                    debug_struct.field("letter_spacing", &self.letter_spacing);
                    debug_struct.field("font_type", &self.font_type);
                    debug_struct.field("bold", &self.bold);
                    debug_struct.field("italic", &self.italic);
                    debug_struct.field("underlined", &self.underlined);
                    debug_struct.field("strikeout", &self.strikeout);
                    debug_struct.field("subscript", &self.subscript);
                    debug_struct.field("superscript", &self.superscript);
                    debug_struct.field("smallcaps", &self.smallcaps);
                    debug_struct.field("font_weight", &self.font_weight);
                    debug_struct.field("handwritten", &self.handwritten);
                    debug_struct.field("text_color", &self.text_color);
                    debug_struct.field("background_color", &self.background_color);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }
        }

        /// A detected symbol.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Symbol {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [Symbol][google.cloud.documentai.v1.Document.Page.Symbol].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            /// [google.cloud.documentai.v1.Document.Page.Symbol]: crate::model::document::page::Symbol
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// A list of detected languages together with confidence.
            pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Symbol {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::Symbol::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::Symbol::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [detected_languages][crate::model::document::page::Symbol::detected_languages].
            pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Symbol {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Symbol"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Symbol {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __detected_languages,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Symbol")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                    "detected_languages" => Ok(__FieldTag::__detected_languages),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Symbol;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Symbol")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__detected_languages => {
                                    if !fields.insert(__FieldTag::__detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_languages",
                                            ),
                                        );
                                    }
                                    result.detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Symbol {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if !self.detected_languages.is_empty() {
                    state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Symbol {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Symbol");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("detected_languages", &self.detected_languages);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Detected non-text visual elements e.g. checkbox, signature etc. on the
        /// page.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct VisualElement {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [VisualElement][google.cloud.documentai.v1.Document.Page.VisualElement].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            /// [google.cloud.documentai.v1.Document.Page.VisualElement]: crate::model::document::page::VisualElement
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// Type of the
            /// [VisualElement][google.cloud.documentai.v1.Document.Page.VisualElement].
            ///
            /// [google.cloud.documentai.v1.Document.Page.VisualElement]: crate::model::document::page::VisualElement
            pub r#type: std::string::String,

            /// A list of detected languages together with confidence.
            pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VisualElement {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::VisualElement::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::VisualElement::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [r#type][crate::model::document::page::VisualElement::type].
            pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [detected_languages][crate::model::document::page::VisualElement::detected_languages].
            pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for VisualElement {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.VisualElement"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for VisualElement {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __type,
                    __detected_languages,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for VisualElement")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "type" => Ok(__FieldTag::__type),
                                    "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                    "detected_languages" => Ok(__FieldTag::__detected_languages),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = VisualElement;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct VisualElement")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__detected_languages => {
                                    if !fields.insert(__FieldTag::__detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_languages",
                                            ),
                                        );
                                    }
                                    result.detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for VisualElement {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if !self.r#type.is_empty() {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !self.detected_languages.is_empty() {
                    state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for VisualElement {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("VisualElement");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("r#type", &self.r#type);
                debug_struct.field("detected_languages", &self.detected_languages);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// A table representation similar to HTML table structure.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Table {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [Table][google.cloud.documentai.v1.Document.Page.Table].
            ///
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            /// [google.cloud.documentai.v1.Document.Page.Table]: crate::model::document::page::Table
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// Header rows of the table.
            pub header_rows: std::vec::Vec<crate::model::document::page::table::TableRow>,

            /// Body rows of the table.
            pub body_rows: std::vec::Vec<crate::model::document::page::table::TableRow>,

            /// A list of detected languages together with confidence.
            pub detected_languages: std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            /// The history of this table.
            #[deprecated]
            pub provenance: std::option::Option<crate::model::document::Provenance>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Table {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::Table::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::Table::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [header_rows][crate::model::document::page::Table::header_rows].
            pub fn set_header_rows<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::table::TableRow>,
            {
                use std::iter::Iterator;
                self.header_rows = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [body_rows][crate::model::document::page::Table::body_rows].
            pub fn set_body_rows<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::table::TableRow>,
            {
                use std::iter::Iterator;
                self.body_rows = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [detected_languages][crate::model::document::page::Table::detected_languages].
            pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [provenance][crate::model::document::page::Table::provenance].
            #[deprecated]
            pub fn set_provenance<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [provenance][crate::model::document::page::Table::provenance].
            #[deprecated]
            pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Table {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Table"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Table {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __header_rows,
                    __body_rows,
                    __detected_languages,
                    __provenance,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Table")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "headerRows" => Ok(__FieldTag::__header_rows),
                                    "header_rows" => Ok(__FieldTag::__header_rows),
                                    "bodyRows" => Ok(__FieldTag::__body_rows),
                                    "body_rows" => Ok(__FieldTag::__body_rows),
                                    "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                    "detected_languages" => Ok(__FieldTag::__detected_languages),
                                    "provenance" => Ok(__FieldTag::__provenance),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Table;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Table")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__header_rows => {
                                    if !fields.insert(__FieldTag::__header_rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for header_rows",
                                            ),
                                        );
                                    }
                                    result.header_rows = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::table::TableRow,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__body_rows => {
                                    if !fields.insert(__FieldTag::__body_rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for body_rows",
                                            ),
                                        );
                                    }
                                    result.body_rows = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::table::TableRow,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__detected_languages => {
                                    if !fields.insert(__FieldTag::__detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_languages",
                                            ),
                                        );
                                    }
                                    result.detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__provenance => {
                                    if !fields.insert(__FieldTag::__provenance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for provenance",
                                            ),
                                        );
                                    }
                                    result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Table {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if !self.header_rows.is_empty() {
                    state.serialize_entry("headerRows", &self.header_rows)?;
                }
                if !self.body_rows.is_empty() {
                    state.serialize_entry("bodyRows", &self.body_rows)?;
                }
                if !self.detected_languages.is_empty() {
                    state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                }
                if self.provenance.is_some() {
                    state.serialize_entry("provenance", &self.provenance)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Table {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Table");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("header_rows", &self.header_rows);
                debug_struct.field("body_rows", &self.body_rows);
                debug_struct.field("detected_languages", &self.detected_languages);
                debug_struct.field("provenance", &self.provenance);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Table].
        pub mod table {
            #[allow(unused_imports)]
            use super::*;

            /// A row of table cells.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct TableRow {
                /// Cells that make up this row.
                pub cells: std::vec::Vec<crate::model::document::page::table::TableCell>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl TableRow {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [cells][crate::model::document::page::table::TableRow::cells].
                pub fn set_cells<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::document::page::table::TableCell>,
                {
                    use std::iter::Iterator;
                    self.cells = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for TableRow {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Table.TableRow"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for TableRow {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __cells,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for TableRow")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "cells" => Ok(__FieldTag::__cells),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = TableRow;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct TableRow")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__cells => {
                                        if !fields.insert(__FieldTag::__cells) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for cells",
                                                ),
                                            );
                                        }
                                        result.cells = map
                                            .next_value::<std::option::Option<
                                                std::vec::Vec<
                                                    crate::model::document::page::table::TableCell,
                                                >,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for TableRow {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.cells.is_empty() {
                        state.serialize_entry("cells", &self.cells)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for TableRow {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("TableRow");
                    debug_struct.field("cells", &self.cells);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// A cell representation inside the table.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct TableCell {
                /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
                /// [TableCell][google.cloud.documentai.v1.Document.Page.Table.TableCell].
                ///
                /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
                /// [google.cloud.documentai.v1.Document.Page.Table.TableCell]: crate::model::document::page::table::TableCell
                pub layout: std::option::Option<crate::model::document::page::Layout>,

                /// How many rows this cell spans.
                pub row_span: i32,

                /// How many columns this cell spans.
                pub col_span: i32,

                /// A list of detected languages together with confidence.
                pub detected_languages:
                    std::vec::Vec<crate::model::document::page::DetectedLanguage>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl TableCell {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [layout][crate::model::document::page::table::TableCell::layout].
                pub fn set_layout<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::document::page::Layout>,
                {
                    self.layout = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [layout][crate::model::document::page::table::TableCell::layout].
                pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::document::page::Layout>,
                {
                    self.layout = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [row_span][crate::model::document::page::table::TableCell::row_span].
                pub fn set_row_span<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.row_span = v.into();
                    self
                }

                /// Sets the value of [col_span][crate::model::document::page::table::TableCell::col_span].
                pub fn set_col_span<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.col_span = v.into();
                    self
                }

                /// Sets the value of [detected_languages][crate::model::document::page::table::TableCell::detected_languages].
                pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
                {
                    use std::iter::Iterator;
                    self.detected_languages = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for TableCell {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.Page.Table.TableCell"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for TableCell {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __layout,
                        __row_span,
                        __col_span,
                        __detected_languages,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for TableCell")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "layout" => Ok(__FieldTag::__layout),
                                        "rowSpan" => Ok(__FieldTag::__row_span),
                                        "row_span" => Ok(__FieldTag::__row_span),
                                        "colSpan" => Ok(__FieldTag::__col_span),
                                        "col_span" => Ok(__FieldTag::__col_span),
                                        "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                        "detected_languages" => {
                                            Ok(__FieldTag::__detected_languages)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = TableCell;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct TableCell")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__layout => {
                                        if !fields.insert(__FieldTag::__layout) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for layout",
                                                ),
                                            );
                                        }
                                        result.layout = map
                                            .next_value::<std::option::Option<
                                                crate::model::document::page::Layout,
                                            >>()?;
                                    }
                                    __FieldTag::__row_span => {
                                        if !fields.insert(__FieldTag::__row_span) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for row_span",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.row_span =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__col_span => {
                                        if !fields.insert(__FieldTag::__col_span) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for col_span",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.col_span =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__detected_languages => {
                                        if !fields.insert(__FieldTag::__detected_languages) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for detected_languages",
                                                ),
                                            );
                                        }
                                        result.detected_languages = map
                                            .next_value::<std::option::Option<
                                                std::vec::Vec<
                                                    crate::model::document::page::DetectedLanguage,
                                                >,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for TableCell {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.layout.is_some() {
                        state.serialize_entry("layout", &self.layout)?;
                    }
                    if !wkt::internal::is_default(&self.row_span) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("rowSpan", &__With(&self.row_span))?;
                    }
                    if !wkt::internal::is_default(&self.col_span) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("colSpan", &__With(&self.col_span))?;
                    }
                    if !self.detected_languages.is_empty() {
                        state.serialize_entry("detectedLanguages", &self.detected_languages)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for TableCell {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("TableCell");
                    debug_struct.field("layout", &self.layout);
                    debug_struct.field("row_span", &self.row_span);
                    debug_struct.field("col_span", &self.col_span);
                    debug_struct.field("detected_languages", &self.detected_languages);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }
        }

        /// A form field detected on the page.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FormField {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for the
            /// [FormField][google.cloud.documentai.v1.Document.Page.FormField] name.
            /// e.g. `Address`, `Email`, `Grand total`, `Phone number`, etc.
            ///
            /// [google.cloud.documentai.v1.Document.Page.FormField]: crate::model::document::page::FormField
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            pub field_name: std::option::Option<crate::model::document::page::Layout>,

            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for the
            /// [FormField][google.cloud.documentai.v1.Document.Page.FormField] value.
            ///
            /// [google.cloud.documentai.v1.Document.Page.FormField]: crate::model::document::page::FormField
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            pub field_value: std::option::Option<crate::model::document::page::Layout>,

            /// A list of detected languages for name together with confidence.
            pub name_detected_languages:
                std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            /// A list of detected languages for value together with confidence.
            pub value_detected_languages:
                std::vec::Vec<crate::model::document::page::DetectedLanguage>,

            /// If the value is non-textual, this field represents the type. Current
            /// valid values are:
            ///
            /// - blank (this indicates the `field_value` is normal text)
            /// - `unfilled_checkbox`
            /// - `filled_checkbox`
            pub value_type: std::string::String,

            /// Created for Labeling UI to export key text.
            /// If corrections were made to the text identified by the
            /// `field_name.text_anchor`, this field will contain the correction.
            pub corrected_key_text: std::string::String,

            /// Created for Labeling UI to export value text.
            /// If corrections were made to the text identified by the
            /// `field_value.text_anchor`, this field will contain the correction.
            pub corrected_value_text: std::string::String,

            /// The history of this annotation.
            pub provenance: std::option::Option<crate::model::document::Provenance>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FormField {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [field_name][crate::model::document::page::FormField::field_name].
            pub fn set_field_name<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.field_name = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [field_name][crate::model::document::page::FormField::field_name].
            pub fn set_or_clear_field_name<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.field_name = v.map(|x| x.into());
                self
            }

            /// Sets the value of [field_value][crate::model::document::page::FormField::field_value].
            pub fn set_field_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.field_value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [field_value][crate::model::document::page::FormField::field_value].
            pub fn set_or_clear_field_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.field_value = v.map(|x| x.into());
                self
            }

            /// Sets the value of [name_detected_languages][crate::model::document::page::FormField::name_detected_languages].
            pub fn set_name_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.name_detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [value_detected_languages][crate::model::document::page::FormField::value_detected_languages].
            pub fn set_value_detected_languages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::document::page::DetectedLanguage>,
            {
                use std::iter::Iterator;
                self.value_detected_languages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [value_type][crate::model::document::page::FormField::value_type].
            pub fn set_value_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_type = v.into();
                self
            }

            /// Sets the value of [corrected_key_text][crate::model::document::page::FormField::corrected_key_text].
            pub fn set_corrected_key_text<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.corrected_key_text = v.into();
                self
            }

            /// Sets the value of [corrected_value_text][crate::model::document::page::FormField::corrected_value_text].
            pub fn set_corrected_value_text<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.corrected_value_text = v.into();
                self
            }

            /// Sets the value of [provenance][crate::model::document::page::FormField::provenance].
            pub fn set_provenance<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [provenance][crate::model::document::page::FormField::provenance].
            pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::Provenance>,
            {
                self.provenance = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for FormField {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.FormField"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FormField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __field_name,
                    __field_value,
                    __name_detected_languages,
                    __value_detected_languages,
                    __value_type,
                    __corrected_key_text,
                    __corrected_value_text,
                    __provenance,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FormField")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "fieldName" => Ok(__FieldTag::__field_name),
                                    "field_name" => Ok(__FieldTag::__field_name),
                                    "fieldValue" => Ok(__FieldTag::__field_value),
                                    "field_value" => Ok(__FieldTag::__field_value),
                                    "nameDetectedLanguages" => {
                                        Ok(__FieldTag::__name_detected_languages)
                                    }
                                    "name_detected_languages" => {
                                        Ok(__FieldTag::__name_detected_languages)
                                    }
                                    "valueDetectedLanguages" => {
                                        Ok(__FieldTag::__value_detected_languages)
                                    }
                                    "value_detected_languages" => {
                                        Ok(__FieldTag::__value_detected_languages)
                                    }
                                    "valueType" => Ok(__FieldTag::__value_type),
                                    "value_type" => Ok(__FieldTag::__value_type),
                                    "correctedKeyText" => Ok(__FieldTag::__corrected_key_text),
                                    "corrected_key_text" => Ok(__FieldTag::__corrected_key_text),
                                    "correctedValueText" => Ok(__FieldTag::__corrected_value_text),
                                    "corrected_value_text" => {
                                        Ok(__FieldTag::__corrected_value_text)
                                    }
                                    "provenance" => Ok(__FieldTag::__provenance),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FormField;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FormField")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__field_name => {
                                    if !fields.insert(__FieldTag::__field_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for field_name",
                                            ),
                                        );
                                    }
                                    result.field_name =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__field_value => {
                                    if !fields.insert(__FieldTag::__field_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for field_value",
                                            ),
                                        );
                                    }
                                    result.field_value =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__name_detected_languages => {
                                    if !fields.insert(__FieldTag::__name_detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for name_detected_languages",
                                            ),
                                        );
                                    }
                                    result.name_detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__value_detected_languages => {
                                    if !fields.insert(__FieldTag::__value_detected_languages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for value_detected_languages",
                                            ),
                                        );
                                    }
                                    result.value_detected_languages = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::document::page::DetectedLanguage,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__value_type => {
                                    if !fields.insert(__FieldTag::__value_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for value_type",
                                            ),
                                        );
                                    }
                                    result.value_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__corrected_key_text => {
                                    if !fields.insert(__FieldTag::__corrected_key_text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for corrected_key_text",
                                            ),
                                        );
                                    }
                                    result.corrected_key_text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__corrected_value_text => {
                                    if !fields.insert(__FieldTag::__corrected_value_text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for corrected_value_text",
                                            ),
                                        );
                                    }
                                    result.corrected_value_text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__provenance => {
                                    if !fields.insert(__FieldTag::__provenance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for provenance",
                                            ),
                                        );
                                    }
                                    result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for FormField {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.field_name.is_some() {
                    state.serialize_entry("fieldName", &self.field_name)?;
                }
                if self.field_value.is_some() {
                    state.serialize_entry("fieldValue", &self.field_value)?;
                }
                if !self.name_detected_languages.is_empty() {
                    state
                        .serialize_entry("nameDetectedLanguages", &self.name_detected_languages)?;
                }
                if !self.value_detected_languages.is_empty() {
                    state.serialize_entry(
                        "valueDetectedLanguages",
                        &self.value_detected_languages,
                    )?;
                }
                if !self.value_type.is_empty() {
                    state.serialize_entry("valueType", &self.value_type)?;
                }
                if !self.corrected_key_text.is_empty() {
                    state.serialize_entry("correctedKeyText", &self.corrected_key_text)?;
                }
                if !self.corrected_value_text.is_empty() {
                    state.serialize_entry("correctedValueText", &self.corrected_value_text)?;
                }
                if self.provenance.is_some() {
                    state.serialize_entry("provenance", &self.provenance)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for FormField {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("FormField");
                debug_struct.field("field_name", &self.field_name);
                debug_struct.field("field_value", &self.field_value);
                debug_struct.field("name_detected_languages", &self.name_detected_languages);
                debug_struct.field("value_detected_languages", &self.value_detected_languages);
                debug_struct.field("value_type", &self.value_type);
                debug_struct.field("corrected_key_text", &self.corrected_key_text);
                debug_struct.field("corrected_value_text", &self.corrected_value_text);
                debug_struct.field("provenance", &self.provenance);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// A detected barcode.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DetectedBarcode {
            /// [Layout][google.cloud.documentai.v1.Document.Page.Layout] for
            /// [DetectedBarcode][google.cloud.documentai.v1.Document.Page.DetectedBarcode].
            ///
            /// [google.cloud.documentai.v1.Document.Page.DetectedBarcode]: crate::model::document::page::DetectedBarcode
            /// [google.cloud.documentai.v1.Document.Page.Layout]: crate::model::document::page::Layout
            pub layout: std::option::Option<crate::model::document::page::Layout>,

            /// Detailed barcode information of the
            /// [DetectedBarcode][google.cloud.documentai.v1.Document.Page.DetectedBarcode].
            ///
            /// [google.cloud.documentai.v1.Document.Page.DetectedBarcode]: crate::model::document::page::DetectedBarcode
            pub barcode: std::option::Option<crate::model::Barcode>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DetectedBarcode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [layout][crate::model::document::page::DetectedBarcode::layout].
            pub fn set_layout<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [layout][crate::model::document::page::DetectedBarcode::layout].
            pub fn set_or_clear_layout<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::document::page::Layout>,
            {
                self.layout = v.map(|x| x.into());
                self
            }

            /// Sets the value of [barcode][crate::model::document::page::DetectedBarcode::barcode].
            pub fn set_barcode<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::Barcode>,
            {
                self.barcode = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [barcode][crate::model::document::page::DetectedBarcode::barcode].
            pub fn set_or_clear_barcode<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::Barcode>,
            {
                self.barcode = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for DetectedBarcode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.DetectedBarcode"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DetectedBarcode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __layout,
                    __barcode,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DetectedBarcode")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "layout" => Ok(__FieldTag::__layout),
                                    "barcode" => Ok(__FieldTag::__barcode),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DetectedBarcode;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DetectedBarcode")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__layout => {
                                    if !fields.insert(__FieldTag::__layout) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for layout"),
                                        );
                                    }
                                    result.layout =
                                        map.next_value::<std::option::Option<
                                            crate::model::document::page::Layout,
                                        >>()?;
                                }
                                __FieldTag::__barcode => {
                                    if !fields.insert(__FieldTag::__barcode) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for barcode",
                                            ),
                                        );
                                    }
                                    result.barcode = map
                                        .next_value::<std::option::Option<crate::model::Barcode>>(
                                        )?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DetectedBarcode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.layout.is_some() {
                    state.serialize_entry("layout", &self.layout)?;
                }
                if self.barcode.is_some() {
                    state.serialize_entry("barcode", &self.barcode)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for DetectedBarcode {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("DetectedBarcode");
                debug_struct.field("layout", &self.layout);
                debug_struct.field("barcode", &self.barcode);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Detected language for a structural component.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DetectedLanguage {
            /// The [BCP-47 language
            /// code](https://www.unicode.org/reports/tr35/#Unicode_locale_identifier),
            /// such as `en-US` or `sr-Latn`.
            pub language_code: std::string::String,

            /// Confidence of detected language. Range `[0, 1]`.
            pub confidence: f32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DetectedLanguage {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [language_code][crate::model::document::page::DetectedLanguage::language_code].
            pub fn set_language_code<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.language_code = v.into();
                self
            }

            /// Sets the value of [confidence][crate::model::document::page::DetectedLanguage::confidence].
            pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.confidence = v.into();
                self
            }
        }

        impl wkt::message::Message for DetectedLanguage {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.DetectedLanguage"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DetectedLanguage {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __language_code,
                    __confidence,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DetectedLanguage")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "languageCode" => Ok(__FieldTag::__language_code),
                                    "language_code" => Ok(__FieldTag::__language_code),
                                    "confidence" => Ok(__FieldTag::__confidence),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DetectedLanguage;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DetectedLanguage")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__language_code => {
                                    if !fields.insert(__FieldTag::__language_code) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for language_code",
                                            ),
                                        );
                                    }
                                    result.language_code = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__confidence => {
                                    if !fields.insert(__FieldTag::__confidence) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidence",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.confidence =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DetectedLanguage {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.language_code.is_empty() {
                    state.serialize_entry("languageCode", &self.language_code)?;
                }
                if !wkt::internal::is_default(&self.confidence) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("confidence", &__With(&self.confidence))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for DetectedLanguage {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("DetectedLanguage");
                debug_struct.field("language_code", &self.language_code);
                debug_struct.field("confidence", &self.confidence);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Image quality scores for the page image.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ImageQualityScores {
            /// The overall quality score. Range `[0, 1]` where `1` is perfect quality.
            pub quality_score: f32,

            /// A list of detected defects.
            pub detected_defects:
                std::vec::Vec<crate::model::document::page::image_quality_scores::DetectedDefect>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ImageQualityScores {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [quality_score][crate::model::document::page::ImageQualityScores::quality_score].
            pub fn set_quality_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.quality_score = v.into();
                self
            }

            /// Sets the value of [detected_defects][crate::model::document::page::ImageQualityScores::detected_defects].
            pub fn set_detected_defects<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::document::page::image_quality_scores::DetectedDefect,
                    >,
            {
                use std::iter::Iterator;
                self.detected_defects = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ImageQualityScores {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Page.ImageQualityScores"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ImageQualityScores {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __quality_score,
                    __detected_defects,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ImageQualityScores")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "qualityScore" => Ok(__FieldTag::__quality_score),
                                    "quality_score" => Ok(__FieldTag::__quality_score),
                                    "detectedDefects" => Ok(__FieldTag::__detected_defects),
                                    "detected_defects" => Ok(__FieldTag::__detected_defects),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ImageQualityScores;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ImageQualityScores")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__quality_score => {
                                    if !fields.insert(__FieldTag::__quality_score) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for quality_score",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.quality_score =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__detected_defects => {
                                    if !fields.insert(__FieldTag::__detected_defects) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for detected_defects",
                                            ),
                                        );
                                    }
                                    result.detected_defects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::page::image_quality_scores::DetectedDefect>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ImageQualityScores {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.quality_score) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("qualityScore", &__With(&self.quality_score))?;
                }
                if !self.detected_defects.is_empty() {
                    state.serialize_entry("detectedDefects", &self.detected_defects)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for ImageQualityScores {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("ImageQualityScores");
                debug_struct.field("quality_score", &self.quality_score);
                debug_struct.field("detected_defects", &self.detected_defects);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [ImageQualityScores].
        pub mod image_quality_scores {
            #[allow(unused_imports)]
            use super::*;

            /// Image Quality Defects
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct DetectedDefect {
                /// Name of the defect type. Supported values are:
                ///
                /// - `quality/defect_blurry`
                /// - `quality/defect_noisy`
                /// - `quality/defect_dark`
                /// - `quality/defect_faint`
                /// - `quality/defect_text_too_small`
                /// - `quality/defect_document_cutoff`
                /// - `quality/defect_text_cutoff`
                /// - `quality/defect_glare`
                pub r#type: std::string::String,

                /// Confidence of detected defect. Range `[0, 1]` where `1` indicates
                /// strong confidence that the defect exists.
                pub confidence: f32,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DetectedDefect {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [r#type][crate::model::document::page::image_quality_scores::DetectedDefect::type].
                pub fn set_type<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.r#type = v.into();
                    self
                }

                /// Sets the value of [confidence][crate::model::document::page::image_quality_scores::DetectedDefect::confidence].
                pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.confidence = v.into();
                    self
                }
            }

            impl wkt::message::Message for DetectedDefect {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.Page.ImageQualityScores.DetectedDefect"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for DetectedDefect {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __type,
                        __confidence,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for DetectedDefect")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "type" => Ok(__FieldTag::__type),
                                        "confidence" => Ok(__FieldTag::__confidence),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = DetectedDefect;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct DetectedDefect")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__type => {
                                        if !fields.insert(__FieldTag::__type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for type",
                                                ),
                                            );
                                        }
                                        result.r#type = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__confidence => {
                                        if !fields.insert(__FieldTag::__confidence) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for confidence",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.confidence =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for DetectedDefect {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.r#type.is_empty() {
                        state.serialize_entry("type", &self.r#type)?;
                    }
                    if !wkt::internal::is_default(&self.confidence) {
                        struct __With<'a>(&'a f32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("confidence", &__With(&self.confidence))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for DetectedDefect {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("DetectedDefect");
                    debug_struct.field("r#type", &self.r#type);
                    debug_struct.field("confidence", &self.confidence);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }
        }
    }

    /// An entity that could be a phrase in the text or a property that belongs to
    /// the document. It is a known entity type, such as a person, an organization,
    /// or location.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Entity {
        /// Optional. Provenance of the entity.
        /// Text anchor indexing into the
        /// [Document.text][google.cloud.documentai.v1.Document.text].
        ///
        /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
        pub text_anchor: std::option::Option<crate::model::document::TextAnchor>,

        /// Required. Entity type from a schema e.g. `Address`.
        pub r#type: std::string::String,

        /// Optional. Text value of the entity e.g. `1600 Amphitheatre Pkwy`.
        pub mention_text: std::string::String,

        /// Optional. Deprecated.  Use `id` field instead.
        pub mention_id: std::string::String,

        /// Optional. Confidence of detected Schema entity. Range `[0, 1]`.
        pub confidence: f32,

        /// Optional. Represents the provenance of this entity wrt. the location on
        /// the page where it was found.
        pub page_anchor: std::option::Option<crate::model::document::PageAnchor>,

        /// Optional. Canonical id. This will be a unique value in the entity list
        /// for this document.
        pub id: std::string::String,

        /// Optional. Normalized entity value. Absent if the extracted value could
        /// not be converted or the type (e.g. address) is not supported for certain
        /// parsers. This field is also only populated for certain supported document
        /// types.
        pub normalized_value: std::option::Option<crate::model::document::entity::NormalizedValue>,

        /// Optional. Entities can be nested to form a hierarchical data structure
        /// representing the content in the document.
        pub properties: std::vec::Vec<crate::model::document::Entity>,

        /// Optional. The history of this annotation.
        pub provenance: std::option::Option<crate::model::document::Provenance>,

        /// Optional. Whether the entity will be redacted for de-identification
        /// purposes.
        pub redacted: bool,

        /// Optional. Specifies how the entity's value is obtained.
        pub method: crate::model::document::entity::Method,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Entity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text_anchor][crate::model::document::Entity::text_anchor].
        pub fn set_text_anchor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::TextAnchor>,
        {
            self.text_anchor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [text_anchor][crate::model::document::Entity::text_anchor].
        pub fn set_or_clear_text_anchor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::TextAnchor>,
        {
            self.text_anchor = v.map(|x| x.into());
            self
        }

        /// Sets the value of [r#type][crate::model::document::Entity::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [mention_text][crate::model::document::Entity::mention_text].
        pub fn set_mention_text<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.mention_text = v.into();
            self
        }

        /// Sets the value of [mention_id][crate::model::document::Entity::mention_id].
        pub fn set_mention_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mention_id = v.into();
            self
        }

        /// Sets the value of [confidence][crate::model::document::Entity::confidence].
        pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.confidence = v.into();
            self
        }

        /// Sets the value of [page_anchor][crate::model::document::Entity::page_anchor].
        pub fn set_page_anchor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::PageAnchor>,
        {
            self.page_anchor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_anchor][crate::model::document::Entity::page_anchor].
        pub fn set_or_clear_page_anchor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::PageAnchor>,
        {
            self.page_anchor = v.map(|x| x.into());
            self
        }

        /// Sets the value of [id][crate::model::document::Entity::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [normalized_value][crate::model::document::Entity::normalized_value].
        pub fn set_normalized_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::entity::NormalizedValue>,
        {
            self.normalized_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [normalized_value][crate::model::document::Entity::normalized_value].
        pub fn set_or_clear_normalized_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::entity::NormalizedValue>,
        {
            self.normalized_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [properties][crate::model::document::Entity::properties].
        pub fn set_properties<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::Entity>,
        {
            use std::iter::Iterator;
            self.properties = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [provenance][crate::model::document::Entity::provenance].
        pub fn set_provenance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::Provenance>,
        {
            self.provenance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [provenance][crate::model::document::Entity::provenance].
        pub fn set_or_clear_provenance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::Provenance>,
        {
            self.provenance = v.map(|x| x.into());
            self
        }

        /// Sets the value of [redacted][crate::model::document::Entity::redacted].
        pub fn set_redacted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.redacted = v.into();
            self
        }

        /// Sets the value of [method][crate::model::document::Entity::method].
        pub fn set_method<T: std::convert::Into<crate::model::document::entity::Method>>(
            mut self,
            v: T,
        ) -> Self {
            self.method = v.into();
            self
        }
    }

    impl wkt::message::Message for Entity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.Entity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Entity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text_anchor,
                __type,
                __mention_text,
                __mention_id,
                __confidence,
                __page_anchor,
                __id,
                __normalized_value,
                __properties,
                __provenance,
                __redacted,
                __method,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Entity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "textAnchor" => Ok(__FieldTag::__text_anchor),
                                "text_anchor" => Ok(__FieldTag::__text_anchor),
                                "type" => Ok(__FieldTag::__type),
                                "mentionText" => Ok(__FieldTag::__mention_text),
                                "mention_text" => Ok(__FieldTag::__mention_text),
                                "mentionId" => Ok(__FieldTag::__mention_id),
                                "mention_id" => Ok(__FieldTag::__mention_id),
                                "confidence" => Ok(__FieldTag::__confidence),
                                "pageAnchor" => Ok(__FieldTag::__page_anchor),
                                "page_anchor" => Ok(__FieldTag::__page_anchor),
                                "id" => Ok(__FieldTag::__id),
                                "normalizedValue" => Ok(__FieldTag::__normalized_value),
                                "normalized_value" => Ok(__FieldTag::__normalized_value),
                                "properties" => Ok(__FieldTag::__properties),
                                "provenance" => Ok(__FieldTag::__provenance),
                                "redacted" => Ok(__FieldTag::__redacted),
                                "method" => Ok(__FieldTag::__method),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Entity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Entity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text_anchor => {
                                if !fields.insert(__FieldTag::__text_anchor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_anchor",
                                    ));
                                }
                                result.text_anchor = map.next_value::<std::option::Option<crate::model::document::TextAnchor>>()?
                                    ;
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mention_text => {
                                if !fields.insert(__FieldTag::__mention_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mention_text",
                                    ));
                                }
                                result.mention_text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mention_id => {
                                if !fields.insert(__FieldTag::__mention_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mention_id",
                                    ));
                                }
                                result.mention_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__confidence => {
                                if !fields.insert(__FieldTag::__confidence) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.confidence =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__page_anchor => {
                                if !fields.insert(__FieldTag::__page_anchor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for page_anchor",
                                    ));
                                }
                                result.page_anchor = map.next_value::<std::option::Option<crate::model::document::PageAnchor>>()?
                                    ;
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__normalized_value => {
                                if !fields.insert(__FieldTag::__normalized_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for normalized_value",
                                    ));
                                }
                                result.normalized_value = map
                                    .next_value::<std::option::Option<
                                        crate::model::document::entity::NormalizedValue,
                                    >>()?;
                            }
                            __FieldTag::__properties => {
                                if !fields.insert(__FieldTag::__properties) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for properties",
                                    ));
                                }
                                result.properties = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::Entity>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__provenance => {
                                if !fields.insert(__FieldTag::__provenance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for provenance",
                                    ));
                                }
                                result.provenance = map.next_value::<std::option::Option<crate::model::document::Provenance>>()?
                                    ;
                            }
                            __FieldTag::__redacted => {
                                if !fields.insert(__FieldTag::__redacted) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for redacted",
                                    ));
                                }
                                result.redacted = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__method => {
                                if !fields.insert(__FieldTag::__method) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for method",
                                    ));
                                }
                                result.method = map.next_value::<std::option::Option<crate::model::document::entity::Method>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Entity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.text_anchor.is_some() {
                state.serialize_entry("textAnchor", &self.text_anchor)?;
            }
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.mention_text.is_empty() {
                state.serialize_entry("mentionText", &self.mention_text)?;
            }
            if !self.mention_id.is_empty() {
                state.serialize_entry("mentionId", &self.mention_id)?;
            }
            if !wkt::internal::is_default(&self.confidence) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("confidence", &__With(&self.confidence))?;
            }
            if self.page_anchor.is_some() {
                state.serialize_entry("pageAnchor", &self.page_anchor)?;
            }
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if self.normalized_value.is_some() {
                state.serialize_entry("normalizedValue", &self.normalized_value)?;
            }
            if !self.properties.is_empty() {
                state.serialize_entry("properties", &self.properties)?;
            }
            if self.provenance.is_some() {
                state.serialize_entry("provenance", &self.provenance)?;
            }
            if !wkt::internal::is_default(&self.redacted) {
                state.serialize_entry("redacted", &self.redacted)?;
            }
            if !wkt::internal::is_default(&self.method) {
                state.serialize_entry("method", &self.method)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Entity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Entity");
            debug_struct.field("text_anchor", &self.text_anchor);
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("mention_text", &self.mention_text);
            debug_struct.field("mention_id", &self.mention_id);
            debug_struct.field("confidence", &self.confidence);
            debug_struct.field("page_anchor", &self.page_anchor);
            debug_struct.field("id", &self.id);
            debug_struct.field("normalized_value", &self.normalized_value);
            debug_struct.field("properties", &self.properties);
            debug_struct.field("provenance", &self.provenance);
            debug_struct.field("redacted", &self.redacted);
            debug_struct.field("method", &self.method);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Entity].
    pub mod entity {
        #[allow(unused_imports)]
        use super::*;

        /// Parsed and normalized entity value.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NormalizedValue {
            /// Optional. An optional field to store a normalized string.
            /// For some entity types, one of respective `structured_value` fields may
            /// also be populated. Also not all the types of `structured_value` will be
            /// normalized. For example, some processors may not generate `float`
            /// or `integer` normalized text by default.
            ///
            /// Below are sample formats mapped to structured values.
            ///
            /// - Money/Currency type (`money_value`) is in the ISO 4217 text format.
            /// - Date type (`date_value`) is in the ISO 8601 text format.
            /// - Datetime type (`datetime_value`) is in the ISO 8601 text format.
            pub text: std::string::String,

            /// An optional structured entity value.
            /// Must match entity type defined in schema if
            /// known. If this field is present, the `text` field could also be
            /// populated.
            pub structured_value: std::option::Option<
                crate::model::document::entity::normalized_value::StructuredValue,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NormalizedValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [text][crate::model::document::entity::NormalizedValue::text].
            pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.text = v.into();
                self
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value].
            ///
            /// Note that all the setters affecting `structured_value` are mutually
            /// exclusive.
            pub fn set_structured_value<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::document::entity::normalized_value::StructuredValue,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.structured_value = v.into();
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `MoneyValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn money_value(
                &self,
            ) -> std::option::Option<&std::boxed::Box<gtype::model::Money>> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::MoneyValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `MoneyValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_money_value<T: std::convert::Into<std::boxed::Box<gtype::model::Money>>>(
                mut self,
                v: T,
            ) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::MoneyValue(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `DateValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn date_value(&self) -> std::option::Option<&std::boxed::Box<gtype::model::Date>> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::DateValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `DateValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_date_value<T: std::convert::Into<std::boxed::Box<gtype::model::Date>>>(
                mut self,
                v: T,
            ) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::DateValue(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `DatetimeValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn datetime_value(
                &self,
            ) -> std::option::Option<&std::boxed::Box<gtype::model::DateTime>> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::DatetimeValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `DatetimeValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_datetime_value<
                T: std::convert::Into<std::boxed::Box<gtype::model::DateTime>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::DatetimeValue(
                        v.into()
                    )
                );
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `AddressValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn address_value(
                &self,
            ) -> std::option::Option<&std::boxed::Box<gtype::model::PostalAddress>> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::AddressValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `AddressValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_address_value<
                T: std::convert::Into<std::boxed::Box<gtype::model::PostalAddress>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::AddressValue(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `BooleanValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn boolean_value(&self) -> std::option::Option<&bool> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::BooleanValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `BooleanValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_boolean_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::BooleanValue(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `IntegerValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn integer_value(&self) -> std::option::Option<&i32> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::IntegerValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `IntegerValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_integer_value<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::IntegerValue(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `FloatValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn float_value(&self) -> std::option::Option<&f32> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::FloatValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `FloatValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_float_value<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::FloatValue(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// if it holds a `SignatureValue`, `None` if the field is not set or
            /// holds a different branch.
            pub fn signature_value(&self) -> std::option::Option<&bool> {
                #[allow(unreachable_patterns)]
                self.structured_value.as_ref().and_then(|v| match v {
                    crate::model::document::entity::normalized_value::StructuredValue::SignatureValue(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [structured_value][crate::model::document::entity::NormalizedValue::structured_value]
            /// to hold a `SignatureValue`.
            ///
            /// Note that all the setters affecting `structured_value` are
            /// mutually exclusive.
            pub fn set_signature_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.structured_value = std::option::Option::Some(
                    crate::model::document::entity::normalized_value::StructuredValue::SignatureValue(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for NormalizedValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Entity.NormalizedValue"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for NormalizedValue {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __money_value,
                    __date_value,
                    __datetime_value,
                    __address_value,
                    __boolean_value,
                    __integer_value,
                    __float_value,
                    __signature_value,
                    __text,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for NormalizedValue")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "moneyValue" => Ok(__FieldTag::__money_value),
                                    "money_value" => Ok(__FieldTag::__money_value),
                                    "dateValue" => Ok(__FieldTag::__date_value),
                                    "date_value" => Ok(__FieldTag::__date_value),
                                    "datetimeValue" => Ok(__FieldTag::__datetime_value),
                                    "datetime_value" => Ok(__FieldTag::__datetime_value),
                                    "addressValue" => Ok(__FieldTag::__address_value),
                                    "address_value" => Ok(__FieldTag::__address_value),
                                    "booleanValue" => Ok(__FieldTag::__boolean_value),
                                    "boolean_value" => Ok(__FieldTag::__boolean_value),
                                    "integerValue" => Ok(__FieldTag::__integer_value),
                                    "integer_value" => Ok(__FieldTag::__integer_value),
                                    "floatValue" => Ok(__FieldTag::__float_value),
                                    "float_value" => Ok(__FieldTag::__float_value),
                                    "signatureValue" => Ok(__FieldTag::__signature_value),
                                    "signature_value" => Ok(__FieldTag::__signature_value),
                                    "text" => Ok(__FieldTag::__text),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = NormalizedValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct NormalizedValue")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__money_value => {
                                    if !fields.insert(__FieldTag::__money_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for money_value",
                                            ),
                                        );
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.money_value, latest field was moneyValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::MoneyValue(
                                            map.next_value::<std::option::Option<std::boxed::Box<gtype::model::Money>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__date_value => {
                                    if !fields.insert(__FieldTag::__date_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for date_value",
                                            ),
                                        );
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.date_value, latest field was dateValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::DateValue(
                                            map.next_value::<std::option::Option<std::boxed::Box<gtype::model::Date>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__datetime_value => {
                                    if !fields.insert(__FieldTag::__datetime_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for datetime_value",
                                            ),
                                        );
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.datetime_value, latest field was datetimeValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::DatetimeValue(
                                            map.next_value::<std::option::Option<std::boxed::Box<gtype::model::DateTime>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__address_value => {
                                    if !fields.insert(__FieldTag::__address_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for address_value",
                                            ),
                                        );
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.address_value, latest field was addressValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::AddressValue(
                                            map.next_value::<std::option::Option<std::boxed::Box<gtype::model::PostalAddress>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__boolean_value => {
                                    if !fields.insert(__FieldTag::__boolean_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for boolean_value",
                                            ),
                                        );
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.boolean_value, latest field was booleanValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::BooleanValue(
                                            map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__integer_value => {
                                    if !fields.insert(__FieldTag::__integer_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for integer_value",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.integer_value, latest field was integerValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::IntegerValue(
                                            map.next_value::<__With>()?.0.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__float_value => {
                                    if !fields.insert(__FieldTag::__float_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for float_value",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.float_value, latest field was floatValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::FloatValue(
                                            map.next_value::<__With>()?.0.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__signature_value => {
                                    if !fields.insert(__FieldTag::__signature_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for signature_value",
                                            ),
                                        );
                                    }
                                    if result.structured_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `structured_value`, a oneof with full ID .google.cloud.documentai.v1.Document.Entity.NormalizedValue.signature_value, latest field was signatureValue",
                                            ),
                                        );
                                    }
                                    result.structured_value = std::option::Option::Some(
                                        crate::model::document::entity::normalized_value::StructuredValue::SignatureValue(
                                            map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__text => {
                                    if !fields.insert(__FieldTag::__text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for text"),
                                        );
                                    }
                                    result.text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for NormalizedValue {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.money_value() {
                    state.serialize_entry("moneyValue", value)?;
                }
                if let Some(value) = self.date_value() {
                    state.serialize_entry("dateValue", value)?;
                }
                if let Some(value) = self.datetime_value() {
                    state.serialize_entry("datetimeValue", value)?;
                }
                if let Some(value) = self.address_value() {
                    state.serialize_entry("addressValue", value)?;
                }
                if let Some(value) = self.boolean_value() {
                    state.serialize_entry("booleanValue", value)?;
                }
                if let Some(value) = self.integer_value() {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("integerValue", &__With(value))?;
                }
                if let Some(value) = self.float_value() {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("floatValue", &__With(value))?;
                }
                if let Some(value) = self.signature_value() {
                    state.serialize_entry("signatureValue", value)?;
                }
                if !self.text.is_empty() {
                    state.serialize_entry("text", &self.text)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for NormalizedValue {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("NormalizedValue");
                debug_struct.field("text", &self.text);
                debug_struct.field("structured_value", &self.structured_value);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [NormalizedValue].
        pub mod normalized_value {
            #[allow(unused_imports)]
            use super::*;

            /// An optional structured entity value.
            /// Must match entity type defined in schema if
            /// known. If this field is present, the `text` field could also be
            /// populated.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum StructuredValue {
                /// Money value. See also:
                /// <https://github.com/googleapis/googleapis/blob/master/google/type/money.proto>
                MoneyValue(std::boxed::Box<gtype::model::Money>),
                /// Date value. Includes year, month, day. See also:
                /// <https://github.com/googleapis/googleapis/blob/master/google/type/date.proto>
                DateValue(std::boxed::Box<gtype::model::Date>),
                /// DateTime value. Includes date, time, and timezone. See also:
                /// <https://github.com/googleapis/googleapis/blob/master/google/type/datetime.proto>
                DatetimeValue(std::boxed::Box<gtype::model::DateTime>),
                /// Postal address. See also:
                /// <https://github.com/googleapis/googleapis/blob/master/google/type/postal_address.proto>
                AddressValue(std::boxed::Box<gtype::model::PostalAddress>),
                /// Boolean value. Can be used for entities with binary values, or for
                /// checkboxes.
                BooleanValue(bool),
                /// Integer value.
                IntegerValue(i32),
                /// Float value.
                FloatValue(f32),
                SignatureValue(bool),
            }
        }

        /// Specifies how the entity's value is obtained.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Method {
            /// When the method is not specified, it should be treated as `EXTRACT`.
            Unspecified,
            /// The entity's value is directly extracted as-is from the document
            /// text.
            Extract,
            /// The entity's value is derived through inference and is not
            /// necessarily an exact text extraction from the document.
            Derive,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Method::value] or
            /// [Method::name].
            UnknownValue(method::UnknownValue),
        }

        #[doc(hidden)]
        pub mod method {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Method {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Extract => std::option::Option::Some(1),
                    Self::Derive => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                    Self::Extract => std::option::Option::Some("EXTRACT"),
                    Self::Derive => std::option::Option::Some("DERIVE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Method {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Method {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Method {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Extract,
                    2 => Self::Derive,
                    _ => Self::UnknownValue(method::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Method {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "METHOD_UNSPECIFIED" => Self::Unspecified,
                    "EXTRACT" => Self::Extract,
                    "DERIVE" => Self::Derive,
                    _ => Self::UnknownValue(method::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Method {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Extract => serializer.serialize_i32(1),
                    Self::Derive => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Method {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                    ".google.cloud.documentai.v1.Document.Entity.Method",
                ))
            }
        }
    }

    /// Relationship between
    /// [Entities][google.cloud.documentai.v1.Document.Entity].
    ///
    /// [google.cloud.documentai.v1.Document.Entity]: crate::model::document::Entity
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EntityRelation {
        /// Subject entity id.
        pub subject_id: std::string::String,

        /// Object entity id.
        pub object_id: std::string::String,

        /// Relationship description.
        pub relation: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EntityRelation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [subject_id][crate::model::document::EntityRelation::subject_id].
        pub fn set_subject_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subject_id = v.into();
            self
        }

        /// Sets the value of [object_id][crate::model::document::EntityRelation::object_id].
        pub fn set_object_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.object_id = v.into();
            self
        }

        /// Sets the value of [relation][crate::model::document::EntityRelation::relation].
        pub fn set_relation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.relation = v.into();
            self
        }
    }

    impl wkt::message::Message for EntityRelation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.EntityRelation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EntityRelation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __subject_id,
                __object_id,
                __relation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EntityRelation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "subjectId" => Ok(__FieldTag::__subject_id),
                                "subject_id" => Ok(__FieldTag::__subject_id),
                                "objectId" => Ok(__FieldTag::__object_id),
                                "object_id" => Ok(__FieldTag::__object_id),
                                "relation" => Ok(__FieldTag::__relation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EntityRelation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EntityRelation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__subject_id => {
                                if !fields.insert(__FieldTag::__subject_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subject_id",
                                    ));
                                }
                                result.subject_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__object_id => {
                                if !fields.insert(__FieldTag::__object_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_id",
                                    ));
                                }
                                result.object_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__relation => {
                                if !fields.insert(__FieldTag::__relation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for relation",
                                    ));
                                }
                                result.relation = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EntityRelation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.subject_id.is_empty() {
                state.serialize_entry("subjectId", &self.subject_id)?;
            }
            if !self.object_id.is_empty() {
                state.serialize_entry("objectId", &self.object_id)?;
            }
            if !self.relation.is_empty() {
                state.serialize_entry("relation", &self.relation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for EntityRelation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("EntityRelation");
            debug_struct.field("subject_id", &self.subject_id);
            debug_struct.field("object_id", &self.object_id);
            debug_struct.field("relation", &self.relation);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Text reference indexing into the
    /// [Document.text][google.cloud.documentai.v1.Document.text].
    ///
    /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TextAnchor {
        /// The text segments from the
        /// [Document.text][google.cloud.documentai.v1.Document.text].
        ///
        /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
        pub text_segments: std::vec::Vec<crate::model::document::text_anchor::TextSegment>,

        /// Contains the content of the text span so that users do
        /// not have to look it up in the text_segments.  It is always
        /// populated for formFields.
        pub content: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextAnchor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text_segments][crate::model::document::TextAnchor::text_segments].
        pub fn set_text_segments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::text_anchor::TextSegment>,
        {
            use std::iter::Iterator;
            self.text_segments = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [content][crate::model::document::TextAnchor::content].
        pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content = v.into();
            self
        }
    }

    impl wkt::message::Message for TextAnchor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.TextAnchor"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TextAnchor {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text_segments,
                __content,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TextAnchor")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "textSegments" => Ok(__FieldTag::__text_segments),
                                "text_segments" => Ok(__FieldTag::__text_segments),
                                "content" => Ok(__FieldTag::__content),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TextAnchor;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TextAnchor")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text_segments => {
                                if !fields.insert(__FieldTag::__text_segments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_segments",
                                    ));
                                }
                                result.text_segments = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::document::text_anchor::TextSegment,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__content => {
                                if !fields.insert(__FieldTag::__content) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for content",
                                    ));
                                }
                                result.content = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TextAnchor {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text_segments.is_empty() {
                state.serialize_entry("textSegments", &self.text_segments)?;
            }
            if !self.content.is_empty() {
                state.serialize_entry("content", &self.content)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TextAnchor {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TextAnchor");
            debug_struct.field("text_segments", &self.text_segments);
            debug_struct.field("content", &self.content);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [TextAnchor].
    pub mod text_anchor {
        #[allow(unused_imports)]
        use super::*;

        /// A text segment in the
        /// [Document.text][google.cloud.documentai.v1.Document.text]. The indices
        /// may be out of bounds which indicate that the text extends into another
        /// document shard for large sharded documents. See
        /// [ShardInfo.text_offset][google.cloud.documentai.v1.Document.ShardInfo.text_offset]
        ///
        /// [google.cloud.documentai.v1.Document.ShardInfo.text_offset]: crate::model::document::ShardInfo::text_offset
        /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TextSegment {
            /// [TextSegment][google.cloud.documentai.v1.Document.TextAnchor.TextSegment]
            /// start UTF-8 char index in the
            /// [Document.text][google.cloud.documentai.v1.Document.text].
            ///
            /// [google.cloud.documentai.v1.Document.TextAnchor.TextSegment]: crate::model::document::text_anchor::TextSegment
            /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
            pub start_index: i64,

            /// [TextSegment][google.cloud.documentai.v1.Document.TextAnchor.TextSegment]
            /// half open end UTF-8 char index in the
            /// [Document.text][google.cloud.documentai.v1.Document.text].
            ///
            /// [google.cloud.documentai.v1.Document.TextAnchor.TextSegment]: crate::model::document::text_anchor::TextSegment
            /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
            pub end_index: i64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl TextSegment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [start_index][crate::model::document::text_anchor::TextSegment::start_index].
            pub fn set_start_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.start_index = v.into();
                self
            }

            /// Sets the value of [end_index][crate::model::document::text_anchor::TextSegment::end_index].
            pub fn set_end_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.end_index = v.into();
                self
            }
        }

        impl wkt::message::Message for TextSegment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.TextAnchor.TextSegment"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TextSegment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __start_index,
                    __end_index,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TextSegment")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "startIndex" => Ok(__FieldTag::__start_index),
                                    "start_index" => Ok(__FieldTag::__start_index),
                                    "endIndex" => Ok(__FieldTag::__end_index),
                                    "end_index" => Ok(__FieldTag::__end_index),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TextSegment;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TextSegment")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__start_index => {
                                    if !fields.insert(__FieldTag::__start_index) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for start_index",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.start_index =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__end_index => {
                                    if !fields.insert(__FieldTag::__end_index) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for end_index",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.end_index =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for TextSegment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.start_index) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("startIndex", &__With(&self.start_index))?;
                }
                if !wkt::internal::is_default(&self.end_index) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("endIndex", &__With(&self.end_index))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for TextSegment {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("TextSegment");
                debug_struct.field("start_index", &self.start_index);
                debug_struct.field("end_index", &self.end_index);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Referencing the visual context of the entity in the
    /// [Document.pages][google.cloud.documentai.v1.Document.pages]. Page anchors
    /// can be cross-page, consist of multiple bounding polygons and optionally
    /// reference specific layout element types.
    ///
    /// [google.cloud.documentai.v1.Document.pages]: crate::model::Document::pages
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PageAnchor {
        /// One or more references to visual page elements
        pub page_refs: std::vec::Vec<crate::model::document::page_anchor::PageRef>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PageAnchor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [page_refs][crate::model::document::PageAnchor::page_refs].
        pub fn set_page_refs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::page_anchor::PageRef>,
        {
            use std::iter::Iterator;
            self.page_refs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PageAnchor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.PageAnchor"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PageAnchor {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __page_refs,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PageAnchor")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pageRefs" => Ok(__FieldTag::__page_refs),
                                "page_refs" => Ok(__FieldTag::__page_refs),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PageAnchor;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PageAnchor")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__page_refs => {
                                if !fields.insert(__FieldTag::__page_refs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for page_refs",
                                    ));
                                }
                                result.page_refs = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::page_anchor::PageRef>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PageAnchor {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.page_refs.is_empty() {
                state.serialize_entry("pageRefs", &self.page_refs)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PageAnchor {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PageAnchor");
            debug_struct.field("page_refs", &self.page_refs);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [PageAnchor].
    pub mod page_anchor {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a weak reference to a page element within a document.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PageRef {
            /// Required. Index into the
            /// [Document.pages][google.cloud.documentai.v1.Document.pages] element,
            /// for example using
            /// `[Document.pages][page_refs.page]` to locate the related page element.
            /// This field is skipped when its value is the default `0`. See
            /// <https://developers.google.com/protocol-buffers/docs/proto3#json>.
            ///
            /// [google.cloud.documentai.v1.Document.pages]: crate::model::Document::pages
            pub page: i64,

            /// Optional. The type of the layout element that is being referenced if
            /// any.
            pub layout_type: crate::model::document::page_anchor::page_ref::LayoutType,

            /// Optional. Deprecated.  Use
            /// [PageRef.bounding_poly][google.cloud.documentai.v1.Document.PageAnchor.PageRef.bounding_poly]
            /// instead.
            ///
            /// [google.cloud.documentai.v1.Document.PageAnchor.PageRef.bounding_poly]: crate::model::document::page_anchor::PageRef::bounding_poly
            #[deprecated]
            pub layout_id: std::string::String,

            /// Optional. Identifies the bounding polygon of a layout element on the
            /// page. If `layout_type` is set, the bounding polygon must be exactly the
            /// same to the layout element it's referring to.
            pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

            /// Optional. Confidence of detected page element, if applicable. Range
            /// `[0, 1]`.
            pub confidence: f32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PageRef {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [page][crate::model::document::page_anchor::PageRef::page].
            pub fn set_page<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.page = v.into();
                self
            }

            /// Sets the value of [layout_type][crate::model::document::page_anchor::PageRef::layout_type].
            pub fn set_layout_type<
                T: std::convert::Into<crate::model::document::page_anchor::page_ref::LayoutType>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.layout_type = v.into();
                self
            }

            /// Sets the value of [layout_id][crate::model::document::page_anchor::PageRef::layout_id].
            #[deprecated]
            pub fn set_layout_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.layout_id = v.into();
                self
            }

            /// Sets the value of [bounding_poly][crate::model::document::page_anchor::PageRef::bounding_poly].
            pub fn set_bounding_poly<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::BoundingPoly>,
            {
                self.bounding_poly = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [bounding_poly][crate::model::document::page_anchor::PageRef::bounding_poly].
            pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::BoundingPoly>,
            {
                self.bounding_poly = v.map(|x| x.into());
                self
            }

            /// Sets the value of [confidence][crate::model::document::page_anchor::PageRef::confidence].
            pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.confidence = v.into();
                self
            }
        }

        impl wkt::message::Message for PageRef {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.PageAnchor.PageRef"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PageRef {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __page,
                    __layout_type,
                    __layout_id,
                    __bounding_poly,
                    __confidence,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PageRef")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "page" => Ok(__FieldTag::__page),
                                    "layoutType" => Ok(__FieldTag::__layout_type),
                                    "layout_type" => Ok(__FieldTag::__layout_type),
                                    "layoutId" => Ok(__FieldTag::__layout_id),
                                    "layout_id" => Ok(__FieldTag::__layout_id),
                                    "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                                    "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                                    "confidence" => Ok(__FieldTag::__confidence),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PageRef;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PageRef")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__page => {
                                    if !fields.insert(__FieldTag::__page) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for page"),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.page = map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__layout_type => {
                                    if !fields.insert(__FieldTag::__layout_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for layout_type",
                                            ),
                                        );
                                    }
                                    result.layout_type = map.next_value::<std::option::Option<crate::model::document::page_anchor::page_ref::LayoutType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__layout_id => {
                                    if !fields.insert(__FieldTag::__layout_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for layout_id",
                                            ),
                                        );
                                    }
                                    result.layout_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__bounding_poly => {
                                    if !fields.insert(__FieldTag::__bounding_poly) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bounding_poly",
                                            ),
                                        );
                                    }
                                    result.bounding_poly = map.next_value::<std::option::Option<crate::model::BoundingPoly>>()?
                                        ;
                                }
                                __FieldTag::__confidence => {
                                    if !fields.insert(__FieldTag::__confidence) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidence",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.confidence =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for PageRef {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.page) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("page", &__With(&self.page))?;
                }
                if !wkt::internal::is_default(&self.layout_type) {
                    state.serialize_entry("layoutType", &self.layout_type)?;
                }
                if !self.layout_id.is_empty() {
                    state.serialize_entry("layoutId", &self.layout_id)?;
                }
                if self.bounding_poly.is_some() {
                    state.serialize_entry("boundingPoly", &self.bounding_poly)?;
                }
                if !wkt::internal::is_default(&self.confidence) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("confidence", &__With(&self.confidence))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for PageRef {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("PageRef");
                debug_struct.field("page", &self.page);
                debug_struct.field("layout_type", &self.layout_type);
                debug_struct.field("layout_id", &self.layout_id);
                debug_struct.field("bounding_poly", &self.bounding_poly);
                debug_struct.field("confidence", &self.confidence);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [PageRef].
        pub mod page_ref {
            #[allow(unused_imports)]
            use super::*;

            /// The type of layout that is being referenced.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum LayoutType {
                /// Layout Unspecified.
                Unspecified,
                /// References a
                /// [Page.blocks][google.cloud.documentai.v1.Document.Page.blocks]
                /// element.
                ///
                /// [google.cloud.documentai.v1.Document.Page.blocks]: crate::model::document::Page::blocks
                Block,
                /// References a
                /// [Page.paragraphs][google.cloud.documentai.v1.Document.Page.paragraphs]
                /// element.
                ///
                /// [google.cloud.documentai.v1.Document.Page.paragraphs]: crate::model::document::Page::paragraphs
                Paragraph,
                /// References a
                /// [Page.lines][google.cloud.documentai.v1.Document.Page.lines] element.
                ///
                /// [google.cloud.documentai.v1.Document.Page.lines]: crate::model::document::Page::lines
                Line,
                /// References a
                /// [Page.tokens][google.cloud.documentai.v1.Document.Page.tokens]
                /// element.
                ///
                /// [google.cloud.documentai.v1.Document.Page.tokens]: crate::model::document::Page::tokens
                Token,
                /// References a
                /// [Page.visual_elements][google.cloud.documentai.v1.Document.Page.visual_elements]
                /// element.
                ///
                /// [google.cloud.documentai.v1.Document.Page.visual_elements]: crate::model::document::Page::visual_elements
                VisualElement,
                /// Refrrences a
                /// [Page.tables][google.cloud.documentai.v1.Document.Page.tables]
                /// element.
                ///
                /// [google.cloud.documentai.v1.Document.Page.tables]: crate::model::document::Page::tables
                Table,
                /// References a
                /// [Page.form_fields][google.cloud.documentai.v1.Document.Page.form_fields]
                /// element.
                ///
                /// [google.cloud.documentai.v1.Document.Page.form_fields]: crate::model::document::Page::form_fields
                FormField,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [LayoutType::value] or
                /// [LayoutType::name].
                UnknownValue(layout_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod layout_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl LayoutType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Block => std::option::Option::Some(1),
                        Self::Paragraph => std::option::Option::Some(2),
                        Self::Line => std::option::Option::Some(3),
                        Self::Token => std::option::Option::Some(4),
                        Self::VisualElement => std::option::Option::Some(5),
                        Self::Table => std::option::Option::Some(6),
                        Self::FormField => std::option::Option::Some(7),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("LAYOUT_TYPE_UNSPECIFIED"),
                        Self::Block => std::option::Option::Some("BLOCK"),
                        Self::Paragraph => std::option::Option::Some("PARAGRAPH"),
                        Self::Line => std::option::Option::Some("LINE"),
                        Self::Token => std::option::Option::Some("TOKEN"),
                        Self::VisualElement => std::option::Option::Some("VISUAL_ELEMENT"),
                        Self::Table => std::option::Option::Some("TABLE"),
                        Self::FormField => std::option::Option::Some("FORM_FIELD"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for LayoutType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for LayoutType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for LayoutType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Block,
                        2 => Self::Paragraph,
                        3 => Self::Line,
                        4 => Self::Token,
                        5 => Self::VisualElement,
                        6 => Self::Table,
                        7 => Self::FormField,
                        _ => Self::UnknownValue(layout_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for LayoutType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "LAYOUT_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "BLOCK" => Self::Block,
                        "PARAGRAPH" => Self::Paragraph,
                        "LINE" => Self::Line,
                        "TOKEN" => Self::Token,
                        "VISUAL_ELEMENT" => Self::VisualElement,
                        "TABLE" => Self::Table,
                        "FORM_FIELD" => Self::FormField,
                        _ => Self::UnknownValue(layout_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for LayoutType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Block => serializer.serialize_i32(1),
                        Self::Paragraph => serializer.serialize_i32(2),
                        Self::Line => serializer.serialize_i32(3),
                        Self::Token => serializer.serialize_i32(4),
                        Self::VisualElement => serializer.serialize_i32(5),
                        Self::Table => serializer.serialize_i32(6),
                        Self::FormField => serializer.serialize_i32(7),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for LayoutType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<LayoutType>::new(
                        ".google.cloud.documentai.v1.Document.PageAnchor.PageRef.LayoutType",
                    ))
                }
            }
        }
    }

    /// Structure to identify provenance relationships between annotations in
    /// different revisions.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Provenance {
        /// The index of the revision that produced this element.
        #[deprecated]
        pub revision: i32,

        /// The Id of this operation.  Needs to be unique within the scope of the
        /// revision.
        #[deprecated]
        pub id: i32,

        /// References to the original elements that are replaced.
        pub parents: std::vec::Vec<crate::model::document::provenance::Parent>,

        /// The type of provenance operation.
        pub r#type: crate::model::document::provenance::OperationType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Provenance {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [revision][crate::model::document::Provenance::revision].
        #[deprecated]
        pub fn set_revision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.revision = v.into();
            self
        }

        /// Sets the value of [id][crate::model::document::Provenance::id].
        #[deprecated]
        pub fn set_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [parents][crate::model::document::Provenance::parents].
        pub fn set_parents<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::provenance::Parent>,
        {
            use std::iter::Iterator;
            self.parents = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [r#type][crate::model::document::Provenance::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::document::provenance::OperationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Provenance {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.Provenance"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Provenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __revision,
                __id,
                __parents,
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Provenance")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "revision" => Ok(__FieldTag::__revision),
                                "id" => Ok(__FieldTag::__id),
                                "parents" => Ok(__FieldTag::__parents),
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Provenance;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Provenance")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__revision => {
                                if !fields.insert(__FieldTag::__revision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for revision",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.revision = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__parents => {
                                if !fields.insert(__FieldTag::__parents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parents",
                                    ));
                                }
                                result.parents = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::provenance::Parent>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::document::provenance::OperationType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Provenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.revision) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("revision", &__With(&self.revision))?;
            }
            if !wkt::internal::is_default(&self.id) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("id", &__With(&self.id))?;
            }
            if !self.parents.is_empty() {
                state.serialize_entry("parents", &self.parents)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Provenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Provenance");
            debug_struct.field("revision", &self.revision);
            debug_struct.field("id", &self.id);
            debug_struct.field("parents", &self.parents);
            debug_struct.field("r#type", &self.r#type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Provenance].
    pub mod provenance {
        #[allow(unused_imports)]
        use super::*;

        /// The parent element the current element is based on. Used for
        /// referencing/aligning, removal and replacement operations.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Parent {
            /// The index of the index into current revision's parent_ids list.
            pub revision: i32,

            /// The index of the parent item in the corresponding item list (eg. list
            /// of entities, properties within entities, etc.) in the parent revision.
            pub index: i32,

            /// The id of the parent provenance.
            #[deprecated]
            pub id: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Parent {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [revision][crate::model::document::provenance::Parent::revision].
            pub fn set_revision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.revision = v.into();
                self
            }

            /// Sets the value of [index][crate::model::document::provenance::Parent::index].
            pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.index = v.into();
                self
            }

            /// Sets the value of [id][crate::model::document::provenance::Parent::id].
            #[deprecated]
            pub fn set_id<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.id = v.into();
                self
            }
        }

        impl wkt::message::Message for Parent {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Provenance.Parent"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Parent {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __revision,
                    __index,
                    __id,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Parent")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "revision" => Ok(__FieldTag::__revision),
                                    "index" => Ok(__FieldTag::__index),
                                    "id" => Ok(__FieldTag::__id),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Parent;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Parent")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__revision => {
                                    if !fields.insert(__FieldTag::__revision) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for revision",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.revision =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__index => {
                                    if !fields.insert(__FieldTag::__index) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for index"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.index =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__id => {
                                    if !fields.insert(__FieldTag::__id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for id"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.id = map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Parent {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.revision) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("revision", &__With(&self.revision))?;
                }
                if !wkt::internal::is_default(&self.index) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("index", &__With(&self.index))?;
                }
                if !wkt::internal::is_default(&self.id) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("id", &__With(&self.id))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Parent {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Parent");
                debug_struct.field("revision", &self.revision);
                debug_struct.field("index", &self.index);
                debug_struct.field("id", &self.id);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// If a processor or agent does an explicit operation on existing elements.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum OperationType {
            /// Operation type unspecified. If no operation is specified a provenance
            /// entry is simply used to match against a `parent`.
            Unspecified,
            /// Add an element.
            Add,
            /// Remove an element identified by `parent`.
            Remove,
            /// Updates any fields within the given provenance scope of the message. It
            /// overwrites the fields rather than replacing them.  Use this when you
            /// want to update a field value of an entity without also updating all the
            /// child properties.
            Update,
            /// Currently unused. Replace an element identified by `parent`.
            Replace,
            /// Deprecated. Request human review for the element identified by
            /// `parent`.
            #[deprecated]
            EvalRequested,
            /// Deprecated. Element is reviewed and approved at human review,
            /// confidence will be set to 1.0.
            #[deprecated]
            EvalApproved,
            /// Deprecated. Element is skipped in the validation process.
            #[deprecated]
            EvalSkipped,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [OperationType::value] or
            /// [OperationType::name].
            UnknownValue(operation_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod operation_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl OperationType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Add => std::option::Option::Some(1),
                    Self::Remove => std::option::Option::Some(2),
                    Self::Update => std::option::Option::Some(7),
                    Self::Replace => std::option::Option::Some(3),
                    Self::EvalRequested => std::option::Option::Some(4),
                    Self::EvalApproved => std::option::Option::Some(5),
                    Self::EvalSkipped => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATION_TYPE_UNSPECIFIED"),
                    Self::Add => std::option::Option::Some("ADD"),
                    Self::Remove => std::option::Option::Some("REMOVE"),
                    Self::Update => std::option::Option::Some("UPDATE"),
                    Self::Replace => std::option::Option::Some("REPLACE"),
                    Self::EvalRequested => std::option::Option::Some("EVAL_REQUESTED"),
                    Self::EvalApproved => std::option::Option::Some("EVAL_APPROVED"),
                    Self::EvalSkipped => std::option::Option::Some("EVAL_SKIPPED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for OperationType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for OperationType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for OperationType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Add,
                    2 => Self::Remove,
                    3 => Self::Replace,
                    4 => Self::EvalRequested,
                    5 => Self::EvalApproved,
                    6 => Self::EvalSkipped,
                    7 => Self::Update,
                    _ => Self::UnknownValue(operation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for OperationType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ADD" => Self::Add,
                    "REMOVE" => Self::Remove,
                    "UPDATE" => Self::Update,
                    "REPLACE" => Self::Replace,
                    "EVAL_REQUESTED" => Self::EvalRequested,
                    "EVAL_APPROVED" => Self::EvalApproved,
                    "EVAL_SKIPPED" => Self::EvalSkipped,
                    _ => Self::UnknownValue(operation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for OperationType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Add => serializer.serialize_i32(1),
                    Self::Remove => serializer.serialize_i32(2),
                    Self::Update => serializer.serialize_i32(7),
                    Self::Replace => serializer.serialize_i32(3),
                    Self::EvalRequested => serializer.serialize_i32(4),
                    Self::EvalApproved => serializer.serialize_i32(5),
                    Self::EvalSkipped => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for OperationType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationType>::new(
                    ".google.cloud.documentai.v1.Document.Provenance.OperationType",
                ))
            }
        }
    }

    /// Contains past or forward revisions of this document.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Revision {
        /// Id of the revision, internally generated by doc proto storage.
        /// Unique within the context of the document.
        pub id: std::string::String,

        /// The revisions that this revision is based on.  This can include one or
        /// more parent (when documents are merged.)  This field represents the
        /// index into the `revisions` field.
        #[deprecated]
        pub parent: std::vec::Vec<i32>,

        /// The revisions that this revision is based on. Must include all the ids
        /// that have anything to do with this revision - eg. there are
        /// `provenance.parent.revision` fields that index into this field.
        pub parent_ids: std::vec::Vec<std::string::String>,

        /// The time that the revision was created, internally generated by
        /// doc proto storage at the time of create.
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// Human Review information of this revision.
        pub human_review: std::option::Option<crate::model::document::revision::HumanReview>,

        /// Who/what made the change
        pub source: std::option::Option<crate::model::document::revision::Source>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Revision {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::document::Revision::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [parent][crate::model::document::Revision::parent].
        #[deprecated]
        pub fn set_parent<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.parent = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [parent_ids][crate::model::document::Revision::parent_ids].
        pub fn set_parent_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.parent_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [create_time][crate::model::document::Revision::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::document::Revision::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [human_review][crate::model::document::Revision::human_review].
        pub fn set_human_review<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::revision::HumanReview>,
        {
            self.human_review = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [human_review][crate::model::document::Revision::human_review].
        pub fn set_or_clear_human_review<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::revision::HumanReview>,
        {
            self.human_review = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source][crate::model::document::Revision::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<std::option::Option<crate::model::document::revision::Source>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::document::Revision::source]
        /// if it holds a `Agent`, `None` if the field is not set or
        /// holds a different branch.
        pub fn agent(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::document::revision::Source::Agent(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::document::Revision::source]
        /// to hold a `Agent`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = std::option::Option::Some(
                crate::model::document::revision::Source::Agent(v.into()),
            );
            self
        }

        /// The value of [source][crate::model::document::Revision::source]
        /// if it holds a `Processor`, `None` if the field is not set or
        /// holds a different branch.
        pub fn processor(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::document::revision::Source::Processor(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::document::Revision::source]
        /// to hold a `Processor`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_processor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = std::option::Option::Some(
                crate::model::document::revision::Source::Processor(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Revision {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.Revision"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Revision {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __agent,
                __processor,
                __id,
                __parent,
                __parent_ids,
                __create_time,
                __human_review,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Revision")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "agent" => Ok(__FieldTag::__agent),
                                "processor" => Ok(__FieldTag::__processor),
                                "id" => Ok(__FieldTag::__id),
                                "parent" => Ok(__FieldTag::__parent),
                                "parentIds" => Ok(__FieldTag::__parent_ids),
                                "parent_ids" => Ok(__FieldTag::__parent_ids),
                                "createTime" => Ok(__FieldTag::__create_time),
                                "create_time" => Ok(__FieldTag::__create_time),
                                "humanReview" => Ok(__FieldTag::__human_review),
                                "human_review" => Ok(__FieldTag::__human_review),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Revision;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Revision")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__agent => {
                                if !fields.insert(__FieldTag::__agent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.Document.Revision.agent, latest field was agent",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::document::revision::Source::Agent(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__processor => {
                                if !fields.insert(__FieldTag::__processor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for processor",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.Document.Revision.processor, latest field was processor",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::document::revision::Source::Processor(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parent => {
                                if !fields.insert(__FieldTag::__parent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i32>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.parent = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__parent_ids => {
                                if !fields.insert(__FieldTag::__parent_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent_ids",
                                    ));
                                }
                                result.parent_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__create_time => {
                                if !fields.insert(__FieldTag::__create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create_time",
                                    ));
                                }
                                result.create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__human_review => {
                                if !fields.insert(__FieldTag::__human_review) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for human_review",
                                    ));
                                }
                                result.human_review = map.next_value::<std::option::Option<
                                    crate::model::document::revision::HumanReview,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Revision {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.agent() {
                state.serialize_entry("agent", value)?;
            }
            if let Some(value) = self.processor() {
                state.serialize_entry("processor", value)?;
            }
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.parent.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("parent", &__With(&self.parent))?;
            }
            if !self.parent_ids.is_empty() {
                state.serialize_entry("parentIds", &self.parent_ids)?;
            }
            if self.create_time.is_some() {
                state.serialize_entry("createTime", &self.create_time)?;
            }
            if self.human_review.is_some() {
                state.serialize_entry("humanReview", &self.human_review)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Revision {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Revision");
            debug_struct.field("id", &self.id);
            debug_struct.field("parent", &self.parent);
            debug_struct.field("parent_ids", &self.parent_ids);
            debug_struct.field("create_time", &self.create_time);
            debug_struct.field("human_review", &self.human_review);
            debug_struct.field("source", &self.source);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Revision].
    pub mod revision {
        #[allow(unused_imports)]
        use super::*;

        /// Human Review information of the document.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct HumanReview {
            /// Human review state. e.g. `requested`, `succeeded`, `rejected`.
            pub state: std::string::String,

            /// A message providing more details about the current state of processing.
            /// For example, the rejection reason when the state is `rejected`.
            pub state_message: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl HumanReview {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::document::revision::HumanReview::state].
            pub fn set_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.state = v.into();
                self
            }

            /// Sets the value of [state_message][crate::model::document::revision::HumanReview::state_message].
            pub fn set_state_message<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.state_message = v.into();
                self
            }
        }

        impl wkt::message::Message for HumanReview {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.Revision.HumanReview"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for HumanReview {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __state,
                    __state_message,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for HumanReview")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "state" => Ok(__FieldTag::__state),
                                    "stateMessage" => Ok(__FieldTag::__state_message),
                                    "state_message" => Ok(__FieldTag::__state_message),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = HumanReview;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct HumanReview")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__state => {
                                    if !fields.insert(__FieldTag::__state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for state"),
                                        );
                                    }
                                    result.state = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__state_message => {
                                    if !fields.insert(__FieldTag::__state_message) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for state_message",
                                            ),
                                        );
                                    }
                                    result.state_message = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for HumanReview {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.state.is_empty() {
                    state.serialize_entry("state", &self.state)?;
                }
                if !self.state_message.is_empty() {
                    state.serialize_entry("stateMessage", &self.state_message)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for HumanReview {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("HumanReview");
                debug_struct.field("state", &self.state);
                debug_struct.field("state_message", &self.state_message);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Who/what made the change
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Source {
            /// If the change was made by a person specify the name or id of that
            /// person.
            Agent(std::string::String),
            /// If the annotation was made by processor identify the processor by its
            /// resource name.
            Processor(std::string::String),
        }
    }

    /// This message is used for text changes aka. OCR corrections.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TextChange {
        /// Provenance of the correction.
        /// Text anchor indexing into the
        /// [Document.text][google.cloud.documentai.v1.Document.text].  There can
        /// only be a single `TextAnchor.text_segments` element.  If the start and
        /// end index of the text segment are the same, the text change is inserted
        /// before that index.
        ///
        /// [google.cloud.documentai.v1.Document.text]: crate::model::Document::text
        pub text_anchor: std::option::Option<crate::model::document::TextAnchor>,

        /// The text that replaces the text identified in the `text_anchor`.
        pub changed_text: std::string::String,

        /// The history of this annotation.
        #[deprecated]
        pub provenance: std::vec::Vec<crate::model::document::Provenance>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextChange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text_anchor][crate::model::document::TextChange::text_anchor].
        pub fn set_text_anchor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::document::TextAnchor>,
        {
            self.text_anchor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [text_anchor][crate::model::document::TextChange::text_anchor].
        pub fn set_or_clear_text_anchor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::document::TextAnchor>,
        {
            self.text_anchor = v.map(|x| x.into());
            self
        }

        /// Sets the value of [changed_text][crate::model::document::TextChange::changed_text].
        pub fn set_changed_text<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.changed_text = v.into();
            self
        }

        /// Sets the value of [provenance][crate::model::document::TextChange::provenance].
        #[deprecated]
        pub fn set_provenance<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::Provenance>,
        {
            use std::iter::Iterator;
            self.provenance = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TextChange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.TextChange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TextChange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text_anchor,
                __changed_text,
                __provenance,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TextChange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "textAnchor" => Ok(__FieldTag::__text_anchor),
                                "text_anchor" => Ok(__FieldTag::__text_anchor),
                                "changedText" => Ok(__FieldTag::__changed_text),
                                "changed_text" => Ok(__FieldTag::__changed_text),
                                "provenance" => Ok(__FieldTag::__provenance),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TextChange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TextChange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text_anchor => {
                                if !fields.insert(__FieldTag::__text_anchor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_anchor",
                                    ));
                                }
                                result.text_anchor = map.next_value::<std::option::Option<crate::model::document::TextAnchor>>()?
                                    ;
                            }
                            __FieldTag::__changed_text => {
                                if !fields.insert(__FieldTag::__changed_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for changed_text",
                                    ));
                                }
                                result.changed_text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__provenance => {
                                if !fields.insert(__FieldTag::__provenance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for provenance",
                                    ));
                                }
                                result.provenance = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::document::Provenance>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TextChange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.text_anchor.is_some() {
                state.serialize_entry("textAnchor", &self.text_anchor)?;
            }
            if !self.changed_text.is_empty() {
                state.serialize_entry("changedText", &self.changed_text)?;
            }
            if !self.provenance.is_empty() {
                state.serialize_entry("provenance", &self.provenance)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TextChange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TextChange");
            debug_struct.field("text_anchor", &self.text_anchor);
            debug_struct.field("changed_text", &self.changed_text);
            debug_struct.field("provenance", &self.provenance);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents the parsed layout of a document as a collection of blocks that
    /// the document is divided into.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DocumentLayout {
        /// List of blocks in the document.
        pub blocks: std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DocumentLayout {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [blocks][crate::model::document::DocumentLayout::blocks].
        pub fn set_blocks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::document_layout::DocumentLayoutBlock>,
        {
            use std::iter::Iterator;
            self.blocks = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DocumentLayout {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DocumentLayout {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __blocks,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DocumentLayout")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "blocks" => Ok(__FieldTag::__blocks),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DocumentLayout;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DocumentLayout")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__blocks => {
                                if !fields.insert(__FieldTag::__blocks) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for blocks",
                                    ));
                                }
                                result.blocks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DocumentLayout {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.blocks.is_empty() {
                state.serialize_entry("blocks", &self.blocks)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DocumentLayout {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DocumentLayout");
            debug_struct.field("blocks", &self.blocks);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [DocumentLayout].
    pub mod document_layout {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a block. A block could be one of the various types (text,
        /// table, list) supported.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DocumentLayoutBlock {
            /// ID of the block.
            pub block_id: std::string::String,

            /// Page span of the block.
            pub page_span: std::option::Option<
                crate::model::document::document_layout::document_layout_block::LayoutPageSpan,
            >,

            /// Identifies the bounding box for the block.
            pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

            pub block: std::option::Option<
                crate::model::document::document_layout::document_layout_block::Block,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DocumentLayoutBlock {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [block_id][crate::model::document::document_layout::DocumentLayoutBlock::block_id].
            pub fn set_block_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.block_id = v.into();
                self
            }

            /// Sets the value of [page_span][crate::model::document::document_layout::DocumentLayoutBlock::page_span].
            pub fn set_page_span<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::document::document_layout::document_layout_block::LayoutPageSpan>
            {
                self.page_span = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [page_span][crate::model::document::document_layout::DocumentLayoutBlock::page_span].
            pub fn set_or_clear_page_span<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::document::document_layout::document_layout_block::LayoutPageSpan>
            {
                self.page_span = v.map(|x| x.into());
                self
            }

            /// Sets the value of [bounding_box][crate::model::document::document_layout::DocumentLayoutBlock::bounding_box].
            pub fn set_bounding_box<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::BoundingPoly>,
            {
                self.bounding_box = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [bounding_box][crate::model::document::document_layout::DocumentLayoutBlock::bounding_box].
            pub fn set_or_clear_bounding_box<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::BoundingPoly>,
            {
                self.bounding_box = v.map(|x| x.into());
                self
            }

            /// Sets the value of [block][crate::model::document::document_layout::DocumentLayoutBlock::block].
            ///
            /// Note that all the setters affecting `block` are mutually
            /// exclusive.
            pub fn set_block<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::document::document_layout::document_layout_block::Block,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.block = v.into();
                self
            }

            /// The value of [block][crate::model::document::document_layout::DocumentLayoutBlock::block]
            /// if it holds a `TextBlock`, `None` if the field is not set or
            /// holds a different branch.
            pub fn text_block(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::document::document_layout::document_layout_block::LayoutTextBlock,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.block.as_ref().and_then(|v| match v {
                    crate::model::document::document_layout::document_layout_block::Block::TextBlock(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [block][crate::model::document::document_layout::DocumentLayoutBlock::block]
            /// to hold a `TextBlock`.
            ///
            /// Note that all the setters affecting `block` are
            /// mutually exclusive.
            pub fn set_text_block<T: std::convert::Into<std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutTextBlock>>>(mut self, v: T) -> Self{
                self.block = std::option::Option::Some(
                    crate::model::document::document_layout::document_layout_block::Block::TextBlock(
                        v.into()
                    )
                );
                self
            }

            /// The value of [block][crate::model::document::document_layout::DocumentLayoutBlock::block]
            /// if it holds a `TableBlock`, `None` if the field is not set or
            /// holds a different branch.
            pub fn table_block(&self) -> std::option::Option<&std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutTableBlock>>{
                #[allow(unreachable_patterns)]
                self.block.as_ref().and_then(|v| match v {
                    crate::model::document::document_layout::document_layout_block::Block::TableBlock(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [block][crate::model::document::document_layout::DocumentLayoutBlock::block]
            /// to hold a `TableBlock`.
            ///
            /// Note that all the setters affecting `block` are
            /// mutually exclusive.
            pub fn set_table_block<T: std::convert::Into<std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutTableBlock>>>(mut self, v: T) -> Self{
                self.block = std::option::Option::Some(
                    crate::model::document::document_layout::document_layout_block::Block::TableBlock(
                        v.into()
                    )
                );
                self
            }

            /// The value of [block][crate::model::document::document_layout::DocumentLayoutBlock::block]
            /// if it holds a `ListBlock`, `None` if the field is not set or
            /// holds a different branch.
            pub fn list_block(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::document::document_layout::document_layout_block::LayoutListBlock,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.block.as_ref().and_then(|v| match v {
                    crate::model::document::document_layout::document_layout_block::Block::ListBlock(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [block][crate::model::document::document_layout::DocumentLayoutBlock::block]
            /// to hold a `ListBlock`.
            ///
            /// Note that all the setters affecting `block` are
            /// mutually exclusive.
            pub fn set_list_block<T: std::convert::Into<std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutListBlock>>>(mut self, v: T) -> Self{
                self.block = std::option::Option::Some(
                    crate::model::document::document_layout::document_layout_block::Block::ListBlock(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for DocumentLayoutBlock {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DocumentLayoutBlock {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text_block,
                    __table_block,
                    __list_block,
                    __block_id,
                    __page_span,
                    __bounding_box,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DocumentLayoutBlock")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "textBlock" => Ok(__FieldTag::__text_block),
                                    "text_block" => Ok(__FieldTag::__text_block),
                                    "tableBlock" => Ok(__FieldTag::__table_block),
                                    "table_block" => Ok(__FieldTag::__table_block),
                                    "listBlock" => Ok(__FieldTag::__list_block),
                                    "list_block" => Ok(__FieldTag::__list_block),
                                    "blockId" => Ok(__FieldTag::__block_id),
                                    "block_id" => Ok(__FieldTag::__block_id),
                                    "pageSpan" => Ok(__FieldTag::__page_span),
                                    "page_span" => Ok(__FieldTag::__page_span),
                                    "boundingBox" => Ok(__FieldTag::__bounding_box),
                                    "bounding_box" => Ok(__FieldTag::__bounding_box),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DocumentLayoutBlock;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DocumentLayoutBlock")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text_block => {
                                    if !fields.insert(__FieldTag::__text_block) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for text_block",
                                            ),
                                        );
                                    }
                                    if result.block.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `block`, a oneof with full ID .google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.text_block, latest field was textBlock",
                                            ),
                                        );
                                    }
                                    result.block = std::option::Option::Some(
                                        crate::model::document::document_layout::document_layout_block::Block::TextBlock(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutTextBlock>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__table_block => {
                                    if !fields.insert(__FieldTag::__table_block) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for table_block",
                                            ),
                                        );
                                    }
                                    if result.block.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `block`, a oneof with full ID .google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.table_block, latest field was tableBlock",
                                            ),
                                        );
                                    }
                                    result.block = std::option::Option::Some(
                                        crate::model::document::document_layout::document_layout_block::Block::TableBlock(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutTableBlock>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__list_block => {
                                    if !fields.insert(__FieldTag::__list_block) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for list_block",
                                            ),
                                        );
                                    }
                                    if result.block.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `block`, a oneof with full ID .google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.list_block, latest field was listBlock",
                                            ),
                                        );
                                    }
                                    result.block = std::option::Option::Some(
                                        crate::model::document::document_layout::document_layout_block::Block::ListBlock(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutListBlock>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__block_id => {
                                    if !fields.insert(__FieldTag::__block_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for block_id",
                                            ),
                                        );
                                    }
                                    result.block_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__page_span => {
                                    if !fields.insert(__FieldTag::__page_span) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for page_span",
                                            ),
                                        );
                                    }
                                    result.page_span = map.next_value::<std::option::Option<crate::model::document::document_layout::document_layout_block::LayoutPageSpan>>()?
                                        ;
                                }
                                __FieldTag::__bounding_box => {
                                    if !fields.insert(__FieldTag::__bounding_box) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bounding_box",
                                            ),
                                        );
                                    }
                                    result.bounding_box = map.next_value::<std::option::Option<crate::model::BoundingPoly>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DocumentLayoutBlock {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.text_block() {
                    state.serialize_entry("textBlock", value)?;
                }
                if let Some(value) = self.table_block() {
                    state.serialize_entry("tableBlock", value)?;
                }
                if let Some(value) = self.list_block() {
                    state.serialize_entry("listBlock", value)?;
                }
                if !self.block_id.is_empty() {
                    state.serialize_entry("blockId", &self.block_id)?;
                }
                if self.page_span.is_some() {
                    state.serialize_entry("pageSpan", &self.page_span)?;
                }
                if self.bounding_box.is_some() {
                    state.serialize_entry("boundingBox", &self.bounding_box)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for DocumentLayoutBlock {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("DocumentLayoutBlock");
                debug_struct.field("block_id", &self.block_id);
                debug_struct.field("page_span", &self.page_span);
                debug_struct.field("bounding_box", &self.bounding_box);
                debug_struct.field("block", &self.block);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [DocumentLayoutBlock].
        pub mod document_layout_block {
            #[allow(unused_imports)]
            use super::*;

            /// Represents where the block starts and ends in the document.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct LayoutPageSpan {
                /// Page where block starts in the document.
                pub page_start: i32,

                /// Page where block ends in the document.
                pub page_end: i32,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl LayoutPageSpan {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [page_start][crate::model::document::document_layout::document_layout_block::LayoutPageSpan::page_start].
                pub fn set_page_start<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.page_start = v.into();
                    self
                }

                /// Sets the value of [page_end][crate::model::document::document_layout::document_layout_block::LayoutPageSpan::page_end].
                pub fn set_page_end<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.page_end = v.into();
                    self
                }
            }

            impl wkt::message::Message for LayoutPageSpan {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.LayoutPageSpan"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for LayoutPageSpan {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __page_start,
                        __page_end,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for LayoutPageSpan")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "pageStart" => Ok(__FieldTag::__page_start),
                                        "page_start" => Ok(__FieldTag::__page_start),
                                        "pageEnd" => Ok(__FieldTag::__page_end),
                                        "page_end" => Ok(__FieldTag::__page_end),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = LayoutPageSpan;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct LayoutPageSpan")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__page_start => {
                                        if !fields.insert(__FieldTag::__page_start) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for page_start",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.page_start =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__page_end => {
                                        if !fields.insert(__FieldTag::__page_end) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for page_end",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.page_end =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for LayoutPageSpan {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.page_start) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("pageStart", &__With(&self.page_start))?;
                    }
                    if !wkt::internal::is_default(&self.page_end) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("pageEnd", &__With(&self.page_end))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for LayoutPageSpan {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("LayoutPageSpan");
                    debug_struct.field("page_start", &self.page_start);
                    debug_struct.field("page_end", &self.page_end);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents a text type block.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct LayoutTextBlock {
                /// Text content stored in the block.
                pub text: std::string::String,

                /// Type of the text in the block. Available options are: `paragraph`,
                /// `subtitle`, `heading-1`, `heading-2`, `heading-3`, `heading-4`,
                /// `heading-5`, `header`, `footer`.
                pub r#type: std::string::String,

                /// A text block could further have child blocks.
                /// Repeated blocks support further hierarchies and nested blocks.
                pub blocks:
                    std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl LayoutTextBlock {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [text][crate::model::document::document_layout::document_layout_block::LayoutTextBlock::text].
                pub fn set_text<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.text = v.into();
                    self
                }

                /// Sets the value of [r#type][crate::model::document::document_layout::document_layout_block::LayoutTextBlock::type].
                pub fn set_type<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.r#type = v.into();
                    self
                }

                /// Sets the value of [blocks][crate::model::document::document_layout::document_layout_block::LayoutTextBlock::blocks].
                pub fn set_blocks<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<
                            crate::model::document::document_layout::DocumentLayoutBlock,
                        >,
                {
                    use std::iter::Iterator;
                    self.blocks = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for LayoutTextBlock {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.LayoutTextBlock"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for LayoutTextBlock {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __text,
                        __type,
                        __blocks,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for LayoutTextBlock")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "text" => Ok(__FieldTag::__text),
                                        "type" => Ok(__FieldTag::__type),
                                        "blocks" => Ok(__FieldTag::__blocks),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = LayoutTextBlock;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct LayoutTextBlock")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__text => {
                                        if !fields.insert(__FieldTag::__text) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for text",
                                                ),
                                            );
                                        }
                                        result.text = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__type => {
                                        if !fields.insert(__FieldTag::__type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for type",
                                                ),
                                            );
                                        }
                                        result.r#type = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__blocks => {
                                        if !fields.insert(__FieldTag::__blocks) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for blocks",
                                                ),
                                            );
                                        }
                                        result.blocks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for LayoutTextBlock {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.text.is_empty() {
                        state.serialize_entry("text", &self.text)?;
                    }
                    if !self.r#type.is_empty() {
                        state.serialize_entry("type", &self.r#type)?;
                    }
                    if !self.blocks.is_empty() {
                        state.serialize_entry("blocks", &self.blocks)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for LayoutTextBlock {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("LayoutTextBlock");
                    debug_struct.field("text", &self.text);
                    debug_struct.field("r#type", &self.r#type);
                    debug_struct.field("blocks", &self.blocks);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents a table type block.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct LayoutTableBlock {
                /// Header rows at the top of the table.
                pub header_rows: std::vec::Vec<
                    crate::model::document::document_layout::document_layout_block::LayoutTableRow,
                >,

                /// Body rows containing main table content.
                pub body_rows: std::vec::Vec<
                    crate::model::document::document_layout::document_layout_block::LayoutTableRow,
                >,

                /// Table caption/title.
                pub caption: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl LayoutTableBlock {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [header_rows][crate::model::document::document_layout::document_layout_block::LayoutTableBlock::header_rows].
                pub fn set_header_rows<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::document::document_layout::document_layout_block::LayoutTableRow>
                {
                    use std::iter::Iterator;
                    self.header_rows = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [body_rows][crate::model::document::document_layout::document_layout_block::LayoutTableBlock::body_rows].
                pub fn set_body_rows<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::document::document_layout::document_layout_block::LayoutTableRow>
                {
                    use std::iter::Iterator;
                    self.body_rows = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [caption][crate::model::document::document_layout::document_layout_block::LayoutTableBlock::caption].
                pub fn set_caption<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.caption = v.into();
                    self
                }
            }

            impl wkt::message::Message for LayoutTableBlock {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.LayoutTableBlock"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for LayoutTableBlock {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __header_rows,
                        __body_rows,
                        __caption,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for LayoutTableBlock")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "headerRows" => Ok(__FieldTag::__header_rows),
                                        "header_rows" => Ok(__FieldTag::__header_rows),
                                        "bodyRows" => Ok(__FieldTag::__body_rows),
                                        "body_rows" => Ok(__FieldTag::__body_rows),
                                        "caption" => Ok(__FieldTag::__caption),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = LayoutTableBlock;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct LayoutTableBlock")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__header_rows => {
                                        if !fields.insert(__FieldTag::__header_rows) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for header_rows",
                                                ),
                                            );
                                        }
                                        result.header_rows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::document_layout_block::LayoutTableRow>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__body_rows => {
                                        if !fields.insert(__FieldTag::__body_rows) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for body_rows",
                                                ),
                                            );
                                        }
                                        result.body_rows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::document_layout_block::LayoutTableRow>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__caption => {
                                        if !fields.insert(__FieldTag::__caption) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for caption",
                                                ),
                                            );
                                        }
                                        result.caption = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for LayoutTableBlock {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.header_rows.is_empty() {
                        state.serialize_entry("headerRows", &self.header_rows)?;
                    }
                    if !self.body_rows.is_empty() {
                        state.serialize_entry("bodyRows", &self.body_rows)?;
                    }
                    if !self.caption.is_empty() {
                        state.serialize_entry("caption", &self.caption)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for LayoutTableBlock {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("LayoutTableBlock");
                    debug_struct.field("header_rows", &self.header_rows);
                    debug_struct.field("body_rows", &self.body_rows);
                    debug_struct.field("caption", &self.caption);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents a row in a table.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct LayoutTableRow {
                /// A table row is a list of table cells.
                pub cells: std::vec::Vec<
                    crate::model::document::document_layout::document_layout_block::LayoutTableCell,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl LayoutTableRow {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [cells][crate::model::document::document_layout::document_layout_block::LayoutTableRow::cells].
                pub fn set_cells<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::document::document_layout::document_layout_block::LayoutTableCell>
                {
                    use std::iter::Iterator;
                    self.cells = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for LayoutTableRow {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.LayoutTableRow"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for LayoutTableRow {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __cells,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for LayoutTableRow")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "cells" => Ok(__FieldTag::__cells),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = LayoutTableRow;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct LayoutTableRow")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__cells => {
                                        if !fields.insert(__FieldTag::__cells) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for cells",
                                                ),
                                            );
                                        }
                                        result.cells = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::document_layout_block::LayoutTableCell>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for LayoutTableRow {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.cells.is_empty() {
                        state.serialize_entry("cells", &self.cells)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for LayoutTableRow {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("LayoutTableRow");
                    debug_struct.field("cells", &self.cells);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents a cell in a table row.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct LayoutTableCell {
                /// A table cell is a list of blocks.
                /// Repeated blocks support further hierarchies and nested blocks.
                pub blocks:
                    std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>,

                /// How many rows this cell spans.
                pub row_span: i32,

                /// How many columns this cell spans.
                pub col_span: i32,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl LayoutTableCell {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [blocks][crate::model::document::document_layout::document_layout_block::LayoutTableCell::blocks].
                pub fn set_blocks<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<
                            crate::model::document::document_layout::DocumentLayoutBlock,
                        >,
                {
                    use std::iter::Iterator;
                    self.blocks = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [row_span][crate::model::document::document_layout::document_layout_block::LayoutTableCell::row_span].
                pub fn set_row_span<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.row_span = v.into();
                    self
                }

                /// Sets the value of [col_span][crate::model::document::document_layout::document_layout_block::LayoutTableCell::col_span].
                pub fn set_col_span<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.col_span = v.into();
                    self
                }
            }

            impl wkt::message::Message for LayoutTableCell {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.LayoutTableCell"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for LayoutTableCell {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __blocks,
                        __row_span,
                        __col_span,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for LayoutTableCell")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "blocks" => Ok(__FieldTag::__blocks),
                                        "rowSpan" => Ok(__FieldTag::__row_span),
                                        "row_span" => Ok(__FieldTag::__row_span),
                                        "colSpan" => Ok(__FieldTag::__col_span),
                                        "col_span" => Ok(__FieldTag::__col_span),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = LayoutTableCell;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct LayoutTableCell")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__blocks => {
                                        if !fields.insert(__FieldTag::__blocks) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for blocks",
                                                ),
                                            );
                                        }
                                        result.blocks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__row_span => {
                                        if !fields.insert(__FieldTag::__row_span) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for row_span",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.row_span =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__col_span => {
                                        if !fields.insert(__FieldTag::__col_span) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for col_span",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.col_span =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for LayoutTableCell {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.blocks.is_empty() {
                        state.serialize_entry("blocks", &self.blocks)?;
                    }
                    if !wkt::internal::is_default(&self.row_span) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("rowSpan", &__With(&self.row_span))?;
                    }
                    if !wkt::internal::is_default(&self.col_span) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("colSpan", &__With(&self.col_span))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for LayoutTableCell {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("LayoutTableCell");
                    debug_struct.field("blocks", &self.blocks);
                    debug_struct.field("row_span", &self.row_span);
                    debug_struct.field("col_span", &self.col_span);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents a list type block.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct LayoutListBlock {
                /// List entries that constitute a list block.
                pub list_entries: std::vec::Vec<
                    crate::model::document::document_layout::document_layout_block::LayoutListEntry,
                >,

                /// Type of the list_entries (if exist). Available options are `ordered`
                /// and `unordered`.
                pub r#type: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl LayoutListBlock {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [list_entries][crate::model::document::document_layout::document_layout_block::LayoutListBlock::list_entries].
                pub fn set_list_entries<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::document::document_layout::document_layout_block::LayoutListEntry>
                {
                    use std::iter::Iterator;
                    self.list_entries = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [r#type][crate::model::document::document_layout::document_layout_block::LayoutListBlock::type].
                pub fn set_type<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.r#type = v.into();
                    self
                }
            }

            impl wkt::message::Message for LayoutListBlock {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.LayoutListBlock"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for LayoutListBlock {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __list_entries,
                        __type,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for LayoutListBlock")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "listEntries" => Ok(__FieldTag::__list_entries),
                                        "list_entries" => Ok(__FieldTag::__list_entries),
                                        "type" => Ok(__FieldTag::__type),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = LayoutListBlock;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct LayoutListBlock")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__list_entries => {
                                        if !fields.insert(__FieldTag::__list_entries) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for list_entries",
                                                ),
                                            );
                                        }
                                        result.list_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::document_layout_block::LayoutListEntry>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::__type => {
                                        if !fields.insert(__FieldTag::__type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for type",
                                                ),
                                            );
                                        }
                                        result.r#type = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for LayoutListBlock {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.list_entries.is_empty() {
                        state.serialize_entry("listEntries", &self.list_entries)?;
                    }
                    if !self.r#type.is_empty() {
                        state.serialize_entry("type", &self.r#type)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for LayoutListBlock {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("LayoutListBlock");
                    debug_struct.field("list_entries", &self.list_entries);
                    debug_struct.field("r#type", &self.r#type);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents an entry in the list.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct LayoutListEntry {
                /// A list entry is a list of blocks.
                /// Repeated blocks support further hierarchies and nested blocks.
                pub blocks:
                    std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl LayoutListEntry {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [blocks][crate::model::document::document_layout::document_layout_block::LayoutListEntry::blocks].
                pub fn set_blocks<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<
                            crate::model::document::document_layout::DocumentLayoutBlock,
                        >,
                {
                    use std::iter::Iterator;
                    self.blocks = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for LayoutListEntry {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.DocumentLayout.DocumentLayoutBlock.LayoutListEntry"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for LayoutListEntry {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __blocks,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for LayoutListEntry")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "blocks" => Ok(__FieldTag::__blocks),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = LayoutListEntry;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct LayoutListEntry")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__blocks => {
                                        if !fields.insert(__FieldTag::__blocks) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for blocks",
                                                ),
                                            );
                                        }
                                        result.blocks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::document_layout::DocumentLayoutBlock>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for LayoutListEntry {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.blocks.is_empty() {
                        state.serialize_entry("blocks", &self.blocks)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for LayoutListEntry {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("LayoutListEntry");
                    debug_struct.field("blocks", &self.blocks);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Block {
                /// Block consisting of text content.
                TextBlock(std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutTextBlock>),
                /// Block consisting of table content/structure.
                TableBlock(std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutTableBlock>),
                /// Block consisting of list content/structure.
                ListBlock(std::boxed::Box<crate::model::document::document_layout::document_layout_block::LayoutListBlock>),
            }
        }
    }

    /// Represents the chunks that the document is divided into.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ChunkedDocument {
        /// List of chunks.
        pub chunks: std::vec::Vec<crate::model::document::chunked_document::Chunk>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ChunkedDocument {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [chunks][crate::model::document::ChunkedDocument::chunks].
        pub fn set_chunks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document::chunked_document::Chunk>,
        {
            use std::iter::Iterator;
            self.chunks = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ChunkedDocument {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Document.ChunkedDocument"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ChunkedDocument {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __chunks,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ChunkedDocument")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "chunks" => Ok(__FieldTag::__chunks),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ChunkedDocument;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ChunkedDocument")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__chunks => {
                                if !fields.insert(__FieldTag::__chunks) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for chunks",
                                    ));
                                }
                                result.chunks = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::document::chunked_document::Chunk,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ChunkedDocument {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.chunks.is_empty() {
                state.serialize_entry("chunks", &self.chunks)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ChunkedDocument {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ChunkedDocument");
            debug_struct.field("chunks", &self.chunks);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ChunkedDocument].
    pub mod chunked_document {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a chunk.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Chunk {
            /// ID of the chunk.
            pub chunk_id: std::string::String,

            /// Unused.
            pub source_block_ids: std::vec::Vec<std::string::String>,

            /// Text content of the chunk.
            pub content: std::string::String,

            /// Page span of the chunk.
            pub page_span:
                std::option::Option<crate::model::document::chunked_document::chunk::ChunkPageSpan>,

            /// Page headers associated with the chunk.
            pub page_headers:
                std::vec::Vec<crate::model::document::chunked_document::chunk::ChunkPageHeader>,

            /// Page footers associated with the chunk.
            pub page_footers:
                std::vec::Vec<crate::model::document::chunked_document::chunk::ChunkPageFooter>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Chunk {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [chunk_id][crate::model::document::chunked_document::Chunk::chunk_id].
            pub fn set_chunk_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.chunk_id = v.into();
                self
            }

            /// Sets the value of [source_block_ids][crate::model::document::chunked_document::Chunk::source_block_ids].
            pub fn set_source_block_ids<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.source_block_ids = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [content][crate::model::document::chunked_document::Chunk::content].
            pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.content = v.into();
                self
            }

            /// Sets the value of [page_span][crate::model::document::chunked_document::Chunk::page_span].
            pub fn set_page_span<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::document::chunked_document::chunk::ChunkPageSpan,
                    >,
            {
                self.page_span = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [page_span][crate::model::document::chunked_document::Chunk::page_span].
            pub fn set_or_clear_page_span<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::document::chunked_document::chunk::ChunkPageSpan,
                    >,
            {
                self.page_span = v.map(|x| x.into());
                self
            }

            /// Sets the value of [page_headers][crate::model::document::chunked_document::Chunk::page_headers].
            pub fn set_page_headers<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::document::chunked_document::chunk::ChunkPageHeader,
                    >,
            {
                use std::iter::Iterator;
                self.page_headers = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [page_footers][crate::model::document::chunked_document::Chunk::page_footers].
            pub fn set_page_footers<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::document::chunked_document::chunk::ChunkPageFooter,
                    >,
            {
                use std::iter::Iterator;
                self.page_footers = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Chunk {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.Document.ChunkedDocument.Chunk"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Chunk {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __chunk_id,
                    __source_block_ids,
                    __content,
                    __page_span,
                    __page_headers,
                    __page_footers,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Chunk")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "chunkId" => Ok(__FieldTag::__chunk_id),
                                    "chunk_id" => Ok(__FieldTag::__chunk_id),
                                    "sourceBlockIds" => Ok(__FieldTag::__source_block_ids),
                                    "source_block_ids" => Ok(__FieldTag::__source_block_ids),
                                    "content" => Ok(__FieldTag::__content),
                                    "pageSpan" => Ok(__FieldTag::__page_span),
                                    "page_span" => Ok(__FieldTag::__page_span),
                                    "pageHeaders" => Ok(__FieldTag::__page_headers),
                                    "page_headers" => Ok(__FieldTag::__page_headers),
                                    "pageFooters" => Ok(__FieldTag::__page_footers),
                                    "page_footers" => Ok(__FieldTag::__page_footers),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Chunk;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Chunk")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__chunk_id => {
                                    if !fields.insert(__FieldTag::__chunk_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for chunk_id",
                                            ),
                                        );
                                    }
                                    result.chunk_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__source_block_ids => {
                                    if !fields.insert(__FieldTag::__source_block_ids) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for source_block_ids",
                                            ),
                                        );
                                    }
                                    result.source_block_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__content => {
                                    if !fields.insert(__FieldTag::__content) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for content",
                                            ),
                                        );
                                    }
                                    result.content = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__page_span => {
                                    if !fields.insert(__FieldTag::__page_span) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for page_span",
                                            ),
                                        );
                                    }
                                    result.page_span = map.next_value::<std::option::Option<crate::model::document::chunked_document::chunk::ChunkPageSpan>>()?
                                        ;
                                }
                                __FieldTag::__page_headers => {
                                    if !fields.insert(__FieldTag::__page_headers) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for page_headers",
                                            ),
                                        );
                                    }
                                    result.page_headers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::chunked_document::chunk::ChunkPageHeader>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__page_footers => {
                                    if !fields.insert(__FieldTag::__page_footers) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for page_footers",
                                            ),
                                        );
                                    }
                                    result.page_footers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::document::chunked_document::chunk::ChunkPageFooter>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Chunk {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.chunk_id.is_empty() {
                    state.serialize_entry("chunkId", &self.chunk_id)?;
                }
                if !self.source_block_ids.is_empty() {
                    state.serialize_entry("sourceBlockIds", &self.source_block_ids)?;
                }
                if !self.content.is_empty() {
                    state.serialize_entry("content", &self.content)?;
                }
                if self.page_span.is_some() {
                    state.serialize_entry("pageSpan", &self.page_span)?;
                }
                if !self.page_headers.is_empty() {
                    state.serialize_entry("pageHeaders", &self.page_headers)?;
                }
                if !self.page_footers.is_empty() {
                    state.serialize_entry("pageFooters", &self.page_footers)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Chunk {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Chunk");
                debug_struct.field("chunk_id", &self.chunk_id);
                debug_struct.field("source_block_ids", &self.source_block_ids);
                debug_struct.field("content", &self.content);
                debug_struct.field("page_span", &self.page_span);
                debug_struct.field("page_headers", &self.page_headers);
                debug_struct.field("page_footers", &self.page_footers);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Chunk].
        pub mod chunk {
            #[allow(unused_imports)]
            use super::*;

            /// Represents where the chunk starts and ends in the document.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ChunkPageSpan {
                /// Page where chunk starts in the document.
                pub page_start: i32,

                /// Page where chunk ends in the document.
                pub page_end: i32,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ChunkPageSpan {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [page_start][crate::model::document::chunked_document::chunk::ChunkPageSpan::page_start].
                pub fn set_page_start<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.page_start = v.into();
                    self
                }

                /// Sets the value of [page_end][crate::model::document::chunked_document::chunk::ChunkPageSpan::page_end].
                pub fn set_page_end<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                    self.page_end = v.into();
                    self
                }
            }

            impl wkt::message::Message for ChunkPageSpan {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.ChunkedDocument.Chunk.ChunkPageSpan"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ChunkPageSpan {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __page_start,
                        __page_end,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ChunkPageSpan")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "pageStart" => Ok(__FieldTag::__page_start),
                                        "page_start" => Ok(__FieldTag::__page_start),
                                        "pageEnd" => Ok(__FieldTag::__page_end),
                                        "page_end" => Ok(__FieldTag::__page_end),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ChunkPageSpan;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ChunkPageSpan")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__page_start => {
                                        if !fields.insert(__FieldTag::__page_start) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for page_start",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.page_start =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__page_end => {
                                        if !fields.insert(__FieldTag::__page_end) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for page_end",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.page_end =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ChunkPageSpan {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.page_start) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("pageStart", &__With(&self.page_start))?;
                    }
                    if !wkt::internal::is_default(&self.page_end) {
                        struct __With<'a>(&'a i32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("pageEnd", &__With(&self.page_end))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ChunkPageSpan {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ChunkPageSpan");
                    debug_struct.field("page_start", &self.page_start);
                    debug_struct.field("page_end", &self.page_end);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents the page header associated with the chunk.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ChunkPageHeader {
                /// Header in text format.
                pub text: std::string::String,

                /// Page span of the header.
                pub page_span: std::option::Option<
                    crate::model::document::chunked_document::chunk::ChunkPageSpan,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ChunkPageHeader {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [text][crate::model::document::chunked_document::chunk::ChunkPageHeader::text].
                pub fn set_text<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.text = v.into();
                    self
                }

                /// Sets the value of [page_span][crate::model::document::chunked_document::chunk::ChunkPageHeader::page_span].
                pub fn set_page_span<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<
                            crate::model::document::chunked_document::chunk::ChunkPageSpan,
                        >,
                {
                    self.page_span = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [page_span][crate::model::document::chunked_document::chunk::ChunkPageHeader::page_span].
                pub fn set_or_clear_page_span<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<
                            crate::model::document::chunked_document::chunk::ChunkPageSpan,
                        >,
                {
                    self.page_span = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ChunkPageHeader {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.ChunkedDocument.Chunk.ChunkPageHeader"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ChunkPageHeader {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __text,
                        __page_span,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ChunkPageHeader")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "text" => Ok(__FieldTag::__text),
                                        "pageSpan" => Ok(__FieldTag::__page_span),
                                        "page_span" => Ok(__FieldTag::__page_span),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ChunkPageHeader;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ChunkPageHeader")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__text => {
                                        if !fields.insert(__FieldTag::__text) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for text",
                                                ),
                                            );
                                        }
                                        result.text = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__page_span => {
                                        if !fields.insert(__FieldTag::__page_span) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for page_span",
                                                ),
                                            );
                                        }
                                        result.page_span = map.next_value::<std::option::Option<crate::model::document::chunked_document::chunk::ChunkPageSpan>>()?
                                            ;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ChunkPageHeader {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.text.is_empty() {
                        state.serialize_entry("text", &self.text)?;
                    }
                    if self.page_span.is_some() {
                        state.serialize_entry("pageSpan", &self.page_span)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ChunkPageHeader {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ChunkPageHeader");
                    debug_struct.field("text", &self.text);
                    debug_struct.field("page_span", &self.page_span);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Represents the page footer associated with the chunk.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ChunkPageFooter {
                /// Footer in text format.
                pub text: std::string::String,

                /// Page span of the footer.
                pub page_span: std::option::Option<
                    crate::model::document::chunked_document::chunk::ChunkPageSpan,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ChunkPageFooter {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [text][crate::model::document::chunked_document::chunk::ChunkPageFooter::text].
                pub fn set_text<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.text = v.into();
                    self
                }

                /// Sets the value of [page_span][crate::model::document::chunked_document::chunk::ChunkPageFooter::page_span].
                pub fn set_page_span<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<
                            crate::model::document::chunked_document::chunk::ChunkPageSpan,
                        >,
                {
                    self.page_span = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [page_span][crate::model::document::chunked_document::chunk::ChunkPageFooter::page_span].
                pub fn set_or_clear_page_span<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<
                            crate::model::document::chunked_document::chunk::ChunkPageSpan,
                        >,
                {
                    self.page_span = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ChunkPageFooter {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.documentai.v1.Document.ChunkedDocument.Chunk.ChunkPageFooter"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ChunkPageFooter {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __text,
                        __page_span,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ChunkPageFooter")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "text" => Ok(__FieldTag::__text),
                                        "pageSpan" => Ok(__FieldTag::__page_span),
                                        "page_span" => Ok(__FieldTag::__page_span),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ChunkPageFooter;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ChunkPageFooter")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__text => {
                                        if !fields.insert(__FieldTag::__text) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for text",
                                                ),
                                            );
                                        }
                                        result.text = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__page_span => {
                                        if !fields.insert(__FieldTag::__page_span) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for page_span",
                                                ),
                                            );
                                        }
                                        result.page_span = map.next_value::<std::option::Option<crate::model::document::chunked_document::chunk::ChunkPageSpan>>()?
                                            ;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ChunkPageFooter {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.text.is_empty() {
                        state.serialize_entry("text", &self.text)?;
                    }
                    if self.page_span.is_some() {
                        state.serialize_entry("pageSpan", &self.page_span)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ChunkPageFooter {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ChunkPageFooter");
                    debug_struct.field("text", &self.text);
                    debug_struct.field("page_span", &self.page_span);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }
        }
    }

    /// Original source document from the user.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. Currently supports Google Cloud Storage URI of the form
        /// `gs://bucket_name/object_name`. Object versioning is not supported.
        /// For more information, refer to [Google Cloud Storage Request
        /// URIs](https://cloud.google.com/storage/docs/reference-uris).
        Uri(std::string::String),
        /// Optional. Inline document content, represented as a stream of bytes.
        /// Note: As with all `bytes` fields, protobuffers use a pure binary
        /// representation, whereas JSON representations use base64.
        Content(::bytes::Bytes),
    }
}

/// Payload message of raw document content (bytes).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RawDocument {
    /// Inline document content.
    pub content: ::bytes::Bytes,

    /// An IANA MIME type (RFC6838) indicating the nature and format of the
    /// [content][google.cloud.documentai.v1.RawDocument.content].
    ///
    /// [google.cloud.documentai.v1.RawDocument.content]: crate::model::RawDocument::content
    pub mime_type: std::string::String,

    /// The display name of the document, it supports all Unicode characters except
    /// the following:
    /// `*`, `?`, `[`, `]`, `%`, `{`, `}`,`'`, `\"`, `,`
    /// `~`, `=` and `:` are reserved.
    /// If not specified, a default ID is generated.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RawDocument {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::RawDocument::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::RawDocument::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::RawDocument::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for RawDocument {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.RawDocument"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RawDocument {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __mime_type,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RawDocument")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RawDocument;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RawDocument")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RawDocument {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RawDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RawDocument");
        debug_struct.field("content", &self.content);
        debug_struct.field("mime_type", &self.mime_type);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies a document stored on Cloud Storage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDocument {
    /// The Cloud Storage object uri.
    pub gcs_uri: std::string::String,

    /// An IANA MIME type (RFC6838) of the content.
    pub mime_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDocument {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_uri][crate::model::GcsDocument::gcs_uri].
    pub fn set_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_uri = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::GcsDocument::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for GcsDocument {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.GcsDocument"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDocument {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_uri,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDocument")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsUri" => Ok(__FieldTag::__gcs_uri),
                            "gcs_uri" => Ok(__FieldTag::__gcs_uri),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDocument;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDocument")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_uri => {
                            if !fields.insert(__FieldTag::__gcs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_uri",
                                ));
                            }
                            result.gcs_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsDocument {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcs_uri.is_empty() {
            state.serialize_entry("gcsUri", &self.gcs_uri)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDocument");
        debug_struct.field("gcs_uri", &self.gcs_uri);
        debug_struct.field("mime_type", &self.mime_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies a set of documents on Cloud Storage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDocuments {
    /// The list of documents.
    pub documents: std::vec::Vec<crate::model::GcsDocument>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDocuments {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [documents][crate::model::GcsDocuments::documents].
    pub fn set_documents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcsDocument>,
    {
        use std::iter::Iterator;
        self.documents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GcsDocuments {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.GcsDocuments"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDocuments {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDocuments")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documents" => Ok(__FieldTag::__documents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDocuments;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDocuments")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents",
                                ));
                            }
                            result.documents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GcsDocument>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsDocuments {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsDocuments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDocuments");
        debug_struct.field("documents", &self.documents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies all documents on Cloud Storage with a common prefix.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsPrefix {
    /// The URI prefix.
    pub gcs_uri_prefix: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsPrefix {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_uri_prefix][crate::model::GcsPrefix::gcs_uri_prefix].
    pub fn set_gcs_uri_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for GcsPrefix {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.GcsPrefix"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsPrefix {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_uri_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsPrefix")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsUriPrefix" => Ok(__FieldTag::__gcs_uri_prefix),
                            "gcs_uri_prefix" => Ok(__FieldTag::__gcs_uri_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsPrefix;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsPrefix")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_uri_prefix => {
                            if !fields.insert(__FieldTag::__gcs_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_uri_prefix",
                                ));
                            }
                            result.gcs_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsPrefix {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcs_uri_prefix.is_empty() {
            state.serialize_entry("gcsUriPrefix", &self.gcs_uri_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsPrefix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsPrefix");
        debug_struct.field("gcs_uri_prefix", &self.gcs_uri_prefix);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The common config to specify a set of documents used as input.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDocumentsInputConfig {
    /// The source. Make sure that the caller of the API has storage.objects.get
    /// access to the buckets.
    pub source: std::option::Option<crate::model::batch_documents_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDocumentsInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::BatchDocumentsInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::batch_documents_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::BatchDocumentsInputConfig::source]
    /// if it holds a `GcsPrefix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_prefix(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsPrefix>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::batch_documents_input_config::Source::GcsPrefix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::BatchDocumentsInputConfig::source]
    /// to hold a `GcsPrefix`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_prefix<T: std::convert::Into<std::boxed::Box<crate::model::GcsPrefix>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::batch_documents_input_config::Source::GcsPrefix(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::BatchDocumentsInputConfig::source]
    /// if it holds a `GcsDocuments`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_documents(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDocuments>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::batch_documents_input_config::Source::GcsDocuments(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::BatchDocumentsInputConfig::source]
    /// to hold a `GcsDocuments`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_documents<T: std::convert::Into<std::boxed::Box<crate::model::GcsDocuments>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::batch_documents_input_config::Source::GcsDocuments(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchDocumentsInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.BatchDocumentsInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDocumentsInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_prefix,
            __gcs_documents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDocumentsInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsPrefix" => Ok(__FieldTag::__gcs_prefix),
                            "gcs_prefix" => Ok(__FieldTag::__gcs_prefix),
                            "gcsDocuments" => Ok(__FieldTag::__gcs_documents),
                            "gcs_documents" => Ok(__FieldTag::__gcs_documents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDocumentsInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDocumentsInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_prefix => {
                            if !fields.insert(__FieldTag::__gcs_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_prefix",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.BatchDocumentsInputConfig.gcs_prefix, latest field was gcsPrefix",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::batch_documents_input_config::Source::GcsPrefix(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsPrefix>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_documents => {
                            if !fields.insert(__FieldTag::__gcs_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_documents",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.BatchDocumentsInputConfig.gcs_documents, latest field was gcsDocuments",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::batch_documents_input_config::Source::GcsDocuments(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDocuments>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchDocumentsInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_prefix() {
            state.serialize_entry("gcsPrefix", value)?;
        }
        if let Some(value) = self.gcs_documents() {
            state.serialize_entry("gcsDocuments", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchDocumentsInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchDocumentsInputConfig");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BatchDocumentsInputConfig].
pub mod batch_documents_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source. Make sure that the caller of the API has storage.objects.get
    /// access to the buckets.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The set of documents that match the specified Cloud Storage `gcs_prefix`.
        GcsPrefix(std::boxed::Box<crate::model::GcsPrefix>),
        /// The set of documents individually specified on Cloud Storage.
        GcsDocuments(std::boxed::Box<crate::model::GcsDocuments>),
    }
}

/// Config that controls the output of documents. All documents will be written
/// as a JSON file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DocumentOutputConfig {
    /// The destination of the results.
    pub destination: std::option::Option<crate::model::document_output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::DocumentOutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::document_output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::DocumentOutputConfig::destination]
    /// if it holds a `GcsOutputConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_output_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::document_output_config::GcsOutputConfig>>
    {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::document_output_config::Destination::GcsOutputConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::DocumentOutputConfig::destination]
    /// to hold a `GcsOutputConfig`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_output_config<
        T: std::convert::Into<std::boxed::Box<crate::model::document_output_config::GcsOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::document_output_config::Destination::GcsOutputConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DocumentOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DocumentOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DocumentOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsOutputConfig" => Ok(__FieldTag::__gcs_output_config),
                            "gcs_output_config" => Ok(__FieldTag::__gcs_output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DocumentOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_output_config => {
                            if !fields.insert(__FieldTag::__gcs_output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_output_config",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.documentai.v1.DocumentOutputConfig.gcs_output_config, latest field was gcsOutputConfig",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::document_output_config::Destination::GcsOutputConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::document_output_config::GcsOutputConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DocumentOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_output_config() {
            state.serialize_entry("gcsOutputConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DocumentOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DocumentOutputConfig");
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DocumentOutputConfig].
pub mod document_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration used when outputting documents.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsOutputConfig {
        /// The Cloud Storage uri (a directory) of the output.
        pub gcs_uri: std::string::String,

        /// Specifies which fields to include in the output documents.
        /// Only supports top level document and pages field so it must be in the
        /// form of `{document_field_name}` or `pages.{page_field_name}`.
        pub field_mask: std::option::Option<wkt::FieldMask>,

        /// Specifies the sharding config for the output document.
        pub sharding_config: std::option::Option<
            crate::model::document_output_config::gcs_output_config::ShardingConfig,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsOutputConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [gcs_uri][crate::model::document_output_config::GcsOutputConfig::gcs_uri].
        pub fn set_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.gcs_uri = v.into();
            self
        }

        /// Sets the value of [field_mask][crate::model::document_output_config::GcsOutputConfig::field_mask].
        pub fn set_field_mask<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.field_mask = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [field_mask][crate::model::document_output_config::GcsOutputConfig::field_mask].
        pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.field_mask = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sharding_config][crate::model::document_output_config::GcsOutputConfig::sharding_config].
        pub fn set_sharding_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::document_output_config::gcs_output_config::ShardingConfig,
                >,
        {
            self.sharding_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sharding_config][crate::model::document_output_config::GcsOutputConfig::sharding_config].
        pub fn set_or_clear_sharding_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::document_output_config::gcs_output_config::ShardingConfig,
                >,
        {
            self.sharding_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for GcsOutputConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.DocumentOutputConfig.GcsOutputConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsOutputConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __gcs_uri,
                __field_mask,
                __sharding_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsOutputConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "gcsUri" => Ok(__FieldTag::__gcs_uri),
                                "gcs_uri" => Ok(__FieldTag::__gcs_uri),
                                "fieldMask" => Ok(__FieldTag::__field_mask),
                                "field_mask" => Ok(__FieldTag::__field_mask),
                                "shardingConfig" => Ok(__FieldTag::__sharding_config),
                                "sharding_config" => Ok(__FieldTag::__sharding_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsOutputConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsOutputConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__gcs_uri => {
                                if !fields.insert(__FieldTag::__gcs_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gcs_uri",
                                    ));
                                }
                                result.gcs_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__field_mask => {
                                if !fields.insert(__FieldTag::__field_mask) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field_mask",
                                    ));
                                }
                                result.field_mask =
                                    map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                            }
                            __FieldTag::__sharding_config => {
                                if !fields.insert(__FieldTag::__sharding_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sharding_config",
                                    ));
                                }
                                result.sharding_config = map.next_value::<std::option::Option<crate::model::document_output_config::gcs_output_config::ShardingConfig>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsOutputConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.gcs_uri.is_empty() {
                state.serialize_entry("gcsUri", &self.gcs_uri)?;
            }
            if self.field_mask.is_some() {
                state.serialize_entry("fieldMask", &self.field_mask)?;
            }
            if self.sharding_config.is_some() {
                state.serialize_entry("shardingConfig", &self.sharding_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsOutputConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsOutputConfig");
            debug_struct.field("gcs_uri", &self.gcs_uri);
            debug_struct.field("field_mask", &self.field_mask);
            debug_struct.field("sharding_config", &self.sharding_config);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GcsOutputConfig].
    pub mod gcs_output_config {
        #[allow(unused_imports)]
        use super::*;

        /// The sharding config for the output document.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ShardingConfig {
            /// The number of pages per shard.
            pub pages_per_shard: i32,

            /// The number of overlapping pages between consecutive shards.
            pub pages_overlap: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ShardingConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [pages_per_shard][crate::model::document_output_config::gcs_output_config::ShardingConfig::pages_per_shard].
            pub fn set_pages_per_shard<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.pages_per_shard = v.into();
                self
            }

            /// Sets the value of [pages_overlap][crate::model::document_output_config::gcs_output_config::ShardingConfig::pages_overlap].
            pub fn set_pages_overlap<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.pages_overlap = v.into();
                self
            }
        }

        impl wkt::message::Message for ShardingConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.DocumentOutputConfig.GcsOutputConfig.ShardingConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ShardingConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __pages_per_shard,
                    __pages_overlap,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ShardingConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "pagesPerShard" => Ok(__FieldTag::__pages_per_shard),
                                    "pages_per_shard" => Ok(__FieldTag::__pages_per_shard),
                                    "pagesOverlap" => Ok(__FieldTag::__pages_overlap),
                                    "pages_overlap" => Ok(__FieldTag::__pages_overlap),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ShardingConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ShardingConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__pages_per_shard => {
                                    if !fields.insert(__FieldTag::__pages_per_shard) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pages_per_shard",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.pages_per_shard =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__pages_overlap => {
                                    if !fields.insert(__FieldTag::__pages_overlap) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pages_overlap",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.pages_overlap =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ShardingConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.pages_per_shard) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("pagesPerShard", &__With(&self.pages_per_shard))?;
                }
                if !wkt::internal::is_default(&self.pages_overlap) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("pagesOverlap", &__With(&self.pages_overlap))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for ShardingConfig {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("ShardingConfig");
                debug_struct.field("pages_per_shard", &self.pages_per_shard);
                debug_struct.field("pages_overlap", &self.pages_overlap);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// The destination of the results.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Output config to write the results to Cloud Storage.
        GcsOutputConfig(std::boxed::Box<crate::model::document_output_config::GcsOutputConfig>),
    }
}

/// Config for Document OCR.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OcrConfig {
    /// Hints for the OCR model.
    pub hints: std::option::Option<crate::model::ocr_config::Hints>,

    /// Enables special handling for PDFs with existing text information. Results
    /// in better text extraction quality in such PDF inputs.
    pub enable_native_pdf_parsing: bool,

    /// Enables intelligent document quality scores after OCR. Can help with
    /// diagnosing why OCR responses are of poor quality for a given input.
    /// Adds additional latency comparable to regular OCR to the process call.
    pub enable_image_quality_scores: bool,

    /// A list of advanced OCR options to further fine-tune OCR behavior. Current
    /// valid values are:
    ///
    /// - `legacy_layout`: a heuristics layout detection algorithm, which serves as
    ///   an alternative to the current ML-based layout detection algorithm.
    ///   Customers can choose the best suitable layout algorithm based on their
    ///   situation.
    pub advanced_ocr_options: std::vec::Vec<std::string::String>,

    /// Includes symbol level OCR information if set to true.
    pub enable_symbol: bool,

    /// Turn on font identification model and return font style information.
    /// Deprecated, use
    /// [PremiumFeatures.compute_style_info][google.cloud.documentai.v1.OcrConfig.PremiumFeatures.compute_style_info]
    /// instead.
    ///
    /// [google.cloud.documentai.v1.OcrConfig.PremiumFeatures.compute_style_info]: crate::model::ocr_config::PremiumFeatures::compute_style_info
    #[deprecated]
    pub compute_style_info: bool,

    /// Turn off character box detector in OCR engine. Character box detection is
    /// enabled by default in OCR 2.0 (and later) processors.
    pub disable_character_boxes_detection: bool,

    /// Configurations for premium OCR features.
    pub premium_features: std::option::Option<crate::model::ocr_config::PremiumFeatures>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OcrConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hints][crate::model::OcrConfig::hints].
    pub fn set_hints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ocr_config::Hints>,
    {
        self.hints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hints][crate::model::OcrConfig::hints].
    pub fn set_or_clear_hints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ocr_config::Hints>,
    {
        self.hints = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_native_pdf_parsing][crate::model::OcrConfig::enable_native_pdf_parsing].
    pub fn set_enable_native_pdf_parsing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_native_pdf_parsing = v.into();
        self
    }

    /// Sets the value of [enable_image_quality_scores][crate::model::OcrConfig::enable_image_quality_scores].
    pub fn set_enable_image_quality_scores<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_image_quality_scores = v.into();
        self
    }

    /// Sets the value of [advanced_ocr_options][crate::model::OcrConfig::advanced_ocr_options].
    pub fn set_advanced_ocr_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.advanced_ocr_options = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_symbol][crate::model::OcrConfig::enable_symbol].
    pub fn set_enable_symbol<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_symbol = v.into();
        self
    }

    /// Sets the value of [compute_style_info][crate::model::OcrConfig::compute_style_info].
    #[deprecated]
    pub fn set_compute_style_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.compute_style_info = v.into();
        self
    }

    /// Sets the value of [disable_character_boxes_detection][crate::model::OcrConfig::disable_character_boxes_detection].
    pub fn set_disable_character_boxes_detection<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.disable_character_boxes_detection = v.into();
        self
    }

    /// Sets the value of [premium_features][crate::model::OcrConfig::premium_features].
    pub fn set_premium_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ocr_config::PremiumFeatures>,
    {
        self.premium_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [premium_features][crate::model::OcrConfig::premium_features].
    pub fn set_or_clear_premium_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ocr_config::PremiumFeatures>,
    {
        self.premium_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OcrConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.OcrConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OcrConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hints,
            __enable_native_pdf_parsing,
            __enable_image_quality_scores,
            __advanced_ocr_options,
            __enable_symbol,
            __compute_style_info,
            __disable_character_boxes_detection,
            __premium_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OcrConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hints" => Ok(__FieldTag::__hints),
                            "enableNativePdfParsing" => Ok(__FieldTag::__enable_native_pdf_parsing),
                            "enable_native_pdf_parsing" => {
                                Ok(__FieldTag::__enable_native_pdf_parsing)
                            }
                            "enableImageQualityScores" => {
                                Ok(__FieldTag::__enable_image_quality_scores)
                            }
                            "enable_image_quality_scores" => {
                                Ok(__FieldTag::__enable_image_quality_scores)
                            }
                            "advancedOcrOptions" => Ok(__FieldTag::__advanced_ocr_options),
                            "advanced_ocr_options" => Ok(__FieldTag::__advanced_ocr_options),
                            "enableSymbol" => Ok(__FieldTag::__enable_symbol),
                            "enable_symbol" => Ok(__FieldTag::__enable_symbol),
                            "computeStyleInfo" => Ok(__FieldTag::__compute_style_info),
                            "compute_style_info" => Ok(__FieldTag::__compute_style_info),
                            "disableCharacterBoxesDetection" => {
                                Ok(__FieldTag::__disable_character_boxes_detection)
                            }
                            "disable_character_boxes_detection" => {
                                Ok(__FieldTag::__disable_character_boxes_detection)
                            }
                            "premiumFeatures" => Ok(__FieldTag::__premium_features),
                            "premium_features" => Ok(__FieldTag::__premium_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OcrConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OcrConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hints => {
                            if !fields.insert(__FieldTag::__hints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hints",
                                ));
                            }
                            result.hints = map
                                .next_value::<std::option::Option<crate::model::ocr_config::Hints>>(
                                )?;
                        }
                        __FieldTag::__enable_native_pdf_parsing => {
                            if !fields.insert(__FieldTag::__enable_native_pdf_parsing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_native_pdf_parsing",
                                ));
                            }
                            result.enable_native_pdf_parsing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_image_quality_scores => {
                            if !fields.insert(__FieldTag::__enable_image_quality_scores) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_image_quality_scores",
                                ));
                            }
                            result.enable_image_quality_scores = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__advanced_ocr_options => {
                            if !fields.insert(__FieldTag::__advanced_ocr_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_ocr_options",
                                ));
                            }
                            result.advanced_ocr_options = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enable_symbol => {
                            if !fields.insert(__FieldTag::__enable_symbol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_symbol",
                                ));
                            }
                            result.enable_symbol = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_style_info => {
                            if !fields.insert(__FieldTag::__compute_style_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_style_info",
                                ));
                            }
                            result.compute_style_info = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_character_boxes_detection => {
                            if !fields.insert(__FieldTag::__disable_character_boxes_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_character_boxes_detection",
                                ));
                            }
                            result.disable_character_boxes_detection = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__premium_features => {
                            if !fields.insert(__FieldTag::__premium_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for premium_features",
                                ));
                            }
                            result.premium_features = map.next_value::<std::option::Option<crate::model::ocr_config::PremiumFeatures>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OcrConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hints.is_some() {
            state.serialize_entry("hints", &self.hints)?;
        }
        if !wkt::internal::is_default(&self.enable_native_pdf_parsing) {
            state.serialize_entry("enableNativePdfParsing", &self.enable_native_pdf_parsing)?;
        }
        if !wkt::internal::is_default(&self.enable_image_quality_scores) {
            state.serialize_entry(
                "enableImageQualityScores",
                &self.enable_image_quality_scores,
            )?;
        }
        if !self.advanced_ocr_options.is_empty() {
            state.serialize_entry("advancedOcrOptions", &self.advanced_ocr_options)?;
        }
        if !wkt::internal::is_default(&self.enable_symbol) {
            state.serialize_entry("enableSymbol", &self.enable_symbol)?;
        }
        if !wkt::internal::is_default(&self.compute_style_info) {
            state.serialize_entry("computeStyleInfo", &self.compute_style_info)?;
        }
        if !wkt::internal::is_default(&self.disable_character_boxes_detection) {
            state.serialize_entry(
                "disableCharacterBoxesDetection",
                &self.disable_character_boxes_detection,
            )?;
        }
        if self.premium_features.is_some() {
            state.serialize_entry("premiumFeatures", &self.premium_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OcrConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OcrConfig");
        debug_struct.field("hints", &self.hints);
        debug_struct.field("enable_native_pdf_parsing", &self.enable_native_pdf_parsing);
        debug_struct.field(
            "enable_image_quality_scores",
            &self.enable_image_quality_scores,
        );
        debug_struct.field("advanced_ocr_options", &self.advanced_ocr_options);
        debug_struct.field("enable_symbol", &self.enable_symbol);
        debug_struct.field("compute_style_info", &self.compute_style_info);
        debug_struct.field(
            "disable_character_boxes_detection",
            &self.disable_character_boxes_detection,
        );
        debug_struct.field("premium_features", &self.premium_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OcrConfig].
pub mod ocr_config {
    #[allow(unused_imports)]
    use super::*;

    /// Hints for OCR Engine
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Hints {
        /// List of BCP-47 language codes to use for OCR. In most cases, not
        /// specifying it yields the best results since it enables automatic language
        /// detection. For languages based on the Latin alphabet, setting hints is
        /// not needed. In rare cases, when the language of the text in the
        /// image is known, setting a hint will help get better results (although it
        /// will be a significant hindrance if the hint is wrong).
        pub language_hints: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Hints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [language_hints][crate::model::ocr_config::Hints::language_hints].
        pub fn set_language_hints<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.language_hints = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Hints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.OcrConfig.Hints"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Hints {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __language_hints,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Hints")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "languageHints" => Ok(__FieldTag::__language_hints),
                                "language_hints" => Ok(__FieldTag::__language_hints),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Hints;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Hints")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__language_hints => {
                                if !fields.insert(__FieldTag::__language_hints) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for language_hints",
                                    ));
                                }
                                result.language_hints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Hints {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.language_hints.is_empty() {
                state.serialize_entry("languageHints", &self.language_hints)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Hints {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Hints");
            debug_struct.field("language_hints", &self.language_hints);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configurations for premium OCR features.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PremiumFeatures {
        /// Turn on selection mark detector in OCR engine. Only available in OCR 2.0
        /// (and later) processors.
        pub enable_selection_mark_detection: bool,

        /// Turn on font identification model and return font style information.
        pub compute_style_info: bool,

        /// Turn on the model that can extract LaTeX math formulas.
        pub enable_math_ocr: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PremiumFeatures {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_selection_mark_detection][crate::model::ocr_config::PremiumFeatures::enable_selection_mark_detection].
        pub fn set_enable_selection_mark_detection<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_selection_mark_detection = v.into();
            self
        }

        /// Sets the value of [compute_style_info][crate::model::ocr_config::PremiumFeatures::compute_style_info].
        pub fn set_compute_style_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.compute_style_info = v.into();
            self
        }

        /// Sets the value of [enable_math_ocr][crate::model::ocr_config::PremiumFeatures::enable_math_ocr].
        pub fn set_enable_math_ocr<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_math_ocr = v.into();
            self
        }
    }

    impl wkt::message::Message for PremiumFeatures {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.OcrConfig.PremiumFeatures"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PremiumFeatures {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enable_selection_mark_detection,
                __compute_style_info,
                __enable_math_ocr,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PremiumFeatures")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enableSelectionMarkDetection" => {
                                    Ok(__FieldTag::__enable_selection_mark_detection)
                                }
                                "enable_selection_mark_detection" => {
                                    Ok(__FieldTag::__enable_selection_mark_detection)
                                }
                                "computeStyleInfo" => Ok(__FieldTag::__compute_style_info),
                                "compute_style_info" => Ok(__FieldTag::__compute_style_info),
                                "enableMathOcr" => Ok(__FieldTag::__enable_math_ocr),
                                "enable_math_ocr" => Ok(__FieldTag::__enable_math_ocr),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PremiumFeatures;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PremiumFeatures")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enable_selection_mark_detection => {
                                if !fields.insert(__FieldTag::__enable_selection_mark_detection) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_selection_mark_detection",
                                    ));
                                }
                                result.enable_selection_mark_detection = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__compute_style_info => {
                                if !fields.insert(__FieldTag::__compute_style_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compute_style_info",
                                    ));
                                }
                                result.compute_style_info = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_math_ocr => {
                                if !fields.insert(__FieldTag::__enable_math_ocr) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_math_ocr",
                                    ));
                                }
                                result.enable_math_ocr = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PremiumFeatures {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enable_selection_mark_detection) {
                state.serialize_entry(
                    "enableSelectionMarkDetection",
                    &self.enable_selection_mark_detection,
                )?;
            }
            if !wkt::internal::is_default(&self.compute_style_info) {
                state.serialize_entry("computeStyleInfo", &self.compute_style_info)?;
            }
            if !wkt::internal::is_default(&self.enable_math_ocr) {
                state.serialize_entry("enableMathOcr", &self.enable_math_ocr)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PremiumFeatures {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PremiumFeatures");
            debug_struct.field(
                "enable_selection_mark_detection",
                &self.enable_selection_mark_detection,
            );
            debug_struct.field("compute_style_info", &self.compute_style_info);
            debug_struct.field("enable_math_ocr", &self.enable_math_ocr);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Options for Process API
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProcessOptions {
    /// Only applicable to `OCR_PROCESSOR` and `FORM_PARSER_PROCESSOR`.
    /// Returns error if set on other processor types.
    pub ocr_config: std::option::Option<crate::model::OcrConfig>,

    /// Optional. Only applicable to `LAYOUT_PARSER_PROCESSOR`.
    /// Returns error if set on other processor types.
    pub layout_config: std::option::Option<crate::model::process_options::LayoutConfig>,

    /// Optional. Override the schema of the
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion]. Will
    /// return an Invalid Argument error if this field is set when the underlying
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion] doesn't
    /// support schema override.
    ///
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    pub schema_override: std::option::Option<crate::model::DocumentSchema>,

    /// A subset of pages to process. If not specified, all pages are processed.
    /// If a page range is set, only the given pages are extracted and processed
    /// from the document. In the output document,
    /// [Document.Page.page_number][google.cloud.documentai.v1.Document.Page.page_number]
    /// refers to the page number in the original document.
    /// This configuration only applies to online processing with
    /// [ProcessDocument][google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument].
    ///
    /// [google.cloud.documentai.v1.Document.Page.page_number]: crate::model::document::Page::page_number
    /// [google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument]: crate::client::DocumentProcessorService::process_document
    pub page_range: std::option::Option<crate::model::process_options::PageRange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ocr_config][crate::model::ProcessOptions::ocr_config].
    pub fn set_ocr_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OcrConfig>,
    {
        self.ocr_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ocr_config][crate::model::ProcessOptions::ocr_config].
    pub fn set_or_clear_ocr_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OcrConfig>,
    {
        self.ocr_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [layout_config][crate::model::ProcessOptions::layout_config].
    pub fn set_layout_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::process_options::LayoutConfig>,
    {
        self.layout_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [layout_config][crate::model::ProcessOptions::layout_config].
    pub fn set_or_clear_layout_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::process_options::LayoutConfig>,
    {
        self.layout_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema_override][crate::model::ProcessOptions::schema_override].
    pub fn set_schema_override<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.schema_override = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema_override][crate::model::ProcessOptions::schema_override].
    pub fn set_or_clear_schema_override<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.schema_override = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_range][crate::model::ProcessOptions::page_range].
    ///
    /// Note that all the setters affecting `page_range` are mutually
    /// exclusive.
    pub fn set_page_range<
        T: std::convert::Into<std::option::Option<crate::model::process_options::PageRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.page_range = v.into();
        self
    }

    /// The value of [page_range][crate::model::ProcessOptions::page_range]
    /// if it holds a `IndividualPageSelector`, `None` if the field is not set or
    /// holds a different branch.
    pub fn individual_page_selector(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::process_options::IndividualPageSelector>>
    {
        #[allow(unreachable_patterns)]
        self.page_range.as_ref().and_then(|v| match v {
            crate::model::process_options::PageRange::IndividualPageSelector(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [page_range][crate::model::ProcessOptions::page_range]
    /// to hold a `IndividualPageSelector`.
    ///
    /// Note that all the setters affecting `page_range` are
    /// mutually exclusive.
    pub fn set_individual_page_selector<
        T: std::convert::Into<std::boxed::Box<crate::model::process_options::IndividualPageSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.page_range = std::option::Option::Some(
            crate::model::process_options::PageRange::IndividualPageSelector(v.into()),
        );
        self
    }

    /// The value of [page_range][crate::model::ProcessOptions::page_range]
    /// if it holds a `FromStart`, `None` if the field is not set or
    /// holds a different branch.
    pub fn from_start(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.page_range.as_ref().and_then(|v| match v {
            crate::model::process_options::PageRange::FromStart(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [page_range][crate::model::ProcessOptions::page_range]
    /// to hold a `FromStart`.
    ///
    /// Note that all the setters affecting `page_range` are
    /// mutually exclusive.
    pub fn set_from_start<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_range = std::option::Option::Some(
            crate::model::process_options::PageRange::FromStart(v.into()),
        );
        self
    }

    /// The value of [page_range][crate::model::ProcessOptions::page_range]
    /// if it holds a `FromEnd`, `None` if the field is not set or
    /// holds a different branch.
    pub fn from_end(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.page_range.as_ref().and_then(|v| match v {
            crate::model::process_options::PageRange::FromEnd(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [page_range][crate::model::ProcessOptions::page_range]
    /// to hold a `FromEnd`.
    ///
    /// Note that all the setters affecting `page_range` are
    /// mutually exclusive.
    pub fn set_from_end<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_range =
            std::option::Option::Some(crate::model::process_options::PageRange::FromEnd(v.into()));
        self
    }
}

impl wkt::message::Message for ProcessOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ProcessOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProcessOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __individual_page_selector,
            __from_start,
            __from_end,
            __ocr_config,
            __layout_config,
            __schema_override,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProcessOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "individualPageSelector" => Ok(__FieldTag::__individual_page_selector),
                            "individual_page_selector" => {
                                Ok(__FieldTag::__individual_page_selector)
                            }
                            "fromStart" => Ok(__FieldTag::__from_start),
                            "from_start" => Ok(__FieldTag::__from_start),
                            "fromEnd" => Ok(__FieldTag::__from_end),
                            "from_end" => Ok(__FieldTag::__from_end),
                            "ocrConfig" => Ok(__FieldTag::__ocr_config),
                            "ocr_config" => Ok(__FieldTag::__ocr_config),
                            "layoutConfig" => Ok(__FieldTag::__layout_config),
                            "layout_config" => Ok(__FieldTag::__layout_config),
                            "schemaOverride" => Ok(__FieldTag::__schema_override),
                            "schema_override" => Ok(__FieldTag::__schema_override),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProcessOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProcessOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__individual_page_selector => {
                            if !fields.insert(__FieldTag::__individual_page_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for individual_page_selector",
                                ));
                            }
                            if result.page_range.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `page_range`, a oneof with full ID .google.cloud.documentai.v1.ProcessOptions.individual_page_selector, latest field was individualPageSelector",
                                ));
                            }
                            result.page_range = std::option::Option::Some(
                                crate::model::process_options::PageRange::IndividualPageSelector(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::process_options::IndividualPageSelector,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__from_start => {
                            if !fields.insert(__FieldTag::__from_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for from_start",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.page_range.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `page_range`, a oneof with full ID .google.cloud.documentai.v1.ProcessOptions.from_start, latest field was fromStart",
                                ));
                            }
                            result.page_range = std::option::Option::Some(
                                crate::model::process_options::PageRange::FromStart(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__from_end => {
                            if !fields.insert(__FieldTag::__from_end) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for from_end",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.page_range.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `page_range`, a oneof with full ID .google.cloud.documentai.v1.ProcessOptions.from_end, latest field was fromEnd",
                                ));
                            }
                            result.page_range = std::option::Option::Some(
                                crate::model::process_options::PageRange::FromEnd(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ocr_config => {
                            if !fields.insert(__FieldTag::__ocr_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocr_config",
                                ));
                            }
                            result.ocr_config =
                                map.next_value::<std::option::Option<crate::model::OcrConfig>>()?;
                        }
                        __FieldTag::__layout_config => {
                            if !fields.insert(__FieldTag::__layout_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for layout_config",
                                ));
                            }
                            result.layout_config =
                                map.next_value::<std::option::Option<
                                    crate::model::process_options::LayoutConfig,
                                >>()?;
                        }
                        __FieldTag::__schema_override => {
                            if !fields.insert(__FieldTag::__schema_override) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_override",
                                ));
                            }
                            result.schema_override = map
                                .next_value::<std::option::Option<crate::model::DocumentSchema>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProcessOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.individual_page_selector() {
            state.serialize_entry("individualPageSelector", value)?;
        }
        if let Some(value) = self.from_start() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fromStart", &__With(value))?;
        }
        if let Some(value) = self.from_end() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fromEnd", &__With(value))?;
        }
        if self.ocr_config.is_some() {
            state.serialize_entry("ocrConfig", &self.ocr_config)?;
        }
        if self.layout_config.is_some() {
            state.serialize_entry("layoutConfig", &self.layout_config)?;
        }
        if self.schema_override.is_some() {
            state.serialize_entry("schemaOverride", &self.schema_override)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProcessOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessOptions");
        debug_struct.field("ocr_config", &self.ocr_config);
        debug_struct.field("layout_config", &self.layout_config);
        debug_struct.field("schema_override", &self.schema_override);
        debug_struct.field("page_range", &self.page_range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ProcessOptions].
pub mod process_options {
    #[allow(unused_imports)]
    use super::*;

    /// Serving config for layout parser processor.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LayoutConfig {
        /// Optional. Config for chunking in layout parser processor.
        pub chunking_config:
            std::option::Option<crate::model::process_options::layout_config::ChunkingConfig>,

        /// Optional. Whether to include images in layout parser processor response.
        pub return_images: bool,

        /// Optional. Whether to include bounding boxes in layout parser processor
        /// response.
        pub return_bounding_boxes: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LayoutConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [chunking_config][crate::model::process_options::LayoutConfig::chunking_config].
        pub fn set_chunking_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::process_options::layout_config::ChunkingConfig>,
        {
            self.chunking_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [chunking_config][crate::model::process_options::LayoutConfig::chunking_config].
        pub fn set_or_clear_chunking_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::process_options::layout_config::ChunkingConfig>,
        {
            self.chunking_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [return_images][crate::model::process_options::LayoutConfig::return_images].
        pub fn set_return_images<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.return_images = v.into();
            self
        }

        /// Sets the value of [return_bounding_boxes][crate::model::process_options::LayoutConfig::return_bounding_boxes].
        pub fn set_return_bounding_boxes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.return_bounding_boxes = v.into();
            self
        }
    }

    impl wkt::message::Message for LayoutConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.ProcessOptions.LayoutConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LayoutConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __chunking_config,
                __return_images,
                __return_bounding_boxes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LayoutConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "chunkingConfig" => Ok(__FieldTag::__chunking_config),
                                "chunking_config" => Ok(__FieldTag::__chunking_config),
                                "returnImages" => Ok(__FieldTag::__return_images),
                                "return_images" => Ok(__FieldTag::__return_images),
                                "returnBoundingBoxes" => Ok(__FieldTag::__return_bounding_boxes),
                                "return_bounding_boxes" => Ok(__FieldTag::__return_bounding_boxes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LayoutConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LayoutConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__chunking_config => {
                                if !fields.insert(__FieldTag::__chunking_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for chunking_config",
                                    ));
                                }
                                result.chunking_config = map.next_value::<std::option::Option<
                                    crate::model::process_options::layout_config::ChunkingConfig,
                                >>()?;
                            }
                            __FieldTag::__return_images => {
                                if !fields.insert(__FieldTag::__return_images) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for return_images",
                                    ));
                                }
                                result.return_images = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__return_bounding_boxes => {
                                if !fields.insert(__FieldTag::__return_bounding_boxes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for return_bounding_boxes",
                                    ));
                                }
                                result.return_bounding_boxes = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LayoutConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.chunking_config.is_some() {
                state.serialize_entry("chunkingConfig", &self.chunking_config)?;
            }
            if !wkt::internal::is_default(&self.return_images) {
                state.serialize_entry("returnImages", &self.return_images)?;
            }
            if !wkt::internal::is_default(&self.return_bounding_boxes) {
                state.serialize_entry("returnBoundingBoxes", &self.return_bounding_boxes)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for LayoutConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("LayoutConfig");
            debug_struct.field("chunking_config", &self.chunking_config);
            debug_struct.field("return_images", &self.return_images);
            debug_struct.field("return_bounding_boxes", &self.return_bounding_boxes);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [LayoutConfig].
    pub mod layout_config {
        #[allow(unused_imports)]
        use super::*;

        /// Serving config for chunking.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ChunkingConfig {
            /// Optional. The chunk sizes to use when splitting documents, in order of
            /// level.
            pub chunk_size: i32,

            /// Optional. Whether or not to include ancestor headings when splitting.
            pub include_ancestor_headings: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ChunkingConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [chunk_size][crate::model::process_options::layout_config::ChunkingConfig::chunk_size].
            pub fn set_chunk_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.chunk_size = v.into();
                self
            }

            /// Sets the value of [include_ancestor_headings][crate::model::process_options::layout_config::ChunkingConfig::include_ancestor_headings].
            pub fn set_include_ancestor_headings<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.include_ancestor_headings = v.into();
                self
            }
        }

        impl wkt::message::Message for ChunkingConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.ProcessOptions.LayoutConfig.ChunkingConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ChunkingConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __chunk_size,
                    __include_ancestor_headings,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ChunkingConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "chunkSize" => Ok(__FieldTag::__chunk_size),
                                    "chunk_size" => Ok(__FieldTag::__chunk_size),
                                    "includeAncestorHeadings" => {
                                        Ok(__FieldTag::__include_ancestor_headings)
                                    }
                                    "include_ancestor_headings" => {
                                        Ok(__FieldTag::__include_ancestor_headings)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ChunkingConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ChunkingConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__chunk_size => {
                                    if !fields.insert(__FieldTag::__chunk_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for chunk_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.chunk_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__include_ancestor_headings => {
                                    if !fields.insert(__FieldTag::__include_ancestor_headings) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for include_ancestor_headings",
                                            ),
                                        );
                                    }
                                    result.include_ancestor_headings = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ChunkingConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.chunk_size) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("chunkSize", &__With(&self.chunk_size))?;
                }
                if !wkt::internal::is_default(&self.include_ancestor_headings) {
                    state.serialize_entry(
                        "includeAncestorHeadings",
                        &self.include_ancestor_headings,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for ChunkingConfig {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("ChunkingConfig");
                debug_struct.field("chunk_size", &self.chunk_size);
                debug_struct.field("include_ancestor_headings", &self.include_ancestor_headings);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// A list of individual page numbers.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IndividualPageSelector {
        /// Optional. Indices of the pages (starting from 1).
        pub pages: std::vec::Vec<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndividualPageSelector {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pages][crate::model::process_options::IndividualPageSelector::pages].
        pub fn set_pages<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.pages = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for IndividualPageSelector {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.ProcessOptions.IndividualPageSelector"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IndividualPageSelector {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __pages,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IndividualPageSelector")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pages" => Ok(__FieldTag::__pages),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IndividualPageSelector;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IndividualPageSelector")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__pages => {
                                if !fields.insert(__FieldTag::__pages) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pages",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i32>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.pages = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IndividualPageSelector {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.pages.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("pages", &__With(&self.pages))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IndividualPageSelector {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IndividualPageSelector");
            debug_struct.field("pages", &self.pages);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A subset of pages to process. If not specified, all pages are processed.
    /// If a page range is set, only the given pages are extracted and processed
    /// from the document. In the output document,
    /// [Document.Page.page_number][google.cloud.documentai.v1.Document.Page.page_number]
    /// refers to the page number in the original document.
    /// This configuration only applies to online processing with
    /// [ProcessDocument][google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument].
    ///
    /// [google.cloud.documentai.v1.Document.Page.page_number]: crate::model::document::Page::page_number
    /// [google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument]: crate::client::DocumentProcessorService::process_document
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PageRange {
        /// Which pages to process (1-indexed).
        IndividualPageSelector(
            std::boxed::Box<crate::model::process_options::IndividualPageSelector>,
        ),
        /// Only process certain pages from the start. Process all if the document
        /// has fewer pages.
        FromStart(i32),
        /// Only process certain pages from the end, same as above.
        FromEnd(i32),
    }
}

/// Request message for the
/// [ProcessDocument][google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument]: crate::client::DocumentProcessorService::process_document
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProcessRequest {
    /// Required. The resource name of the
    /// [Processor][google.cloud.documentai.v1.Processor] or
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion]
    /// to use for processing. If a
    /// [Processor][google.cloud.documentai.v1.Processor] is specified, the server
    /// will use its [default
    /// version][google.cloud.documentai.v1.Processor.default_processor_version].
    /// Format: `projects/{project}/locations/{location}/processors/{processor}`,
    /// or
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`
    ///
    /// [google.cloud.documentai.v1.Processor]: crate::model::Processor
    /// [google.cloud.documentai.v1.Processor.default_processor_version]: crate::model::Processor::default_processor_version
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    pub name: std::string::String,

    /// Whether human review should be skipped for this request. Default to
    /// `false`.
    pub skip_human_review: bool,

    /// Specifies which fields to include in the
    /// [ProcessResponse.document][google.cloud.documentai.v1.ProcessResponse.document]
    /// output. Only supports top-level document and pages field, so it must be in
    /// the form of `{document_field_name}` or `pages.{page_field_name}`.
    ///
    /// [google.cloud.documentai.v1.ProcessResponse.document]: crate::model::ProcessResponse::document
    pub field_mask: std::option::Option<wkt::FieldMask>,

    /// Inference-time options for the process API
    pub process_options: std::option::Option<crate::model::ProcessOptions>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints) and can only contain lowercase letters, numeric
    /// characters, underscores, and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Option to remove images from the document.
    pub imageless_mode: bool,

    /// The document payload.
    pub source: std::option::Option<crate::model::process_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProcessRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_human_review][crate::model::ProcessRequest::skip_human_review].
    pub fn set_skip_human_review<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_human_review = v.into();
        self
    }

    /// Sets the value of [field_mask][crate::model::ProcessRequest::field_mask].
    pub fn set_field_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [field_mask][crate::model::ProcessRequest::field_mask].
    pub fn set_or_clear_field_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.field_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [process_options][crate::model::ProcessRequest::process_options].
    pub fn set_process_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProcessOptions>,
    {
        self.process_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [process_options][crate::model::ProcessRequest::process_options].
    pub fn set_or_clear_process_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProcessOptions>,
    {
        self.process_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ProcessRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [imageless_mode][crate::model::ProcessRequest::imageless_mode].
    pub fn set_imageless_mode<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.imageless_mode = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ProcessRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::process_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ProcessRequest::source]
    /// if it holds a `InlineDocument`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_document(&self) -> std::option::Option<&std::boxed::Box<crate::model::Document>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::process_request::Source::InlineDocument(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ProcessRequest::source]
    /// to hold a `InlineDocument`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_document<T: std::convert::Into<std::boxed::Box<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::process_request::Source::InlineDocument(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ProcessRequest::source]
    /// if it holds a `RawDocument`, `None` if the field is not set or
    /// holds a different branch.
    pub fn raw_document(&self) -> std::option::Option<&std::boxed::Box<crate::model::RawDocument>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::process_request::Source::RawDocument(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ProcessRequest::source]
    /// to hold a `RawDocument`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_raw_document<T: std::convert::Into<std::boxed::Box<crate::model::RawDocument>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::process_request::Source::RawDocument(v.into()));
        self
    }

    /// The value of [source][crate::model::ProcessRequest::source]
    /// if it holds a `GcsDocument`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_document(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsDocument>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::process_request::Source::GcsDocument(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ProcessRequest::source]
    /// to hold a `GcsDocument`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_document<T: std::convert::Into<std::boxed::Box<crate::model::GcsDocument>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::process_request::Source::GcsDocument(v.into()));
        self
    }
}

impl wkt::message::Message for ProcessRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ProcessRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProcessRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inline_document,
            __raw_document,
            __gcs_document,
            __name,
            __skip_human_review,
            __field_mask,
            __process_options,
            __labels,
            __imageless_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProcessRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inlineDocument" => Ok(__FieldTag::__inline_document),
                            "inline_document" => Ok(__FieldTag::__inline_document),
                            "rawDocument" => Ok(__FieldTag::__raw_document),
                            "raw_document" => Ok(__FieldTag::__raw_document),
                            "gcsDocument" => Ok(__FieldTag::__gcs_document),
                            "gcs_document" => Ok(__FieldTag::__gcs_document),
                            "name" => Ok(__FieldTag::__name),
                            "skipHumanReview" => Ok(__FieldTag::__skip_human_review),
                            "skip_human_review" => Ok(__FieldTag::__skip_human_review),
                            "fieldMask" => Ok(__FieldTag::__field_mask),
                            "field_mask" => Ok(__FieldTag::__field_mask),
                            "processOptions" => Ok(__FieldTag::__process_options),
                            "process_options" => Ok(__FieldTag::__process_options),
                            "labels" => Ok(__FieldTag::__labels),
                            "imagelessMode" => Ok(__FieldTag::__imageless_mode),
                            "imageless_mode" => Ok(__FieldTag::__imageless_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProcessRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProcessRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inline_document => {
                            if !fields.insert(__FieldTag::__inline_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline_document",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.ProcessRequest.inline_document, latest field was inlineDocument",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::process_request::Source::InlineDocument(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Document>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__raw_document => {
                            if !fields.insert(__FieldTag::__raw_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_document",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.ProcessRequest.raw_document, latest field was rawDocument",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::process_request::Source::RawDocument(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RawDocument>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_document => {
                            if !fields.insert(__FieldTag::__gcs_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_document",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.ProcessRequest.gcs_document, latest field was gcsDocument",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::process_request::Source::GcsDocument(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDocument>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_human_review => {
                            if !fields.insert(__FieldTag::__skip_human_review) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_human_review",
                                ));
                            }
                            result.skip_human_review = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__field_mask => {
                            if !fields.insert(__FieldTag::__field_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for field_mask",
                                ));
                            }
                            result.field_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__process_options => {
                            if !fields.insert(__FieldTag::__process_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for process_options",
                                ));
                            }
                            result.process_options = map
                                .next_value::<std::option::Option<crate::model::ProcessOptions>>(
                                )?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imageless_mode => {
                            if !fields.insert(__FieldTag::__imageless_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imageless_mode",
                                ));
                            }
                            result.imageless_mode = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProcessRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_document() {
            state.serialize_entry("inlineDocument", value)?;
        }
        if let Some(value) = self.raw_document() {
            state.serialize_entry("rawDocument", value)?;
        }
        if let Some(value) = self.gcs_document() {
            state.serialize_entry("gcsDocument", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.skip_human_review) {
            state.serialize_entry("skipHumanReview", &self.skip_human_review)?;
        }
        if self.field_mask.is_some() {
            state.serialize_entry("fieldMask", &self.field_mask)?;
        }
        if self.process_options.is_some() {
            state.serialize_entry("processOptions", &self.process_options)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.imageless_mode) {
            state.serialize_entry("imagelessMode", &self.imageless_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProcessRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("skip_human_review", &self.skip_human_review);
        debug_struct.field("field_mask", &self.field_mask);
        debug_struct.field("process_options", &self.process_options);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("imageless_mode", &self.imageless_mode);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ProcessRequest].
pub mod process_request {
    #[allow(unused_imports)]
    use super::*;

    /// The document payload.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// An inline document proto.
        InlineDocument(std::boxed::Box<crate::model::Document>),
        /// A raw document content (bytes).
        RawDocument(std::boxed::Box<crate::model::RawDocument>),
        /// A raw document on Google Cloud Storage.
        GcsDocument(std::boxed::Box<crate::model::GcsDocument>),
    }
}

/// The status of human review on a processed document.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HumanReviewStatus {
    /// The state of human review on the processing request.
    pub state: crate::model::human_review_status::State,

    /// A message providing more details about the human review state.
    pub state_message: std::string::String,

    /// The name of the operation triggered by the processed document. This field
    /// is populated only when the
    /// [state][google.cloud.documentai.v1.HumanReviewStatus.state] is
    /// `HUMAN_REVIEW_IN_PROGRESS`. It has the same response type and metadata as
    /// the long-running operation returned by
    /// [ReviewDocument][google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument].
    ///
    /// [google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument]: crate::client::DocumentProcessorService::review_document
    /// [google.cloud.documentai.v1.HumanReviewStatus.state]: crate::model::HumanReviewStatus::state
    pub human_review_operation: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HumanReviewStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::HumanReviewStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::human_review_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::HumanReviewStatus::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [human_review_operation][crate::model::HumanReviewStatus::human_review_operation].
    pub fn set_human_review_operation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.human_review_operation = v.into();
        self
    }
}

impl wkt::message::Message for HumanReviewStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.HumanReviewStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HumanReviewStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __state_message,
            __human_review_operation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanReviewStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "humanReviewOperation" => Ok(__FieldTag::__human_review_operation),
                            "human_review_operation" => Ok(__FieldTag::__human_review_operation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HumanReviewStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanReviewStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::human_review_status::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__human_review_operation => {
                            if !fields.insert(__FieldTag::__human_review_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_review_operation",
                                ));
                            }
                            result.human_review_operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HumanReviewStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if !self.human_review_operation.is_empty() {
            state.serialize_entry("humanReviewOperation", &self.human_review_operation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HumanReviewStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HumanReviewStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("human_review_operation", &self.human_review_operation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [HumanReviewStatus].
pub mod human_review_status {
    #[allow(unused_imports)]
    use super::*;

    /// The final state of human review on a processed document.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Human review state is unspecified. Most likely due to an internal error.
        Unspecified,
        /// Human review is skipped for the document. This can happen because human
        /// review isn't enabled on the processor or the processing request has
        /// been set to skip this document.
        Skipped,
        /// Human review validation is triggered and passed, so no review is needed.
        ValidationPassed,
        /// Human review validation is triggered and the document is under review.
        InProgress,
        /// Some error happened during triggering human review, see the
        /// [state_message][google.cloud.documentai.v1.HumanReviewStatus.state_message]
        /// for details.
        ///
        /// [google.cloud.documentai.v1.HumanReviewStatus.state_message]: crate::model::HumanReviewStatus::state_message
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skipped => std::option::Option::Some(1),
                Self::ValidationPassed => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::ValidationPassed => std::option::Option::Some("VALIDATION_PASSED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skipped,
                2 => Self::ValidationPassed,
                3 => Self::InProgress,
                4 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SKIPPED" => Self::Skipped,
                "VALIDATION_PASSED" => Self::ValidationPassed,
                "IN_PROGRESS" => Self::InProgress,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skipped => serializer.serialize_i32(1),
                Self::ValidationPassed => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.documentai.v1.HumanReviewStatus.State",
            ))
        }
    }
}

/// Response message for the
/// [ProcessDocument][google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ProcessDocument]: crate::client::DocumentProcessorService::process_document
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProcessResponse {
    /// The document payload, will populate fields based on the processor's
    /// behavior.
    pub document: std::option::Option<crate::model::Document>,

    /// The status of human review on the processed document.
    pub human_review_status: std::option::Option<crate::model::HumanReviewStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::ProcessResponse::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::ProcessResponse::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [human_review_status][crate::model::ProcessResponse::human_review_status].
    pub fn set_human_review_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HumanReviewStatus>,
    {
        self.human_review_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [human_review_status][crate::model::ProcessResponse::human_review_status].
    pub fn set_or_clear_human_review_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HumanReviewStatus>,
    {
        self.human_review_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProcessResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ProcessResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProcessResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __human_review_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProcessResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "humanReviewStatus" => Ok(__FieldTag::__human_review_status),
                            "human_review_status" => Ok(__FieldTag::__human_review_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProcessResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProcessResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__human_review_status => {
                            if !fields.insert(__FieldTag::__human_review_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_review_status",
                                ));
                            }
                            result.human_review_status = map
                                .next_value::<std::option::Option<crate::model::HumanReviewStatus>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProcessResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if self.human_review_status.is_some() {
            state.serialize_entry("humanReviewStatus", &self.human_review_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProcessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessResponse");
        debug_struct.field("document", &self.document);
        debug_struct.field("human_review_status", &self.human_review_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [BatchProcessDocuments][google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments].
///
/// [google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments]: crate::client::DocumentProcessorService::batch_process_documents
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchProcessRequest {
    /// Required. The resource name of
    /// [Processor][google.cloud.documentai.v1.Processor] or
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion].
    /// Format: `projects/{project}/locations/{location}/processors/{processor}`,
    /// or
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`
    ///
    /// [google.cloud.documentai.v1.Processor]: crate::model::Processor
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    pub name: std::string::String,

    /// The input documents for the
    /// [BatchProcessDocuments][google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments]
    /// method.
    ///
    /// [google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments]: crate::client::DocumentProcessorService::batch_process_documents
    pub input_documents: std::option::Option<crate::model::BatchDocumentsInputConfig>,

    /// The output configuration for the
    /// [BatchProcessDocuments][google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments]
    /// method.
    ///
    /// [google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments]: crate::client::DocumentProcessorService::batch_process_documents
    pub document_output_config: std::option::Option<crate::model::DocumentOutputConfig>,

    /// Whether human review should be skipped for this request. Default to
    /// `false`.
    pub skip_human_review: bool,

    /// Inference-time options for the process API
    pub process_options: std::option::Option<crate::model::ProcessOptions>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints) and can only contain lowercase letters, numeric
    /// characters, underscores, and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchProcessRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BatchProcessRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input_documents][crate::model::BatchProcessRequest::input_documents].
    pub fn set_input_documents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
    {
        self.input_documents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_documents][crate::model::BatchProcessRequest::input_documents].
    pub fn set_or_clear_input_documents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
    {
        self.input_documents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_output_config][crate::model::BatchProcessRequest::document_output_config].
    pub fn set_document_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentOutputConfig>,
    {
        self.document_output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_output_config][crate::model::BatchProcessRequest::document_output_config].
    pub fn set_or_clear_document_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentOutputConfig>,
    {
        self.document_output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_human_review][crate::model::BatchProcessRequest::skip_human_review].
    pub fn set_skip_human_review<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_human_review = v.into();
        self
    }

    /// Sets the value of [process_options][crate::model::BatchProcessRequest::process_options].
    pub fn set_process_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProcessOptions>,
    {
        self.process_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [process_options][crate::model::BatchProcessRequest::process_options].
    pub fn set_or_clear_process_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProcessOptions>,
    {
        self.process_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::BatchProcessRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchProcessRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.BatchProcessRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchProcessRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __input_documents,
            __document_output_config,
            __skip_human_review,
            __process_options,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchProcessRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "inputDocuments" => Ok(__FieldTag::__input_documents),
                            "input_documents" => Ok(__FieldTag::__input_documents),
                            "documentOutputConfig" => Ok(__FieldTag::__document_output_config),
                            "document_output_config" => Ok(__FieldTag::__document_output_config),
                            "skipHumanReview" => Ok(__FieldTag::__skip_human_review),
                            "skip_human_review" => Ok(__FieldTag::__skip_human_review),
                            "processOptions" => Ok(__FieldTag::__process_options),
                            "process_options" => Ok(__FieldTag::__process_options),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchProcessRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchProcessRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_documents => {
                            if !fields.insert(__FieldTag::__input_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_documents",
                                ));
                            }
                            result.input_documents = map.next_value::<std::option::Option<crate::model::BatchDocumentsInputConfig>>()?
                                ;
                        }
                        __FieldTag::__document_output_config => {
                            if !fields.insert(__FieldTag::__document_output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_output_config",
                                ));
                            }
                            result.document_output_config = map.next_value::<std::option::Option<crate::model::DocumentOutputConfig>>()?
                                ;
                        }
                        __FieldTag::__skip_human_review => {
                            if !fields.insert(__FieldTag::__skip_human_review) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_human_review",
                                ));
                            }
                            result.skip_human_review = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__process_options => {
                            if !fields.insert(__FieldTag::__process_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for process_options",
                                ));
                            }
                            result.process_options = map
                                .next_value::<std::option::Option<crate::model::ProcessOptions>>(
                                )?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchProcessRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.input_documents.is_some() {
            state.serialize_entry("inputDocuments", &self.input_documents)?;
        }
        if self.document_output_config.is_some() {
            state.serialize_entry("documentOutputConfig", &self.document_output_config)?;
        }
        if !wkt::internal::is_default(&self.skip_human_review) {
            state.serialize_entry("skipHumanReview", &self.skip_human_review)?;
        }
        if self.process_options.is_some() {
            state.serialize_entry("processOptions", &self.process_options)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchProcessRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchProcessRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("input_documents", &self.input_documents);
        debug_struct.field("document_output_config", &self.document_output_config);
        debug_struct.field("skip_human_review", &self.skip_human_review);
        debug_struct.field("process_options", &self.process_options);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [BatchProcessDocuments][google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments].
///
/// [google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments]: crate::client::DocumentProcessorService::batch_process_documents
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchProcessResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchProcessResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BatchProcessResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.BatchProcessResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchProcessResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchProcessResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchProcessResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchProcessResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchProcessResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchProcessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchProcessResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for
/// [BatchProcessDocuments][google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments].
///
/// [google.cloud.documentai.v1.DocumentProcessorService.BatchProcessDocuments]: crate::client::DocumentProcessorService::batch_process_documents
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchProcessMetadata {
    /// The state of the current batch processing.
    pub state: crate::model::batch_process_metadata::State,

    /// A message providing more details about the current state of processing.
    /// For example, the error message if the operation is failed.
    pub state_message: std::string::String,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The list of response details of each document.
    pub individual_process_statuses:
        std::vec::Vec<crate::model::batch_process_metadata::IndividualProcessStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchProcessMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchProcessMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_process_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::BatchProcessMetadata::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BatchProcessMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BatchProcessMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BatchProcessMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BatchProcessMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [individual_process_statuses][crate::model::BatchProcessMetadata::individual_process_statuses].
    pub fn set_individual_process_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch_process_metadata::IndividualProcessStatus>,
    {
        use std::iter::Iterator;
        self.individual_process_statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchProcessMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.BatchProcessMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchProcessMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __state_message,
            __create_time,
            __update_time,
            __individual_process_statuses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchProcessMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "individualProcessStatuses" => {
                                Ok(__FieldTag::__individual_process_statuses)
                            }
                            "individual_process_statuses" => {
                                Ok(__FieldTag::__individual_process_statuses)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchProcessMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchProcessMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::batch_process_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__individual_process_statuses => {
                            if !fields.insert(__FieldTag::__individual_process_statuses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for individual_process_statuses",
                                ));
                            }
                            result.individual_process_statuses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::batch_process_metadata::IndividualProcessStatus>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchProcessMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.individual_process_statuses.is_empty() {
            state.serialize_entry(
                "individualProcessStatuses",
                &self.individual_process_statuses,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchProcessMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchProcessMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field(
            "individual_process_statuses",
            &self.individual_process_statuses,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BatchProcessMetadata].
pub mod batch_process_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The status of a each individual document in the batch process.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IndividualProcessStatus {
        /// The source of the document, same as the
        /// [input_gcs_source][google.cloud.documentai.v1.BatchProcessMetadata.IndividualProcessStatus.input_gcs_source]
        /// field in the request when the batch process started.
        ///
        /// [google.cloud.documentai.v1.BatchProcessMetadata.IndividualProcessStatus.input_gcs_source]: crate::model::batch_process_metadata::IndividualProcessStatus::input_gcs_source
        pub input_gcs_source: std::string::String,

        /// The status processing the document.
        pub status: std::option::Option<rpc::model::Status>,

        /// The Cloud Storage output destination (in the request as
        /// [DocumentOutputConfig.GcsOutputConfig.gcs_uri][google.cloud.documentai.v1.DocumentOutputConfig.GcsOutputConfig.gcs_uri])
        /// of the processed document if it was successful, otherwise empty.
        ///
        /// [google.cloud.documentai.v1.DocumentOutputConfig.GcsOutputConfig.gcs_uri]: crate::model::document_output_config::GcsOutputConfig::gcs_uri
        pub output_gcs_destination: std::string::String,

        /// The status of human review on the processed document.
        pub human_review_status: std::option::Option<crate::model::HumanReviewStatus>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndividualProcessStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_gcs_source][crate::model::batch_process_metadata::IndividualProcessStatus::input_gcs_source].
        pub fn set_input_gcs_source<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.input_gcs_source = v.into();
            self
        }

        /// Sets the value of [status][crate::model::batch_process_metadata::IndividualProcessStatus::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::batch_process_metadata::IndividualProcessStatus::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [output_gcs_destination][crate::model::batch_process_metadata::IndividualProcessStatus::output_gcs_destination].
        pub fn set_output_gcs_destination<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_gcs_destination = v.into();
            self
        }

        /// Sets the value of [human_review_status][crate::model::batch_process_metadata::IndividualProcessStatus::human_review_status].
        pub fn set_human_review_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::HumanReviewStatus>,
        {
            self.human_review_status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [human_review_status][crate::model::batch_process_metadata::IndividualProcessStatus::human_review_status].
        pub fn set_or_clear_human_review_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::HumanReviewStatus>,
        {
            self.human_review_status = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for IndividualProcessStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.BatchProcessMetadata.IndividualProcessStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IndividualProcessStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __input_gcs_source,
                __status,
                __output_gcs_destination,
                __human_review_status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IndividualProcessStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inputGcsSource" => Ok(__FieldTag::__input_gcs_source),
                                "input_gcs_source" => Ok(__FieldTag::__input_gcs_source),
                                "status" => Ok(__FieldTag::__status),
                                "outputGcsDestination" => Ok(__FieldTag::__output_gcs_destination),
                                "output_gcs_destination" => {
                                    Ok(__FieldTag::__output_gcs_destination)
                                }
                                "humanReviewStatus" => Ok(__FieldTag::__human_review_status),
                                "human_review_status" => Ok(__FieldTag::__human_review_status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IndividualProcessStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IndividualProcessStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__input_gcs_source => {
                                if !fields.insert(__FieldTag::__input_gcs_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_gcs_source",
                                    ));
                                }
                                result.input_gcs_source = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::__output_gcs_destination => {
                                if !fields.insert(__FieldTag::__output_gcs_destination) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_gcs_destination",
                                    ));
                                }
                                result.output_gcs_destination = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__human_review_status => {
                                if !fields.insert(__FieldTag::__human_review_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for human_review_status",
                                    ));
                                }
                                result.human_review_status = map.next_value::<std::option::Option<crate::model::HumanReviewStatus>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IndividualProcessStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.input_gcs_source.is_empty() {
                state.serialize_entry("inputGcsSource", &self.input_gcs_source)?;
            }
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self.output_gcs_destination.is_empty() {
                state.serialize_entry("outputGcsDestination", &self.output_gcs_destination)?;
            }
            if self.human_review_status.is_some() {
                state.serialize_entry("humanReviewStatus", &self.human_review_status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IndividualProcessStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IndividualProcessStatus");
            debug_struct.field("input_gcs_source", &self.input_gcs_source);
            debug_struct.field("status", &self.status);
            debug_struct.field("output_gcs_destination", &self.output_gcs_destination);
            debug_struct.field("human_review_status", &self.human_review_status);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible states of the batch processing operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// Request operation is waiting for scheduling.
        Waiting,
        /// Request is being processed.
        Running,
        /// The batch processing completed successfully.
        Succeeded,
        /// The batch processing was being cancelled.
        Cancelling,
        /// The batch processing was cancelled.
        Cancelled,
        /// The batch processing has failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Waiting => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Waiting => std::option::Option::Some("WAITING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Waiting,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "WAITING" => Self::Waiting,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Waiting => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.documentai.v1.BatchProcessMetadata.State",
            ))
        }
    }
}

/// Request message for the
/// [FetchProcessorTypes][google.cloud.documentai.v1.DocumentProcessorService.FetchProcessorTypes]
/// method. Some processor types may require the project be added to an
/// allowlist.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.FetchProcessorTypes]: crate::client::DocumentProcessorService::fetch_processor_types
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchProcessorTypesRequest {
    /// Required. The location of processor types to list.
    /// Format: `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchProcessorTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::FetchProcessorTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for FetchProcessorTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.FetchProcessorTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchProcessorTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchProcessorTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchProcessorTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchProcessorTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchProcessorTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchProcessorTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchProcessorTypesRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [FetchProcessorTypes][google.cloud.documentai.v1.DocumentProcessorService.FetchProcessorTypes]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.FetchProcessorTypes]: crate::client::DocumentProcessorService::fetch_processor_types
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchProcessorTypesResponse {
    /// The list of processor types.
    pub processor_types: std::vec::Vec<crate::model::ProcessorType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchProcessorTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processor_types][crate::model::FetchProcessorTypesResponse::processor_types].
    pub fn set_processor_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProcessorType>,
    {
        use std::iter::Iterator;
        self.processor_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchProcessorTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.FetchProcessorTypesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchProcessorTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processor_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchProcessorTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processorTypes" => Ok(__FieldTag::__processor_types),
                            "processor_types" => Ok(__FieldTag::__processor_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchProcessorTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchProcessorTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processor_types => {
                            if !fields.insert(__FieldTag::__processor_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_types",
                                ));
                            }
                            result.processor_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ProcessorType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchProcessorTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.processor_types.is_empty() {
            state.serialize_entry("processorTypes", &self.processor_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchProcessorTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchProcessorTypesResponse");
        debug_struct.field("processor_types", &self.processor_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [ListProcessorTypes][google.cloud.documentai.v1.DocumentProcessorService.ListProcessorTypes]
/// method. Some processor types may require the project be added to an
/// allowlist.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ListProcessorTypes]: crate::client::DocumentProcessorService::list_processor_types
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProcessorTypesRequest {
    /// Required. The location of processor types to list.
    /// Format: `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of processor types to return.
    /// If unspecified, at most `100` processor types will be returned.
    /// The maximum value is `500`. Values above `500` will be coerced to `500`.
    pub page_size: i32,

    /// Used to retrieve the next page of results, empty if at the end of the list.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessorTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProcessorTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProcessorTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProcessorTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessorTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListProcessorTypesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProcessorTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProcessorTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProcessorTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProcessorTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProcessorTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProcessorTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorTypesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [ListProcessorTypes][google.cloud.documentai.v1.DocumentProcessorService.ListProcessorTypes]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ListProcessorTypes]: crate::client::DocumentProcessorService::list_processor_types
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProcessorTypesResponse {
    /// The processor types.
    pub processor_types: std::vec::Vec<crate::model::ProcessorType>,

    /// Points to the next page, otherwise empty.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessorTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processor_types][crate::model::ListProcessorTypesResponse::processor_types].
    pub fn set_processor_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProcessorType>,
    {
        use std::iter::Iterator;
        self.processor_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProcessorTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessorTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListProcessorTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProcessorTypesResponse {
    type PageItem = crate::model::ProcessorType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.processor_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProcessorTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processor_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProcessorTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processorTypes" => Ok(__FieldTag::__processor_types),
                            "processor_types" => Ok(__FieldTag::__processor_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProcessorTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProcessorTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processor_types => {
                            if !fields.insert(__FieldTag::__processor_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_types",
                                ));
                            }
                            result.processor_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ProcessorType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProcessorTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.processor_types.is_empty() {
            state.serialize_entry("processorTypes", &self.processor_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProcessorTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorTypesResponse");
        debug_struct.field("processor_types", &self.processor_types);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for list all processors belongs to a project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProcessorsRequest {
    /// Required. The parent (project and location) which owns this collection of
    /// Processors. Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// The maximum number of processors to return.
    /// If unspecified, at most `50` processors will be returned.
    /// The maximum value is `100`. Values above `100` will be coerced to `100`.
    pub page_size: i32,

    /// We will return the processors sorted by creation time. The page token
    /// will point to the next processor.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProcessorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProcessorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProcessorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListProcessorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProcessorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProcessorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProcessorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProcessorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProcessorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProcessorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [ListProcessors][google.cloud.documentai.v1.DocumentProcessorService.ListProcessors]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ListProcessors]: crate::client::DocumentProcessorService::list_processors
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProcessorsResponse {
    /// The list of processors.
    pub processors: std::vec::Vec<crate::model::Processor>,

    /// Points to the next processor, otherwise empty.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processors][crate::model::ListProcessorsResponse::processors].
    pub fn set_processors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Processor>,
    {
        use std::iter::Iterator;
        self.processors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProcessorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListProcessorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProcessorsResponse {
    type PageItem = crate::model::Processor;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.processors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProcessorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processors,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProcessorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processors" => Ok(__FieldTag::__processors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProcessorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProcessorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processors => {
                            if !fields.insert(__FieldTag::__processors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processors",
                                ));
                            }
                            result.processors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Processor>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProcessorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.processors.is_empty() {
            state.serialize_entry("processors", &self.processors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProcessorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorsResponse");
        debug_struct.field("processors", &self.processors);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [GetProcessorType][google.cloud.documentai.v1.DocumentProcessorService.GetProcessorType]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.GetProcessorType]: crate::client::DocumentProcessorService::get_processor_type
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProcessorTypeRequest {
    /// Required. The processor type resource name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProcessorTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProcessorTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProcessorTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.GetProcessorTypeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProcessorTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProcessorTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProcessorTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProcessorTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProcessorTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetProcessorTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProcessorTypeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [GetProcessor][google.cloud.documentai.v1.DocumentProcessorService.GetProcessor]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.GetProcessor]: crate::client::DocumentProcessorService::get_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProcessorRequest {
    /// Required. The processor resource name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProcessorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProcessorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProcessorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.GetProcessorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProcessorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProcessorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProcessorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProcessorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProcessorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [GetProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.GetProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.GetProcessorVersion]: crate::client::DocumentProcessorService::get_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProcessorVersionRequest {
    /// Required. The processor resource name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProcessorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProcessorVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProcessorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.GetProcessorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProcessorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProcessorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProcessorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProcessorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProcessorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for list all processor versions belongs to a processor.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProcessorVersionsRequest {
    /// Required. The parent (project, location and processor) to list all
    /// versions. Format:
    /// `projects/{project}/locations/{location}/processors/{processor}`
    pub parent: std::string::String,

    /// The maximum number of processor versions to return.
    /// If unspecified, at most `10` processor versions will be returned.
    /// The maximum value is `20`. Values above `20` will be coerced to `20`.
    pub page_size: i32,

    /// We will return the processor versions sorted by creation time. The page
    /// token will point to the next processor version.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessorVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProcessorVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProcessorVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProcessorVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessorVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListProcessorVersionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProcessorVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProcessorVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProcessorVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProcessorVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProcessorVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProcessorVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [ListProcessorVersions][google.cloud.documentai.v1.DocumentProcessorService.ListProcessorVersions]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ListProcessorVersions]: crate::client::DocumentProcessorService::list_processor_versions
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProcessorVersionsResponse {
    /// The list of processors.
    pub processor_versions: std::vec::Vec<crate::model::ProcessorVersion>,

    /// Points to the next processor, otherwise empty.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProcessorVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processor_versions][crate::model::ListProcessorVersionsResponse::processor_versions].
    pub fn set_processor_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProcessorVersion>,
    {
        use std::iter::Iterator;
        self.processor_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProcessorVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProcessorVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListProcessorVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProcessorVersionsResponse {
    type PageItem = crate::model::ProcessorVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.processor_versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProcessorVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processor_versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProcessorVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processorVersions" => Ok(__FieldTag::__processor_versions),
                            "processor_versions" => Ok(__FieldTag::__processor_versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProcessorVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProcessorVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processor_versions => {
                            if !fields.insert(__FieldTag::__processor_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_versions",
                                ));
                            }
                            result.processor_versions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ProcessorVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProcessorVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.processor_versions.is_empty() {
            state.serialize_entry("processorVersions", &self.processor_versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProcessorVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorVersionsResponse");
        debug_struct.field("processor_versions", &self.processor_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [DeleteProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessorVersion]: crate::client::DocumentProcessorService::delete_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteProcessorVersionRequest {
    /// Required. The processor version resource name to be deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProcessorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProcessorVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProcessorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DeleteProcessorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteProcessorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteProcessorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteProcessorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteProcessorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteProcessorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for the
/// [DeleteProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessorVersion]: crate::client::DocumentProcessorService::delete_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteProcessorVersionMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProcessorVersionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::DeleteProcessorVersionMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::DeleteProcessorVersionMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteProcessorVersionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DeleteProcessorVersionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteProcessorVersionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteProcessorVersionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteProcessorVersionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteProcessorVersionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteProcessorVersionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [DeployProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.DeployProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DeployProcessorVersion]: crate::client::DocumentProcessorService::deploy_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployProcessorVersionRequest {
    /// Required. The processor version resource name to be deployed.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployProcessorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployProcessorVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeployProcessorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DeployProcessorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployProcessorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployProcessorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployProcessorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployProcessorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployProcessorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [DeployProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.DeployProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DeployProcessorVersion]: crate::client::DocumentProcessorService::deploy_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployProcessorVersionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployProcessorVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DeployProcessorVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DeployProcessorVersionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployProcessorVersionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployProcessorVersionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployProcessorVersionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployProcessorVersionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployProcessorVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployProcessorVersionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for the
/// [DeployProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.DeployProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DeployProcessorVersion]: crate::client::DocumentProcessorService::deploy_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployProcessorVersionMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeployProcessorVersionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::DeployProcessorVersionMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::DeployProcessorVersionMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeployProcessorVersionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DeployProcessorVersionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployProcessorVersionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployProcessorVersionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployProcessorVersionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployProcessorVersionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeployProcessorVersionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeployProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [UndeployProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.UndeployProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.UndeployProcessorVersion]: crate::client::DocumentProcessorService::undeploy_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployProcessorVersionRequest {
    /// Required. The processor version resource name to be undeployed.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployProcessorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeployProcessorVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeployProcessorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.UndeployProcessorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployProcessorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployProcessorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployProcessorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployProcessorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeployProcessorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeployProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [UndeployProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.UndeployProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.UndeployProcessorVersion]: crate::client::DocumentProcessorService::undeploy_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployProcessorVersionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployProcessorVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UndeployProcessorVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.UndeployProcessorVersionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployProcessorVersionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployProcessorVersionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployProcessorVersionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployProcessorVersionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeployProcessorVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeployProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployProcessorVersionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for the
/// [UndeployProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.UndeployProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.UndeployProcessorVersion]: crate::client::DocumentProcessorService::undeploy_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployProcessorVersionMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeployProcessorVersionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::UndeployProcessorVersionMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::UndeployProcessorVersionMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UndeployProcessorVersionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.UndeployProcessorVersionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployProcessorVersionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployProcessorVersionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployProcessorVersionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployProcessorVersionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeployProcessorVersionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeployProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [CreateProcessor][google.cloud.documentai.v1.DocumentProcessorService.CreateProcessor]
/// method. Notice this request is sent to a regionalized backend service. If the
/// [ProcessorType][google.cloud.documentai.v1.ProcessorType] isn't available in
/// that region, the creation fails.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.CreateProcessor]: crate::client::DocumentProcessorService::create_processor
/// [google.cloud.documentai.v1.ProcessorType]: crate::model::ProcessorType
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateProcessorRequest {
    /// Required. The parent (project and location) under which to create the
    /// processor. Format: `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The processor to be created, requires
    /// [Processor.type][google.cloud.documentai.v1.Processor.type] and
    /// [Processor.display_name][google.cloud.documentai.v1.Processor.display_name]
    /// to be set. Also, the
    /// [Processor.kms_key_name][google.cloud.documentai.v1.Processor.kms_key_name]
    /// field must be set if the processor is under CMEK.
    ///
    /// [google.cloud.documentai.v1.Processor.display_name]: crate::model::Processor::display_name
    /// [google.cloud.documentai.v1.Processor.kms_key_name]: crate::model::Processor::kms_key_name
    /// [google.cloud.documentai.v1.Processor.type]: crate::model::Processor::type
    pub processor: std::option::Option<crate::model::Processor>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProcessorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProcessorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [processor][crate::model::CreateProcessorRequest::processor].
    pub fn set_processor<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Processor>,
    {
        self.processor = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processor][crate::model::CreateProcessorRequest::processor].
    pub fn set_or_clear_processor<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Processor>,
    {
        self.processor = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateProcessorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.CreateProcessorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateProcessorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __processor,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateProcessorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "processor" => Ok(__FieldTag::__processor),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateProcessorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateProcessorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__processor => {
                            if !fields.insert(__FieldTag::__processor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor",
                                ));
                            }
                            result.processor =
                                map.next_value::<std::option::Option<crate::model::Processor>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateProcessorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.processor.is_some() {
            state.serialize_entry("processor", &self.processor)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateProcessorRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("processor", &self.processor);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [DeleteProcessor][google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessor]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessor]: crate::client::DocumentProcessorService::delete_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteProcessorRequest {
    /// Required. The processor resource name to be deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProcessorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProcessorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProcessorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DeleteProcessorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteProcessorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteProcessorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteProcessorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteProcessorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteProcessorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for the
/// [DeleteProcessor][google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessor]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DeleteProcessor]: crate::client::DocumentProcessorService::delete_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteProcessorMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProcessorMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::DeleteProcessorMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::DeleteProcessorMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteProcessorMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DeleteProcessorMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteProcessorMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteProcessorMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteProcessorMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteProcessorMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteProcessorMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteProcessorMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [EnableProcessor][google.cloud.documentai.v1.DocumentProcessorService.EnableProcessor]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.EnableProcessor]: crate::client::DocumentProcessorService::enable_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableProcessorRequest {
    /// Required. The processor resource name to be enabled.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableProcessorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableProcessorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnableProcessorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.EnableProcessorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableProcessorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableProcessorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableProcessorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableProcessorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableProcessorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnableProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnableProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [EnableProcessor][google.cloud.documentai.v1.DocumentProcessorService.EnableProcessor]
/// method. Intentionally empty proto for adding fields in future.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.EnableProcessor]: crate::client::DocumentProcessorService::enable_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableProcessorResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableProcessorResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnableProcessorResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.EnableProcessorResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableProcessorResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableProcessorResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableProcessorResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableProcessorResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableProcessorResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnableProcessorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnableProcessorResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for the
/// [EnableProcessor][google.cloud.documentai.v1.DocumentProcessorService.EnableProcessor]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.EnableProcessor]: crate::client::DocumentProcessorService::enable_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableProcessorMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableProcessorMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::EnableProcessorMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::EnableProcessorMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EnableProcessorMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.EnableProcessorMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableProcessorMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableProcessorMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableProcessorMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableProcessorMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableProcessorMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnableProcessorMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnableProcessorMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [DisableProcessor][google.cloud.documentai.v1.DocumentProcessorService.DisableProcessor]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DisableProcessor]: crate::client::DocumentProcessorService::disable_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableProcessorRequest {
    /// Required. The processor resource name to be disabled.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableProcessorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableProcessorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DisableProcessorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DisableProcessorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableProcessorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableProcessorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableProcessorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableProcessorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableProcessorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisableProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisableProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [DisableProcessor][google.cloud.documentai.v1.DocumentProcessorService.DisableProcessor]
/// method. Intentionally empty proto for adding fields in future.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DisableProcessor]: crate::client::DocumentProcessorService::disable_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableProcessorResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableProcessorResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisableProcessorResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DisableProcessorResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableProcessorResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableProcessorResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableProcessorResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableProcessorResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableProcessorResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisableProcessorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisableProcessorResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for the
/// [DisableProcessor][google.cloud.documentai.v1.DocumentProcessorService.DisableProcessor]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.DisableProcessor]: crate::client::DocumentProcessorService::disable_processor
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableProcessorMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableProcessorMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::DisableProcessorMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::DisableProcessorMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DisableProcessorMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DisableProcessorMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableProcessorMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableProcessorMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableProcessorMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableProcessorMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableProcessorMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisableProcessorMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisableProcessorMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [SetDefaultProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.SetDefaultProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.SetDefaultProcessorVersion]: crate::client::DocumentProcessorService::set_default_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetDefaultProcessorVersionRequest {
    /// Required. The resource name of the
    /// [Processor][google.cloud.documentai.v1.Processor] to change default
    /// version.
    ///
    /// [google.cloud.documentai.v1.Processor]: crate::model::Processor
    pub processor: std::string::String,

    /// Required. The resource name of child
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion] to use as
    /// default. Format:
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{version}`
    ///
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    pub default_processor_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetDefaultProcessorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processor][crate::model::SetDefaultProcessorVersionRequest::processor].
    pub fn set_processor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.processor = v.into();
        self
    }

    /// Sets the value of [default_processor_version][crate::model::SetDefaultProcessorVersionRequest::default_processor_version].
    pub fn set_default_processor_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_processor_version = v.into();
        self
    }
}

impl wkt::message::Message for SetDefaultProcessorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.SetDefaultProcessorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetDefaultProcessorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processor,
            __default_processor_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetDefaultProcessorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processor" => Ok(__FieldTag::__processor),
                            "defaultProcessorVersion" => {
                                Ok(__FieldTag::__default_processor_version)
                            }
                            "default_processor_version" => {
                                Ok(__FieldTag::__default_processor_version)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetDefaultProcessorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetDefaultProcessorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processor => {
                            if !fields.insert(__FieldTag::__processor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor",
                                ));
                            }
                            result.processor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_processor_version => {
                            if !fields.insert(__FieldTag::__default_processor_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_processor_version",
                                ));
                            }
                            result.default_processor_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetDefaultProcessorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.processor.is_empty() {
            state.serialize_entry("processor", &self.processor)?;
        }
        if !self.default_processor_version.is_empty() {
            state.serialize_entry("defaultProcessorVersion", &self.default_processor_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetDefaultProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetDefaultProcessorVersionRequest");
        debug_struct.field("processor", &self.processor);
        debug_struct.field("default_processor_version", &self.default_processor_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the
/// [SetDefaultProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.SetDefaultProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.SetDefaultProcessorVersion]: crate::client::DocumentProcessorService::set_default_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetDefaultProcessorVersionResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetDefaultProcessorVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SetDefaultProcessorVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.SetDefaultProcessorVersionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetDefaultProcessorVersionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetDefaultProcessorVersionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetDefaultProcessorVersionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetDefaultProcessorVersionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetDefaultProcessorVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetDefaultProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetDefaultProcessorVersionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The long-running operation metadata for the
/// [SetDefaultProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.SetDefaultProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.SetDefaultProcessorVersion]: crate::client::DocumentProcessorService::set_default_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetDefaultProcessorVersionMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetDefaultProcessorVersionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::SetDefaultProcessorVersionMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::SetDefaultProcessorVersionMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SetDefaultProcessorVersionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.SetDefaultProcessorVersionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetDefaultProcessorVersionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetDefaultProcessorVersionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetDefaultProcessorVersionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetDefaultProcessorVersionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetDefaultProcessorVersionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetDefaultProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetDefaultProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the
/// [TrainProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.TrainProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.TrainProcessorVersion]: crate::client::DocumentProcessorService::train_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TrainProcessorVersionRequest {
    /// Required. The parent (project, location and processor) to create the new
    /// version for. Format:
    /// `projects/{project}/locations/{location}/processors/{processor}`.
    pub parent: std::string::String,

    /// Required. The processor version to be created.
    pub processor_version: std::option::Option<crate::model::ProcessorVersion>,

    /// Optional. The schema the processor version will be trained with.
    pub document_schema: std::option::Option<crate::model::DocumentSchema>,

    /// Optional. The input data used to train the
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion].
    ///
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    pub input_data: std::option::Option<crate::model::train_processor_version_request::InputData>,

    /// Optional. The processor version to use as a base for training. This
    /// processor version must be a child of `parent`. Format:
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`.
    pub base_processor_version: std::string::String,

    pub processor_flags:
        std::option::Option<crate::model::train_processor_version_request::ProcessorFlags>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrainProcessorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::TrainProcessorVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [processor_version][crate::model::TrainProcessorVersionRequest::processor_version].
    pub fn set_processor_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProcessorVersion>,
    {
        self.processor_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processor_version][crate::model::TrainProcessorVersionRequest::processor_version].
    pub fn set_or_clear_processor_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProcessorVersion>,
    {
        self.processor_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_schema][crate::model::TrainProcessorVersionRequest::document_schema].
    pub fn set_document_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.document_schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_schema][crate::model::TrainProcessorVersionRequest::document_schema].
    pub fn set_or_clear_document_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.document_schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_data][crate::model::TrainProcessorVersionRequest::input_data].
    pub fn set_input_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::train_processor_version_request::InputData>,
    {
        self.input_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_data][crate::model::TrainProcessorVersionRequest::input_data].
    pub fn set_or_clear_input_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::train_processor_version_request::InputData>,
    {
        self.input_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [base_processor_version][crate::model::TrainProcessorVersionRequest::base_processor_version].
    pub fn set_base_processor_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.base_processor_version = v.into();
        self
    }

    /// Sets the value of [processor_flags][crate::model::TrainProcessorVersionRequest::processor_flags].
    ///
    /// Note that all the setters affecting `processor_flags` are mutually
    /// exclusive.
    pub fn set_processor_flags<
        T: std::convert::Into<
                std::option::Option<crate::model::train_processor_version_request::ProcessorFlags>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processor_flags = v.into();
        self
    }

    /// The value of [processor_flags][crate::model::TrainProcessorVersionRequest::processor_flags]
    /// if it holds a `CustomDocumentExtractionOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn custom_document_extraction_options(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::train_processor_version_request::CustomDocumentExtractionOptions,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.processor_flags.as_ref().and_then(|v| match v {
            crate::model::train_processor_version_request::ProcessorFlags::CustomDocumentExtractionOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [processor_flags][crate::model::TrainProcessorVersionRequest::processor_flags]
    /// to hold a `CustomDocumentExtractionOptions`.
    ///
    /// Note that all the setters affecting `processor_flags` are
    /// mutually exclusive.
    pub fn set_custom_document_extraction_options<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::train_processor_version_request::CustomDocumentExtractionOptions,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processor_flags = std::option::Option::Some(
            crate::model::train_processor_version_request::ProcessorFlags::CustomDocumentExtractionOptions(
                v.into()
            )
        );
        self
    }

    /// The value of [processor_flags][crate::model::TrainProcessorVersionRequest::processor_flags]
    /// if it holds a `FoundationModelTuningOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn foundation_model_tuning_options(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<
            crate::model::train_processor_version_request::FoundationModelTuningOptions,
        >,
    > {
        #[allow(unreachable_patterns)]
        self.processor_flags.as_ref().and_then(|v| match v {
            crate::model::train_processor_version_request::ProcessorFlags::FoundationModelTuningOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [processor_flags][crate::model::TrainProcessorVersionRequest::processor_flags]
    /// to hold a `FoundationModelTuningOptions`.
    ///
    /// Note that all the setters affecting `processor_flags` are
    /// mutually exclusive.
    pub fn set_foundation_model_tuning_options<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::train_processor_version_request::FoundationModelTuningOptions,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processor_flags = std::option::Option::Some(
            crate::model::train_processor_version_request::ProcessorFlags::FoundationModelTuningOptions(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for TrainProcessorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.TrainProcessorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrainProcessorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_document_extraction_options,
            __foundation_model_tuning_options,
            __parent,
            __processor_version,
            __document_schema,
            __input_data,
            __base_processor_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainProcessorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customDocumentExtractionOptions" => {
                                Ok(__FieldTag::__custom_document_extraction_options)
                            }
                            "custom_document_extraction_options" => {
                                Ok(__FieldTag::__custom_document_extraction_options)
                            }
                            "foundationModelTuningOptions" => {
                                Ok(__FieldTag::__foundation_model_tuning_options)
                            }
                            "foundation_model_tuning_options" => {
                                Ok(__FieldTag::__foundation_model_tuning_options)
                            }
                            "parent" => Ok(__FieldTag::__parent),
                            "processorVersion" => Ok(__FieldTag::__processor_version),
                            "processor_version" => Ok(__FieldTag::__processor_version),
                            "documentSchema" => Ok(__FieldTag::__document_schema),
                            "document_schema" => Ok(__FieldTag::__document_schema),
                            "inputData" => Ok(__FieldTag::__input_data),
                            "input_data" => Ok(__FieldTag::__input_data),
                            "baseProcessorVersion" => Ok(__FieldTag::__base_processor_version),
                            "base_processor_version" => Ok(__FieldTag::__base_processor_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrainProcessorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainProcessorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_document_extraction_options => {
                            if !fields.insert(__FieldTag::__custom_document_extraction_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_document_extraction_options",
                                ));
                            }
                            if result.processor_flags.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `processor_flags`, a oneof with full ID .google.cloud.documentai.v1.TrainProcessorVersionRequest.custom_document_extraction_options, latest field was customDocumentExtractionOptions",
                                ));
                            }
                            result.processor_flags = std::option::Option::Some(
                                crate::model::train_processor_version_request::ProcessorFlags::CustomDocumentExtractionOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::train_processor_version_request::CustomDocumentExtractionOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__foundation_model_tuning_options => {
                            if !fields.insert(__FieldTag::__foundation_model_tuning_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for foundation_model_tuning_options",
                                ));
                            }
                            if result.processor_flags.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `processor_flags`, a oneof with full ID .google.cloud.documentai.v1.TrainProcessorVersionRequest.foundation_model_tuning_options, latest field was foundationModelTuningOptions",
                                ));
                            }
                            result.processor_flags = std::option::Option::Some(
                                crate::model::train_processor_version_request::ProcessorFlags::FoundationModelTuningOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::train_processor_version_request::FoundationModelTuningOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__processor_version => {
                            if !fields.insert(__FieldTag::__processor_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_version",
                                ));
                            }
                            result.processor_version = map
                                .next_value::<std::option::Option<crate::model::ProcessorVersion>>(
                                )?;
                        }
                        __FieldTag::__document_schema => {
                            if !fields.insert(__FieldTag::__document_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_schema",
                                ));
                            }
                            result.document_schema = map
                                .next_value::<std::option::Option<crate::model::DocumentSchema>>(
                                )?;
                        }
                        __FieldTag::__input_data => {
                            if !fields.insert(__FieldTag::__input_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_data",
                                ));
                            }
                            result.input_data = map.next_value::<std::option::Option<
                                crate::model::train_processor_version_request::InputData,
                            >>()?;
                        }
                        __FieldTag::__base_processor_version => {
                            if !fields.insert(__FieldTag::__base_processor_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_processor_version",
                                ));
                            }
                            result.base_processor_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TrainProcessorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.custom_document_extraction_options() {
            state.serialize_entry("customDocumentExtractionOptions", value)?;
        }
        if let Some(value) = self.foundation_model_tuning_options() {
            state.serialize_entry("foundationModelTuningOptions", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.processor_version.is_some() {
            state.serialize_entry("processorVersion", &self.processor_version)?;
        }
        if self.document_schema.is_some() {
            state.serialize_entry("documentSchema", &self.document_schema)?;
        }
        if self.input_data.is_some() {
            state.serialize_entry("inputData", &self.input_data)?;
        }
        if !self.base_processor_version.is_empty() {
            state.serialize_entry("baseProcessorVersion", &self.base_processor_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TrainProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainProcessorVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("processor_version", &self.processor_version);
        debug_struct.field("document_schema", &self.document_schema);
        debug_struct.field("input_data", &self.input_data);
        debug_struct.field("base_processor_version", &self.base_processor_version);
        debug_struct.field("processor_flags", &self.processor_flags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TrainProcessorVersionRequest].
pub mod train_processor_version_request {
    #[allow(unused_imports)]
    use super::*;

    /// The input data used to train a new
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion].
    ///
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InputData {
        /// The documents used for training the new version.
        pub training_documents: std::option::Option<crate::model::BatchDocumentsInputConfig>,

        /// The documents used for testing the trained version.
        pub test_documents: std::option::Option<crate::model::BatchDocumentsInputConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InputData {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_documents][crate::model::train_processor_version_request::InputData::training_documents].
        pub fn set_training_documents<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
        {
            self.training_documents = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [training_documents][crate::model::train_processor_version_request::InputData::training_documents].
        pub fn set_or_clear_training_documents<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
        {
            self.training_documents = v.map(|x| x.into());
            self
        }

        /// Sets the value of [test_documents][crate::model::train_processor_version_request::InputData::test_documents].
        pub fn set_test_documents<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
        {
            self.test_documents = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [test_documents][crate::model::train_processor_version_request::InputData::test_documents].
        pub fn set_or_clear_test_documents<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
        {
            self.test_documents = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for InputData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.TrainProcessorVersionRequest.InputData"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InputData {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __training_documents,
                __test_documents,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InputData")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trainingDocuments" => Ok(__FieldTag::__training_documents),
                                "training_documents" => Ok(__FieldTag::__training_documents),
                                "testDocuments" => Ok(__FieldTag::__test_documents),
                                "test_documents" => Ok(__FieldTag::__test_documents),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InputData;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InputData")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__training_documents => {
                                if !fields.insert(__FieldTag::__training_documents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for training_documents",
                                    ));
                                }
                                result.training_documents =
                                    map.next_value::<std::option::Option<
                                        crate::model::BatchDocumentsInputConfig,
                                    >>()?;
                            }
                            __FieldTag::__test_documents => {
                                if !fields.insert(__FieldTag::__test_documents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for test_documents",
                                    ));
                                }
                                result.test_documents =
                                    map.next_value::<std::option::Option<
                                        crate::model::BatchDocumentsInputConfig,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InputData {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.training_documents.is_some() {
                state.serialize_entry("trainingDocuments", &self.training_documents)?;
            }
            if self.test_documents.is_some() {
                state.serialize_entry("testDocuments", &self.test_documents)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for InputData {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("InputData");
            debug_struct.field("training_documents", &self.training_documents);
            debug_struct.field("test_documents", &self.test_documents);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Options to control the training of the Custom Document Extraction (CDE)
    /// Processor.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CustomDocumentExtractionOptions {

        /// Training method to use for CDE training.
        pub training_method: crate::model::train_processor_version_request::custom_document_extraction_options::TrainingMethod,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomDocumentExtractionOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [training_method][crate::model::train_processor_version_request::CustomDocumentExtractionOptions::training_method].
        pub fn set_training_method<T: std::convert::Into<crate::model::train_processor_version_request::custom_document_extraction_options::TrainingMethod>>(mut self, v: T) -> Self{
            self.training_method = v.into();
            self
        }
    }

    impl wkt::message::Message for CustomDocumentExtractionOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.TrainProcessorVersionRequest.CustomDocumentExtractionOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CustomDocumentExtractionOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __training_method,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CustomDocumentExtractionOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trainingMethod" => Ok(__FieldTag::__training_method),
                                "training_method" => Ok(__FieldTag::__training_method),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CustomDocumentExtractionOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CustomDocumentExtractionOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__training_method => {
                                if !fields.insert(__FieldTag::__training_method) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for training_method",
                                    ));
                                }
                                result.training_method = map.next_value::<std::option::Option<crate::model::train_processor_version_request::custom_document_extraction_options::TrainingMethod>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CustomDocumentExtractionOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.training_method) {
                state.serialize_entry("trainingMethod", &self.training_method)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CustomDocumentExtractionOptions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CustomDocumentExtractionOptions");
            debug_struct.field("training_method", &self.training_method);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [CustomDocumentExtractionOptions].
    pub mod custom_document_extraction_options {
        #[allow(unused_imports)]
        use super::*;

        /// Training Method for CDE. `TRAINING_METHOD_UNSPECIFIED` will fall back to
        /// `MODEL_BASED`.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TrainingMethod {
            Unspecified,
            ModelBased,
            TemplateBased,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TrainingMethod::value] or
            /// [TrainingMethod::name].
            UnknownValue(training_method::UnknownValue),
        }

        #[doc(hidden)]
        pub mod training_method {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TrainingMethod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ModelBased => std::option::Option::Some(1),
                    Self::TemplateBased => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TRAINING_METHOD_UNSPECIFIED"),
                    Self::ModelBased => std::option::Option::Some("MODEL_BASED"),
                    Self::TemplateBased => std::option::Option::Some("TEMPLATE_BASED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TrainingMethod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TrainingMethod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TrainingMethod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ModelBased,
                    2 => Self::TemplateBased,
                    _ => Self::UnknownValue(training_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TrainingMethod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TRAINING_METHOD_UNSPECIFIED" => Self::Unspecified,
                    "MODEL_BASED" => Self::ModelBased,
                    "TEMPLATE_BASED" => Self::TemplateBased,
                    _ => Self::UnknownValue(training_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TrainingMethod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ModelBased => serializer.serialize_i32(1),
                    Self::TemplateBased => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TrainingMethod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrainingMethod>::new(
                    ".google.cloud.documentai.v1.TrainProcessorVersionRequest.CustomDocumentExtractionOptions.TrainingMethod"))
            }
        }
    }

    /// Options to control foundation model tuning of the processor.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FoundationModelTuningOptions {
        /// Optional. The number of steps to run for model tuning. Valid values are
        /// between 1 and 400. If not provided, recommended steps will be used.
        pub train_steps: i32,

        /// Optional. The multiplier to apply to the recommended learning rate. Valid
        /// values are between 0.1 and 10. If not provided, recommended learning rate
        /// will be used.
        pub learning_rate_multiplier: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FoundationModelTuningOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [train_steps][crate::model::train_processor_version_request::FoundationModelTuningOptions::train_steps].
        pub fn set_train_steps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.train_steps = v.into();
            self
        }

        /// Sets the value of [learning_rate_multiplier][crate::model::train_processor_version_request::FoundationModelTuningOptions::learning_rate_multiplier].
        pub fn set_learning_rate_multiplier<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.learning_rate_multiplier = v.into();
            self
        }
    }

    impl wkt::message::Message for FoundationModelTuningOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.TrainProcessorVersionRequest.FoundationModelTuningOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FoundationModelTuningOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __train_steps,
                __learning_rate_multiplier,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FoundationModelTuningOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trainSteps" => Ok(__FieldTag::__train_steps),
                                "train_steps" => Ok(__FieldTag::__train_steps),
                                "learningRateMultiplier" => {
                                    Ok(__FieldTag::__learning_rate_multiplier)
                                }
                                "learning_rate_multiplier" => {
                                    Ok(__FieldTag::__learning_rate_multiplier)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FoundationModelTuningOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FoundationModelTuningOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__train_steps => {
                                if !fields.insert(__FieldTag::__train_steps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for train_steps",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.train_steps =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__learning_rate_multiplier => {
                                if !fields.insert(__FieldTag::__learning_rate_multiplier) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for learning_rate_multiplier",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.learning_rate_multiplier =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FoundationModelTuningOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.train_steps) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("trainSteps", &__With(&self.train_steps))?;
            }
            if !wkt::internal::is_default(&self.learning_rate_multiplier) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "learningRateMultiplier",
                    &__With(&self.learning_rate_multiplier),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FoundationModelTuningOptions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FoundationModelTuningOptions");
            debug_struct.field("train_steps", &self.train_steps);
            debug_struct.field("learning_rate_multiplier", &self.learning_rate_multiplier);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProcessorFlags {
        /// Options to control Custom Document Extraction (CDE) Processor.
        CustomDocumentExtractionOptions(
            std::boxed::Box<
                crate::model::train_processor_version_request::CustomDocumentExtractionOptions,
            >,
        ),
        /// Options to control foundation model tuning of a processor.
        FoundationModelTuningOptions(
            std::boxed::Box<
                crate::model::train_processor_version_request::FoundationModelTuningOptions,
            >,
        ),
    }
}

/// The response for
/// [TrainProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.TrainProcessorVersion].
///
/// [google.cloud.documentai.v1.DocumentProcessorService.TrainProcessorVersion]: crate::client::DocumentProcessorService::train_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TrainProcessorVersionResponse {
    /// The resource name of the processor version produced by training.
    pub processor_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrainProcessorVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processor_version][crate::model::TrainProcessorVersionResponse::processor_version].
    pub fn set_processor_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.processor_version = v.into();
        self
    }
}

impl wkt::message::Message for TrainProcessorVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.TrainProcessorVersionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrainProcessorVersionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processor_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainProcessorVersionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processorVersion" => Ok(__FieldTag::__processor_version),
                            "processor_version" => Ok(__FieldTag::__processor_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrainProcessorVersionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainProcessorVersionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processor_version => {
                            if !fields.insert(__FieldTag::__processor_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_version",
                                ));
                            }
                            result.processor_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TrainProcessorVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.processor_version.is_empty() {
            state.serialize_entry("processorVersion", &self.processor_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TrainProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainProcessorVersionResponse");
        debug_struct.field("processor_version", &self.processor_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata that represents a processor version being created.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TrainProcessorVersionMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    /// The training dataset validation information.
    pub training_dataset_validation:
        std::option::Option<crate::model::train_processor_version_metadata::DatasetValidation>,

    /// The test dataset validation information.
    pub test_dataset_validation:
        std::option::Option<crate::model::train_processor_version_metadata::DatasetValidation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrainProcessorVersionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::TrainProcessorVersionMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::TrainProcessorVersionMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [training_dataset_validation][crate::model::TrainProcessorVersionMetadata::training_dataset_validation].
    pub fn set_training_dataset_validation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::train_processor_version_metadata::DatasetValidation>,
    {
        self.training_dataset_validation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [training_dataset_validation][crate::model::TrainProcessorVersionMetadata::training_dataset_validation].
    pub fn set_or_clear_training_dataset_validation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::train_processor_version_metadata::DatasetValidation>,
    {
        self.training_dataset_validation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [test_dataset_validation][crate::model::TrainProcessorVersionMetadata::test_dataset_validation].
    pub fn set_test_dataset_validation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::train_processor_version_metadata::DatasetValidation>,
    {
        self.test_dataset_validation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_dataset_validation][crate::model::TrainProcessorVersionMetadata::test_dataset_validation].
    pub fn set_or_clear_test_dataset_validation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::train_processor_version_metadata::DatasetValidation>,
    {
        self.test_dataset_validation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TrainProcessorVersionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.TrainProcessorVersionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrainProcessorVersionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            __training_dataset_validation,
            __test_dataset_validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainProcessorVersionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            "trainingDatasetValidation" => {
                                Ok(__FieldTag::__training_dataset_validation)
                            }
                            "training_dataset_validation" => {
                                Ok(__FieldTag::__training_dataset_validation)
                            }
                            "testDatasetValidation" => Ok(__FieldTag::__test_dataset_validation),
                            "test_dataset_validation" => Ok(__FieldTag::__test_dataset_validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrainProcessorVersionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainProcessorVersionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::__training_dataset_validation => {
                            if !fields.insert(__FieldTag::__training_dataset_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_dataset_validation",
                                ));
                            }
                            result.training_dataset_validation = map
                                .next_value::<std::option::Option<
                                crate::model::train_processor_version_metadata::DatasetValidation,
                            >>(
                            )?;
                        }
                        __FieldTag::__test_dataset_validation => {
                            if !fields.insert(__FieldTag::__test_dataset_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_dataset_validation",
                                ));
                            }
                            result.test_dataset_validation = map.next_value::<std::option::Option<
                                crate::model::train_processor_version_metadata::DatasetValidation,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TrainProcessorVersionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if self.training_dataset_validation.is_some() {
            state.serialize_entry(
                "trainingDatasetValidation",
                &self.training_dataset_validation,
            )?;
        }
        if self.test_dataset_validation.is_some() {
            state.serialize_entry("testDatasetValidation", &self.test_dataset_validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TrainProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        debug_struct.field(
            "training_dataset_validation",
            &self.training_dataset_validation,
        );
        debug_struct.field("test_dataset_validation", &self.test_dataset_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TrainProcessorVersionMetadata].
pub mod train_processor_version_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The dataset validation information.
    /// This includes any and all errors with documents and the dataset.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DatasetValidation {
        /// The total number of document errors.
        pub document_error_count: i32,

        /// The total number of dataset errors.
        pub dataset_error_count: i32,

        /// Error information pertaining to specific documents. A maximum of 10
        /// document errors will be returned.
        /// Any document with errors will not be used throughout training.
        pub document_errors: std::vec::Vec<rpc::model::Status>,

        /// Error information for the dataset as a whole. A maximum of 10 dataset
        /// errors will be returned.
        /// A single dataset error is terminal for training.
        pub dataset_errors: std::vec::Vec<rpc::model::Status>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DatasetValidation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [document_error_count][crate::model::train_processor_version_metadata::DatasetValidation::document_error_count].
        pub fn set_document_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.document_error_count = v.into();
            self
        }

        /// Sets the value of [dataset_error_count][crate::model::train_processor_version_metadata::DatasetValidation::dataset_error_count].
        pub fn set_dataset_error_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.dataset_error_count = v.into();
            self
        }

        /// Sets the value of [document_errors][crate::model::train_processor_version_metadata::DatasetValidation::document_errors].
        pub fn set_document_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<rpc::model::Status>,
        {
            use std::iter::Iterator;
            self.document_errors = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dataset_errors][crate::model::train_processor_version_metadata::DatasetValidation::dataset_errors].
        pub fn set_dataset_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<rpc::model::Status>,
        {
            use std::iter::Iterator;
            self.dataset_errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DatasetValidation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.TrainProcessorVersionMetadata.DatasetValidation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DatasetValidation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __document_error_count,
                __dataset_error_count,
                __document_errors,
                __dataset_errors,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DatasetValidation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "documentErrorCount" => Ok(__FieldTag::__document_error_count),
                                "document_error_count" => Ok(__FieldTag::__document_error_count),
                                "datasetErrorCount" => Ok(__FieldTag::__dataset_error_count),
                                "dataset_error_count" => Ok(__FieldTag::__dataset_error_count),
                                "documentErrors" => Ok(__FieldTag::__document_errors),
                                "document_errors" => Ok(__FieldTag::__document_errors),
                                "datasetErrors" => Ok(__FieldTag::__dataset_errors),
                                "dataset_errors" => Ok(__FieldTag::__dataset_errors),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DatasetValidation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DatasetValidation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__document_error_count => {
                                if !fields.insert(__FieldTag::__document_error_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_error_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.document_error_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__dataset_error_count => {
                                if !fields.insert(__FieldTag::__dataset_error_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_error_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.dataset_error_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__document_errors => {
                                if !fields.insert(__FieldTag::__document_errors) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_errors",
                                    ));
                                }
                                result.document_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__dataset_errors => {
                                if !fields.insert(__FieldTag::__dataset_errors) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_errors",
                                    ));
                                }
                                result.dataset_errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DatasetValidation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.document_error_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("documentErrorCount", &__With(&self.document_error_count))?;
            }
            if !wkt::internal::is_default(&self.dataset_error_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("datasetErrorCount", &__With(&self.dataset_error_count))?;
            }
            if !self.document_errors.is_empty() {
                state.serialize_entry("documentErrors", &self.document_errors)?;
            }
            if !self.dataset_errors.is_empty() {
                state.serialize_entry("datasetErrors", &self.dataset_errors)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DatasetValidation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DatasetValidation");
            debug_struct.field("document_error_count", &self.document_error_count);
            debug_struct.field("dataset_error_count", &self.dataset_error_count);
            debug_struct.field("document_errors", &self.document_errors);
            debug_struct.field("dataset_errors", &self.dataset_errors);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Request message for the
/// [ReviewDocument][google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument]: crate::client::DocumentProcessorService::review_document
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReviewDocumentRequest {
    /// Required. The resource name of the
    /// [HumanReviewConfig][google.cloud.documentai.v1.HumanReviewConfig] that the
    /// document will be reviewed with.
    pub human_review_config: std::string::String,

    /// Whether the validation should be performed on the ad-hoc review request.
    pub enable_schema_validation: bool,

    /// The priority of the human review task.
    pub priority: crate::model::review_document_request::Priority,

    /// The document schema of the human review task.
    pub document_schema: std::option::Option<crate::model::DocumentSchema>,

    /// The document payload.
    pub source: std::option::Option<crate::model::review_document_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReviewDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [human_review_config][crate::model::ReviewDocumentRequest::human_review_config].
    pub fn set_human_review_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.human_review_config = v.into();
        self
    }

    /// Sets the value of [enable_schema_validation][crate::model::ReviewDocumentRequest::enable_schema_validation].
    pub fn set_enable_schema_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_schema_validation = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::ReviewDocumentRequest::priority].
    pub fn set_priority<T: std::convert::Into<crate::model::review_document_request::Priority>>(
        mut self,
        v: T,
    ) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [document_schema][crate::model::ReviewDocumentRequest::document_schema].
    pub fn set_document_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.document_schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_schema][crate::model::ReviewDocumentRequest::document_schema].
    pub fn set_or_clear_document_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.document_schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::ReviewDocumentRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::review_document_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ReviewDocumentRequest::source]
    /// if it holds a `InlineDocument`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_document(&self) -> std::option::Option<&std::boxed::Box<crate::model::Document>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::review_document_request::Source::InlineDocument(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ReviewDocumentRequest::source]
    /// to hold a `InlineDocument`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_document<T: std::convert::Into<std::boxed::Box<crate::model::Document>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::review_document_request::Source::InlineDocument(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReviewDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ReviewDocumentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReviewDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inline_document,
            __human_review_config,
            __enable_schema_validation,
            __priority,
            __document_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReviewDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inlineDocument" => Ok(__FieldTag::__inline_document),
                            "inline_document" => Ok(__FieldTag::__inline_document),
                            "humanReviewConfig" => Ok(__FieldTag::__human_review_config),
                            "human_review_config" => Ok(__FieldTag::__human_review_config),
                            "enableSchemaValidation" => Ok(__FieldTag::__enable_schema_validation),
                            "enable_schema_validation" => {
                                Ok(__FieldTag::__enable_schema_validation)
                            }
                            "priority" => Ok(__FieldTag::__priority),
                            "documentSchema" => Ok(__FieldTag::__document_schema),
                            "document_schema" => Ok(__FieldTag::__document_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReviewDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReviewDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inline_document => {
                            if !fields.insert(__FieldTag::__inline_document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline_document",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.documentai.v1.ReviewDocumentRequest.inline_document, latest field was inlineDocument",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::review_document_request::Source::InlineDocument(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Document>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__human_review_config => {
                            if !fields.insert(__FieldTag::__human_review_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_review_config",
                                ));
                            }
                            result.human_review_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_schema_validation => {
                            if !fields.insert(__FieldTag::__enable_schema_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_schema_validation",
                                ));
                            }
                            result.enable_schema_validation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            result.priority = map
                                .next_value::<std::option::Option<
                                    crate::model::review_document_request::Priority,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_schema => {
                            if !fields.insert(__FieldTag::__document_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_schema",
                                ));
                            }
                            result.document_schema = map
                                .next_value::<std::option::Option<crate::model::DocumentSchema>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReviewDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.inline_document() {
            state.serialize_entry("inlineDocument", value)?;
        }
        if !self.human_review_config.is_empty() {
            state.serialize_entry("humanReviewConfig", &self.human_review_config)?;
        }
        if !wkt::internal::is_default(&self.enable_schema_validation) {
            state.serialize_entry("enableSchemaValidation", &self.enable_schema_validation)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            state.serialize_entry("priority", &self.priority)?;
        }
        if self.document_schema.is_some() {
            state.serialize_entry("documentSchema", &self.document_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReviewDocumentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReviewDocumentRequest");
        debug_struct.field("human_review_config", &self.human_review_config);
        debug_struct.field("enable_schema_validation", &self.enable_schema_validation);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("document_schema", &self.document_schema);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReviewDocumentRequest].
pub mod review_document_request {
    #[allow(unused_imports)]
    use super::*;

    /// The priority level of the human review task.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Priority {
        /// The default priority level.
        Default,
        /// The urgent priority level. The labeling manager should allocate labeler
        /// resource to the urgent task queue to respect this priority level.
        Urgent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Priority::value] or
        /// [Priority::name].
        UnknownValue(priority::UnknownValue),
    }

    #[doc(hidden)]
    pub mod priority {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Priority {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Default => std::option::Option::Some(0),
                Self::Urgent => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Urgent => std::option::Option::Some("URGENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Priority {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Priority {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Priority {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Default,
                1 => Self::Urgent,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Priority {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT" => Self::Default,
                "URGENT" => Self::Urgent,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Priority {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Default => serializer.serialize_i32(0),
                Self::Urgent => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Priority {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Priority>::new(
                ".google.cloud.documentai.v1.ReviewDocumentRequest.Priority",
            ))
        }
    }

    /// The document payload.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// An inline document proto.
        InlineDocument(std::boxed::Box<crate::model::Document>),
    }
}

/// Response message for the
/// [ReviewDocument][google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument]: crate::client::DocumentProcessorService::review_document
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReviewDocumentResponse {
    /// The Cloud Storage uri for the human reviewed document if the review is
    /// succeeded.
    pub gcs_destination: std::string::String,

    /// The state of the review operation.
    pub state: crate::model::review_document_response::State,

    /// The reason why the review is rejected by reviewer.
    pub rejection_reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReviewDocumentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_destination][crate::model::ReviewDocumentResponse::gcs_destination].
    pub fn set_gcs_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_destination = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ReviewDocumentResponse::state].
    pub fn set_state<T: std::convert::Into<crate::model::review_document_response::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [rejection_reason][crate::model::ReviewDocumentResponse::rejection_reason].
    pub fn set_rejection_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rejection_reason = v.into();
        self
    }
}

impl wkt::message::Message for ReviewDocumentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ReviewDocumentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReviewDocumentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __state,
            __rejection_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReviewDocumentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "state" => Ok(__FieldTag::__state),
                            "rejectionReason" => Ok(__FieldTag::__rejection_reason),
                            "rejection_reason" => Ok(__FieldTag::__rejection_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReviewDocumentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReviewDocumentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            result.gcs_destination = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::review_document_response::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rejection_reason => {
                            if !fields.insert(__FieldTag::__rejection_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rejection_reason",
                                ));
                            }
                            result.rejection_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReviewDocumentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcs_destination.is_empty() {
            state.serialize_entry("gcsDestination", &self.gcs_destination)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.rejection_reason.is_empty() {
            state.serialize_entry("rejectionReason", &self.rejection_reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReviewDocumentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReviewDocumentResponse");
        debug_struct.field("gcs_destination", &self.gcs_destination);
        debug_struct.field("state", &self.state);
        debug_struct.field("rejection_reason", &self.rejection_reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReviewDocumentResponse].
pub mod review_document_response {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the review operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// The review operation is rejected by the reviewer.
        Rejected,
        /// The review operation is succeeded.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rejected => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Rejected => std::option::Option::Some("REJECTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rejected,
                2 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "REJECTED" => Self::Rejected,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rejected => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.documentai.v1.ReviewDocumentResponse.State",
            ))
        }
    }
}

/// The long-running operation metadata for the
/// [ReviewDocument][google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.ReviewDocument]: crate::client::DocumentProcessorService::review_document
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReviewDocumentOperationMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    /// The Crowd Compute question ID.
    pub question_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReviewDocumentOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::ReviewDocumentOperationMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::ReviewDocumentOperationMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [question_id][crate::model::ReviewDocumentOperationMetadata::question_id].
    pub fn set_question_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question_id = v.into();
        self
    }
}

impl wkt::message::Message for ReviewDocumentOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ReviewDocumentOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReviewDocumentOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            __question_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReviewDocumentOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            "questionId" => Ok(__FieldTag::__question_id),
                            "question_id" => Ok(__FieldTag::__question_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReviewDocumentOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReviewDocumentOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::__question_id => {
                            if !fields.insert(__FieldTag::__question_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for question_id",
                                ));
                            }
                            result.question_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReviewDocumentOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self.question_id.is_empty() {
            state.serialize_entry("questionId", &self.question_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReviewDocumentOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReviewDocumentOperationMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        debug_struct.field("question_id", &self.question_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Evaluates the given
/// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion] against the
/// supplied documents.
///
/// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluateProcessorVersionRequest {
    /// Required. The resource name of the
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion] to
    /// evaluate.
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`
    ///
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    pub processor_version: std::string::String,

    /// Optional. The documents used in the evaluation. If unspecified, use the
    /// processor's dataset as evaluation input.
    pub evaluation_documents: std::option::Option<crate::model::BatchDocumentsInputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluateProcessorVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [processor_version][crate::model::EvaluateProcessorVersionRequest::processor_version].
    pub fn set_processor_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.processor_version = v.into();
        self
    }

    /// Sets the value of [evaluation_documents][crate::model::EvaluateProcessorVersionRequest::evaluation_documents].
    pub fn set_evaluation_documents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
    {
        self.evaluation_documents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [evaluation_documents][crate::model::EvaluateProcessorVersionRequest::evaluation_documents].
    pub fn set_or_clear_evaluation_documents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BatchDocumentsInputConfig>,
    {
        self.evaluation_documents = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluateProcessorVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.EvaluateProcessorVersionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluateProcessorVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __processor_version,
            __evaluation_documents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluateProcessorVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "processorVersion" => Ok(__FieldTag::__processor_version),
                            "processor_version" => Ok(__FieldTag::__processor_version),
                            "evaluationDocuments" => Ok(__FieldTag::__evaluation_documents),
                            "evaluation_documents" => Ok(__FieldTag::__evaluation_documents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluateProcessorVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluateProcessorVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__processor_version => {
                            if !fields.insert(__FieldTag::__processor_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_version",
                                ));
                            }
                            result.processor_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluation_documents => {
                            if !fields.insert(__FieldTag::__evaluation_documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_documents",
                                ));
                            }
                            result.evaluation_documents = map.next_value::<std::option::Option<crate::model::BatchDocumentsInputConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvaluateProcessorVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.processor_version.is_empty() {
            state.serialize_entry("processorVersion", &self.processor_version)?;
        }
        if self.evaluation_documents.is_some() {
            state.serialize_entry("evaluationDocuments", &self.evaluation_documents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EvaluateProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluateProcessorVersionRequest");
        debug_struct.field("processor_version", &self.processor_version);
        debug_struct.field("evaluation_documents", &self.evaluation_documents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata of the
/// [EvaluateProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.EvaluateProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.EvaluateProcessorVersion]: crate::client::DocumentProcessorService::evaluate_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluateProcessorVersionMetadata {
    /// The basic metadata of the long-running operation.
    pub common_metadata: std::option::Option<crate::model::CommonOperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluateProcessorVersionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_metadata][crate::model::EvaluateProcessorVersionMetadata::common_metadata].
    pub fn set_common_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_metadata][crate::model::EvaluateProcessorVersionMetadata::common_metadata].
    pub fn set_or_clear_common_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommonOperationMetadata>,
    {
        self.common_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluateProcessorVersionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.EvaluateProcessorVersionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluateProcessorVersionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluateProcessorVersionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonMetadata" => Ok(__FieldTag::__common_metadata),
                            "common_metadata" => Ok(__FieldTag::__common_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluateProcessorVersionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluateProcessorVersionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_metadata => {
                            if !fields.insert(__FieldTag::__common_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_metadata",
                                ));
                            }
                            result.common_metadata = map.next_value::<std::option::Option<crate::model::CommonOperationMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvaluateProcessorVersionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.common_metadata.is_some() {
            state.serialize_entry("commonMetadata", &self.common_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EvaluateProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluateProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the
/// [EvaluateProcessorVersion][google.cloud.documentai.v1.DocumentProcessorService.EvaluateProcessorVersion]
/// method.
///
/// [google.cloud.documentai.v1.DocumentProcessorService.EvaluateProcessorVersion]: crate::client::DocumentProcessorService::evaluate_processor_version
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluateProcessorVersionResponse {
    /// The resource name of the created evaluation.
    pub evaluation: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluateProcessorVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluation][crate::model::EvaluateProcessorVersionResponse::evaluation].
    pub fn set_evaluation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.evaluation = v.into();
        self
    }
}

impl wkt::message::Message for EvaluateProcessorVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.EvaluateProcessorVersionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluateProcessorVersionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __evaluation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluateProcessorVersionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "evaluation" => Ok(__FieldTag::__evaluation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluateProcessorVersionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluateProcessorVersionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__evaluation => {
                            if !fields.insert(__FieldTag::__evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation",
                                ));
                            }
                            result.evaluation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvaluateProcessorVersionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.evaluation.is_empty() {
            state.serialize_entry("evaluation", &self.evaluation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EvaluateProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluateProcessorVersionResponse");
        debug_struct.field("evaluation", &self.evaluation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Retrieves a specific Evaluation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEvaluationRequest {
    /// Required. The resource name of the
    /// [Evaluation][google.cloud.documentai.v1.Evaluation] to get.
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}/evaluations/{evaluation}`
    ///
    /// [google.cloud.documentai.v1.Evaluation]: crate::model::Evaluation
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEvaluationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEvaluationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEvaluationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.GetEvaluationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEvaluationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetEvaluationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEvaluationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Retrieves a list of evaluations for a given
/// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion].
///
/// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEvaluationsRequest {
    /// Required. The resource name of the
    /// [ProcessorVersion][google.cloud.documentai.v1.ProcessorVersion] to list
    /// evaluations for.
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`
    ///
    /// [google.cloud.documentai.v1.ProcessorVersion]: crate::model::ProcessorVersion
    pub parent: std::string::String,

    /// The standard list page size.
    /// If unspecified, at most `5` evaluations are returned.
    /// The maximum value is `100`. Values above `100` are coerced to `100`.
    pub page_size: i32,

    /// A page token, received from a previous `ListEvaluations` call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEvaluationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEvaluationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEvaluationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEvaluationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEvaluationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListEvaluationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEvaluationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEvaluationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEvaluationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEvaluationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEvaluationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEvaluationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEvaluationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response from `ListEvaluations`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEvaluationsResponse {
    /// The evaluations requested.
    pub evaluations: std::vec::Vec<crate::model::Evaluation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEvaluationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [evaluations][crate::model::ListEvaluationsResponse::evaluations].
    pub fn set_evaluations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Evaluation>,
    {
        use std::iter::Iterator;
        self.evaluations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEvaluationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEvaluationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ListEvaluationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEvaluationsResponse {
    type PageItem = crate::model::Evaluation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.evaluations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEvaluationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __evaluations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEvaluationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "evaluations" => Ok(__FieldTag::__evaluations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEvaluationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEvaluationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__evaluations => {
                            if !fields.insert(__FieldTag::__evaluations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluations",
                                ));
                            }
                            result.evaluations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Evaluation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEvaluationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.evaluations.is_empty() {
            state.serialize_entry("evaluations", &self.evaluations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEvaluationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEvaluationsResponse");
        debug_struct.field("evaluations", &self.evaluations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The schema defines the output of the processed document by a processor.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DocumentSchema {
    /// Display name to show to users.
    pub display_name: std::string::String,

    /// Description of the schema.
    pub description: std::string::String,

    /// Entity types of the schema.
    pub entity_types: std::vec::Vec<crate::model::document_schema::EntityType>,

    /// Metadata of the schema.
    pub metadata: std::option::Option<crate::model::document_schema::Metadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentSchema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::DocumentSchema::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DocumentSchema::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [entity_types][crate::model::DocumentSchema::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document_schema::EntityType>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::DocumentSchema::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document_schema::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::DocumentSchema::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document_schema::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DocumentSchema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.DocumentSchema"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DocumentSchema {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __description,
            __entity_types,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentSchema")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DocumentSchema;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentSchema")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types",
                                ));
                            }
                            result.entity_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document_schema::EntityType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::document_schema::Metadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DocumentSchema {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DocumentSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DocumentSchema");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("entity_types", &self.entity_types);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DocumentSchema].
pub mod document_schema {
    #[allow(unused_imports)]
    use super::*;

    /// EntityType is the wrapper of a label of the corresponding model with
    /// detailed attributes and limitations for entity-based processors. Multiple
    /// types can also compose a dependency tree to represent nested types.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EntityType {
        /// User defined name for the type.
        pub display_name: std::string::String,

        /// Name of the type. It must be unique within the schema file and
        /// cannot be a "Common Type".  The following naming conventions are used:
        ///
        /// - Use `snake_casing`.
        /// - Name matching is case-sensitive.
        /// - Maximum 64 characters.
        /// - Must start with a letter.
        /// - Allowed characters: ASCII letters `[a-z0-9_-]`.  (For backward
        ///   compatibility internal infrastructure and tooling can handle any ascii
        ///   character.)
        /// - The `/` is sometimes used to denote a property of a type.  For example
        ///   `line_item/amount`.  This convention is deprecated, but will still be
        ///   honored for backward compatibility.
        pub name: std::string::String,

        /// The entity type that this type is derived from.  For now, one and only
        /// one should be set.
        pub base_types: std::vec::Vec<std::string::String>,

        /// Description the nested structure, or composition of an entity.
        pub properties: std::vec::Vec<crate::model::document_schema::entity_type::Property>,

        pub value_source:
            std::option::Option<crate::model::document_schema::entity_type::ValueSource>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EntityType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::document_schema::EntityType::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [name][crate::model::document_schema::EntityType::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [base_types][crate::model::document_schema::EntityType::base_types].
        pub fn set_base_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.base_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [properties][crate::model::document_schema::EntityType::properties].
        pub fn set_properties<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::document_schema::entity_type::Property>,
        {
            use std::iter::Iterator;
            self.properties = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [value_source][crate::model::document_schema::EntityType::value_source].
        ///
        /// Note that all the setters affecting `value_source` are mutually
        /// exclusive.
        pub fn set_value_source<
            T: std::convert::Into<
                    std::option::Option<crate::model::document_schema::entity_type::ValueSource>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_source = v.into();
            self
        }

        /// The value of [value_source][crate::model::document_schema::EntityType::value_source]
        /// if it holds a `EnumValues`, `None` if the field is not set or
        /// holds a different branch.
        pub fn enum_values(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::document_schema::entity_type::EnumValues>,
        > {
            #[allow(unreachable_patterns)]
            self.value_source.as_ref().and_then(|v| match v {
                crate::model::document_schema::entity_type::ValueSource::EnumValues(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value_source][crate::model::document_schema::EntityType::value_source]
        /// to hold a `EnumValues`.
        ///
        /// Note that all the setters affecting `value_source` are
        /// mutually exclusive.
        pub fn set_enum_values<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::document_schema::entity_type::EnumValues>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_source = std::option::Option::Some(
                crate::model::document_schema::entity_type::ValueSource::EnumValues(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for EntityType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.DocumentSchema.EntityType"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EntityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enum_values,
                __display_name,
                __name,
                __base_types,
                __properties,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EntityType")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enumValues" => Ok(__FieldTag::__enum_values),
                                "enum_values" => Ok(__FieldTag::__enum_values),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "name" => Ok(__FieldTag::__name),
                                "baseTypes" => Ok(__FieldTag::__base_types),
                                "base_types" => Ok(__FieldTag::__base_types),
                                "properties" => Ok(__FieldTag::__properties),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EntityType;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EntityType")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enum_values => {
                                if !fields.insert(__FieldTag::__enum_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enum_values",
                                    ));
                                }
                                if result.value_source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value_source`, a oneof with full ID .google.cloud.documentai.v1.DocumentSchema.EntityType.enum_values, latest field was enumValues",
                                    ));
                                }
                                result.value_source = std::option::Option::Some(
                                    crate::model::document_schema::entity_type::ValueSource::EnumValues(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::document_schema::entity_type::EnumValues>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__base_types => {
                                if !fields.insert(__FieldTag::__base_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for base_types",
                                    ));
                                }
                                result.base_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__properties => {
                                if !fields.insert(__FieldTag::__properties) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for properties",
                                    ));
                                }
                                result.properties = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::document_schema::entity_type::Property,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EntityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.enum_values() {
                state.serialize_entry("enumValues", value)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.base_types.is_empty() {
                state.serialize_entry("baseTypes", &self.base_types)?;
            }
            if !self.properties.is_empty() {
                state.serialize_entry("properties", &self.properties)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for EntityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("EntityType");
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("name", &self.name);
            debug_struct.field("base_types", &self.base_types);
            debug_struct.field("properties", &self.properties);
            debug_struct.field("value_source", &self.value_source);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [EntityType].
    pub mod entity_type {
        #[allow(unused_imports)]
        use super::*;

        /// Defines the a list of enum values.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct EnumValues {
            /// The individual values that this enum values type can include.
            pub values: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EnumValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [values][crate::model::document_schema::entity_type::EnumValues::values].
            pub fn set_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for EnumValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.DocumentSchema.EntityType.EnumValues"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for EnumValues {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __values,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for EnumValues")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "values" => Ok(__FieldTag::__values),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = EnumValues;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct EnumValues")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__values => {
                                    if !fields.insert(__FieldTag::__values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for values"),
                                        );
                                    }
                                    result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for EnumValues {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.values.is_empty() {
                    state.serialize_entry("values", &self.values)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for EnumValues {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("EnumValues");
                debug_struct.field("values", &self.values);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines properties that can be part of the entity type.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Property {
            /// The name of the property.  Follows the same guidelines as the
            /// EntityType name.
            pub name: std::string::String,

            /// User defined name for the property.
            pub display_name: std::string::String,

            /// A reference to the value type of the property.  This type is subject
            /// to the same conventions as the `Entity.base_types` field.
            pub value_type: std::string::String,

            /// Occurrence type limits the number of instances an entity type appears
            /// in the document.
            pub occurrence_type:
                crate::model::document_schema::entity_type::property::OccurrenceType,

            /// Specifies how the entity's value is obtained.
            pub method: crate::model::document_schema::entity_type::property::Method,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Property {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::document_schema::entity_type::Property::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [display_name][crate::model::document_schema::entity_type::Property::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [value_type][crate::model::document_schema::entity_type::Property::value_type].
            pub fn set_value_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.value_type = v.into();
                self
            }

            /// Sets the value of [occurrence_type][crate::model::document_schema::entity_type::Property::occurrence_type].
            pub fn set_occurrence_type<
                T: std::convert::Into<
                        crate::model::document_schema::entity_type::property::OccurrenceType,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.occurrence_type = v.into();
                self
            }

            /// Sets the value of [method][crate::model::document_schema::entity_type::Property::method].
            pub fn set_method<
                T: std::convert::Into<crate::model::document_schema::entity_type::property::Method>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.method = v.into();
                self
            }
        }

        impl wkt::message::Message for Property {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.DocumentSchema.EntityType.Property"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Property {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __name,
                    __display_name,
                    __value_type,
                    __occurrence_type,
                    __method,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Property")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "name" => Ok(__FieldTag::__name),
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "valueType" => Ok(__FieldTag::__value_type),
                                    "value_type" => Ok(__FieldTag::__value_type),
                                    "occurrenceType" => Ok(__FieldTag::__occurrence_type),
                                    "occurrence_type" => Ok(__FieldTag::__occurrence_type),
                                    "method" => Ok(__FieldTag::__method),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Property;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Property")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__value_type => {
                                    if !fields.insert(__FieldTag::__value_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for value_type",
                                            ),
                                        );
                                    }
                                    result.value_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__occurrence_type => {
                                    if !fields.insert(__FieldTag::__occurrence_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for occurrence_type",
                                            ),
                                        );
                                    }
                                    result.occurrence_type = map.next_value::<std::option::Option<crate::model::document_schema::entity_type::property::OccurrenceType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__method => {
                                    if !fields.insert(__FieldTag::__method) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for method"),
                                        );
                                    }
                                    result.method = map.next_value::<std::option::Option<crate::model::document_schema::entity_type::property::Method>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Property {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.value_type.is_empty() {
                    state.serialize_entry("valueType", &self.value_type)?;
                }
                if !wkt::internal::is_default(&self.occurrence_type) {
                    state.serialize_entry("occurrenceType", &self.occurrence_type)?;
                }
                if !wkt::internal::is_default(&self.method) {
                    state.serialize_entry("method", &self.method)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Property {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Property");
                debug_struct.field("name", &self.name);
                debug_struct.field("display_name", &self.display_name);
                debug_struct.field("value_type", &self.value_type);
                debug_struct.field("occurrence_type", &self.occurrence_type);
                debug_struct.field("method", &self.method);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Property].
        pub mod property {
            #[allow(unused_imports)]
            use super::*;

            /// Types of occurrences of the entity type in the document.  This
            /// represents the number of instances, not mentions, of an entity.
            /// For example, a bank statement might only have one
            /// `account_number`, but this account number can be mentioned in several
            /// places on the document.  In this case, the `account_number` is
            /// considered a `REQUIRED_ONCE` entity type. If, on the other hand, we
            /// expect a bank statement to contain the status of multiple different
            /// accounts for the customers, the occurrence type is set to
            /// `REQUIRED_MULTIPLE`.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum OccurrenceType {
                /// Unspecified occurrence type.
                Unspecified,
                /// There will be zero or one instance of this entity type.  The same
                /// entity instance may be mentioned multiple times.
                OptionalOnce,
                /// The entity type will appear zero or multiple times.
                OptionalMultiple,
                /// The entity type will only appear exactly once.  The same
                /// entity instance may be mentioned multiple times.
                RequiredOnce,
                /// The entity type will appear once or more times.
                RequiredMultiple,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [OccurrenceType::value] or
                /// [OccurrenceType::name].
                UnknownValue(occurrence_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod occurrence_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl OccurrenceType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::OptionalOnce => std::option::Option::Some(1),
                        Self::OptionalMultiple => std::option::Option::Some(2),
                        Self::RequiredOnce => std::option::Option::Some(3),
                        Self::RequiredMultiple => std::option::Option::Some(4),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("OCCURRENCE_TYPE_UNSPECIFIED")
                        }
                        Self::OptionalOnce => std::option::Option::Some("OPTIONAL_ONCE"),
                        Self::OptionalMultiple => std::option::Option::Some("OPTIONAL_MULTIPLE"),
                        Self::RequiredOnce => std::option::Option::Some("REQUIRED_ONCE"),
                        Self::RequiredMultiple => std::option::Option::Some("REQUIRED_MULTIPLE"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for OccurrenceType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for OccurrenceType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for OccurrenceType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::OptionalOnce,
                        2 => Self::OptionalMultiple,
                        3 => Self::RequiredOnce,
                        4 => Self::RequiredMultiple,
                        _ => Self::UnknownValue(occurrence_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for OccurrenceType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "OCCURRENCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "OPTIONAL_ONCE" => Self::OptionalOnce,
                        "OPTIONAL_MULTIPLE" => Self::OptionalMultiple,
                        "REQUIRED_ONCE" => Self::RequiredOnce,
                        "REQUIRED_MULTIPLE" => Self::RequiredMultiple,
                        _ => Self::UnknownValue(occurrence_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for OccurrenceType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::OptionalOnce => serializer.serialize_i32(1),
                        Self::OptionalMultiple => serializer.serialize_i32(2),
                        Self::RequiredOnce => serializer.serialize_i32(3),
                        Self::RequiredMultiple => serializer.serialize_i32(4),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for OccurrenceType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<OccurrenceType>::new(
                        ".google.cloud.documentai.v1.DocumentSchema.EntityType.Property.OccurrenceType"))
                }
            }

            /// Specifies how the entity's value is obtained from the document.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Method {
                /// Unspecified method. It defaults to `EXTRACT`.
                Unspecified,
                /// The entity's value is directly extracted as-is from the document
                /// text.
                Extract,
                /// The entity's value is derived through inference and is not
                /// necessarily an exact text extraction from the document.
                Derive,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Method::value] or
                /// [Method::name].
                UnknownValue(method::UnknownValue),
            }

            #[doc(hidden)]
            pub mod method {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Method {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Extract => std::option::Option::Some(1),
                        Self::Derive => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("METHOD_UNSPECIFIED"),
                        Self::Extract => std::option::Option::Some("EXTRACT"),
                        Self::Derive => std::option::Option::Some("DERIVE"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Method {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Method {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Method {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Extract,
                        2 => Self::Derive,
                        _ => Self::UnknownValue(method::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Method {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "METHOD_UNSPECIFIED" => Self::Unspecified,
                        "EXTRACT" => Self::Extract,
                        "DERIVE" => Self::Derive,
                        _ => Self::UnknownValue(method::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Method {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Extract => serializer.serialize_i32(1),
                        Self::Derive => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Method {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Method>::new(
                        ".google.cloud.documentai.v1.DocumentSchema.EntityType.Property.Method",
                    ))
                }
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ValueSource {
            /// If specified, lists all the possible values for this entity.  This
            /// should not be more than a handful of values.  If the number of values
            /// is >10 or could change frequently use the `EntityType.value_ontology`
            /// field and specify a list of all possible values in a value ontology
            /// file.
            EnumValues(std::boxed::Box<crate::model::document_schema::entity_type::EnumValues>),
        }
    }

    /// Metadata for global schema behavior.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Metadata {
        /// If true, a `document` entity type can be applied to subdocument
        /// (splitting). Otherwise, it can only be applied to the entire document
        /// (classification).
        pub document_splitter: bool,

        /// If true, on a given page, there can be multiple `document` annotations
        /// covering it.
        pub document_allow_multiple_labels: bool,

        /// If set, all the nested entities must be prefixed with the parents.
        pub prefixed_naming_on_properties: bool,

        /// If set, we will skip the naming format validation in the schema. So the
        /// string values in `DocumentSchema.EntityType.name` and
        /// `DocumentSchema.EntityType.Property.name` will not be checked.
        pub skip_naming_validation: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [document_splitter][crate::model::document_schema::Metadata::document_splitter].
        pub fn set_document_splitter<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.document_splitter = v.into();
            self
        }

        /// Sets the value of [document_allow_multiple_labels][crate::model::document_schema::Metadata::document_allow_multiple_labels].
        pub fn set_document_allow_multiple_labels<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.document_allow_multiple_labels = v.into();
            self
        }

        /// Sets the value of [prefixed_naming_on_properties][crate::model::document_schema::Metadata::prefixed_naming_on_properties].
        pub fn set_prefixed_naming_on_properties<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.prefixed_naming_on_properties = v.into();
            self
        }

        /// Sets the value of [skip_naming_validation][crate::model::document_schema::Metadata::skip_naming_validation].
        pub fn set_skip_naming_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.skip_naming_validation = v.into();
            self
        }
    }

    impl wkt::message::Message for Metadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.DocumentSchema.Metadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Metadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __document_splitter,
                __document_allow_multiple_labels,
                __prefixed_naming_on_properties,
                __skip_naming_validation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Metadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "documentSplitter" => Ok(__FieldTag::__document_splitter),
                                "document_splitter" => Ok(__FieldTag::__document_splitter),
                                "documentAllowMultipleLabels" => {
                                    Ok(__FieldTag::__document_allow_multiple_labels)
                                }
                                "document_allow_multiple_labels" => {
                                    Ok(__FieldTag::__document_allow_multiple_labels)
                                }
                                "prefixedNamingOnProperties" => {
                                    Ok(__FieldTag::__prefixed_naming_on_properties)
                                }
                                "prefixed_naming_on_properties" => {
                                    Ok(__FieldTag::__prefixed_naming_on_properties)
                                }
                                "skipNamingValidation" => Ok(__FieldTag::__skip_naming_validation),
                                "skip_naming_validation" => {
                                    Ok(__FieldTag::__skip_naming_validation)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Metadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Metadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__document_splitter => {
                                if !fields.insert(__FieldTag::__document_splitter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_splitter",
                                    ));
                                }
                                result.document_splitter = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__document_allow_multiple_labels => {
                                if !fields.insert(__FieldTag::__document_allow_multiple_labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_allow_multiple_labels",
                                    ));
                                }
                                result.document_allow_multiple_labels = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__prefixed_naming_on_properties => {
                                if !fields.insert(__FieldTag::__prefixed_naming_on_properties) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for prefixed_naming_on_properties",
                                    ));
                                }
                                result.prefixed_naming_on_properties = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__skip_naming_validation => {
                                if !fields.insert(__FieldTag::__skip_naming_validation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for skip_naming_validation",
                                    ));
                                }
                                result.skip_naming_validation = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Metadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.document_splitter) {
                state.serialize_entry("documentSplitter", &self.document_splitter)?;
            }
            if !wkt::internal::is_default(&self.document_allow_multiple_labels) {
                state.serialize_entry(
                    "documentAllowMultipleLabels",
                    &self.document_allow_multiple_labels,
                )?;
            }
            if !wkt::internal::is_default(&self.prefixed_naming_on_properties) {
                state.serialize_entry(
                    "prefixedNamingOnProperties",
                    &self.prefixed_naming_on_properties,
                )?;
            }
            if !wkt::internal::is_default(&self.skip_naming_validation) {
                state.serialize_entry("skipNamingValidation", &self.skip_naming_validation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Metadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Metadata");
            debug_struct.field("document_splitter", &self.document_splitter);
            debug_struct.field(
                "document_allow_multiple_labels",
                &self.document_allow_multiple_labels,
            );
            debug_struct.field(
                "prefixed_naming_on_properties",
                &self.prefixed_naming_on_properties,
            );
            debug_struct.field("skip_naming_validation", &self.skip_naming_validation);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Gives a short summary of an evaluation, and links to the evaluation itself.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluationReference {
    /// The resource name of the Long Running Operation for the evaluation.
    pub operation: std::string::String,

    /// The resource name of the evaluation.
    pub evaluation: std::string::String,

    /// An aggregate of the statistics for the evaluation with fuzzy matching on.
    pub aggregate_metrics: std::option::Option<crate::model::evaluation::Metrics>,

    /// An aggregate of the statistics for the evaluation with fuzzy matching off.
    pub aggregate_metrics_exact: std::option::Option<crate::model::evaluation::Metrics>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvaluationReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation][crate::model::EvaluationReference::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [evaluation][crate::model::EvaluationReference::evaluation].
    pub fn set_evaluation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.evaluation = v.into();
        self
    }

    /// Sets the value of [aggregate_metrics][crate::model::EvaluationReference::aggregate_metrics].
    pub fn set_aggregate_metrics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::Metrics>,
    {
        self.aggregate_metrics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregate_metrics][crate::model::EvaluationReference::aggregate_metrics].
    pub fn set_or_clear_aggregate_metrics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::Metrics>,
    {
        self.aggregate_metrics = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aggregate_metrics_exact][crate::model::EvaluationReference::aggregate_metrics_exact].
    pub fn set_aggregate_metrics_exact<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::Metrics>,
    {
        self.aggregate_metrics_exact = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregate_metrics_exact][crate::model::EvaluationReference::aggregate_metrics_exact].
    pub fn set_or_clear_aggregate_metrics_exact<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::Metrics>,
    {
        self.aggregate_metrics_exact = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EvaluationReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.EvaluationReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluationReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation,
            __evaluation,
            __aggregate_metrics,
            __aggregate_metrics_exact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluationReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operation" => Ok(__FieldTag::__operation),
                            "evaluation" => Ok(__FieldTag::__evaluation),
                            "aggregateMetrics" => Ok(__FieldTag::__aggregate_metrics),
                            "aggregate_metrics" => Ok(__FieldTag::__aggregate_metrics),
                            "aggregateMetricsExact" => Ok(__FieldTag::__aggregate_metrics_exact),
                            "aggregate_metrics_exact" => Ok(__FieldTag::__aggregate_metrics_exact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluationReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluationReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluation => {
                            if !fields.insert(__FieldTag::__evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation",
                                ));
                            }
                            result.evaluation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aggregate_metrics => {
                            if !fields.insert(__FieldTag::__aggregate_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregate_metrics",
                                ));
                            }
                            result.aggregate_metrics = map.next_value::<std::option::Option<crate::model::evaluation::Metrics>>()?
                                ;
                        }
                        __FieldTag::__aggregate_metrics_exact => {
                            if !fields.insert(__FieldTag::__aggregate_metrics_exact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregate_metrics_exact",
                                ));
                            }
                            result.aggregate_metrics_exact = map.next_value::<std::option::Option<crate::model::evaluation::Metrics>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvaluationReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self.evaluation.is_empty() {
            state.serialize_entry("evaluation", &self.evaluation)?;
        }
        if self.aggregate_metrics.is_some() {
            state.serialize_entry("aggregateMetrics", &self.aggregate_metrics)?;
        }
        if self.aggregate_metrics_exact.is_some() {
            state.serialize_entry("aggregateMetricsExact", &self.aggregate_metrics_exact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EvaluationReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluationReference");
        debug_struct.field("operation", &self.operation);
        debug_struct.field("evaluation", &self.evaluation);
        debug_struct.field("aggregate_metrics", &self.aggregate_metrics);
        debug_struct.field("aggregate_metrics_exact", &self.aggregate_metrics_exact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An evaluation of a ProcessorVersion's performance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Evaluation {
    /// The resource name of the evaluation.
    /// Format:
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processor_version}/evaluations/{evaluation}`
    pub name: std::string::String,

    /// The time that the evaluation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Counters for the documents used in the evaluation.
    pub document_counters: std::option::Option<crate::model::evaluation::Counters>,

    /// Metrics for all the entities in aggregate.
    pub all_entities_metrics: std::option::Option<crate::model::evaluation::MultiConfidenceMetrics>,

    /// Metrics across confidence levels, for different entities.
    pub entity_metrics: std::collections::HashMap<
        std::string::String,
        crate::model::evaluation::MultiConfidenceMetrics,
    >,

    /// The KMS key name used for encryption.
    pub kms_key_name: std::string::String,

    /// The KMS key version with which data is encrypted.
    pub kms_key_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Evaluation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Evaluation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Evaluation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Evaluation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_counters][crate::model::Evaluation::document_counters].
    pub fn set_document_counters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::Counters>,
    {
        self.document_counters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_counters][crate::model::Evaluation::document_counters].
    pub fn set_or_clear_document_counters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::Counters>,
    {
        self.document_counters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [all_entities_metrics][crate::model::Evaluation::all_entities_metrics].
    pub fn set_all_entities_metrics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::MultiConfidenceMetrics>,
    {
        self.all_entities_metrics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_entities_metrics][crate::model::Evaluation::all_entities_metrics].
    pub fn set_or_clear_all_entities_metrics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::evaluation::MultiConfidenceMetrics>,
    {
        self.all_entities_metrics = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entity_metrics][crate::model::Evaluation::entity_metrics].
    pub fn set_entity_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::evaluation::MultiConfidenceMetrics>,
    {
        use std::iter::Iterator;
        self.entity_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Evaluation::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::Evaluation::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }
}

impl wkt::message::Message for Evaluation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.Evaluation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Evaluation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __document_counters,
            __all_entities_metrics,
            __entity_metrics,
            __kms_key_name,
            __kms_key_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Evaluation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "documentCounters" => Ok(__FieldTag::__document_counters),
                            "document_counters" => Ok(__FieldTag::__document_counters),
                            "allEntitiesMetrics" => Ok(__FieldTag::__all_entities_metrics),
                            "all_entities_metrics" => Ok(__FieldTag::__all_entities_metrics),
                            "entityMetrics" => Ok(__FieldTag::__entity_metrics),
                            "entity_metrics" => Ok(__FieldTag::__entity_metrics),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Evaluation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Evaluation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__document_counters => {
                            if !fields.insert(__FieldTag::__document_counters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_counters",
                                ));
                            }
                            result.document_counters = map.next_value::<std::option::Option<crate::model::evaluation::Counters>>()?
                                ;
                        }
                        __FieldTag::__all_entities_metrics => {
                            if !fields.insert(__FieldTag::__all_entities_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_entities_metrics",
                                ));
                            }
                            result.all_entities_metrics = map.next_value::<std::option::Option<
                                crate::model::evaluation::MultiConfidenceMetrics,
                            >>()?;
                        }
                        __FieldTag::__entity_metrics => {
                            if !fields.insert(__FieldTag::__entity_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_metrics",
                                ));
                            }
                            result.entity_metrics = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::evaluation::MultiConfidenceMetrics,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Evaluation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.document_counters.is_some() {
            state.serialize_entry("documentCounters", &self.document_counters)?;
        }
        if self.all_entities_metrics.is_some() {
            state.serialize_entry("allEntitiesMetrics", &self.all_entities_metrics)?;
        }
        if !self.entity_metrics.is_empty() {
            state.serialize_entry("entityMetrics", &self.entity_metrics)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Evaluation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Evaluation");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("document_counters", &self.document_counters);
        debug_struct.field("all_entities_metrics", &self.all_entities_metrics);
        debug_struct.field("entity_metrics", &self.entity_metrics);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Evaluation].
pub mod evaluation {
    #[allow(unused_imports)]
    use super::*;

    /// Evaluation counters for the documents that were used.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Counters {
        /// How many documents were sent for evaluation.
        pub input_documents_count: i32,

        /// How many documents were not included in the evaluation as they didn't
        /// pass validation.
        pub invalid_documents_count: i32,

        /// How many documents were not included in the evaluation as Document AI
        /// failed to process them.
        pub failed_documents_count: i32,

        /// How many documents were used in the evaluation.
        pub evaluated_documents_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Counters {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_documents_count][crate::model::evaluation::Counters::input_documents_count].
        pub fn set_input_documents_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.input_documents_count = v.into();
            self
        }

        /// Sets the value of [invalid_documents_count][crate::model::evaluation::Counters::invalid_documents_count].
        pub fn set_invalid_documents_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.invalid_documents_count = v.into();
            self
        }

        /// Sets the value of [failed_documents_count][crate::model::evaluation::Counters::failed_documents_count].
        pub fn set_failed_documents_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.failed_documents_count = v.into();
            self
        }

        /// Sets the value of [evaluated_documents_count][crate::model::evaluation::Counters::evaluated_documents_count].
        pub fn set_evaluated_documents_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.evaluated_documents_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Counters {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Evaluation.Counters"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Counters {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __input_documents_count,
                __invalid_documents_count,
                __failed_documents_count,
                __evaluated_documents_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Counters")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inputDocumentsCount" => Ok(__FieldTag::__input_documents_count),
                                "input_documents_count" => Ok(__FieldTag::__input_documents_count),
                                "invalidDocumentsCount" => {
                                    Ok(__FieldTag::__invalid_documents_count)
                                }
                                "invalid_documents_count" => {
                                    Ok(__FieldTag::__invalid_documents_count)
                                }
                                "failedDocumentsCount" => Ok(__FieldTag::__failed_documents_count),
                                "failed_documents_count" => {
                                    Ok(__FieldTag::__failed_documents_count)
                                }
                                "evaluatedDocumentsCount" => {
                                    Ok(__FieldTag::__evaluated_documents_count)
                                }
                                "evaluated_documents_count" => {
                                    Ok(__FieldTag::__evaluated_documents_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Counters;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Counters")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__input_documents_count => {
                                if !fields.insert(__FieldTag::__input_documents_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_documents_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.input_documents_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__invalid_documents_count => {
                                if !fields.insert(__FieldTag::__invalid_documents_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for invalid_documents_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.invalid_documents_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__failed_documents_count => {
                                if !fields.insert(__FieldTag::__failed_documents_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for failed_documents_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.failed_documents_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__evaluated_documents_count => {
                                if !fields.insert(__FieldTag::__evaluated_documents_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for evaluated_documents_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.evaluated_documents_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Counters {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.input_documents_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("inputDocumentsCount", &__With(&self.input_documents_count))?;
            }
            if !wkt::internal::is_default(&self.invalid_documents_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "invalidDocumentsCount",
                    &__With(&self.invalid_documents_count),
                )?;
            }
            if !wkt::internal::is_default(&self.failed_documents_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "failedDocumentsCount",
                    &__With(&self.failed_documents_count),
                )?;
            }
            if !wkt::internal::is_default(&self.evaluated_documents_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "evaluatedDocumentsCount",
                    &__With(&self.evaluated_documents_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Counters {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Counters");
            debug_struct.field("input_documents_count", &self.input_documents_count);
            debug_struct.field("invalid_documents_count", &self.invalid_documents_count);
            debug_struct.field("failed_documents_count", &self.failed_documents_count);
            debug_struct.field("evaluated_documents_count", &self.evaluated_documents_count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Evaluation metrics, either in aggregate or about a specific entity.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Metrics {
        /// The calculated precision.
        pub precision: f32,

        /// The calculated recall.
        pub recall: f32,

        /// The calculated f1 score.
        pub f1_score: f32,

        /// The amount of occurrences in predicted documents.
        pub predicted_occurrences_count: i32,

        /// The amount of occurrences in ground truth documents.
        pub ground_truth_occurrences_count: i32,

        /// The amount of documents with a predicted occurrence.
        pub predicted_document_count: i32,

        /// The amount of documents with a ground truth occurrence.
        pub ground_truth_document_count: i32,

        /// The amount of true positives.
        pub true_positives_count: i32,

        /// The amount of false positives.
        pub false_positives_count: i32,

        /// The amount of false negatives.
        pub false_negatives_count: i32,

        /// The amount of documents that had an occurrence of this label.
        pub total_documents_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [precision][crate::model::evaluation::Metrics::precision].
        pub fn set_precision<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.precision = v.into();
            self
        }

        /// Sets the value of [recall][crate::model::evaluation::Metrics::recall].
        pub fn set_recall<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.recall = v.into();
            self
        }

        /// Sets the value of [f1_score][crate::model::evaluation::Metrics::f1_score].
        pub fn set_f1_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.f1_score = v.into();
            self
        }

        /// Sets the value of [predicted_occurrences_count][crate::model::evaluation::Metrics::predicted_occurrences_count].
        pub fn set_predicted_occurrences_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.predicted_occurrences_count = v.into();
            self
        }

        /// Sets the value of [ground_truth_occurrences_count][crate::model::evaluation::Metrics::ground_truth_occurrences_count].
        pub fn set_ground_truth_occurrences_count<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.ground_truth_occurrences_count = v.into();
            self
        }

        /// Sets the value of [predicted_document_count][crate::model::evaluation::Metrics::predicted_document_count].
        pub fn set_predicted_document_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.predicted_document_count = v.into();
            self
        }

        /// Sets the value of [ground_truth_document_count][crate::model::evaluation::Metrics::ground_truth_document_count].
        pub fn set_ground_truth_document_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.ground_truth_document_count = v.into();
            self
        }

        /// Sets the value of [true_positives_count][crate::model::evaluation::Metrics::true_positives_count].
        pub fn set_true_positives_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.true_positives_count = v.into();
            self
        }

        /// Sets the value of [false_positives_count][crate::model::evaluation::Metrics::false_positives_count].
        pub fn set_false_positives_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.false_positives_count = v.into();
            self
        }

        /// Sets the value of [false_negatives_count][crate::model::evaluation::Metrics::false_negatives_count].
        pub fn set_false_negatives_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.false_negatives_count = v.into();
            self
        }

        /// Sets the value of [total_documents_count][crate::model::evaluation::Metrics::total_documents_count].
        pub fn set_total_documents_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_documents_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Metrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Evaluation.Metrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Metrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __precision,
                __recall,
                __f1_score,
                __predicted_occurrences_count,
                __ground_truth_occurrences_count,
                __predicted_document_count,
                __ground_truth_document_count,
                __true_positives_count,
                __false_positives_count,
                __false_negatives_count,
                __total_documents_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Metrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "precision" => Ok(__FieldTag::__precision),
                                "recall" => Ok(__FieldTag::__recall),
                                "f1Score" => Ok(__FieldTag::__f1_score),
                                "f1_score" => Ok(__FieldTag::__f1_score),
                                "predictedOccurrencesCount" => {
                                    Ok(__FieldTag::__predicted_occurrences_count)
                                }
                                "predicted_occurrences_count" => {
                                    Ok(__FieldTag::__predicted_occurrences_count)
                                }
                                "groundTruthOccurrencesCount" => {
                                    Ok(__FieldTag::__ground_truth_occurrences_count)
                                }
                                "ground_truth_occurrences_count" => {
                                    Ok(__FieldTag::__ground_truth_occurrences_count)
                                }
                                "predictedDocumentCount" => {
                                    Ok(__FieldTag::__predicted_document_count)
                                }
                                "predicted_document_count" => {
                                    Ok(__FieldTag::__predicted_document_count)
                                }
                                "groundTruthDocumentCount" => {
                                    Ok(__FieldTag::__ground_truth_document_count)
                                }
                                "ground_truth_document_count" => {
                                    Ok(__FieldTag::__ground_truth_document_count)
                                }
                                "truePositivesCount" => Ok(__FieldTag::__true_positives_count),
                                "true_positives_count" => Ok(__FieldTag::__true_positives_count),
                                "falsePositivesCount" => Ok(__FieldTag::__false_positives_count),
                                "false_positives_count" => Ok(__FieldTag::__false_positives_count),
                                "falseNegativesCount" => Ok(__FieldTag::__false_negatives_count),
                                "false_negatives_count" => Ok(__FieldTag::__false_negatives_count),
                                "totalDocumentsCount" => Ok(__FieldTag::__total_documents_count),
                                "total_documents_count" => Ok(__FieldTag::__total_documents_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Metrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Metrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__precision => {
                                if !fields.insert(__FieldTag::__precision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for precision",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.precision =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__recall => {
                                if !fields.insert(__FieldTag::__recall) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recall",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.recall = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__f1_score => {
                                if !fields.insert(__FieldTag::__f1_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for f1_score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.f1_score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__predicted_occurrences_count => {
                                if !fields.insert(__FieldTag::__predicted_occurrences_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for predicted_occurrences_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.predicted_occurrences_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__ground_truth_occurrences_count => {
                                if !fields.insert(__FieldTag::__ground_truth_occurrences_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ground_truth_occurrences_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.ground_truth_occurrences_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__predicted_document_count => {
                                if !fields.insert(__FieldTag::__predicted_document_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for predicted_document_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.predicted_document_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__ground_truth_document_count => {
                                if !fields.insert(__FieldTag::__ground_truth_document_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ground_truth_document_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.ground_truth_document_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__true_positives_count => {
                                if !fields.insert(__FieldTag::__true_positives_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for true_positives_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.true_positives_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__false_positives_count => {
                                if !fields.insert(__FieldTag::__false_positives_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for false_positives_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.false_positives_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__false_negatives_count => {
                                if !fields.insert(__FieldTag::__false_negatives_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for false_negatives_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.false_negatives_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_documents_count => {
                                if !fields.insert(__FieldTag::__total_documents_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_documents_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_documents_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Metrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.precision) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("precision", &__With(&self.precision))?;
            }
            if !wkt::internal::is_default(&self.recall) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("recall", &__With(&self.recall))?;
            }
            if !wkt::internal::is_default(&self.f1_score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("f1Score", &__With(&self.f1_score))?;
            }
            if !wkt::internal::is_default(&self.predicted_occurrences_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "predictedOccurrencesCount",
                    &__With(&self.predicted_occurrences_count),
                )?;
            }
            if !wkt::internal::is_default(&self.ground_truth_occurrences_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "groundTruthOccurrencesCount",
                    &__With(&self.ground_truth_occurrences_count),
                )?;
            }
            if !wkt::internal::is_default(&self.predicted_document_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "predictedDocumentCount",
                    &__With(&self.predicted_document_count),
                )?;
            }
            if !wkt::internal::is_default(&self.ground_truth_document_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "groundTruthDocumentCount",
                    &__With(&self.ground_truth_document_count),
                )?;
            }
            if !wkt::internal::is_default(&self.true_positives_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("truePositivesCount", &__With(&self.true_positives_count))?;
            }
            if !wkt::internal::is_default(&self.false_positives_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("falsePositivesCount", &__With(&self.false_positives_count))?;
            }
            if !wkt::internal::is_default(&self.false_negatives_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("falseNegativesCount", &__With(&self.false_negatives_count))?;
            }
            if !wkt::internal::is_default(&self.total_documents_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("totalDocumentsCount", &__With(&self.total_documents_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Metrics {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Metrics");
            debug_struct.field("precision", &self.precision);
            debug_struct.field("recall", &self.recall);
            debug_struct.field("f1_score", &self.f1_score);
            debug_struct.field(
                "predicted_occurrences_count",
                &self.predicted_occurrences_count,
            );
            debug_struct.field(
                "ground_truth_occurrences_count",
                &self.ground_truth_occurrences_count,
            );
            debug_struct.field("predicted_document_count", &self.predicted_document_count);
            debug_struct.field(
                "ground_truth_document_count",
                &self.ground_truth_document_count,
            );
            debug_struct.field("true_positives_count", &self.true_positives_count);
            debug_struct.field("false_positives_count", &self.false_positives_count);
            debug_struct.field("false_negatives_count", &self.false_negatives_count);
            debug_struct.field("total_documents_count", &self.total_documents_count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Evaluations metrics, at a specific confidence level.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConfidenceLevelMetrics {
        /// The confidence level.
        pub confidence_level: f32,

        /// The metrics at the specific confidence level.
        pub metrics: std::option::Option<crate::model::evaluation::Metrics>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConfidenceLevelMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [confidence_level][crate::model::evaluation::ConfidenceLevelMetrics::confidence_level].
        pub fn set_confidence_level<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.confidence_level = v.into();
            self
        }

        /// Sets the value of [metrics][crate::model::evaluation::ConfidenceLevelMetrics::metrics].
        pub fn set_metrics<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::evaluation::Metrics>,
        {
            self.metrics = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metrics][crate::model::evaluation::ConfidenceLevelMetrics::metrics].
        pub fn set_or_clear_metrics<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::evaluation::Metrics>,
        {
            self.metrics = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ConfidenceLevelMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Evaluation.ConfidenceLevelMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConfidenceLevelMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __confidence_level,
                __metrics,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConfidenceLevelMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                                "confidence_level" => Ok(__FieldTag::__confidence_level),
                                "metrics" => Ok(__FieldTag::__metrics),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConfidenceLevelMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConfidenceLevelMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__confidence_level => {
                                if !fields.insert(__FieldTag::__confidence_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence_level",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.confidence_level =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__metrics => {
                                if !fields.insert(__FieldTag::__metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metrics",
                                    ));
                                }
                                result.metrics = map.next_value::<std::option::Option<crate::model::evaluation::Metrics>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConfidenceLevelMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.confidence_level) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("confidenceLevel", &__With(&self.confidence_level))?;
            }
            if self.metrics.is_some() {
                state.serialize_entry("metrics", &self.metrics)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConfidenceLevelMetrics {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConfidenceLevelMetrics");
            debug_struct.field("confidence_level", &self.confidence_level);
            debug_struct.field("metrics", &self.metrics);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metrics across multiple confidence levels.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiConfidenceMetrics {
        /// Metrics across confidence levels with fuzzy matching enabled.
        pub confidence_level_metrics:
            std::vec::Vec<crate::model::evaluation::ConfidenceLevelMetrics>,

        /// Metrics across confidence levels with only exact matching.
        pub confidence_level_metrics_exact:
            std::vec::Vec<crate::model::evaluation::ConfidenceLevelMetrics>,

        /// The calculated area under the precision recall curve (AUPRC), computed by
        /// integrating over all confidence thresholds.
        pub auprc: f32,

        /// The Estimated Calibration Error (ECE) of the confidence of the predicted
        /// entities.
        pub estimated_calibration_error: f32,

        /// The AUPRC for metrics with fuzzy matching disabled, i.e., exact matching
        /// only.
        pub auprc_exact: f32,

        /// The ECE for the predicted entities with fuzzy matching disabled, i.e.,
        /// exact matching only.
        pub estimated_calibration_error_exact: f32,

        /// The metrics type for the label.
        pub metrics_type: crate::model::evaluation::multi_confidence_metrics::MetricsType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiConfidenceMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [confidence_level_metrics][crate::model::evaluation::MultiConfidenceMetrics::confidence_level_metrics].
        pub fn set_confidence_level_metrics<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::evaluation::ConfidenceLevelMetrics>,
        {
            use std::iter::Iterator;
            self.confidence_level_metrics = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [confidence_level_metrics_exact][crate::model::evaluation::MultiConfidenceMetrics::confidence_level_metrics_exact].
        pub fn set_confidence_level_metrics_exact<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::evaluation::ConfidenceLevelMetrics>,
        {
            use std::iter::Iterator;
            self.confidence_level_metrics_exact = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [auprc][crate::model::evaluation::MultiConfidenceMetrics::auprc].
        pub fn set_auprc<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.auprc = v.into();
            self
        }

        /// Sets the value of [estimated_calibration_error][crate::model::evaluation::MultiConfidenceMetrics::estimated_calibration_error].
        pub fn set_estimated_calibration_error<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.estimated_calibration_error = v.into();
            self
        }

        /// Sets the value of [auprc_exact][crate::model::evaluation::MultiConfidenceMetrics::auprc_exact].
        pub fn set_auprc_exact<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.auprc_exact = v.into();
            self
        }

        /// Sets the value of [estimated_calibration_error_exact][crate::model::evaluation::MultiConfidenceMetrics::estimated_calibration_error_exact].
        pub fn set_estimated_calibration_error_exact<T: std::convert::Into<f32>>(
            mut self,
            v: T,
        ) -> Self {
            self.estimated_calibration_error_exact = v.into();
            self
        }

        /// Sets the value of [metrics_type][crate::model::evaluation::MultiConfidenceMetrics::metrics_type].
        pub fn set_metrics_type<
            T: std::convert::Into<crate::model::evaluation::multi_confidence_metrics::MetricsType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metrics_type = v.into();
            self
        }
    }

    impl wkt::message::Message for MultiConfidenceMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.Evaluation.MultiConfidenceMetrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiConfidenceMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __confidence_level_metrics,
                __confidence_level_metrics_exact,
                __auprc,
                __estimated_calibration_error,
                __auprc_exact,
                __estimated_calibration_error_exact,
                __metrics_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiConfidenceMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "confidenceLevelMetrics" => {
                                    Ok(__FieldTag::__confidence_level_metrics)
                                }
                                "confidence_level_metrics" => {
                                    Ok(__FieldTag::__confidence_level_metrics)
                                }
                                "confidenceLevelMetricsExact" => {
                                    Ok(__FieldTag::__confidence_level_metrics_exact)
                                }
                                "confidence_level_metrics_exact" => {
                                    Ok(__FieldTag::__confidence_level_metrics_exact)
                                }
                                "auprc" => Ok(__FieldTag::__auprc),
                                "estimatedCalibrationError" => {
                                    Ok(__FieldTag::__estimated_calibration_error)
                                }
                                "estimated_calibration_error" => {
                                    Ok(__FieldTag::__estimated_calibration_error)
                                }
                                "auprcExact" => Ok(__FieldTag::__auprc_exact),
                                "auprc_exact" => Ok(__FieldTag::__auprc_exact),
                                "estimatedCalibrationErrorExact" => {
                                    Ok(__FieldTag::__estimated_calibration_error_exact)
                                }
                                "estimated_calibration_error_exact" => {
                                    Ok(__FieldTag::__estimated_calibration_error_exact)
                                }
                                "metricsType" => Ok(__FieldTag::__metrics_type),
                                "metrics_type" => Ok(__FieldTag::__metrics_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiConfidenceMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiConfidenceMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__confidence_level_metrics => {
                                if !fields.insert(__FieldTag::__confidence_level_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence_level_metrics",
                                    ));
                                }
                                result.confidence_level_metrics = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::evaluation::ConfidenceLevelMetrics,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__confidence_level_metrics_exact => {
                                if !fields.insert(__FieldTag::__confidence_level_metrics_exact) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence_level_metrics_exact",
                                    ));
                                }
                                result.confidence_level_metrics_exact = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::evaluation::ConfidenceLevelMetrics,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__auprc => {
                                if !fields.insert(__FieldTag::__auprc) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auprc",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.auprc = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__estimated_calibration_error => {
                                if !fields.insert(__FieldTag::__estimated_calibration_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for estimated_calibration_error",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.estimated_calibration_error =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__auprc_exact => {
                                if !fields.insert(__FieldTag::__auprc_exact) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auprc_exact",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.auprc_exact =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__estimated_calibration_error_exact => {
                                if !fields.insert(__FieldTag::__estimated_calibration_error_exact) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for estimated_calibration_error_exact",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.estimated_calibration_error_exact =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__metrics_type => {
                                if !fields.insert(__FieldTag::__metrics_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metrics_type",
                                    ));
                                }
                                result.metrics_type = map.next_value::<std::option::Option<crate::model::evaluation::multi_confidence_metrics::MetricsType>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultiConfidenceMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.confidence_level_metrics.is_empty() {
                state.serialize_entry("confidenceLevelMetrics", &self.confidence_level_metrics)?;
            }
            if !self.confidence_level_metrics_exact.is_empty() {
                state.serialize_entry(
                    "confidenceLevelMetricsExact",
                    &self.confidence_level_metrics_exact,
                )?;
            }
            if !wkt::internal::is_default(&self.auprc) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("auprc", &__With(&self.auprc))?;
            }
            if !wkt::internal::is_default(&self.estimated_calibration_error) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "estimatedCalibrationError",
                    &__With(&self.estimated_calibration_error),
                )?;
            }
            if !wkt::internal::is_default(&self.auprc_exact) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("auprcExact", &__With(&self.auprc_exact))?;
            }
            if !wkt::internal::is_default(&self.estimated_calibration_error_exact) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "estimatedCalibrationErrorExact",
                    &__With(&self.estimated_calibration_error_exact),
                )?;
            }
            if !wkt::internal::is_default(&self.metrics_type) {
                state.serialize_entry("metricsType", &self.metrics_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MultiConfidenceMetrics {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MultiConfidenceMetrics");
            debug_struct.field("confidence_level_metrics", &self.confidence_level_metrics);
            debug_struct.field(
                "confidence_level_metrics_exact",
                &self.confidence_level_metrics_exact,
            );
            debug_struct.field("auprc", &self.auprc);
            debug_struct.field(
                "estimated_calibration_error",
                &self.estimated_calibration_error,
            );
            debug_struct.field("auprc_exact", &self.auprc_exact);
            debug_struct.field(
                "estimated_calibration_error_exact",
                &self.estimated_calibration_error_exact,
            );
            debug_struct.field("metrics_type", &self.metrics_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [MultiConfidenceMetrics].
    pub mod multi_confidence_metrics {
        #[allow(unused_imports)]
        use super::*;

        /// A type that determines how metrics should be interpreted.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MetricsType {
            /// The metrics type is unspecified. By default, metrics without a
            /// particular specification are for leaf entity types (i.e., top-level
            /// entity types without child types, or child types which are not
            /// parent types themselves).
            Unspecified,
            /// Indicates whether metrics for this particular label type represent an
            /// aggregate of metrics for other types instead of being based on actual
            /// TP/FP/FN values for the label type. Metrics for parent (i.e., non-leaf)
            /// entity types are an aggregate of metrics for their children.
            Aggregate,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MetricsType::value] or
            /// [MetricsType::name].
            UnknownValue(metrics_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod metrics_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl MetricsType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Aggregate => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("METRICS_TYPE_UNSPECIFIED"),
                    Self::Aggregate => std::option::Option::Some("AGGREGATE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for MetricsType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for MetricsType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for MetricsType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Aggregate,
                    _ => Self::UnknownValue(metrics_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for MetricsType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "METRICS_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "AGGREGATE" => Self::Aggregate,
                    _ => Self::UnknownValue(metrics_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for MetricsType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Aggregate => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for MetricsType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetricsType>::new(
                    ".google.cloud.documentai.v1.Evaluation.MultiConfidenceMetrics.MetricsType",
                ))
            }
        }
    }
}

/// A vertex represents a 2D point in the image.
/// NOTE: the vertex coordinates are in the same scale as the original image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Vertex {
    /// X coordinate.
    pub x: i32,

    /// Y coordinate (starts from the top of the image).
    pub y: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Vertex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::Vertex::x].
    pub fn set_x<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Vertex::y].
    pub fn set_y<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }
}

impl wkt::message::Message for Vertex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.Vertex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Vertex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x,
            __y,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Vertex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Vertex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Vertex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Vertex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.x) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("x", &__With(&self.x))?;
        }
        if !wkt::internal::is_default(&self.y) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("y", &__With(&self.y))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Vertex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vertex");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A vertex represents a 2D point in the image.
/// NOTE: the normalized vertex coordinates are relative to the original image
/// and range from 0 to 1.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NormalizedVertex {
    /// X coordinate.
    pub x: f32,

    /// Y coordinate (starts from the top of the image).
    pub y: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NormalizedVertex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::NormalizedVertex::x].
    pub fn set_x<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::NormalizedVertex::y].
    pub fn set_y<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }
}

impl wkt::message::Message for NormalizedVertex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.NormalizedVertex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NormalizedVertex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x,
            __y,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NormalizedVertex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NormalizedVertex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NormalizedVertex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NormalizedVertex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.x) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("x", &__With(&self.x))?;
        }
        if !wkt::internal::is_default(&self.y) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("y", &__With(&self.y))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NormalizedVertex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NormalizedVertex");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A bounding polygon for the detected image annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BoundingPoly {
    /// The bounding polygon vertices.
    pub vertices: std::vec::Vec<crate::model::Vertex>,

    /// The bounding polygon normalized vertices.
    pub normalized_vertices: std::vec::Vec<crate::model::NormalizedVertex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BoundingPoly {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vertices][crate::model::BoundingPoly::vertices].
    pub fn set_vertices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Vertex>,
    {
        use std::iter::Iterator;
        self.vertices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [normalized_vertices][crate::model::BoundingPoly::normalized_vertices].
    pub fn set_normalized_vertices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NormalizedVertex>,
    {
        use std::iter::Iterator;
        self.normalized_vertices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BoundingPoly {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.BoundingPoly"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BoundingPoly {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vertices,
            __normalized_vertices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoundingPoly")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vertices" => Ok(__FieldTag::__vertices),
                            "normalizedVertices" => Ok(__FieldTag::__normalized_vertices),
                            "normalized_vertices" => Ok(__FieldTag::__normalized_vertices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BoundingPoly;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoundingPoly")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vertices => {
                            if !fields.insert(__FieldTag::__vertices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertices",
                                ));
                            }
                            result.vertices = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Vertex>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__normalized_vertices => {
                            if !fields.insert(__FieldTag::__normalized_vertices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalized_vertices",
                                ));
                            }
                            result.normalized_vertices =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NormalizedVertex>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BoundingPoly {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vertices.is_empty() {
            state.serialize_entry("vertices", &self.vertices)?;
        }
        if !self.normalized_vertices.is_empty() {
            state.serialize_entry("normalizedVertices", &self.normalized_vertices)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BoundingPoly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BoundingPoly");
        debug_struct.field("vertices", &self.vertices);
        debug_struct.field("normalized_vertices", &self.normalized_vertices);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The common metadata for long running operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CommonOperationMetadata {
    /// The state of the operation.
    pub state: crate::model::common_operation_metadata::State,

    /// A message providing more details about the current state of processing.
    pub state_message: std::string::String,

    /// A related resource to this operation.
    pub resource: std::string::String,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommonOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::CommonOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::common_operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::CommonOperationMetadata::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::CommonOperationMetadata::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CommonOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CommonOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CommonOperationMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CommonOperationMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CommonOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.CommonOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommonOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __state_message,
            __resource,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommonOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "resource" => Ok(__FieldTag::__resource),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommonOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommonOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::common_operation_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommonOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CommonOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommonOperationMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CommonOperationMetadata].
pub mod common_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of the longrunning operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Operation is still running.
        Running,
        /// Operation is being cancelled.
        Cancelling,
        /// Operation succeeded.
        Succeeded,
        /// Operation failed.
        Failed,
        /// Operation is cancelled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Cancelling => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Cancelling,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "CANCELLING" => Self::Cancelling,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Cancelling => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.documentai.v1.CommonOperationMetadata.State",
            ))
        }
    }
}

/// A processor version is an implementation of a processor. Each processor
/// can have multiple versions, pretrained by Google internally or uptrained
/// by the customer. A processor can only have one default version at a time.
/// Its document-processing behavior is defined by that version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProcessorVersion {
    /// Identifier. The resource name of the processor version.
    /// Format:
    /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processor_version}`
    pub name: std::string::String,

    /// The display name of the processor version.
    pub display_name: std::string::String,

    /// Output only. The schema of the processor version. Describes the output.
    pub document_schema: std::option::Option<crate::model::DocumentSchema>,

    /// Output only. The state of the processor version.
    pub state: crate::model::processor_version::State,

    /// Output only. The time the processor version was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recently invoked evaluation for the processor
    /// version.
    pub latest_evaluation: std::option::Option<crate::model::EvaluationReference>,

    /// Output only. The KMS key name used for encryption.
    pub kms_key_name: std::string::String,

    /// Output only. The KMS key version with which data is encrypted.
    pub kms_key_version_name: std::string::String,

    /// Output only. Denotes that this `ProcessorVersion` is managed by Google.
    pub google_managed: bool,

    /// Output only. If set, information about the eventual deprecation of this
    /// version.
    pub deprecation_info: std::option::Option<crate::model::processor_version::DeprecationInfo>,

    /// Output only. The model type of this processor version.
    pub model_type: crate::model::processor_version::ModelType,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    /// Output only. Information about Generative AI model-based processor
    /// versions.
    pub gen_ai_model_info: std::option::Option<crate::model::processor_version::GenAiModelInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessorVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProcessorVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ProcessorVersion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [document_schema][crate::model::ProcessorVersion::document_schema].
    pub fn set_document_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.document_schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_schema][crate::model::ProcessorVersion::document_schema].
    pub fn set_or_clear_document_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentSchema>,
    {
        self.document_schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::ProcessorVersion::state].
    pub fn set_state<T: std::convert::Into<crate::model::processor_version::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ProcessorVersion::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ProcessorVersion::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_evaluation][crate::model::ProcessorVersion::latest_evaluation].
    pub fn set_latest_evaluation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EvaluationReference>,
    {
        self.latest_evaluation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_evaluation][crate::model::ProcessorVersion::latest_evaluation].
    pub fn set_or_clear_latest_evaluation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EvaluationReference>,
    {
        self.latest_evaluation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_name][crate::model::ProcessorVersion::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::ProcessorVersion::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [google_managed][crate::model::ProcessorVersion::google_managed].
    pub fn set_google_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.google_managed = v.into();
        self
    }

    /// Sets the value of [deprecation_info][crate::model::ProcessorVersion::deprecation_info].
    pub fn set_deprecation_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::processor_version::DeprecationInfo>,
    {
        self.deprecation_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecation_info][crate::model::ProcessorVersion::deprecation_info].
    pub fn set_or_clear_deprecation_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::processor_version::DeprecationInfo>,
    {
        self.deprecation_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_type][crate::model::ProcessorVersion::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::processor_version::ModelType>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ProcessorVersion::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ProcessorVersion::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [gen_ai_model_info][crate::model::ProcessorVersion::gen_ai_model_info].
    pub fn set_gen_ai_model_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::processor_version::GenAiModelInfo>,
    {
        self.gen_ai_model_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gen_ai_model_info][crate::model::ProcessorVersion::gen_ai_model_info].
    pub fn set_or_clear_gen_ai_model_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::processor_version::GenAiModelInfo>,
    {
        self.gen_ai_model_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProcessorVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ProcessorVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProcessorVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __document_schema,
            __state,
            __create_time,
            __latest_evaluation,
            __kms_key_name,
            __kms_key_version_name,
            __google_managed,
            __deprecation_info,
            __model_type,
            __satisfies_pzs,
            __satisfies_pzi,
            __gen_ai_model_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProcessorVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "documentSchema" => Ok(__FieldTag::__document_schema),
                            "document_schema" => Ok(__FieldTag::__document_schema),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "latestEvaluation" => Ok(__FieldTag::__latest_evaluation),
                            "latest_evaluation" => Ok(__FieldTag::__latest_evaluation),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            "googleManaged" => Ok(__FieldTag::__google_managed),
                            "google_managed" => Ok(__FieldTag::__google_managed),
                            "deprecationInfo" => Ok(__FieldTag::__deprecation_info),
                            "deprecation_info" => Ok(__FieldTag::__deprecation_info),
                            "modelType" => Ok(__FieldTag::__model_type),
                            "model_type" => Ok(__FieldTag::__model_type),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "genAiModelInfo" => Ok(__FieldTag::__gen_ai_model_info),
                            "gen_ai_model_info" => Ok(__FieldTag::__gen_ai_model_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProcessorVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProcessorVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_schema => {
                            if !fields.insert(__FieldTag::__document_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_schema",
                                ));
                            }
                            result.document_schema = map
                                .next_value::<std::option::Option<crate::model::DocumentSchema>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::processor_version::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__latest_evaluation => {
                            if !fields.insert(__FieldTag::__latest_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_evaluation",
                                ));
                            }
                            result.latest_evaluation = map.next_value::<std::option::Option<crate::model::EvaluationReference>>()?
                                ;
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__google_managed => {
                            if !fields.insert(__FieldTag::__google_managed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_managed",
                                ));
                            }
                            result.google_managed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deprecation_info => {
                            if !fields.insert(__FieldTag::__deprecation_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deprecation_info",
                                ));
                            }
                            result.deprecation_info = map.next_value::<std::option::Option<
                                crate::model::processor_version::DeprecationInfo,
                            >>()?;
                        }
                        __FieldTag::__model_type => {
                            if !fields.insert(__FieldTag::__model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_type",
                                ));
                            }
                            result.model_type = map.next_value::<std::option::Option<crate::model::processor_version::ModelType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gen_ai_model_info => {
                            if !fields.insert(__FieldTag::__gen_ai_model_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gen_ai_model_info",
                                ));
                            }
                            result.gen_ai_model_info = map.next_value::<std::option::Option<
                                crate::model::processor_version::GenAiModelInfo,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProcessorVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.document_schema.is_some() {
            state.serialize_entry("documentSchema", &self.document_schema)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.latest_evaluation.is_some() {
            state.serialize_entry("latestEvaluation", &self.latest_evaluation)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !wkt::internal::is_default(&self.google_managed) {
            state.serialize_entry("googleManaged", &self.google_managed)?;
        }
        if self.deprecation_info.is_some() {
            state.serialize_entry("deprecationInfo", &self.deprecation_info)?;
        }
        if !wkt::internal::is_default(&self.model_type) {
            state.serialize_entry("modelType", &self.model_type)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.gen_ai_model_info.is_some() {
            state.serialize_entry("genAiModelInfo", &self.gen_ai_model_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProcessorVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessorVersion");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("document_schema", &self.document_schema);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("latest_evaluation", &self.latest_evaluation);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        debug_struct.field("google_managed", &self.google_managed);
        debug_struct.field("deprecation_info", &self.deprecation_info);
        debug_struct.field("model_type", &self.model_type);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("gen_ai_model_info", &self.gen_ai_model_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ProcessorVersion].
pub mod processor_version {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the upcoming deprecation of this processor version.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeprecationInfo {
        /// The time at which this processor version will be deprecated.
        pub deprecation_time: std::option::Option<wkt::Timestamp>,

        /// If set, the processor version that will be used as a replacement.
        pub replacement_processor_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DeprecationInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [deprecation_time][crate::model::processor_version::DeprecationInfo::deprecation_time].
        pub fn set_deprecation_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.deprecation_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [deprecation_time][crate::model::processor_version::DeprecationInfo::deprecation_time].
        pub fn set_or_clear_deprecation_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.deprecation_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [replacement_processor_version][crate::model::processor_version::DeprecationInfo::replacement_processor_version].
        pub fn set_replacement_processor_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.replacement_processor_version = v.into();
            self
        }
    }

    impl wkt::message::Message for DeprecationInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.ProcessorVersion.DeprecationInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DeprecationInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __deprecation_time,
                __replacement_processor_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DeprecationInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "deprecationTime" => Ok(__FieldTag::__deprecation_time),
                                "deprecation_time" => Ok(__FieldTag::__deprecation_time),
                                "replacementProcessorVersion" => {
                                    Ok(__FieldTag::__replacement_processor_version)
                                }
                                "replacement_processor_version" => {
                                    Ok(__FieldTag::__replacement_processor_version)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DeprecationInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DeprecationInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__deprecation_time => {
                                if !fields.insert(__FieldTag::__deprecation_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deprecation_time",
                                    ));
                                }
                                result.deprecation_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__replacement_processor_version => {
                                if !fields.insert(__FieldTag::__replacement_processor_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replacement_processor_version",
                                    ));
                                }
                                result.replacement_processor_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DeprecationInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.deprecation_time.is_some() {
                state.serialize_entry("deprecationTime", &self.deprecation_time)?;
            }
            if !self.replacement_processor_version.is_empty() {
                state.serialize_entry(
                    "replacementProcessorVersion",
                    &self.replacement_processor_version,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DeprecationInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DeprecationInfo");
            debug_struct.field("deprecation_time", &self.deprecation_time);
            debug_struct.field(
                "replacement_processor_version",
                &self.replacement_processor_version,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Information about Generative AI model-based processor versions.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GenAiModelInfo {
        /// The processor version is either a pretrained Google-managed foundation
        /// model or a custom Generative AI model created by the user.
        pub model_info:
            std::option::Option<crate::model::processor_version::gen_ai_model_info::ModelInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GenAiModelInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model_info][crate::model::processor_version::GenAiModelInfo::model_info].
        ///
        /// Note that all the setters affecting `model_info` are mutually
        /// exclusive.
        pub fn set_model_info<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::processor_version::gen_ai_model_info::ModelInfo,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.model_info = v.into();
            self
        }

        /// The value of [model_info][crate::model::processor_version::GenAiModelInfo::model_info]
        /// if it holds a `FoundationGenAiModelInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn foundation_gen_ai_model_info(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::processor_version::gen_ai_model_info::FoundationGenAiModelInfo,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.model_info.as_ref().and_then(|v| match v {
                crate::model::processor_version::gen_ai_model_info::ModelInfo::FoundationGenAiModelInfo(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [model_info][crate::model::processor_version::GenAiModelInfo::model_info]
        /// to hold a `FoundationGenAiModelInfo`.
        ///
        /// Note that all the setters affecting `model_info` are
        /// mutually exclusive.
        pub fn set_foundation_gen_ai_model_info<T: std::convert::Into<std::boxed::Box<crate::model::processor_version::gen_ai_model_info::FoundationGenAiModelInfo>>>(mut self, v: T) -> Self{
            self.model_info = std::option::Option::Some(
                crate::model::processor_version::gen_ai_model_info::ModelInfo::FoundationGenAiModelInfo(
                    v.into()
                )
            );
            self
        }

        /// The value of [model_info][crate::model::processor_version::GenAiModelInfo::model_info]
        /// if it holds a `CustomGenAiModelInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn custom_gen_ai_model_info(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::processor_version::gen_ai_model_info::CustomGenAiModelInfo,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.model_info.as_ref().and_then(|v| match v {
                crate::model::processor_version::gen_ai_model_info::ModelInfo::CustomGenAiModelInfo(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [model_info][crate::model::processor_version::GenAiModelInfo::model_info]
        /// to hold a `CustomGenAiModelInfo`.
        ///
        /// Note that all the setters affecting `model_info` are
        /// mutually exclusive.
        pub fn set_custom_gen_ai_model_info<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::processor_version::gen_ai_model_info::CustomGenAiModelInfo,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.model_info = std::option::Option::Some(
                crate::model::processor_version::gen_ai_model_info::ModelInfo::CustomGenAiModelInfo(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for GenAiModelInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.ProcessorVersion.GenAiModelInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GenAiModelInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __foundation_gen_ai_model_info,
                __custom_gen_ai_model_info,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GenAiModelInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "foundationGenAiModelInfo" => {
                                    Ok(__FieldTag::__foundation_gen_ai_model_info)
                                }
                                "foundation_gen_ai_model_info" => {
                                    Ok(__FieldTag::__foundation_gen_ai_model_info)
                                }
                                "customGenAiModelInfo" => {
                                    Ok(__FieldTag::__custom_gen_ai_model_info)
                                }
                                "custom_gen_ai_model_info" => {
                                    Ok(__FieldTag::__custom_gen_ai_model_info)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GenAiModelInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GenAiModelInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__foundation_gen_ai_model_info => {
                                if !fields.insert(__FieldTag::__foundation_gen_ai_model_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for foundation_gen_ai_model_info",
                                    ));
                                }
                                if result.model_info.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `model_info`, a oneof with full ID .google.cloud.documentai.v1.ProcessorVersion.GenAiModelInfo.foundation_gen_ai_model_info, latest field was foundationGenAiModelInfo",
                                    ));
                                }
                                result.model_info = std::option::Option::Some(
                                    crate::model::processor_version::gen_ai_model_info::ModelInfo::FoundationGenAiModelInfo(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::processor_version::gen_ai_model_info::FoundationGenAiModelInfo>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__custom_gen_ai_model_info => {
                                if !fields.insert(__FieldTag::__custom_gen_ai_model_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for custom_gen_ai_model_info",
                                    ));
                                }
                                if result.model_info.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `model_info`, a oneof with full ID .google.cloud.documentai.v1.ProcessorVersion.GenAiModelInfo.custom_gen_ai_model_info, latest field was customGenAiModelInfo",
                                    ));
                                }
                                result.model_info = std::option::Option::Some(
                                    crate::model::processor_version::gen_ai_model_info::ModelInfo::CustomGenAiModelInfo(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::processor_version::gen_ai_model_info::CustomGenAiModelInfo>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GenAiModelInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.foundation_gen_ai_model_info() {
                state.serialize_entry("foundationGenAiModelInfo", value)?;
            }
            if let Some(value) = self.custom_gen_ai_model_info() {
                state.serialize_entry("customGenAiModelInfo", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GenAiModelInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GenAiModelInfo");
            debug_struct.field("model_info", &self.model_info);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GenAiModelInfo].
    pub mod gen_ai_model_info {
        #[allow(unused_imports)]
        use super::*;

        /// Information for a pretrained Google-managed foundation model.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FoundationGenAiModelInfo {
            /// Whether finetuning is allowed for this base processor version.
            pub finetuning_allowed: bool,

            /// The minimum number of labeled documents in the training dataset
            /// required for finetuning.
            pub min_train_labeled_documents: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FoundationGenAiModelInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [finetuning_allowed][crate::model::processor_version::gen_ai_model_info::FoundationGenAiModelInfo::finetuning_allowed].
            pub fn set_finetuning_allowed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.finetuning_allowed = v.into();
                self
            }

            /// Sets the value of [min_train_labeled_documents][crate::model::processor_version::gen_ai_model_info::FoundationGenAiModelInfo::min_train_labeled_documents].
            pub fn set_min_train_labeled_documents<T: std::convert::Into<i32>>(
                mut self,
                v: T,
            ) -> Self {
                self.min_train_labeled_documents = v.into();
                self
            }
        }

        impl wkt::message::Message for FoundationGenAiModelInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.ProcessorVersion.GenAiModelInfo.FoundationGenAiModelInfo"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FoundationGenAiModelInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __finetuning_allowed,
                    __min_train_labeled_documents,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FoundationGenAiModelInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "finetuningAllowed" => Ok(__FieldTag::__finetuning_allowed),
                                    "finetuning_allowed" => Ok(__FieldTag::__finetuning_allowed),
                                    "minTrainLabeledDocuments" => {
                                        Ok(__FieldTag::__min_train_labeled_documents)
                                    }
                                    "min_train_labeled_documents" => {
                                        Ok(__FieldTag::__min_train_labeled_documents)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FoundationGenAiModelInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FoundationGenAiModelInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__finetuning_allowed => {
                                    if !fields.insert(__FieldTag::__finetuning_allowed) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for finetuning_allowed",
                                            ),
                                        );
                                    }
                                    result.finetuning_allowed = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__min_train_labeled_documents => {
                                    if !fields.insert(__FieldTag::__min_train_labeled_documents) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_train_labeled_documents",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_train_labeled_documents =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for FoundationGenAiModelInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.finetuning_allowed) {
                    state.serialize_entry("finetuningAllowed", &self.finetuning_allowed)?;
                }
                if !wkt::internal::is_default(&self.min_train_labeled_documents) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "minTrainLabeledDocuments",
                        &__With(&self.min_train_labeled_documents),
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for FoundationGenAiModelInfo {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("FoundationGenAiModelInfo");
                debug_struct.field("finetuning_allowed", &self.finetuning_allowed);
                debug_struct.field(
                    "min_train_labeled_documents",
                    &self.min_train_labeled_documents,
                );
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Information for a custom Generative AI model created by the user. These
        /// are created with `Create New Version` in either the `Call foundation
        /// model` or `Fine tuning` tabs.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CustomGenAiModelInfo {

            /// The type of custom model created by the user.
            pub custom_model_type: crate::model::processor_version::gen_ai_model_info::custom_gen_ai_model_info::CustomModelType,

            /// The base processor version ID for the custom model.
            pub base_processor_version_id: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CustomGenAiModelInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [custom_model_type][crate::model::processor_version::gen_ai_model_info::CustomGenAiModelInfo::custom_model_type].
            pub fn set_custom_model_type<T: std::convert::Into<crate::model::processor_version::gen_ai_model_info::custom_gen_ai_model_info::CustomModelType>>(mut self, v: T) -> Self{
                self.custom_model_type = v.into();
                self
            }

            /// Sets the value of [base_processor_version_id][crate::model::processor_version::gen_ai_model_info::CustomGenAiModelInfo::base_processor_version_id].
            pub fn set_base_processor_version_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.base_processor_version_id = v.into();
                self
            }
        }

        impl wkt::message::Message for CustomGenAiModelInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.documentai.v1.ProcessorVersion.GenAiModelInfo.CustomGenAiModelInfo"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CustomGenAiModelInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __custom_model_type,
                    __base_processor_version_id,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CustomGenAiModelInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "customModelType" => Ok(__FieldTag::__custom_model_type),
                                    "custom_model_type" => Ok(__FieldTag::__custom_model_type),
                                    "baseProcessorVersionId" => {
                                        Ok(__FieldTag::__base_processor_version_id)
                                    }
                                    "base_processor_version_id" => {
                                        Ok(__FieldTag::__base_processor_version_id)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CustomGenAiModelInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CustomGenAiModelInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__custom_model_type => {
                                    if !fields.insert(__FieldTag::__custom_model_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for custom_model_type",
                                            ),
                                        );
                                    }
                                    result.custom_model_type = map.next_value::<std::option::Option<crate::model::processor_version::gen_ai_model_info::custom_gen_ai_model_info::CustomModelType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__base_processor_version_id => {
                                    if !fields.insert(__FieldTag::__base_processor_version_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for base_processor_version_id",
                                            ),
                                        );
                                    }
                                    result.base_processor_version_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CustomGenAiModelInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.custom_model_type) {
                    state.serialize_entry("customModelType", &self.custom_model_type)?;
                }
                if !self.base_processor_version_id.is_empty() {
                    state.serialize_entry(
                        "baseProcessorVersionId",
                        &self.base_processor_version_id,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for CustomGenAiModelInfo {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("CustomGenAiModelInfo");
                debug_struct.field("custom_model_type", &self.custom_model_type);
                debug_struct.field("base_processor_version_id", &self.base_processor_version_id);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [CustomGenAiModelInfo].
        pub mod custom_gen_ai_model_info {
            #[allow(unused_imports)]
            use super::*;

            /// The type of custom model created by the user.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum CustomModelType {
                /// The model type is unspecified.
                Unspecified,
                /// The model is a versioned foundation model.
                VersionedFoundation,
                /// The model is a finetuned foundation model.
                FineTuned,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [CustomModelType::value] or
                /// [CustomModelType::name].
                UnknownValue(custom_model_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod custom_model_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl CustomModelType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::VersionedFoundation => std::option::Option::Some(1),
                        Self::FineTuned => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("CUSTOM_MODEL_TYPE_UNSPECIFIED")
                        }
                        Self::VersionedFoundation => {
                            std::option::Option::Some("VERSIONED_FOUNDATION")
                        }
                        Self::FineTuned => std::option::Option::Some("FINE_TUNED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for CustomModelType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for CustomModelType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for CustomModelType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::VersionedFoundation,
                        2 => Self::FineTuned,
                        _ => Self::UnknownValue(custom_model_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for CustomModelType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "CUSTOM_MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "VERSIONED_FOUNDATION" => Self::VersionedFoundation,
                        "FINE_TUNED" => Self::FineTuned,
                        _ => Self::UnknownValue(custom_model_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for CustomModelType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::VersionedFoundation => serializer.serialize_i32(1),
                        Self::FineTuned => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for CustomModelType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<CustomModelType>::new(
                        ".google.cloud.documentai.v1.ProcessorVersion.GenAiModelInfo.CustomGenAiModelInfo.CustomModelType"))
                }
            }
        }

        /// The processor version is either a pretrained Google-managed foundation
        /// model or a custom Generative AI model created by the user.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ModelInfo {
            /// Information for a pretrained Google-managed foundation model.
            FoundationGenAiModelInfo(
                std::boxed::Box<
                    crate::model::processor_version::gen_ai_model_info::FoundationGenAiModelInfo,
                >,
            ),
            /// Information for a custom Generative AI model created by the user.
            CustomGenAiModelInfo(
                std::boxed::Box<
                    crate::model::processor_version::gen_ai_model_info::CustomGenAiModelInfo,
                >,
            ),
        }
    }

    /// The possible states of the processor version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The processor version is in an unspecified state.
        Unspecified,
        /// The processor version is deployed and can be used for processing.
        Deployed,
        /// The processor version is being deployed.
        Deploying,
        /// The processor version is not deployed and cannot be used for processing.
        Undeployed,
        /// The processor version is being undeployed.
        Undeploying,
        /// The processor version is being created.
        Creating,
        /// The processor version is being deleted.
        Deleting,
        /// The processor version failed and is in an indeterminate state.
        Failed,
        /// The processor version is being imported.
        Importing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Deployed => std::option::Option::Some(1),
                Self::Deploying => std::option::Option::Some(2),
                Self::Undeployed => std::option::Option::Some(3),
                Self::Undeploying => std::option::Option::Some(4),
                Self::Creating => std::option::Option::Some(5),
                Self::Deleting => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::Importing => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Deployed => std::option::Option::Some("DEPLOYED"),
                Self::Deploying => std::option::Option::Some("DEPLOYING"),
                Self::Undeployed => std::option::Option::Some("UNDEPLOYED"),
                Self::Undeploying => std::option::Option::Some("UNDEPLOYING"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Importing => std::option::Option::Some("IMPORTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Deployed,
                2 => Self::Deploying,
                3 => Self::Undeployed,
                4 => Self::Undeploying,
                5 => Self::Creating,
                6 => Self::Deleting,
                7 => Self::Failed,
                8 => Self::Importing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DEPLOYED" => Self::Deployed,
                "DEPLOYING" => Self::Deploying,
                "UNDEPLOYED" => Self::Undeployed,
                "UNDEPLOYING" => Self::Undeploying,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "IMPORTING" => Self::Importing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Deployed => serializer.serialize_i32(1),
                Self::Deploying => serializer.serialize_i32(2),
                Self::Undeployed => serializer.serialize_i32(3),
                Self::Undeploying => serializer.serialize_i32(4),
                Self::Creating => serializer.serialize_i32(5),
                Self::Deleting => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::Importing => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.documentai.v1.ProcessorVersion.State",
            ))
        }
    }

    /// The possible model types of the processor version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// The processor version has unspecified model type.
        Unspecified,
        /// The processor version has generative model type.
        Generative,
        /// The processor version has custom model type.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Generative => std::option::Option::Some(1),
                Self::Custom => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::Generative => std::option::Option::Some("MODEL_TYPE_GENERATIVE"),
                Self::Custom => std::option::Option::Some("MODEL_TYPE_CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Generative,
                2 => Self::Custom,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MODEL_TYPE_GENERATIVE" => Self::Generative,
                "MODEL_TYPE_CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Generative => serializer.serialize_i32(1),
                Self::Custom => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.documentai.v1.ProcessorVersion.ModelType",
            ))
        }
    }
}

/// Contains the alias and the aliased resource name of processor version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProcessorVersionAlias {
    /// The alias in the form of `processor_version` resource name.
    pub alias: std::string::String,

    /// The resource name of aliased processor version.
    pub processor_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessorVersionAlias {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alias][crate::model::ProcessorVersionAlias::alias].
    pub fn set_alias<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alias = v.into();
        self
    }

    /// Sets the value of [processor_version][crate::model::ProcessorVersionAlias::processor_version].
    pub fn set_processor_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.processor_version = v.into();
        self
    }
}

impl wkt::message::Message for ProcessorVersionAlias {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ProcessorVersionAlias"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProcessorVersionAlias {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alias,
            __processor_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProcessorVersionAlias")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alias" => Ok(__FieldTag::__alias),
                            "processorVersion" => Ok(__FieldTag::__processor_version),
                            "processor_version" => Ok(__FieldTag::__processor_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProcessorVersionAlias;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProcessorVersionAlias")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alias => {
                            if !fields.insert(__FieldTag::__alias) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alias",
                                ));
                            }
                            result.alias = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__processor_version => {
                            if !fields.insert(__FieldTag::__processor_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_version",
                                ));
                            }
                            result.processor_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProcessorVersionAlias {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.alias.is_empty() {
            state.serialize_entry("alias", &self.alias)?;
        }
        if !self.processor_version.is_empty() {
            state.serialize_entry("processorVersion", &self.processor_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProcessorVersionAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessorVersionAlias");
        debug_struct.field("alias", &self.alias);
        debug_struct.field("processor_version", &self.processor_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The first-class citizen for Document AI. Each processor defines how to
/// extract structural information from a document.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Processor {
    /// Output only. Immutable. The resource name of the processor.
    /// Format: `projects/{project}/locations/{location}/processors/{processor}`
    pub name: std::string::String,

    /// The processor type, such as: `OCR_PROCESSOR`, `INVOICE_PROCESSOR`.
    /// To get a list of processor types, see
    /// [FetchProcessorTypes][google.cloud.documentai.v1.DocumentProcessorService.FetchProcessorTypes].
    ///
    /// [google.cloud.documentai.v1.DocumentProcessorService.FetchProcessorTypes]: crate::client::DocumentProcessorService::fetch_processor_types
    pub r#type: std::string::String,

    /// The display name of the processor.
    pub display_name: std::string::String,

    /// Output only. The state of the processor.
    pub state: crate::model::processor::State,

    /// The default processor version.
    pub default_processor_version: std::string::String,

    /// Output only. The processor version aliases.
    pub processor_version_aliases: std::vec::Vec<crate::model::ProcessorVersionAlias>,

    /// Output only. Immutable. The http endpoint that can be called to invoke
    /// processing.
    pub process_endpoint: std::string::String,

    /// Output only. The time the processor was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The [KMS key](https://cloud.google.com/security-key-management) used for
    /// encryption and decryption in CMEK scenarios.
    pub kms_key_name: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Processor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Processor::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Processor::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Processor::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Processor::state].
    pub fn set_state<T: std::convert::Into<crate::model::processor::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [default_processor_version][crate::model::Processor::default_processor_version].
    pub fn set_default_processor_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_processor_version = v.into();
        self
    }

    /// Sets the value of [processor_version_aliases][crate::model::Processor::processor_version_aliases].
    pub fn set_processor_version_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProcessorVersionAlias>,
    {
        use std::iter::Iterator;
        self.processor_version_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [process_endpoint][crate::model::Processor::process_endpoint].
    pub fn set_process_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.process_endpoint = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Processor::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Processor::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Processor::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Processor::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Processor::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for Processor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.Processor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Processor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __display_name,
            __state,
            __default_processor_version,
            __processor_version_aliases,
            __process_endpoint,
            __create_time,
            __kms_key_name,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Processor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "defaultProcessorVersion" => {
                                Ok(__FieldTag::__default_processor_version)
                            }
                            "default_processor_version" => {
                                Ok(__FieldTag::__default_processor_version)
                            }
                            "processorVersionAliases" => {
                                Ok(__FieldTag::__processor_version_aliases)
                            }
                            "processor_version_aliases" => {
                                Ok(__FieldTag::__processor_version_aliases)
                            }
                            "processEndpoint" => Ok(__FieldTag::__process_endpoint),
                            "process_endpoint" => Ok(__FieldTag::__process_endpoint),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Processor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Processor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::processor::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_processor_version => {
                            if !fields.insert(__FieldTag::__default_processor_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_processor_version",
                                ));
                            }
                            result.default_processor_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__processor_version_aliases => {
                            if !fields.insert(__FieldTag::__processor_version_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processor_version_aliases",
                                ));
                            }
                            result.processor_version_aliases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ProcessorVersionAlias>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__process_endpoint => {
                            if !fields.insert(__FieldTag::__process_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for process_endpoint",
                                ));
                            }
                            result.process_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Processor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.default_processor_version.is_empty() {
            state.serialize_entry("defaultProcessorVersion", &self.default_processor_version)?;
        }
        if !self.processor_version_aliases.is_empty() {
            state.serialize_entry("processorVersionAliases", &self.processor_version_aliases)?;
        }
        if !self.process_endpoint.is_empty() {
            state.serialize_entry("processEndpoint", &self.process_endpoint)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Processor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Processor");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("default_processor_version", &self.default_processor_version);
        debug_struct.field("processor_version_aliases", &self.processor_version_aliases);
        debug_struct.field("process_endpoint", &self.process_endpoint);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Processor].
pub mod processor {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states of the processor.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The processor is in an unspecified state.
        Unspecified,
        /// The processor is enabled, i.e., has an enabled version which can
        /// currently serve processing requests and all the feature dependencies have
        /// been successfully initialized.
        Enabled,
        /// The processor is disabled.
        Disabled,
        /// The processor is being enabled, will become `ENABLED` if successful.
        Enabling,
        /// The processor is being disabled, will become `DISABLED` if successful.
        Disabling,
        /// The processor is being created, will become either `ENABLED` (for
        /// successful creation) or `FAILED` (for failed ones).
        /// Once a processor is in this state, it can then be used for document
        /// processing, but the feature dependencies of the processor might not be
        /// fully created yet.
        Creating,
        /// The processor failed during creation or initialization of feature
        /// dependencies. The user should delete the processor and recreate one as
        /// all the functionalities of the processor are disabled.
        Failed,
        /// The processor is being deleted, will be removed if successful.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Enabling => std::option::Option::Some(3),
                Self::Disabling => std::option::Option::Some(4),
                Self::Creating => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Deleting => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Enabling => std::option::Option::Some("ENABLING"),
                Self::Disabling => std::option::Option::Some("DISABLING"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Enabling,
                4 => Self::Disabling,
                5 => Self::Creating,
                6 => Self::Failed,
                7 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "ENABLING" => Self::Enabling,
                "DISABLING" => Self::Disabling,
                "CREATING" => Self::Creating,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Enabling => serializer.serialize_i32(3),
                Self::Disabling => serializer.serialize_i32(4),
                Self::Creating => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Deleting => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.documentai.v1.Processor.State",
            ))
        }
    }
}

/// A processor type is responsible for performing a certain document
/// understanding task on a certain type of document.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProcessorType {
    /// The resource name of the processor type.
    /// Format: `projects/{project}/processorTypes/{processor_type}`
    pub name: std::string::String,

    /// The processor type, such as: `OCR_PROCESSOR`, `INVOICE_PROCESSOR`.
    pub r#type: std::string::String,

    /// The processor category, used by UI to group processor types.
    pub category: std::string::String,

    /// The locations in which this processor is available.
    pub available_locations: std::vec::Vec<crate::model::processor_type::LocationInfo>,

    /// Whether the processor type allows creation. If true, users can create a
    /// processor of this processor type. Otherwise, users need to request access.
    pub allow_creation: bool,

    /// Launch stage of the processor type
    pub launch_stage: api::model::LaunchStage,

    /// A set of Cloud Storage URIs of sample documents for this processor.
    pub sample_document_uris: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProcessorType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProcessorType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ProcessorType::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [category][crate::model::ProcessorType::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [available_locations][crate::model::ProcessorType::available_locations].
    pub fn set_available_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::processor_type::LocationInfo>,
    {
        use std::iter::Iterator;
        self.available_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [allow_creation][crate::model::ProcessorType::allow_creation].
    pub fn set_allow_creation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_creation = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::ProcessorType::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [sample_document_uris][crate::model::ProcessorType::sample_document_uris].
    pub fn set_sample_document_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sample_document_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProcessorType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.documentai.v1.ProcessorType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProcessorType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __category,
            __available_locations,
            __allow_creation,
            __launch_stage,
            __sample_document_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProcessorType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "category" => Ok(__FieldTag::__category),
                            "availableLocations" => Ok(__FieldTag::__available_locations),
                            "available_locations" => Ok(__FieldTag::__available_locations),
                            "allowCreation" => Ok(__FieldTag::__allow_creation),
                            "allow_creation" => Ok(__FieldTag::__allow_creation),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            "sampleDocumentUris" => Ok(__FieldTag::__sample_document_uris),
                            "sample_document_uris" => Ok(__FieldTag::__sample_document_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProcessorType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProcessorType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_locations => {
                            if !fields.insert(__FieldTag::__available_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_locations",
                                ));
                            }
                            result.available_locations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::processor_type::LocationInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_creation => {
                            if !fields.insert(__FieldTag::__allow_creation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_creation",
                                ));
                            }
                            result.allow_creation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<api::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_document_uris => {
                            if !fields.insert(__FieldTag::__sample_document_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_document_uris",
                                ));
                            }
                            result.sample_document_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProcessorType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.category.is_empty() {
            state.serialize_entry("category", &self.category)?;
        }
        if !self.available_locations.is_empty() {
            state.serialize_entry("availableLocations", &self.available_locations)?;
        }
        if !wkt::internal::is_default(&self.allow_creation) {
            state.serialize_entry("allowCreation", &self.allow_creation)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if !self.sample_document_uris.is_empty() {
            state.serialize_entry("sampleDocumentUris", &self.sample_document_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProcessorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessorType");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("category", &self.category);
        debug_struct.field("available_locations", &self.available_locations);
        debug_struct.field("allow_creation", &self.allow_creation);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("sample_document_uris", &self.sample_document_uris);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ProcessorType].
pub mod processor_type {
    #[allow(unused_imports)]
    use super::*;

    /// The location information about where the processor is available.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LocationInfo {
        /// The location ID. For supported locations, refer to [regional and
        /// multi-regional support](/document-ai/docs/regions).
        pub location_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LocationInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location_id][crate::model::processor_type::LocationInfo::location_id].
        pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location_id = v.into();
            self
        }
    }

    impl wkt::message::Message for LocationInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.documentai.v1.ProcessorType.LocationInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LocationInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __location_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LocationInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "locationId" => Ok(__FieldTag::__location_id),
                                "location_id" => Ok(__FieldTag::__location_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LocationInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LocationInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__location_id => {
                                if !fields.insert(__FieldTag::__location_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for location_id",
                                    ));
                                }
                                result.location_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LocationInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.location_id.is_empty() {
                state.serialize_entry("locationId", &self.location_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for LocationInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("LocationInfo");
            debug_struct.field("location_id", &self.location_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}
