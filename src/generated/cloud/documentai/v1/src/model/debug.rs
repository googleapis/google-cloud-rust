// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::Barcode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Barcode");
        debug_struct.field("format", &self.format);
        debug_struct.field("value_format", &self.value_format);
        debug_struct.field("raw_value", &self.raw_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Document {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Document");
        debug_struct.field("docid", &self.docid);
        debug_struct.field("mime_type", &self.mime_type);
        debug_struct.field("text", &self.text);
        debug_struct.field("text_styles", &self.text_styles);
        debug_struct.field("pages", &self.pages);
        debug_struct.field("entities", &self.entities);
        debug_struct.field("entity_relations", &self.entity_relations);
        debug_struct.field("text_changes", &self.text_changes);
        debug_struct.field("shard_info", &self.shard_info);
        debug_struct.field("error", &self.error);
        debug_struct.field("revisions", &self.revisions);
        debug_struct.field("document_layout", &self.document_layout);
        debug_struct.field("chunked_document", &self.chunked_document);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::ShardInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShardInfo");
        debug_struct.field("shard_index", &self.shard_index);
        debug_struct.field("shard_count", &self.shard_count);
        debug_struct.field("text_offset", &self.text_offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::Style {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Style");
        debug_struct.field("text_anchor", &self.text_anchor);
        debug_struct.field("color", &self.color);
        debug_struct.field("background_color", &self.background_color);
        debug_struct.field("font_weight", &self.font_weight);
        debug_struct.field("text_style", &self.text_style);
        debug_struct.field("text_decoration", &self.text_decoration);
        debug_struct.field("font_size", &self.font_size);
        debug_struct.field("font_family", &self.font_family);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::style::FontSize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FontSize");
        debug_struct.field("size", &self.size);
        debug_struct.field("unit", &self.unit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Page");
        debug_struct.field("page_number", &self.page_number);
        debug_struct.field("image", &self.image);
        debug_struct.field("transforms", &self.transforms);
        debug_struct.field("dimension", &self.dimension);
        debug_struct.field("layout", &self.layout);
        debug_struct.field("detected_languages", &self.detected_languages);
        debug_struct.field("blocks", &self.blocks);
        debug_struct.field("paragraphs", &self.paragraphs);
        debug_struct.field("lines", &self.lines);
        debug_struct.field("tokens", &self.tokens);
        debug_struct.field("visual_elements", &self.visual_elements);
        debug_struct.field("tables", &self.tables);
        debug_struct.field("form_fields", &self.form_fields);
        debug_struct.field("symbols", &self.symbols);
        debug_struct.field("detected_barcodes", &self.detected_barcodes);
        debug_struct.field("image_quality_scores", &self.image_quality_scores);
        debug_struct.field("provenance", &self.provenance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Dimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Dimension");
        debug_struct.field("width", &self.width);
        debug_struct.field("height", &self.height);
        debug_struct.field("unit", &self.unit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Image");
        debug_struct.field("content", &self.content);
        debug_struct.field("mime_type", &self.mime_type);
        debug_struct.field("width", &self.width);
        debug_struct.field("height", &self.height);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Matrix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Matrix");
        debug_struct.field("rows", &self.rows);
        debug_struct.field("cols", &self.cols);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("data", &self.data);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Layout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Layout");
        debug_struct.field("text_anchor", &self.text_anchor);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("bounding_poly", &self.bounding_poly);
        debug_struct.field("orientation", &self.orientation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Block {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Block");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("detected_languages", &self.detected_languages);
        debug_struct.field("provenance", &self.provenance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Paragraph {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Paragraph");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("detected_languages", &self.detected_languages);
        debug_struct.field("provenance", &self.provenance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Line {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Line");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("detected_languages", &self.detected_languages);
        debug_struct.field("provenance", &self.provenance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Token");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("detected_break", &self.detected_break);
        debug_struct.field("detected_languages", &self.detected_languages);
        debug_struct.field("provenance", &self.provenance);
        debug_struct.field("style_info", &self.style_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::token::DetectedBreak {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetectedBreak");
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::token::StyleInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StyleInfo");
        debug_struct.field("font_size", &self.font_size);
        debug_struct.field("pixel_font_size", &self.pixel_font_size);
        debug_struct.field("letter_spacing", &self.letter_spacing);
        debug_struct.field("font_type", &self.font_type);
        debug_struct.field("bold", &self.bold);
        debug_struct.field("italic", &self.italic);
        debug_struct.field("underlined", &self.underlined);
        debug_struct.field("strikeout", &self.strikeout);
        debug_struct.field("subscript", &self.subscript);
        debug_struct.field("superscript", &self.superscript);
        debug_struct.field("smallcaps", &self.smallcaps);
        debug_struct.field("font_weight", &self.font_weight);
        debug_struct.field("handwritten", &self.handwritten);
        debug_struct.field("text_color", &self.text_color);
        debug_struct.field("background_color", &self.background_color);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Symbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Symbol");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("detected_languages", &self.detected_languages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::VisualElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VisualElement");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("detected_languages", &self.detected_languages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::Table {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Table");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("header_rows", &self.header_rows);
        debug_struct.field("body_rows", &self.body_rows);
        debug_struct.field("detected_languages", &self.detected_languages);
        debug_struct.field("provenance", &self.provenance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::table::TableRow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableRow");
        debug_struct.field("cells", &self.cells);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::table::TableCell {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableCell");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("row_span", &self.row_span);
        debug_struct.field("col_span", &self.col_span);
        debug_struct.field("detected_languages", &self.detected_languages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::FormField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FormField");
        debug_struct.field("field_name", &self.field_name);
        debug_struct.field("field_value", &self.field_value);
        debug_struct.field("name_detected_languages", &self.name_detected_languages);
        debug_struct.field("value_detected_languages", &self.value_detected_languages);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("corrected_key_text", &self.corrected_key_text);
        debug_struct.field("corrected_value_text", &self.corrected_value_text);
        debug_struct.field("provenance", &self.provenance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::DetectedBarcode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetectedBarcode");
        debug_struct.field("layout", &self.layout);
        debug_struct.field("barcode", &self.barcode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::DetectedLanguage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetectedLanguage");
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("confidence", &self.confidence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::ImageQualityScores {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageQualityScores");
        debug_struct.field("quality_score", &self.quality_score);
        debug_struct.field("detected_defects", &self.detected_defects);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page::image_quality_scores::DetectedDefect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DetectedDefect");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("confidence", &self.confidence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::Entity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entity");
        debug_struct.field("text_anchor", &self.text_anchor);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("mention_text", &self.mention_text);
        debug_struct.field("mention_id", &self.mention_id);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("page_anchor", &self.page_anchor);
        debug_struct.field("id", &self.id);
        debug_struct.field("normalized_value", &self.normalized_value);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("provenance", &self.provenance);
        debug_struct.field("redacted", &self.redacted);
        debug_struct.field("method", &self.method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::entity::NormalizedValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NormalizedValue");
        debug_struct.field("text", &self.text);
        debug_struct.field("structured_value", &self.structured_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::EntityRelation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityRelation");
        debug_struct.field("subject_id", &self.subject_id);
        debug_struct.field("object_id", &self.object_id);
        debug_struct.field("relation", &self.relation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::TextAnchor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextAnchor");
        debug_struct.field("text_segments", &self.text_segments);
        debug_struct.field("content", &self.content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::text_anchor::TextSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextSegment");
        debug_struct.field("start_index", &self.start_index);
        debug_struct.field("end_index", &self.end_index);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::PageAnchor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PageAnchor");
        debug_struct.field("page_refs", &self.page_refs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::page_anchor::PageRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PageRef");
        debug_struct.field("page", &self.page);
        debug_struct.field("layout_type", &self.layout_type);
        debug_struct.field("layout_id", &self.layout_id);
        debug_struct.field("bounding_poly", &self.bounding_poly);
        debug_struct.field("confidence", &self.confidence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::Provenance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Provenance");
        debug_struct.field("revision", &self.revision);
        debug_struct.field("id", &self.id);
        debug_struct.field("parents", &self.parents);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::provenance::Parent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Parent");
        debug_struct.field("revision", &self.revision);
        debug_struct.field("index", &self.index);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::Revision {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Revision");
        debug_struct.field("id", &self.id);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("parent_ids", &self.parent_ids);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("human_review", &self.human_review);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::revision::HumanReview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HumanReview");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::TextChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextChange");
        debug_struct.field("text_anchor", &self.text_anchor);
        debug_struct.field("changed_text", &self.changed_text);
        debug_struct.field("provenance", &self.provenance);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::DocumentLayout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DocumentLayout");
        debug_struct.field("blocks", &self.blocks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::DocumentLayoutBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DocumentLayoutBlock");
        debug_struct.field("block_id", &self.block_id);
        debug_struct.field("page_span", &self.page_span);
        debug_struct.field("bounding_box", &self.bounding_box);
        debug_struct.field("block", &self.block);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::document_layout_block::LayoutPageSpan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutPageSpan");
        debug_struct.field("page_start", &self.page_start);
        debug_struct.field("page_end", &self.page_end);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::document_layout_block::LayoutTextBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutTextBlock");
        debug_struct.field("text", &self.text);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("blocks", &self.blocks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::document_layout_block::LayoutTableBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutTableBlock");
        debug_struct.field("header_rows", &self.header_rows);
        debug_struct.field("body_rows", &self.body_rows);
        debug_struct.field("caption", &self.caption);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::document_layout_block::LayoutTableRow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutTableRow");
        debug_struct.field("cells", &self.cells);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::document_layout_block::LayoutTableCell {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutTableCell");
        debug_struct.field("blocks", &self.blocks);
        debug_struct.field("row_span", &self.row_span);
        debug_struct.field("col_span", &self.col_span);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::document_layout_block::LayoutListBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutListBlock");
        debug_struct.field("list_entries", &self.list_entries);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::document_layout::document_layout_block::LayoutListEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutListEntry");
        debug_struct.field("blocks", &self.blocks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::ChunkedDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChunkedDocument");
        debug_struct.field("chunks", &self.chunks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::chunked_document::Chunk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Chunk");
        debug_struct.field("chunk_id", &self.chunk_id);
        debug_struct.field("source_block_ids", &self.source_block_ids);
        debug_struct.field("content", &self.content);
        debug_struct.field("page_span", &self.page_span);
        debug_struct.field("page_headers", &self.page_headers);
        debug_struct.field("page_footers", &self.page_footers);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::chunked_document::chunk::ChunkPageSpan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChunkPageSpan");
        debug_struct.field("page_start", &self.page_start);
        debug_struct.field("page_end", &self.page_end);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::chunked_document::chunk::ChunkPageHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChunkPageHeader");
        debug_struct.field("text", &self.text);
        debug_struct.field("page_span", &self.page_span);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document::chunked_document::chunk::ChunkPageFooter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChunkPageFooter");
        debug_struct.field("text", &self.text);
        debug_struct.field("page_span", &self.page_span);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RawDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RawDocument");
        debug_struct.field("content", &self.content);
        debug_struct.field("mime_type", &self.mime_type);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcsDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDocument");
        debug_struct.field("gcs_uri", &self.gcs_uri);
        debug_struct.field("mime_type", &self.mime_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcsDocuments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDocuments");
        debug_struct.field("documents", &self.documents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcsPrefix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsPrefix");
        debug_struct.field("gcs_uri_prefix", &self.gcs_uri_prefix);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchDocumentsInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchDocumentsInputConfig");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DocumentOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DocumentOutputConfig");
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document_output_config::GcsOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsOutputConfig");
        debug_struct.field("gcs_uri", &self.gcs_uri);
        debug_struct.field("field_mask", &self.field_mask);
        debug_struct.field("sharding_config", &self.sharding_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document_output_config::gcs_output_config::ShardingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShardingConfig");
        debug_struct.field("pages_per_shard", &self.pages_per_shard);
        debug_struct.field("pages_overlap", &self.pages_overlap);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OcrConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OcrConfig");
        debug_struct.field("hints", &self.hints);
        debug_struct.field("enable_native_pdf_parsing", &self.enable_native_pdf_parsing);
        debug_struct.field(
            "enable_image_quality_scores",
            &self.enable_image_quality_scores,
        );
        debug_struct.field("advanced_ocr_options", &self.advanced_ocr_options);
        debug_struct.field("enable_symbol", &self.enable_symbol);
        debug_struct.field("compute_style_info", &self.compute_style_info);
        debug_struct.field(
            "disable_character_boxes_detection",
            &self.disable_character_boxes_detection,
        );
        debug_struct.field("premium_features", &self.premium_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ocr_config::Hints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Hints");
        debug_struct.field("language_hints", &self.language_hints);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ocr_config::PremiumFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PremiumFeatures");
        debug_struct.field(
            "enable_selection_mark_detection",
            &self.enable_selection_mark_detection,
        );
        debug_struct.field("compute_style_info", &self.compute_style_info);
        debug_struct.field("enable_math_ocr", &self.enable_math_ocr);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProcessOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessOptions");
        debug_struct.field("ocr_config", &self.ocr_config);
        debug_struct.field("layout_config", &self.layout_config);
        debug_struct.field("schema_override", &self.schema_override);
        debug_struct.field("page_range", &self.page_range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::process_options::LayoutConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LayoutConfig");
        debug_struct.field("chunking_config", &self.chunking_config);
        debug_struct.field("return_images", &self.return_images);
        debug_struct.field("return_bounding_boxes", &self.return_bounding_boxes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::process_options::layout_config::ChunkingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChunkingConfig");
        debug_struct.field("chunk_size", &self.chunk_size);
        debug_struct.field("include_ancestor_headings", &self.include_ancestor_headings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::process_options::IndividualPageSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IndividualPageSelector");
        debug_struct.field("pages", &self.pages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProcessRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("skip_human_review", &self.skip_human_review);
        debug_struct.field("field_mask", &self.field_mask);
        debug_struct.field("process_options", &self.process_options);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("imageless_mode", &self.imageless_mode);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HumanReviewStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HumanReviewStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("human_review_operation", &self.human_review_operation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProcessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessResponse");
        debug_struct.field("document", &self.document);
        debug_struct.field("human_review_status", &self.human_review_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchProcessRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchProcessRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("input_documents", &self.input_documents);
        debug_struct.field("document_output_config", &self.document_output_config);
        debug_struct.field("skip_human_review", &self.skip_human_review);
        debug_struct.field("process_options", &self.process_options);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchProcessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchProcessResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchProcessMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchProcessMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field(
            "individual_process_statuses",
            &self.individual_process_statuses,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::batch_process_metadata::IndividualProcessStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IndividualProcessStatus");
        debug_struct.field("input_gcs_source", &self.input_gcs_source);
        debug_struct.field("status", &self.status);
        debug_struct.field("output_gcs_destination", &self.output_gcs_destination);
        debug_struct.field("human_review_status", &self.human_review_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchProcessorTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchProcessorTypesRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchProcessorTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchProcessorTypesResponse");
        debug_struct.field("processor_types", &self.processor_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProcessorTypesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorTypesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProcessorTypesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorTypesResponse");
        debug_struct.field("processor_types", &self.processor_types);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProcessorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProcessorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorsResponse");
        debug_struct.field("processors", &self.processors);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetProcessorTypeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProcessorTypeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProcessorVersionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorVersionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListProcessorVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProcessorVersionsResponse");
        debug_struct.field("processor_versions", &self.processor_versions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeployProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeployProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployProcessorVersionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeployProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeployProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UndeployProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployProcessorVersionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UndeployProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployProcessorVersionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UndeployProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeployProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateProcessorRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("processor", &self.processor);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteProcessorMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProcessorMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnableProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnableProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnableProcessorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnableProcessorResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnableProcessorMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnableProcessorMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DisableProcessorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisableProcessorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DisableProcessorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisableProcessorResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DisableProcessorMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisableProcessorMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetDefaultProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetDefaultProcessorVersionRequest");
        debug_struct.field("processor", &self.processor);
        debug_struct.field("default_processor_version", &self.default_processor_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetDefaultProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetDefaultProcessorVersionResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetDefaultProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetDefaultProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TrainProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainProcessorVersionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("processor_version", &self.processor_version);
        debug_struct.field("document_schema", &self.document_schema);
        debug_struct.field("input_data", &self.input_data);
        debug_struct.field("base_processor_version", &self.base_processor_version);
        debug_struct.field("processor_flags", &self.processor_flags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::train_processor_version_request::InputData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InputData");
        debug_struct.field("training_documents", &self.training_documents);
        debug_struct.field("test_documents", &self.test_documents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::train_processor_version_request::CustomDocumentExtractionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomDocumentExtractionOptions");
        debug_struct.field("training_method", &self.training_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::train_processor_version_request::FoundationModelTuningOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FoundationModelTuningOptions");
        debug_struct.field("train_steps", &self.train_steps);
        debug_struct.field("learning_rate_multiplier", &self.learning_rate_multiplier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TrainProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainProcessorVersionResponse");
        debug_struct.field("processor_version", &self.processor_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TrainProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrainProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        debug_struct.field(
            "training_dataset_validation",
            &self.training_dataset_validation,
        );
        debug_struct.field("test_dataset_validation", &self.test_dataset_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::train_processor_version_metadata::DatasetValidation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatasetValidation");
        debug_struct.field("document_error_count", &self.document_error_count);
        debug_struct.field("dataset_error_count", &self.dataset_error_count);
        debug_struct.field("document_errors", &self.document_errors);
        debug_struct.field("dataset_errors", &self.dataset_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReviewDocumentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReviewDocumentRequest");
        debug_struct.field("human_review_config", &self.human_review_config);
        debug_struct.field("enable_schema_validation", &self.enable_schema_validation);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("document_schema", &self.document_schema);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReviewDocumentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReviewDocumentResponse");
        debug_struct.field("gcs_destination", &self.gcs_destination);
        debug_struct.field("state", &self.state);
        debug_struct.field("rejection_reason", &self.rejection_reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReviewDocumentOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReviewDocumentOperationMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        debug_struct.field("question_id", &self.question_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EvaluateProcessorVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluateProcessorVersionRequest");
        debug_struct.field("processor_version", &self.processor_version);
        debug_struct.field("evaluation_documents", &self.evaluation_documents);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EvaluateProcessorVersionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluateProcessorVersionMetadata");
        debug_struct.field("common_metadata", &self.common_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EvaluateProcessorVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluateProcessorVersionResponse");
        debug_struct.field("evaluation", &self.evaluation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetEvaluationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEvaluationRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListEvaluationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEvaluationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListEvaluationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEvaluationsResponse");
        debug_struct.field("evaluations", &self.evaluations);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DocumentSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DocumentSchema");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("entity_types", &self.entity_types);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document_schema::EntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityType");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("name", &self.name);
        debug_struct.field("base_types", &self.base_types);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("value_source", &self.value_source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document_schema::entity_type::EnumValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnumValues");
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document_schema::entity_type::Property {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Property");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("occurrence_type", &self.occurrence_type);
        debug_struct.field("method", &self.method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::document_schema::Metadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metadata");
        debug_struct.field("document_splitter", &self.document_splitter);
        debug_struct.field(
            "document_allow_multiple_labels",
            &self.document_allow_multiple_labels,
        );
        debug_struct.field(
            "prefixed_naming_on_properties",
            &self.prefixed_naming_on_properties,
        );
        debug_struct.field("skip_naming_validation", &self.skip_naming_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EvaluationReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvaluationReference");
        debug_struct.field("operation", &self.operation);
        debug_struct.field("evaluation", &self.evaluation);
        debug_struct.field("aggregate_metrics", &self.aggregate_metrics);
        debug_struct.field("aggregate_metrics_exact", &self.aggregate_metrics_exact);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Evaluation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Evaluation");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("document_counters", &self.document_counters);
        debug_struct.field("all_entities_metrics", &self.all_entities_metrics);
        debug_struct.field("entity_metrics", &self.entity_metrics);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::evaluation::Counters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Counters");
        debug_struct.field("input_documents_count", &self.input_documents_count);
        debug_struct.field("invalid_documents_count", &self.invalid_documents_count);
        debug_struct.field("failed_documents_count", &self.failed_documents_count);
        debug_struct.field("evaluated_documents_count", &self.evaluated_documents_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::evaluation::Metrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metrics");
        debug_struct.field("precision", &self.precision);
        debug_struct.field("recall", &self.recall);
        debug_struct.field("f1_score", &self.f1_score);
        debug_struct.field(
            "predicted_occurrences_count",
            &self.predicted_occurrences_count,
        );
        debug_struct.field(
            "ground_truth_occurrences_count",
            &self.ground_truth_occurrences_count,
        );
        debug_struct.field("predicted_document_count", &self.predicted_document_count);
        debug_struct.field(
            "ground_truth_document_count",
            &self.ground_truth_document_count,
        );
        debug_struct.field("true_positives_count", &self.true_positives_count);
        debug_struct.field("false_positives_count", &self.false_positives_count);
        debug_struct.field("false_negatives_count", &self.false_negatives_count);
        debug_struct.field("total_documents_count", &self.total_documents_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::evaluation::ConfidenceLevelMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfidenceLevelMetrics");
        debug_struct.field("confidence_level", &self.confidence_level);
        debug_struct.field("metrics", &self.metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::evaluation::MultiConfidenceMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiConfidenceMetrics");
        debug_struct.field("confidence_level_metrics", &self.confidence_level_metrics);
        debug_struct.field(
            "confidence_level_metrics_exact",
            &self.confidence_level_metrics_exact,
        );
        debug_struct.field("auprc", &self.auprc);
        debug_struct.field(
            "estimated_calibration_error",
            &self.estimated_calibration_error,
        );
        debug_struct.field("auprc_exact", &self.auprc_exact);
        debug_struct.field(
            "estimated_calibration_error_exact",
            &self.estimated_calibration_error_exact,
        );
        debug_struct.field("metrics_type", &self.metrics_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Vertex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vertex");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NormalizedVertex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NormalizedVertex");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BoundingPoly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BoundingPoly");
        debug_struct.field("vertices", &self.vertices);
        debug_struct.field("normalized_vertices", &self.normalized_vertices);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CommonOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommonOperationMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProcessorVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessorVersion");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("document_schema", &self.document_schema);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("latest_evaluation", &self.latest_evaluation);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        debug_struct.field("google_managed", &self.google_managed);
        debug_struct.field("deprecation_info", &self.deprecation_info);
        debug_struct.field("model_type", &self.model_type);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("gen_ai_model_info", &self.gen_ai_model_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::processor_version::DeprecationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeprecationInfo");
        debug_struct.field("deprecation_time", &self.deprecation_time);
        debug_struct.field(
            "replacement_processor_version",
            &self.replacement_processor_version,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::processor_version::GenAiModelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenAiModelInfo");
        debug_struct.field("model_info", &self.model_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::processor_version::gen_ai_model_info::FoundationGenAiModelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FoundationGenAiModelInfo");
        debug_struct.field("finetuning_allowed", &self.finetuning_allowed);
        debug_struct.field(
            "min_train_labeled_documents",
            &self.min_train_labeled_documents,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::processor_version::gen_ai_model_info::CustomGenAiModelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomGenAiModelInfo");
        debug_struct.field("custom_model_type", &self.custom_model_type);
        debug_struct.field("base_processor_version_id", &self.base_processor_version_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProcessorVersionAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessorVersionAlias");
        debug_struct.field("alias", &self.alias);
        debug_struct.field("processor_version", &self.processor_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Processor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Processor");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("default_processor_version", &self.default_processor_version);
        debug_struct.field("processor_version_aliases", &self.processor_version_aliases);
        debug_struct.field("process_endpoint", &self.process_endpoint);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProcessorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProcessorType");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("category", &self.category);
        debug_struct.field("available_locations", &self.available_locations);
        debug_struct.field("allow_creation", &self.allow_creation);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("sample_document_uris", &self.sample_document_uris);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::processor_type::LocationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationInfo");
        debug_struct.field("location_id", &self.location_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
