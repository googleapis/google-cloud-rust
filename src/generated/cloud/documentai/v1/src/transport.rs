// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [DocumentProcessorService](super::stub::DocumentProcessorService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct DocumentProcessorService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for DocumentProcessorService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DocumentProcessorService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl DocumentProcessorService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        #[cfg(google_cloud_unstable_tracing)]
        let tracing_is_enabled = gaxi::options::tracing_enabled(&config);
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        #[cfg(google_cloud_unstable_tracing)]
        let inner = if tracing_is_enabled {
            inner.with_instrumentation(&crate::info::INSTRUMENTATION_CLIENT_INFO)
        } else {
            inner
        };
        Ok(Self { inner })
    }
}

impl super::stub::DocumentProcessorService for DocumentProcessorService {
    async fn process_document(
        &self,
        req: crate::model::ProcessRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ProcessResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:process",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:process";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/{}:process",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:process";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn batch_process_documents(
        &self,
        req: crate::model::BatchProcessRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:batchProcess",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:batchProcess";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/{}:batchProcess",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:batchProcess";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn fetch_processor_types(
        &self,
        req: crate::model::FetchProcessorTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchProcessorTypesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:fetchProcessorTypes",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}:fetchProcessorTypes";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.parent));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_processor_types(
        &self,
        req: crate::model::ListProcessorTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListProcessorTypesResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/processorTypes",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/processorTypes";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.parent));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_processor_type(
        &self,
        req: crate::model::GetProcessorTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ProcessorType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorTypes/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processorTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_processors(
        &self,
        req: crate::model::ListProcessorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListProcessorsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/processors",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/processors";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.parent));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_processor(
        &self,
        req: crate::model::GetProcessorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Processor>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn train_processor_version(
        &self,
        req: crate::model::TrainProcessorVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/processorVersions:train",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/processorVersions:train";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.parent));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_processor_version(
        &self,
        req: crate::model::GetProcessorVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ProcessorVersion>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_processor_versions(
        &self,
        req: crate::model::ListProcessorVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListProcessorVersionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/processorVersions",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/processorVersions";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.parent));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_processor_version(
        &self,
        req: crate::model::DeleteProcessorVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn deploy_processor_version(
        &self,
        req: crate::model::DeployProcessorVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:deploy",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:deploy";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn undeploy_processor_version(
        &self,
        req: crate::model::UndeployProcessorVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:undeploy",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:undeploy";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_processor(
        &self,
        req: crate::model::CreateProcessorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Processor>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/processors",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/processors";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None
                .or(Some(&req.parent))
                .or(req.processor.as_ref().map(|s| &s.default_processor_version));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.processor, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_processor(
        &self,
        req: crate::model::DeleteProcessorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn enable_processor(
        &self,
        req: crate::model::EnableProcessorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:enable",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:enable";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn disable_processor(
        &self,
        req: crate::model::DisableProcessorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:disable",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:disable";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_default_processor_version(
        &self,
        req: crate::model::SetDefaultProcessorVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setDefaultProcessorVersion",
                    try_match(
                        Some(&req).map(|m| &m.processor).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{processor}:setDefaultProcessorVersion";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.processor).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                        ],
                        "processor",
                        "projects/*/locations/*/processors/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None
                .or(Some(&req.processor))
                .or(Some(&req.default_processor_version));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn review_document(
        &self,
        req: crate::model::ReviewDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:reviewDocument",
                    try_match(
                        Some(&req)
                            .map(|m| &m.human_review_config)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/humanReviewConfig")
                        ]
                    )?,
                );
                let path_template = "/v1/{human_review_config}:reviewDocument";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.human_review_config)
                            .map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/humanReviewConfig"),
                        ],
                        "human_review_config",
                        "projects/*/locations/*/processors/*/humanReviewConfig",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.human_review_config));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn evaluate_processor_version(
        &self,
        req: crate::model::EvaluateProcessorVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:evaluateProcessorVersion",
                    try_match(
                        Some(&req).map(|m| &m.processor_version).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{processor_version}:evaluateProcessorVersion";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.processor_version).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "processor_version",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.processor_version));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_evaluation(
        &self,
        req: crate::model::GetEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Evaluation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/evaluations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/evaluations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/processors/*/processorVersions/*/evaluations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.name));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_evaluations(
        &self,
        req: crate::model::ListEvaluationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEvaluationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/evaluations",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/evaluations";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processors/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/processorVersions/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*/processors/*/processorVersions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        #[cfg(google_cloud_unstable_tracing)]
        let options = {
            let resource_name = Option::<&String>::None.or(Some(&req.parent));
            if let Some(rn) = resource_name {
                let full_resource_name = format!("//documentai.googleapis.com/{}", rn);
                gax::options::internal::set_resource_name(options, full_resource_name)
            } else {
                options
            }
        };
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/locations",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/{name}/locations";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/uiv1beta3/{}/locations",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/uiv1beta3/{name}/locations";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "name",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/uiv1beta3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/uiv1beta3/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations")
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder =
                    builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/uiv1beta3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations")
                        ]
                    )?,
                );
                let path_template = "/uiv1beta3/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder =
                    builder.query(&[("returnPartialSuccess", &req.return_partial_success)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations"),
                        ],
                        "name",
                        "projects/*/locations/*/operations",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations"),
                        ],
                        "name",
                        "projects/*/locations/*/operations",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/uiv1beta3/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/uiv1beta3/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:cancel",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:cancel";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/uiv1beta3/{}:cancel",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/uiv1beta3/{name}:cancel";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
