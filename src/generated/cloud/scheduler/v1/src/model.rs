// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for listing jobs using
/// [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs].
///
/// [google.cloud.scheduler.v1.CloudScheduler.ListJobs]: crate::client::CloudScheduler::list_jobs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The location name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID`.
    pub parent: std::string::String,

    /// Requested page size.
    ///
    /// The maximum page size is 500. If unspecified, the page size will
    /// be the maximum. Fewer jobs than requested might be returned,
    /// even if more jobs exist; use next_page_token to determine if more
    /// jobs exist.
    pub page_size: i32,

    /// A token identifying a page of results the server will return. To
    /// request the first page results, page_token must be empty. To
    /// request the next page of results, page_token must be the value of
    /// [next_page_token][google.cloud.scheduler.v1.ListJobsResponse.next_page_token]
    /// returned from the previous call to
    /// [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs].
    ///
    /// [google.cloud.scheduler.v1.CloudScheduler.ListJobs]: crate::client::CloudScheduler::list_jobs
    /// [google.cloud.scheduler.v1.ListJobsResponse.next_page_token]: crate::model::ListJobsResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.ListJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for listing jobs using
/// [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs].
///
/// [google.cloud.scheduler.v1.CloudScheduler.ListJobs]: crate::client::CloudScheduler::list_jobs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// The list of jobs.
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// A token to retrieve next page of results. Pass this value in the
    /// [page_token][google.cloud.scheduler.v1.ListJobsRequest.page_token] field in
    /// the subsequent call to
    /// [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs] to retrieve
    /// the next page of results. If this is empty it indicates that there are no
    /// more results through which to paginate.
    ///
    /// The page token is valid for only 2 hours.
    ///
    /// [google.cloud.scheduler.v1.CloudScheduler.ListJobs]: crate::client::CloudScheduler::list_jobs
    /// [google.cloud.scheduler.v1.ListJobsRequest.page_token]: crate::model::ListJobsRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobs" => Ok(__FieldTag::__jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [GetJob][google.cloud.scheduler.v1.CloudScheduler.GetJob].
///
/// [google.cloud.scheduler.v1.CloudScheduler.GetJob]: crate::client::CloudScheduler::get_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The job name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.GetJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob].
///
/// [google.cloud.scheduler.v1.CloudScheduler.CreateJob]: crate::client::CloudScheduler::create_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateJobRequest {
    /// Required. The location name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID`.
    pub parent: std::string::String,

    /// Required. The job to add. The user can optionally specify a name for the
    /// job in [name][google.cloud.scheduler.v1.Job.name].
    /// [name][google.cloud.scheduler.v1.Job.name] cannot be the same as an
    /// existing job. If a name is not specified then the system will
    /// generate a random unique name that will be returned
    /// ([name][google.cloud.scheduler.v1.Job.name]) in the response.
    ///
    /// [google.cloud.scheduler.v1.Job.name]: crate::model::Job::name
    pub job: std::option::Option<crate::model::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CreateJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::CreateJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.CreateJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "job" => Ok(__FieldTag::__job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
///
/// [google.cloud.scheduler.v1.CloudScheduler.UpdateJob]: crate::client::CloudScheduler::update_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateJobRequest {
    /// Required. The new job properties.
    /// [name][google.cloud.scheduler.v1.Job.name] must be specified.
    ///
    /// Output only fields cannot be modified using UpdateJob.
    /// Any value specified for an output only field will be ignored.
    ///
    /// [google.cloud.scheduler.v1.Job.name]: crate::model::Job::name
    pub job: std::option::Option<crate::model::Job>,

    /// A  mask used to specify which fields of the job are being updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateJobRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateJobRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.UpdateJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "job" => Ok(__FieldTag::__job),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting a job using
/// [DeleteJob][google.cloud.scheduler.v1.CloudScheduler.DeleteJob].
///
/// [google.cloud.scheduler.v1.CloudScheduler.DeleteJob]: crate::client::CloudScheduler::delete_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteJobRequest {
    /// Required. The job name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.DeleteJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [PauseJob][google.cloud.scheduler.v1.CloudScheduler.PauseJob].
///
/// [google.cloud.scheduler.v1.CloudScheduler.PauseJob]: crate::client::CloudScheduler::pause_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseJobRequest {
    /// Required. The job name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.PauseJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ResumeJob][google.cloud.scheduler.v1.CloudScheduler.ResumeJob].
///
/// [google.cloud.scheduler.v1.CloudScheduler.ResumeJob]: crate::client::CloudScheduler::resume_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeJobRequest {
    /// Required. The job name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.ResumeJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for forcing a job to run now using
/// [RunJob][google.cloud.scheduler.v1.CloudScheduler.RunJob].
///
/// [google.cloud.scheduler.v1.CloudScheduler.RunJob]: crate::client::CloudScheduler::run_job
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunJobRequest {
    /// Required. The job name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RunJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.RunJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for a job.
/// The maximum allowed size for a job is 1MB.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Job {
    /// Optionally caller-specified in
    /// [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob], after
    /// which it becomes output only.
    ///
    /// The job name. For example:
    /// `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
    ///
    /// * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), colons (:), or periods (.).
    ///   For more information, see
    ///   [Identifying
    ///   projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
    /// * `LOCATION_ID` is the canonical ID for the job's location.
    ///   The list of available locations can be obtained by calling
    ///   [ListLocations][google.cloud.location.Locations.ListLocations].
    ///   For more information, see <https://cloud.google.com/about/locations/>.
    /// * `JOB_ID` can contain only letters ([A-Za-z]), numbers ([0-9]),
    ///   hyphens (-), or underscores (_). The maximum length is 500 characters.
    ///
    /// [google.cloud.scheduler.v1.CloudScheduler.CreateJob]: crate::client::CloudScheduler::create_job
    pub name: std::string::String,

    /// Optionally caller-specified in
    /// [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob] or
    /// [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
    ///
    /// A human-readable description for the job. This string must not contain
    /// more than 500 characters.
    ///
    /// [google.cloud.scheduler.v1.CloudScheduler.CreateJob]: crate::client::CloudScheduler::create_job
    /// [google.cloud.scheduler.v1.CloudScheduler.UpdateJob]: crate::client::CloudScheduler::update_job
    pub description: std::string::String,

    /// Required, except when used with
    /// [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
    ///
    /// Describes the schedule on which the job will be executed.
    ///
    /// The schedule can be either of the following types:
    ///
    /// * [Crontab](https://en.wikipedia.org/wiki/Cron#Overview)
    /// * English-like
    ///   [schedule](https://cloud.google.com/scheduler/docs/configuring/cron-job-schedules)
    ///
    /// As a general rule, execution `n + 1` of a job will not begin
    /// until execution `n` has finished. Cloud Scheduler will never
    /// allow two simultaneously outstanding executions. For example,
    /// this implies that if the `n+1`th execution is scheduled to run at
    /// 16:00 but the `n`th execution takes until 16:15, the `n+1`th
    /// execution will not start until `16:15`.
    /// A scheduled start time will be delayed if the previous
    /// execution has not ended when its scheduled time occurs.
    ///
    /// If [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] > 0 and
    /// a job attempt fails, the job will be tried a total of
    /// [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] times,
    /// with exponential backoff, until the next scheduled start time. If
    /// retry_count is 0, a job attempt will not be retried if it fails. Instead
    /// the Cloud Scheduler system will wait for the next scheduled execution time.
    /// Setting retry_count to 0 does not prevent failed jobs from running
    /// according to schedule after the failure.
    ///
    /// [google.cloud.scheduler.v1.CloudScheduler.UpdateJob]: crate::client::CloudScheduler::update_job
    /// [google.cloud.scheduler.v1.RetryConfig.retry_count]: crate::model::RetryConfig::retry_count
    pub schedule: std::string::String,

    /// Specifies the time zone to be used in interpreting
    /// [schedule][google.cloud.scheduler.v1.Job.schedule]. The value of this field
    /// must be a time zone name from the [tz
    /// database](http://en.wikipedia.org/wiki/Tz_database).
    ///
    /// Note that some time zones include a provision for
    /// daylight savings time. The rules for daylight saving time are
    /// determined by the chosen tz. For UTC use the string "utc". If a
    /// time zone is not specified, the default will be in UTC (also known
    /// as GMT).
    ///
    /// [google.cloud.scheduler.v1.Job.schedule]: crate::model::Job::schedule
    pub time_zone: std::string::String,

    /// Output only. The creation time of the job.
    pub user_update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the job.
    pub state: crate::model::job::State,

    /// Output only. The response from the target for the last attempted execution.
    pub status: std::option::Option<rpc::model::Status>,

    /// Output only. The next time the job is scheduled. Note that this may be a
    /// retry of a previously failed attempt or the next execution time
    /// according to the schedule.
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the last job attempt started.
    pub last_attempt_time: std::option::Option<wkt::Timestamp>,

    /// Settings that determine the retry behavior.
    pub retry_config: std::option::Option<crate::model::RetryConfig>,

    /// The deadline for job attempts. If the request handler does not respond by
    /// this deadline then the request is cancelled and the attempt is marked as a
    /// `DEADLINE_EXCEEDED` failure. The failed attempt can be viewed in
    /// execution logs. Cloud Scheduler will retry the job according
    /// to the [RetryConfig][google.cloud.scheduler.v1.RetryConfig].
    ///
    /// The default and the allowed values depend on the type of target:
    ///
    /// * For [HTTP targets][google.cloud.scheduler.v1.Job.http_target], the
    ///   default is 3 minutes. The deadline must be in the interval [15 seconds, 30
    ///   minutes].
    ///
    /// * For [App Engine HTTP
    ///   targets][google.cloud.scheduler.v1.Job.app_engine_http_target], 0 indicates
    ///   that the request has the default deadline. The default deadline depends on
    ///   the scaling type of the service: 10 minutes for standard apps with
    ///   automatic scaling, 24 hours for standard apps with manual and basic
    ///   scaling, and 60 minutes for flex apps. If the request deadline is set, it
    ///   must be in the interval [15 seconds, 24 hours 15 seconds].
    ///
    /// * For [Pub/Sub targets][google.cloud.scheduler.v1.Job.pubsub_target], this
    ///   field is ignored.
    ///
    ///
    /// [google.cloud.scheduler.v1.Job.app_engine_http_target]: crate::model::Job::target
    /// [google.cloud.scheduler.v1.Job.http_target]: crate::model::Job::target
    /// [google.cloud.scheduler.v1.Job.pubsub_target]: crate::model::Job::target
    /// [google.cloud.scheduler.v1.RetryConfig]: crate::model::RetryConfig
    pub attempt_deadline: std::option::Option<wkt::Duration>,

    /// Required.
    ///
    /// Delivery settings containing destination and parameters.
    pub target: std::option::Option<crate::model::job::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Job::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Job::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::Job::schedule].
    pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::Job::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [user_update_time][crate::model::Job::user_update_time].
    pub fn set_user_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.user_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_update_time][crate::model::Job::user_update_time].
    pub fn set_or_clear_user_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.user_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Job::state].
    pub fn set_state<T: std::convert::Into<crate::model::job::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Job::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Job::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule_time][crate::model::Job::schedule_time].
    pub fn set_schedule_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_time][crate::model::Job::schedule_time].
    pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_attempt_time][crate::model::Job::last_attempt_time].
    pub fn set_last_attempt_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_attempt_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_attempt_time][crate::model::Job::last_attempt_time].
    pub fn set_or_clear_last_attempt_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_attempt_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retry_config][crate::model::Job::retry_config].
    pub fn set_retry_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RetryConfig>,
    {
        self.retry_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retry_config][crate::model::Job::retry_config].
    pub fn set_or_clear_retry_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RetryConfig>,
    {
        self.retry_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attempt_deadline][crate::model::Job::attempt_deadline].
    pub fn set_attempt_deadline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.attempt_deadline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attempt_deadline][crate::model::Job::attempt_deadline].
    pub fn set_or_clear_attempt_deadline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.attempt_deadline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::Job::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<T: std::convert::Into<std::option::Option<crate::model::job::Target>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::Job::target]
    /// if it holds a `PubsubTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pubsub_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PubsubTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::job::Target::PubsubTarget(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::Job::target]
    /// to hold a `PubsubTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_pubsub_target<T: std::convert::Into<std::boxed::Box<crate::model::PubsubTarget>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(crate::model::job::Target::PubsubTarget(v.into()));
        self
    }

    /// The value of [target][crate::model::Job::target]
    /// if it holds a `AppEngineHttpTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn app_engine_http_target(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AppEngineHttpTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::job::Target::AppEngineHttpTarget(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::Job::target]
    /// to hold a `AppEngineHttpTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_app_engine_http_target<
        T: std::convert::Into<std::boxed::Box<crate::model::AppEngineHttpTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target =
            std::option::Option::Some(crate::model::job::Target::AppEngineHttpTarget(v.into()));
        self
    }

    /// The value of [target][crate::model::Job::target]
    /// if it holds a `HttpTarget`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_target(&self) -> std::option::Option<&std::boxed::Box<crate::model::HttpTarget>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::job::Target::HttpTarget(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::Job::target]
    /// to hold a `HttpTarget`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_http_target<T: std::convert::Into<std::boxed::Box<crate::model::HttpTarget>>>(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(crate::model::job::Target::HttpTarget(v.into()));
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.Job"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __pubsub_target,
            __app_engine_http_target,
            __http_target,
            __schedule,
            __time_zone,
            __user_update_time,
            __state,
            __status,
            __schedule_time,
            __last_attempt_time,
            __retry_config,
            __attempt_deadline,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "pubsubTarget" => Ok(__FieldTag::__pubsub_target),
                            "pubsub_target" => Ok(__FieldTag::__pubsub_target),
                            "appEngineHttpTarget" => Ok(__FieldTag::__app_engine_http_target),
                            "app_engine_http_target" => Ok(__FieldTag::__app_engine_http_target),
                            "httpTarget" => Ok(__FieldTag::__http_target),
                            "http_target" => Ok(__FieldTag::__http_target),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "userUpdateTime" => Ok(__FieldTag::__user_update_time),
                            "user_update_time" => Ok(__FieldTag::__user_update_time),
                            "state" => Ok(__FieldTag::__state),
                            "status" => Ok(__FieldTag::__status),
                            "scheduleTime" => Ok(__FieldTag::__schedule_time),
                            "schedule_time" => Ok(__FieldTag::__schedule_time),
                            "lastAttemptTime" => Ok(__FieldTag::__last_attempt_time),
                            "last_attempt_time" => Ok(__FieldTag::__last_attempt_time),
                            "retryConfig" => Ok(__FieldTag::__retry_config),
                            "retry_config" => Ok(__FieldTag::__retry_config),
                            "attemptDeadline" => Ok(__FieldTag::__attempt_deadline),
                            "attempt_deadline" => Ok(__FieldTag::__attempt_deadline),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pubsub_target => {
                            if !fields.insert(__FieldTag::__pubsub_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.scheduler.v1.Job.pubsub_target, latest field was pubsubTarget",
                                ));
                            }
                            result.target =
                                std::option::Option::Some(crate::model::job::Target::PubsubTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PubsubTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__app_engine_http_target => {
                            if !fields.insert(__FieldTag::__app_engine_http_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_http_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.scheduler.v1.Job.app_engine_http_target, latest field was appEngineHttpTarget",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::job::Target::AppEngineHttpTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AppEngineHttpTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__http_target => {
                            if !fields.insert(__FieldTag::__http_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_target",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.scheduler.v1.Job.http_target, latest field was httpTarget",
                                ));
                            }
                            result.target =
                                std::option::Option::Some(crate::model::job::Target::HttpTarget(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HttpTarget>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_update_time => {
                            if !fields.insert(__FieldTag::__user_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_update_time",
                                ));
                            }
                            result.user_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::job::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__schedule_time => {
                            if !fields.insert(__FieldTag::__schedule_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_time",
                                ));
                            }
                            result.schedule_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_attempt_time => {
                            if !fields.insert(__FieldTag::__last_attempt_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_attempt_time",
                                ));
                            }
                            result.last_attempt_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__retry_config => {
                            if !fields.insert(__FieldTag::__retry_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_config",
                                ));
                            }
                            result.retry_config =
                                map.next_value::<std::option::Option<crate::model::RetryConfig>>()?;
                        }
                        __FieldTag::__attempt_deadline => {
                            if !fields.insert(__FieldTag::__attempt_deadline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempt_deadline",
                                ));
                            }
                            result.attempt_deadline =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Job {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.pubsub_target() {
            state.serialize_entry("pubsubTarget", value)?;
        }
        if let Some(value) = self.app_engine_http_target() {
            state.serialize_entry("appEngineHttpTarget", value)?;
        }
        if let Some(value) = self.http_target() {
            state.serialize_entry("httpTarget", value)?;
        }
        if !self.schedule.is_empty() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.user_update_time.is_some() {
            state.serialize_entry("userUpdateTime", &self.user_update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.schedule_time.is_some() {
            state.serialize_entry("scheduleTime", &self.schedule_time)?;
        }
        if self.last_attempt_time.is_some() {
            state.serialize_entry("lastAttemptTime", &self.last_attempt_time)?;
        }
        if self.retry_config.is_some() {
            state.serialize_entry("retryConfig", &self.retry_config)?;
        }
        if self.attempt_deadline.is_some() {
            state.serialize_entry("attemptDeadline", &self.attempt_deadline)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    /// State of the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// The job is executing normally.
        Enabled,
        /// The job is paused by the user. It will not execute. A user can
        /// intentionally pause the job using
        /// [PauseJobRequest][google.cloud.scheduler.v1.PauseJobRequest].
        ///
        /// [google.cloud.scheduler.v1.PauseJobRequest]: crate::model::PauseJobRequest
        Paused,
        /// The job is disabled by the system due to error. The user
        /// cannot directly set a job to be disabled.
        Disabled,
        /// The job state resulting from a failed
        /// [CloudScheduler.UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob]
        /// operation. To recover a job from this state, retry
        /// [CloudScheduler.UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob]
        /// until a successful response is received.
        ///
        /// [google.cloud.scheduler.v1.CloudScheduler.UpdateJob]: crate::client::CloudScheduler::update_job
        UpdateFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Disabled => std::option::Option::Some(3),
                Self::UpdateFailed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UpdateFailed => std::option::Option::Some("UPDATE_FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Paused,
                3 => Self::Disabled,
                4 => Self::UpdateFailed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "PAUSED" => Self::Paused,
                "DISABLED" => Self::Disabled,
                "UPDATE_FAILED" => Self::UpdateFailed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Disabled => serializer.serialize_i32(3),
                Self::UpdateFailed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.scheduler.v1.Job.State",
            ))
        }
    }

    /// Required.
    ///
    /// Delivery settings containing destination and parameters.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Pub/Sub target.
        PubsubTarget(std::boxed::Box<crate::model::PubsubTarget>),
        /// App Engine HTTP target.
        AppEngineHttpTarget(std::boxed::Box<crate::model::AppEngineHttpTarget>),
        /// HTTP target.
        HttpTarget(std::boxed::Box<crate::model::HttpTarget>),
    }
}

/// Settings that determine the retry behavior.
///
/// By default, if a job does not complete successfully (meaning that
/// an acknowledgement is not received from the handler, then it will be retried
/// with exponential backoff according to the settings in
/// [RetryConfig][google.cloud.scheduler.v1.RetryConfig].
///
/// [google.cloud.scheduler.v1.RetryConfig]: crate::model::RetryConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RetryConfig {
    /// The number of attempts that the system will make to run a job using the
    /// exponential backoff procedure described by
    /// [max_doublings][google.cloud.scheduler.v1.RetryConfig.max_doublings].
    ///
    /// The default value of retry_count is zero.
    ///
    /// If retry_count is 0, a job attempt will not be retried if
    /// it fails. Instead the Cloud Scheduler system will wait for the
    /// next scheduled execution time. Setting retry_count to 0 does not prevent
    /// failed jobs from running according to schedule after the failure.
    ///
    /// If retry_count is set to a non-zero number then Cloud Scheduler
    /// will retry failed attempts, using exponential backoff,
    /// retry_count times, or until the next scheduled execution time,
    /// whichever comes first.
    ///
    /// Values greater than 5 and negative values are not allowed.
    ///
    /// [google.cloud.scheduler.v1.RetryConfig.max_doublings]: crate::model::RetryConfig::max_doublings
    pub retry_count: i32,

    /// The time limit for retrying a failed job, measured from time when an
    /// execution was first attempted. If specified with
    /// [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count], the job
    /// will be retried until both limits are reached.
    ///
    /// The default value for max_retry_duration is zero, which means retry
    /// duration is unlimited.
    ///
    /// [google.cloud.scheduler.v1.RetryConfig.retry_count]: crate::model::RetryConfig::retry_count
    pub max_retry_duration: std::option::Option<wkt::Duration>,

    /// The minimum amount of time to wait before retrying a job after
    /// it fails.
    ///
    /// The default value of this field is 5 seconds.
    pub min_backoff_duration: std::option::Option<wkt::Duration>,

    /// The maximum amount of time to wait before retrying a job after
    /// it fails.
    ///
    /// The default value of this field is 1 hour.
    pub max_backoff_duration: std::option::Option<wkt::Duration>,

    /// The time between retries will double `max_doublings` times.
    ///
    /// A job's retry interval starts at
    /// [min_backoff_duration][google.cloud.scheduler.v1.RetryConfig.min_backoff_duration],
    /// then doubles `max_doublings` times, then increases linearly, and finally
    /// retries at intervals of
    /// [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
    /// up to [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count]
    /// times.
    ///
    /// For example, if
    /// [min_backoff_duration][google.cloud.scheduler.v1.RetryConfig.min_backoff_duration]
    /// is 10s,
    /// [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
    /// is 300s, and `max_doublings` is 3, then the job will first be retried in
    /// 10s. The retry interval will double three times, and then increase linearly
    /// by 2^3 * 10s.  Finally, the job will retry at intervals of
    /// [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
    /// until the job has been attempted
    /// [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] times.
    /// Thus, the requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s,
    /// 300s, ....
    ///
    /// The default value of this field is 5.
    ///
    /// [google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]: crate::model::RetryConfig::max_backoff_duration
    /// [google.cloud.scheduler.v1.RetryConfig.min_backoff_duration]: crate::model::RetryConfig::min_backoff_duration
    /// [google.cloud.scheduler.v1.RetryConfig.retry_count]: crate::model::RetryConfig::retry_count
    pub max_doublings: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RetryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retry_count][crate::model::RetryConfig::retry_count].
    pub fn set_retry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retry_count = v.into();
        self
    }

    /// Sets the value of [max_retry_duration][crate::model::RetryConfig::max_retry_duration].
    pub fn set_max_retry_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_retry_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_retry_duration][crate::model::RetryConfig::max_retry_duration].
    pub fn set_or_clear_max_retry_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_retry_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_backoff_duration][crate::model::RetryConfig::min_backoff_duration].
    pub fn set_min_backoff_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_backoff_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_backoff_duration][crate::model::RetryConfig::min_backoff_duration].
    pub fn set_or_clear_min_backoff_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.min_backoff_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_backoff_duration][crate::model::RetryConfig::max_backoff_duration].
    pub fn set_max_backoff_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_backoff_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_backoff_duration][crate::model::RetryConfig::max_backoff_duration].
    pub fn set_or_clear_max_backoff_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_backoff_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_doublings][crate::model::RetryConfig::max_doublings].
    pub fn set_max_doublings<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_doublings = v.into();
        self
    }
}

impl wkt::message::Message for RetryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.RetryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RetryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retry_count,
            __max_retry_duration,
            __min_backoff_duration,
            __max_backoff_duration,
            __max_doublings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RetryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retryCount" => Ok(__FieldTag::__retry_count),
                            "retry_count" => Ok(__FieldTag::__retry_count),
                            "maxRetryDuration" => Ok(__FieldTag::__max_retry_duration),
                            "max_retry_duration" => Ok(__FieldTag::__max_retry_duration),
                            "minBackoffDuration" => Ok(__FieldTag::__min_backoff_duration),
                            "min_backoff_duration" => Ok(__FieldTag::__min_backoff_duration),
                            "maxBackoffDuration" => Ok(__FieldTag::__max_backoff_duration),
                            "max_backoff_duration" => Ok(__FieldTag::__max_backoff_duration),
                            "maxDoublings" => Ok(__FieldTag::__max_doublings),
                            "max_doublings" => Ok(__FieldTag::__max_doublings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RetryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RetryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retry_count => {
                            if !fields.insert(__FieldTag::__retry_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retry_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_retry_duration => {
                            if !fields.insert(__FieldTag::__max_retry_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_retry_duration",
                                ));
                            }
                            result.max_retry_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__min_backoff_duration => {
                            if !fields.insert(__FieldTag::__min_backoff_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_backoff_duration",
                                ));
                            }
                            result.min_backoff_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_backoff_duration => {
                            if !fields.insert(__FieldTag::__max_backoff_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_backoff_duration",
                                ));
                            }
                            result.max_backoff_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__max_doublings => {
                            if !fields.insert(__FieldTag::__max_doublings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_doublings",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_doublings =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RetryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.retry_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retryCount", &__With(&self.retry_count))?;
        }
        if self.max_retry_duration.is_some() {
            state.serialize_entry("maxRetryDuration", &self.max_retry_duration)?;
        }
        if self.min_backoff_duration.is_some() {
            state.serialize_entry("minBackoffDuration", &self.min_backoff_duration)?;
        }
        if self.max_backoff_duration.is_some() {
            state.serialize_entry("maxBackoffDuration", &self.max_backoff_duration)?;
        }
        if !wkt::internal::is_default(&self.max_doublings) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxDoublings", &__With(&self.max_doublings))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Http target. The job will be pushed to the job handler by means of
/// an HTTP request via an
/// [http_method][google.cloud.scheduler.v1.HttpTarget.http_method] such as HTTP
/// POST, HTTP GET, etc. The job is acknowledged by means of an HTTP
/// response code in the range [200 - 299]. A failure to receive a response
/// constitutes a failed execution. For a redirected request, the response
/// returned by the redirected request is considered.
///
/// [google.cloud.scheduler.v1.HttpTarget.http_method]: crate::model::HttpTarget::http_method
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpTarget {
    /// Required. The full URI path that the request will be sent to. This string
    /// must begin with either "http://" or "https://". Some examples of
    /// valid values for [uri][google.cloud.scheduler.v1.HttpTarget.uri] are:
    /// `<http://acme.com>` and `<https://acme.com/sales:8080>`. Cloud Scheduler will
    /// encode some characters for safety and compatibility. The maximum allowed
    /// URL length is 2083 characters after encoding.
    ///
    /// [google.cloud.scheduler.v1.HttpTarget.uri]: crate::model::HttpTarget::uri
    pub uri: std::string::String,

    /// Which HTTP method to use for the request.
    pub http_method: crate::model::HttpMethod,

    /// HTTP request headers.
    ///
    /// This map contains the header field names and values.
    ///
    /// The user can specify HTTP request headers to send with the job's
    /// HTTP request. Repeated headers are not supported, but a header value can
    /// contain commas.
    ///
    /// The following headers represent a subset of the headers
    /// that accompany the job's HTTP request. Some HTTP request
    /// headers are ignored or replaced. A partial list of headers that
    /// are ignored or replaced is below:
    ///
    /// * Host: This will be computed by Cloud Scheduler and derived from
    ///   [uri][google.cloud.scheduler.v1.HttpTarget.uri].
    /// * `Content-Length`: This will be computed by Cloud Scheduler.
    /// * `User-Agent`: This will be set to `"Google-Cloud-Scheduler"`.
    /// * `X-Google-*`: Google internal use only.
    /// * `X-AppEngine-*`: Google internal use only.
    /// * `X-CloudScheduler`: This header will be set to true.
    /// * `X-CloudScheduler-JobName`: This header will contain the job name.
    /// * `X-CloudScheduler-ScheduleTime`: For Cloud Scheduler jobs specified in
    ///   the unix-cron format, this header will contain the job schedule as an
    ///   offset of UTC parsed according to RFC3339.
    ///
    /// If the job has a [body][google.cloud.scheduler.v1.HttpTarget.body] and the
    /// following headers are not set by the user, Cloud Scheduler sets default
    /// values:
    ///
    /// * `Content-Type`: This will be set to `"application/octet-stream"`. You
    ///   can override this default by explicitly setting `Content-Type` to a
    ///   particular media type when creating the job. For example, you can set
    ///   `Content-Type` to `"application/json"`.
    ///
    /// The total size of headers must be less than 80KB.
    ///
    /// [google.cloud.scheduler.v1.HttpTarget.body]: crate::model::HttpTarget::body
    /// [google.cloud.scheduler.v1.HttpTarget.uri]: crate::model::HttpTarget::uri
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// HTTP request body. A request body is allowed only if the HTTP
    /// method is POST, PUT, or PATCH. It is an error to set body on a job with an
    /// incompatible [HttpMethod][google.cloud.scheduler.v1.HttpMethod].
    ///
    /// [google.cloud.scheduler.v1.HttpMethod]: crate::model::HttpMethod
    pub body: ::bytes::Bytes,

    /// The mode for generating an `Authorization` header for HTTP requests.
    ///
    /// If specified, all `Authorization` headers in the
    /// [HttpTarget.headers][google.cloud.scheduler.v1.HttpTarget.headers] field
    /// will be overridden.
    ///
    /// [google.cloud.scheduler.v1.HttpTarget.headers]: crate::model::HttpTarget::headers
    pub authorization_header: std::option::Option<crate::model::http_target::AuthorizationHeader>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::HttpTarget::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [http_method][crate::model::HttpTarget::http_method].
    pub fn set_http_method<T: std::convert::Into<crate::model::HttpMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::HttpTarget::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [body][crate::model::HttpTarget::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [authorization_header][crate::model::HttpTarget::authorization_header].
    ///
    /// Note that all the setters affecting `authorization_header` are mutually
    /// exclusive.
    pub fn set_authorization_header<
        T: std::convert::Into<std::option::Option<crate::model::http_target::AuthorizationHeader>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = v.into();
        self
    }

    /// The value of [authorization_header][crate::model::HttpTarget::authorization_header]
    /// if it holds a `OauthToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oauth_token(&self) -> std::option::Option<&std::boxed::Box<crate::model::OAuthToken>> {
        #[allow(unreachable_patterns)]
        self.authorization_header.as_ref().and_then(|v| match v {
            crate::model::http_target::AuthorizationHeader::OauthToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authorization_header][crate::model::HttpTarget::authorization_header]
    /// to hold a `OauthToken`.
    ///
    /// Note that all the setters affecting `authorization_header` are
    /// mutually exclusive.
    pub fn set_oauth_token<T: std::convert::Into<std::boxed::Box<crate::model::OAuthToken>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = std::option::Option::Some(
            crate::model::http_target::AuthorizationHeader::OauthToken(v.into()),
        );
        self
    }

    /// The value of [authorization_header][crate::model::HttpTarget::authorization_header]
    /// if it holds a `OidcToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oidc_token(&self) -> std::option::Option<&std::boxed::Box<crate::model::OidcToken>> {
        #[allow(unreachable_patterns)]
        self.authorization_header.as_ref().and_then(|v| match v {
            crate::model::http_target::AuthorizationHeader::OidcToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authorization_header][crate::model::HttpTarget::authorization_header]
    /// to hold a `OidcToken`.
    ///
    /// Note that all the setters affecting `authorization_header` are
    /// mutually exclusive.
    pub fn set_oidc_token<T: std::convert::Into<std::boxed::Box<crate::model::OidcToken>>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_header = std::option::Option::Some(
            crate::model::http_target::AuthorizationHeader::OidcToken(v.into()),
        );
        self
    }
}

impl wkt::message::Message for HttpTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.HttpTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __http_method,
            __headers,
            __body,
            __oauth_token,
            __oidc_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "httpMethod" => Ok(__FieldTag::__http_method),
                            "http_method" => Ok(__FieldTag::__http_method),
                            "headers" => Ok(__FieldTag::__headers),
                            "body" => Ok(__FieldTag::__body),
                            "oauthToken" => Ok(__FieldTag::__oauth_token),
                            "oauth_token" => Ok(__FieldTag::__oauth_token),
                            "oidcToken" => Ok(__FieldTag::__oidc_token),
                            "oidc_token" => Ok(__FieldTag::__oidc_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__http_method => {
                            if !fields.insert(__FieldTag::__http_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_method",
                                ));
                            }
                            result.http_method = map
                                .next_value::<std::option::Option<crate::model::HttpMethod>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.body = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oauth_token => {
                            if !fields.insert(__FieldTag::__oauth_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_token",
                                ));
                            }
                            if result.authorization_header.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authorization_header`, a oneof with full ID .google.cloud.scheduler.v1.HttpTarget.oauth_token, latest field was oauthToken",
                                ));
                            }
                            result.authorization_header = std::option::Option::Some(
                                crate::model::http_target::AuthorizationHeader::OauthToken(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OAuthToken>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oidc_token => {
                            if !fields.insert(__FieldTag::__oidc_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oidc_token",
                                ));
                            }
                            if result.authorization_header.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authorization_header`, a oneof with full ID .google.cloud.scheduler.v1.HttpTarget.oidc_token, latest field was oidcToken",
                                ));
                            }
                            result.authorization_header = std::option::Option::Some(
                                crate::model::http_target::AuthorizationHeader::OidcToken(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OidcToken>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.http_method) {
            state.serialize_entry("httpMethod", &self.http_method)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.body.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("body", &__With(&self.body))?;
        }
        if let Some(value) = self.oauth_token() {
            state.serialize_entry("oauthToken", value)?;
        }
        if let Some(value) = self.oidc_token() {
            state.serialize_entry("oidcToken", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [HttpTarget].
pub mod http_target {
    #[allow(unused_imports)]
    use super::*;

    /// The mode for generating an `Authorization` header for HTTP requests.
    ///
    /// If specified, all `Authorization` headers in the
    /// [HttpTarget.headers][google.cloud.scheduler.v1.HttpTarget.headers] field
    /// will be overridden.
    ///
    /// [google.cloud.scheduler.v1.HttpTarget.headers]: crate::model::HttpTarget::headers
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthorizationHeader {
        /// If specified, an
        /// [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
        /// will be generated and attached as an `Authorization` header in the HTTP
        /// request.
        ///
        /// This type of authorization should generally only be used when calling
        /// Google APIs hosted on *.googleapis.com.
        OauthToken(std::boxed::Box<crate::model::OAuthToken>),
        /// If specified, an
        /// [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
        /// token will be generated and attached as an `Authorization` header in the
        /// HTTP request.
        ///
        /// This type of authorization can be used for many scenarios, including
        /// calling Cloud Run, or endpoints where you intend to validate the token
        /// yourself.
        OidcToken(std::boxed::Box<crate::model::OidcToken>),
    }
}

/// App Engine target. The job will be pushed to a job handler by means
/// of an HTTP request via an
/// [http_method][google.cloud.scheduler.v1.AppEngineHttpTarget.http_method] such
/// as HTTP POST, HTTP GET, etc. The job is acknowledged by means of an
/// HTTP response code in the range [200 - 299]. Error 503 is
/// considered an App Engine system error instead of an application
/// error. Requests returning error 503 will be retried regardless of
/// retry configuration and not counted against retry counts. Any other
/// response code, or a failure to receive a response before the
/// deadline, constitutes a failed attempt.
///
/// [google.cloud.scheduler.v1.AppEngineHttpTarget.http_method]: crate::model::AppEngineHttpTarget::http_method
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AppEngineHttpTarget {
    /// The HTTP method to use for the request. PATCH and OPTIONS are not
    /// permitted.
    pub http_method: crate::model::HttpMethod,

    /// App Engine Routing setting for the job.
    pub app_engine_routing: std::option::Option<crate::model::AppEngineRouting>,

    /// The relative URI.
    ///
    /// The relative URL must begin with "/" and must be a valid HTTP relative URL.
    /// It can contain a path, query string arguments, and `#` fragments.
    /// If the relative URL is empty, then the root path "/" will be used.
    /// No spaces are allowed, and the maximum length allowed is 2083 characters.
    pub relative_uri: std::string::String,

    /// HTTP request headers.
    ///
    /// This map contains the header field names and values. Headers can be set
    /// when the job is created.
    ///
    /// Cloud Scheduler sets some headers to default values:
    ///
    /// * `User-Agent`: By default, this header is
    ///   `"AppEngine-Google; (+<http://code.google.com/appengine>)"`.
    ///   This header can be modified, but Cloud Scheduler will append
    ///   `"AppEngine-Google; (+<http://code.google.com/appengine>)"` to the
    ///   modified `User-Agent`.
    /// * `X-CloudScheduler`: This header will be set to true.
    /// * `X-CloudScheduler-JobName`: This header will contain the job name.
    /// * `X-CloudScheduler-ScheduleTime`: For Cloud Scheduler jobs specified in
    ///   the unix-cron format, this header will contain the job schedule as an
    ///   offset of UTC parsed according to RFC3339.
    ///
    /// If the job has a [body][google.cloud.scheduler.v1.AppEngineHttpTarget.body]
    /// and the following headers are not set by the user, Cloud Scheduler sets
    /// default values:
    ///
    /// * `Content-Type`: This will be set to `"application/octet-stream"`. You
    ///   can override this default by explicitly setting `Content-Type` to a
    ///   particular media type when creating the job. For example, you can set
    ///   `Content-Type` to `"application/json"`.
    ///
    /// The headers below are output only. They cannot be set or overridden:
    ///
    /// * `Content-Length`: This is computed by Cloud Scheduler.
    /// * `X-Google-*`: For Google internal use only.
    /// * `X-AppEngine-*`: For Google internal use only.
    ///
    /// In addition, some App Engine headers, which contain
    /// job-specific information, are also be sent to the job handler.
    ///
    /// [google.cloud.scheduler.v1.AppEngineHttpTarget.body]: crate::model::AppEngineHttpTarget::body
    pub headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// Body.
    ///
    /// HTTP request body. A request body is allowed only if the HTTP method is
    /// POST or PUT. It will result in invalid argument error to set a body on a
    /// job with an incompatible
    /// [HttpMethod][google.cloud.scheduler.v1.HttpMethod].
    ///
    /// [google.cloud.scheduler.v1.HttpMethod]: crate::model::HttpMethod
    pub body: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppEngineHttpTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_method][crate::model::AppEngineHttpTarget::http_method].
    pub fn set_http_method<T: std::convert::Into<crate::model::HttpMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.http_method = v.into();
        self
    }

    /// Sets the value of [app_engine_routing][crate::model::AppEngineHttpTarget::app_engine_routing].
    pub fn set_app_engine_routing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppEngineRouting>,
    {
        self.app_engine_routing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_engine_routing][crate::model::AppEngineHttpTarget::app_engine_routing].
    pub fn set_or_clear_app_engine_routing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppEngineRouting>,
    {
        self.app_engine_routing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [relative_uri][crate::model::AppEngineHttpTarget::relative_uri].
    pub fn set_relative_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_uri = v.into();
        self
    }

    /// Sets the value of [headers][crate::model::AppEngineHttpTarget::headers].
    pub fn set_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [body][crate::model::AppEngineHttpTarget::body].
    pub fn set_body<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }
}

impl wkt::message::Message for AppEngineHttpTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.AppEngineHttpTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppEngineHttpTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_method,
            __app_engine_routing,
            __relative_uri,
            __headers,
            __body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineHttpTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpMethod" => Ok(__FieldTag::__http_method),
                            "http_method" => Ok(__FieldTag::__http_method),
                            "appEngineRouting" => Ok(__FieldTag::__app_engine_routing),
                            "app_engine_routing" => Ok(__FieldTag::__app_engine_routing),
                            "relativeUri" => Ok(__FieldTag::__relative_uri),
                            "relative_uri" => Ok(__FieldTag::__relative_uri),
                            "headers" => Ok(__FieldTag::__headers),
                            "body" => Ok(__FieldTag::__body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppEngineHttpTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineHttpTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_method => {
                            if !fields.insert(__FieldTag::__http_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_method",
                                ));
                            }
                            result.http_method = map
                                .next_value::<std::option::Option<crate::model::HttpMethod>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_engine_routing => {
                            if !fields.insert(__FieldTag::__app_engine_routing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_engine_routing",
                                ));
                            }
                            result.app_engine_routing = map
                                .next_value::<std::option::Option<crate::model::AppEngineRouting>>(
                                )?;
                        }
                        __FieldTag::__relative_uri => {
                            if !fields.insert(__FieldTag::__relative_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_uri",
                                ));
                            }
                            result.relative_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headers => {
                            if !fields.insert(__FieldTag::__headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headers",
                                ));
                            }
                            result.headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__body => {
                            if !fields.insert(__FieldTag::__body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for body",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.body = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppEngineHttpTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.http_method) {
            state.serialize_entry("httpMethod", &self.http_method)?;
        }
        if self.app_engine_routing.is_some() {
            state.serialize_entry("appEngineRouting", &self.app_engine_routing)?;
        }
        if !self.relative_uri.is_empty() {
            state.serialize_entry("relativeUri", &self.relative_uri)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if !self.body.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("body", &__With(&self.body))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Pub/Sub target. The job will be delivered by publishing a message to
/// the given Pub/Sub topic.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PubsubTarget {
    /// Required. The name of the Cloud Pub/Sub topic to which messages will
    /// be published when a job is delivered. The topic name must be in the
    /// same format as required by Pub/Sub's
    /// [PublishRequest.name](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#publishrequest),
    /// for example `projects/PROJECT_ID/topics/TOPIC_ID`.
    ///
    /// The topic must be in the same project as the Cloud Scheduler job.
    pub topic_name: std::string::String,

    /// The message payload for PubsubMessage.
    ///
    /// Pubsub message must contain either non-empty data, or at least one
    /// attribute.
    pub data: ::bytes::Bytes,

    /// Attributes for PubsubMessage.
    ///
    /// Pubsub message must contain either non-empty data, or at least one
    /// attribute.
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PubsubTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic_name][crate::model::PubsubTarget::topic_name].
    pub fn set_topic_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic_name = v.into();
        self
    }

    /// Sets the value of [data][crate::model::PubsubTarget::data].
    pub fn set_data<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::PubsubTarget::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PubsubTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.PubsubTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PubsubTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic_name,
            __data,
            __attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PubsubTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topicName" => Ok(__FieldTag::__topic_name),
                            "topic_name" => Ok(__FieldTag::__topic_name),
                            "data" => Ok(__FieldTag::__data),
                            "attributes" => Ok(__FieldTag::__attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PubsubTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PubsubTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic_name => {
                            if !fields.insert(__FieldTag::__topic_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic_name",
                                ));
                            }
                            result.topic_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data => {
                            if !fields.insert(__FieldTag::__data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PubsubTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic_name.is_empty() {
            state.serialize_entry("topicName", &self.topic_name)?;
        }
        if !self.data.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("data", &__With(&self.data))?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// App Engine Routing.
///
/// For more information about services, versions, and instances see
/// [An Overview of App
/// Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
/// [Microservices Architecture on Google App
/// Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
/// [App Engine Standard request
/// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
/// and [App Engine Flex request
/// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AppEngineRouting {
    /// App service.
    ///
    /// By default, the job is sent to the service which is the default
    /// service when the job is attempted.
    pub service: std::string::String,

    /// App version.
    ///
    /// By default, the job is sent to the version which is the default
    /// version when the job is attempted.
    pub version: std::string::String,

    /// App instance.
    ///
    /// By default, the job is sent to an instance which is available when
    /// the job is attempted.
    ///
    /// Requests can only be sent to a specific instance if
    /// [manual scaling is used in App Engine
    /// Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?#scaling_types_and_instance_classes).
    /// App Engine Flex does not support instances. For more information, see
    /// [App Engine Standard request
    /// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
    /// and [App Engine Flex request
    /// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
    pub instance: std::string::String,

    /// Output only. The host that the job is sent to.
    ///
    /// For more information about how App Engine requests are routed, see
    /// [here](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
    ///
    /// The host is constructed as:
    ///
    /// * `host = [application_domain_name]`\</br\>
    ///   `| [service] + '.' + [application_domain_name]`\</br\>
    ///   `| [version] + '.' + [application_domain_name]`\</br\>
    ///   `| [version_dot_service]+ '.' + [application_domain_name]`\</br\>
    ///   `| [instance] + '.' + [application_domain_name]`\</br\>
    ///   `| [instance_dot_service] + '.' + [application_domain_name]`\</br\>
    ///   `| [instance_dot_version] + '.' + [application_domain_name]`\</br\>
    ///   `| [instance_dot_version_dot_service] + '.' + [application_domain_name]`
    ///
    /// * `application_domain_name` = The domain name of the app, for
    ///   example \<app-id\>.appspot.com, which is associated with the
    ///   job's project ID.
    ///
    /// * `service =` [service][google.cloud.scheduler.v1.AppEngineRouting.service]
    ///
    /// * `version =` [version][google.cloud.scheduler.v1.AppEngineRouting.version]
    ///
    /// * `version_dot_service =`
    ///   [version][google.cloud.scheduler.v1.AppEngineRouting.version] `+ '.' +`
    ///   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
    ///
    /// * `instance =`
    ///   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance]
    ///
    /// * `instance_dot_service =`
    ///   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
    ///   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
    ///
    /// * `instance_dot_version =`
    ///   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
    ///   [version][google.cloud.scheduler.v1.AppEngineRouting.version]
    ///
    /// * `instance_dot_version_dot_service =`
    ///   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
    ///   [version][google.cloud.scheduler.v1.AppEngineRouting.version] `+ '.' +`
    ///   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
    ///
    ///
    /// If [service][google.cloud.scheduler.v1.AppEngineRouting.service] is empty,
    /// then the job will be sent to the service which is the default service when
    /// the job is attempted.
    ///
    /// If [version][google.cloud.scheduler.v1.AppEngineRouting.version] is empty,
    /// then the job will be sent to the version which is the default version when
    /// the job is attempted.
    ///
    /// If [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] is
    /// empty, then the job will be sent to an instance which is available when the
    /// job is attempted.
    ///
    /// If [service][google.cloud.scheduler.v1.AppEngineRouting.service],
    /// [version][google.cloud.scheduler.v1.AppEngineRouting.version], or
    /// [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] is invalid,
    /// then the job will be sent to the default version of the default service
    /// when the job is attempted.
    ///
    /// [google.cloud.scheduler.v1.AppEngineRouting.instance]: crate::model::AppEngineRouting::instance
    /// [google.cloud.scheduler.v1.AppEngineRouting.service]: crate::model::AppEngineRouting::service
    /// [google.cloud.scheduler.v1.AppEngineRouting.version]: crate::model::AppEngineRouting::version
    pub host: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppEngineRouting {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::AppEngineRouting::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AppEngineRouting::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::AppEngineRouting::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [host][crate::model::AppEngineRouting::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for AppEngineRouting {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.AppEngineRouting"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppEngineRouting {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __version,
            __instance,
            __host,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppEngineRouting")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "version" => Ok(__FieldTag::__version),
                            "instance" => Ok(__FieldTag::__instance),
                            "host" => Ok(__FieldTag::__host),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppEngineRouting;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppEngineRouting")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppEngineRouting {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains information needed for generating an
/// [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
/// This type of authorization should generally only be used when calling Google
/// APIs hosted on *.googleapis.com.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OAuthToken {
    /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
    /// to be used for generating OAuth token.
    /// The service account must be within the same project as the job. The caller
    /// must have iam.serviceAccounts.actAs permission for the service account.
    pub service_account_email: std::string::String,

    /// OAuth scope to be used for generating OAuth access token.
    /// If not specified, `https://www.googleapis.com/auth/cloud-platform`
    /// will be used.
    pub scope: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OAuthToken {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_email][crate::model::OAuthToken::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::OAuthToken::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for OAuthToken {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.OAuthToken"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OAuthToken {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account_email,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OAuthToken")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OAuthToken;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OAuthToken")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OAuthToken {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account_email.is_empty() {
            state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains information needed for generating an
/// [OpenID Connect
/// token](https://developers.google.com/identity/protocols/OpenIDConnect).
/// This type of authorization can be used for many scenarios, including
/// calling Cloud Run, or endpoints where you intend to validate the token
/// yourself.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OidcToken {
    /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
    /// to be used for generating OIDC token.
    /// The service account must be within the same project as the job. The caller
    /// must have iam.serviceAccounts.actAs permission for the service account.
    pub service_account_email: std::string::String,

    /// Audience to be used when generating OIDC token. If not specified, the URI
    /// specified in target will be used.
    pub audience: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OidcToken {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account_email][crate::model::OidcToken::service_account_email].
    pub fn set_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_account_email = v.into();
        self
    }

    /// Sets the value of [audience][crate::model::OidcToken::audience].
    pub fn set_audience<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audience = v.into();
        self
    }
}

impl wkt::message::Message for OidcToken {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.scheduler.v1.OidcToken"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OidcToken {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account_email,
            __audience,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OidcToken")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccountEmail" => Ok(__FieldTag::__service_account_email),
                            "service_account_email" => Ok(__FieldTag::__service_account_email),
                            "audience" => Ok(__FieldTag::__audience),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OidcToken;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OidcToken")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account_email => {
                            if !fields.insert(__FieldTag::__service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_email",
                                ));
                            }
                            result.service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audience",
                                ));
                            }
                            result.audience = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OidcToken {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account_email.is_empty() {
            state.serialize_entry("serviceAccountEmail", &self.service_account_email)?;
        }
        if !self.audience.is_empty() {
            state.serialize_entry("audience", &self.audience)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The HTTP method used to execute the job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum HttpMethod {
    /// HTTP method unspecified. Defaults to POST.
    Unspecified,
    /// HTTP POST
    Post,
    /// HTTP GET
    Get,
    /// HTTP HEAD
    Head,
    /// HTTP PUT
    Put,
    /// HTTP DELETE
    Delete,
    /// HTTP PATCH
    Patch,
    /// HTTP OPTIONS
    Options,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [HttpMethod::value] or
    /// [HttpMethod::name].
    UnknownValue(http_method::UnknownValue),
}

#[doc(hidden)]
pub mod http_method {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl HttpMethod {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Post => std::option::Option::Some(1),
            Self::Get => std::option::Option::Some(2),
            Self::Head => std::option::Option::Some(3),
            Self::Put => std::option::Option::Some(4),
            Self::Delete => std::option::Option::Some(5),
            Self::Patch => std::option::Option::Some(6),
            Self::Options => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("HTTP_METHOD_UNSPECIFIED"),
            Self::Post => std::option::Option::Some("POST"),
            Self::Get => std::option::Option::Some("GET"),
            Self::Head => std::option::Option::Some("HEAD"),
            Self::Put => std::option::Option::Some("PUT"),
            Self::Delete => std::option::Option::Some("DELETE"),
            Self::Patch => std::option::Option::Some("PATCH"),
            Self::Options => std::option::Option::Some("OPTIONS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for HttpMethod {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for HttpMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for HttpMethod {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Post,
            2 => Self::Get,
            3 => Self::Head,
            4 => Self::Put,
            5 => Self::Delete,
            6 => Self::Patch,
            7 => Self::Options,
            _ => Self::UnknownValue(http_method::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for HttpMethod {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "HTTP_METHOD_UNSPECIFIED" => Self::Unspecified,
            "POST" => Self::Post,
            "GET" => Self::Get,
            "HEAD" => Self::Head,
            "PUT" => Self::Put,
            "DELETE" => Self::Delete,
            "PATCH" => Self::Patch,
            "OPTIONS" => Self::Options,
            _ => Self::UnknownValue(http_method::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for HttpMethod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Post => serializer.serialize_i32(1),
            Self::Get => serializer.serialize_i32(2),
            Self::Head => serializer.serialize_i32(3),
            Self::Put => serializer.serialize_i32(4),
            Self::Delete => serializer.serialize_i32(5),
            Self::Patch => serializer.serialize_i32(6),
            Self::Options => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for HttpMethod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<HttpMethod>::new(
            ".google.cloud.scheduler.v1.HttpMethod",
        ))
    }
}
