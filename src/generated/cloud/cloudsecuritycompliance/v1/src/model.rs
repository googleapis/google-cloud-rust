// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Framework is a collection of CloudControls which represents
/// industry/GCP/Customer defined
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Framework {
    /// Required. Identifier. The name of the framework.
    /// Format:
    /// organizations/{organization}/locations/{location}/frameworks/{framework_id}
    pub name: std::string::String,

    /// Output only. Major revision of the framework incremented in ascending
    /// order.
    pub major_revision_id: i64,

    /// Optional. Display name of the framework. The maximum length is 200
    /// characters.
    pub display_name: std::string::String,

    /// Optional. The description of the framework. The maximum length is 2000
    /// characters.
    pub description: std::string::String,

    /// Output only. The type of the framework. The default is TYPE_CUSTOM.
    pub r#type: crate::model::framework::FrameworkType,

    /// Optional. The details of the cloud control groups included in the
    /// framework.
    pub cloud_control_group_details:
        std::vec::Vec<crate::model::framework::CloudControlGroupDetails>,

    /// Optional. The details of the cloud controls directly added without any
    /// grouping in the framework.
    pub cloud_control_details: std::vec::Vec<crate::model::CloudControlDetails>,

    /// Optional. The category of the framework.
    pub category: std::vec::Vec<crate::model::FrameworkCategory>,

    /// Output only. cloud providers supported
    pub supported_cloud_providers: std::vec::Vec<crate::model::CloudProvider>,

    /// Output only. target resource types supported by the Framework.
    pub supported_target_resource_types: std::vec::Vec<crate::model::TargetResourceType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Framework {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Framework::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [major_revision_id][crate::model::Framework::major_revision_id].
    pub fn set_major_revision_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.major_revision_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Framework::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Framework::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Framework::type].
    pub fn set_type<T: std::convert::Into<crate::model::framework::FrameworkType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [cloud_control_group_details][crate::model::Framework::cloud_control_group_details].
    pub fn set_cloud_control_group_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::framework::CloudControlGroupDetails>,
    {
        use std::iter::Iterator;
        self.cloud_control_group_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cloud_control_details][crate::model::Framework::cloud_control_details].
    pub fn set_cloud_control_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlDetails>,
    {
        use std::iter::Iterator;
        self.cloud_control_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [category][crate::model::Framework::category].
    pub fn set_category<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FrameworkCategory>,
    {
        use std::iter::Iterator;
        self.category = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_cloud_providers][crate::model::Framework::supported_cloud_providers].
    pub fn set_supported_cloud_providers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudProvider>,
    {
        use std::iter::Iterator;
        self.supported_cloud_providers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [supported_target_resource_types][crate::model::Framework::supported_target_resource_types].
    pub fn set_supported_target_resource_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetResourceType>,
    {
        use std::iter::Iterator;
        self.supported_target_resource_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Framework {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.Framework"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Framework {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __major_revision_id,
            __display_name,
            __description,
            __type,
            __cloud_control_group_details,
            __cloud_control_details,
            __category,
            __supported_cloud_providers,
            __supported_target_resource_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Framework")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "majorRevisionId" => Ok(__FieldTag::__major_revision_id),
                            "major_revision_id" => Ok(__FieldTag::__major_revision_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "type" => Ok(__FieldTag::__type),
                            "cloudControlGroupDetails" => {
                                Ok(__FieldTag::__cloud_control_group_details)
                            }
                            "cloud_control_group_details" => {
                                Ok(__FieldTag::__cloud_control_group_details)
                            }
                            "cloudControlDetails" => Ok(__FieldTag::__cloud_control_details),
                            "cloud_control_details" => Ok(__FieldTag::__cloud_control_details),
                            "category" => Ok(__FieldTag::__category),
                            "supportedCloudProviders" => {
                                Ok(__FieldTag::__supported_cloud_providers)
                            }
                            "supported_cloud_providers" => {
                                Ok(__FieldTag::__supported_cloud_providers)
                            }
                            "supportedTargetResourceTypes" => {
                                Ok(__FieldTag::__supported_target_resource_types)
                            }
                            "supported_target_resource_types" => {
                                Ok(__FieldTag::__supported_target_resource_types)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Framework;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Framework")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__major_revision_id => {
                            if !fields.insert(__FieldTag::__major_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_revision_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.major_revision_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::framework::FrameworkType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cloud_control_group_details => {
                            if !fields.insert(__FieldTag::__cloud_control_group_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_group_details",
                                ));
                            }
                            result.cloud_control_group_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::framework::CloudControlGroupDetails,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_control_details => {
                            if !fields.insert(__FieldTag::__cloud_control_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_details",
                                ));
                            }
                            result.cloud_control_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FrameworkCategory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_cloud_providers => {
                            if !fields.insert(__FieldTag::__supported_cloud_providers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_cloud_providers",
                                ));
                            }
                            result.supported_cloud_providers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloudProvider>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__supported_target_resource_types => {
                            if !fields.insert(__FieldTag::__supported_target_resource_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_target_resource_types",
                                ));
                            }
                            result.supported_target_resource_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TargetResourceType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Framework {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.major_revision_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("majorRevisionId", &__With(&self.major_revision_id))?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.cloud_control_group_details.is_empty() {
            state.serialize_entry(
                "cloudControlGroupDetails",
                &self.cloud_control_group_details,
            )?;
        }
        if !self.cloud_control_details.is_empty() {
            state.serialize_entry("cloudControlDetails", &self.cloud_control_details)?;
        }
        if !self.category.is_empty() {
            state.serialize_entry("category", &self.category)?;
        }
        if !self.supported_cloud_providers.is_empty() {
            state.serialize_entry("supportedCloudProviders", &self.supported_cloud_providers)?;
        }
        if !self.supported_target_resource_types.is_empty() {
            state.serialize_entry(
                "supportedTargetResourceTypes",
                &self.supported_target_resource_types,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Framework {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Framework");
        debug_struct.field("name", &self.name);
        debug_struct.field("major_revision_id", &self.major_revision_id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field(
            "cloud_control_group_details",
            &self.cloud_control_group_details,
        );
        debug_struct.field("cloud_control_details", &self.cloud_control_details);
        debug_struct.field("category", &self.category);
        debug_struct.field("supported_cloud_providers", &self.supported_cloud_providers);
        debug_struct.field(
            "supported_target_resource_types",
            &self.supported_target_resource_types,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Framework].
pub mod framework {
    #[allow(unused_imports)]
    use super::*;

    /// The details of the cloud control group included in the framework.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudControlGroupDetails {
        /// The inline definition will be replaced with a reference to the
        /// CloudControlGroup resource in future.
        pub kind: std::option::Option<crate::model::framework::cloud_control_group_details::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudControlGroupDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::framework::CloudControlGroupDetails::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<
                    std::option::Option<crate::model::framework::cloud_control_group_details::Kind>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::framework::CloudControlGroupDetails::kind]
        /// if it holds a `CloudControlGroup`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cloud_control_group(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::CloudControlGroup>> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::framework::cloud_control_group_details::Kind::CloudControlGroup(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::framework::CloudControlGroupDetails::kind]
        /// to hold a `CloudControlGroup`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_cloud_control_group<
            T: std::convert::Into<std::boxed::Box<crate::model::CloudControlGroup>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::framework::cloud_control_group_details::Kind::CloudControlGroup(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for CloudControlGroupDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.Framework.CloudControlGroupDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudControlGroupDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cloud_control_group,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudControlGroupDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cloudControlGroup" => Ok(__FieldTag::__cloud_control_group),
                                "cloud_control_group" => Ok(__FieldTag::__cloud_control_group),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudControlGroupDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudControlGroupDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cloud_control_group => {
                                if !fields.insert(__FieldTag::__cloud_control_group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_control_group",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.Framework.CloudControlGroupDetails.cloud_control_group, latest field was cloudControlGroup",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::framework::cloud_control_group_details::Kind::CloudControlGroup(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudControlGroup>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudControlGroupDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.cloud_control_group() {
                state.serialize_entry("cloudControlGroup", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CloudControlGroupDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CloudControlGroupDetails");
            debug_struct.field("kind", &self.kind);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [CloudControlGroupDetails].
    pub mod cloud_control_group_details {
        #[allow(unused_imports)]
        use super::*;

        /// The inline definition will be replaced with a reference to the
        /// CloudControlGroup resource in future.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// The cloud control group included in the framework.
            CloudControlGroup(std::boxed::Box<crate::model::CloudControlGroup>),
        }
    }

    /// The type of the framework.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FrameworkType {
        /// Default value. This value is unused.
        Unspecified,
        /// The framework is a built-in framework if it is created and managed by
        /// GCP.
        BuiltIn,
        /// The framework is a custom framework if it is created and managed by the
        /// user.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FrameworkType::value] or
        /// [FrameworkType::name].
        UnknownValue(framework_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod framework_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FrameworkType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BuiltIn => std::option::Option::Some(1),
                Self::Custom => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FRAMEWORK_TYPE_UNSPECIFIED"),
                Self::BuiltIn => std::option::Option::Some("BUILT_IN"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FrameworkType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FrameworkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FrameworkType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BuiltIn,
                2 => Self::Custom,
                _ => Self::UnknownValue(framework_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FrameworkType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FRAMEWORK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BUILT_IN" => Self::BuiltIn,
                "CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(framework_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FrameworkType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BuiltIn => serializer.serialize_i32(1),
                Self::Custom => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FrameworkType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FrameworkType>::new(
                ".google.cloud.cloudsecuritycompliance.v1.Framework.FrameworkType",
            ))
        }
    }
}

/// CloudControlGroup is an optional entity within a Framework that helps
/// customers organize their CloudControls.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudControlGroup {
    /// Required. The name of the cloud control group in the format:
    /// “organizations/{organization}/locations/{location}/
    /// cloudControlGroups/{cloud-control-group}”
    pub name: std::string::String,

    /// Optional. The description of the cloud control group.The maximum length is
    /// 2000 characters.
    pub description: std::string::String,

    /// Optional. Output only. The type of the cloud control group. Default is
    /// TYPE_CUSTOM.
    pub r#type: crate::model::cloud_control_group::CloudControlGroupType,

    /// Optional. The control identifier used to fetch the findings. This is same
    /// as the control report name.
    pub control_id: std::string::String,

    /// Required. The details of the cloud controls to be referred to in the
    /// framework.
    pub cloud_control_details: std::vec::Vec<crate::model::CloudControlDetails>,

    /// Optional. Major revision of the cloud control group.
    pub major_revision_id: i64,

    /// Optional. The industry-defined Control assciated with the cloud controls in
    /// this group.
    /// organizations/{organization}/locations/{location}/controls/{control_id}
    pub control: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudControlGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudControlGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CloudControlGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CloudControlGroup::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::cloud_control_group::CloudControlGroupType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [control_id][crate::model::CloudControlGroup::control_id].
    pub fn set_control_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.control_id = v.into();
        self
    }

    /// Sets the value of [cloud_control_details][crate::model::CloudControlGroup::cloud_control_details].
    pub fn set_cloud_control_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlDetails>,
    {
        use std::iter::Iterator;
        self.cloud_control_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [major_revision_id][crate::model::CloudControlGroup::major_revision_id].
    pub fn set_major_revision_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.major_revision_id = v.into();
        self
    }

    /// Sets the value of [control][crate::model::CloudControlGroup::control].
    pub fn set_control<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.control = v.into();
        self
    }
}

impl wkt::message::Message for CloudControlGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CloudControlGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudControlGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __type,
            __control_id,
            __cloud_control_details,
            __major_revision_id,
            __control,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudControlGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "type" => Ok(__FieldTag::__type),
                            "controlId" => Ok(__FieldTag::__control_id),
                            "control_id" => Ok(__FieldTag::__control_id),
                            "cloudControlDetails" => Ok(__FieldTag::__cloud_control_details),
                            "cloud_control_details" => Ok(__FieldTag::__cloud_control_details),
                            "majorRevisionId" => Ok(__FieldTag::__major_revision_id),
                            "major_revision_id" => Ok(__FieldTag::__major_revision_id),
                            "control" => Ok(__FieldTag::__control),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudControlGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudControlGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_control_group::CloudControlGroupType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_id => {
                            if !fields.insert(__FieldTag::__control_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_id",
                                ));
                            }
                            result.control_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_control_details => {
                            if !fields.insert(__FieldTag::__cloud_control_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_details",
                                ));
                            }
                            result.cloud_control_details = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__major_revision_id => {
                            if !fields.insert(__FieldTag::__major_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_revision_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.major_revision_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__control => {
                            if !fields.insert(__FieldTag::__control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control",
                                ));
                            }
                            result.control = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudControlGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.control_id.is_empty() {
            state.serialize_entry("controlId", &self.control_id)?;
        }
        if !self.cloud_control_details.is_empty() {
            state.serialize_entry("cloudControlDetails", &self.cloud_control_details)?;
        }
        if !wkt::internal::is_default(&self.major_revision_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("majorRevisionId", &__With(&self.major_revision_id))?;
        }
        if !self.control.is_empty() {
            state.serialize_entry("control", &self.control)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudControlGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudControlGroup");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("control_id", &self.control_id);
        debug_struct.field("cloud_control_details", &self.cloud_control_details);
        debug_struct.field("major_revision_id", &self.major_revision_id);
        debug_struct.field("control", &self.control);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudControlGroup].
pub mod cloud_control_group {
    #[allow(unused_imports)]
    use super::*;

    /// CloudControlGroupType is the type of the CloudControlGroup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudControlGroupType {
        /// Default value. This value is unused.
        Unspecified,
        /// The CloudControlGroup is a built-in group provided by GCP.
        BuiltIn,
        /// The CloudControlGroup is a custom group created by the user.
        Custom,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CloudControlGroupType::value] or
        /// [CloudControlGroupType::name].
        UnknownValue(cloud_control_group_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cloud_control_group_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CloudControlGroupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BuiltIn => std::option::Option::Some(1),
                Self::Custom => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CLOUD_CONTROL_GROUP_TYPE_UNSPECIFIED")
                }
                Self::BuiltIn => std::option::Option::Some("BUILT_IN"),
                Self::Custom => std::option::Option::Some("CUSTOM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CloudControlGroupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CloudControlGroupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CloudControlGroupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BuiltIn,
                2 => Self::Custom,
                _ => Self::UnknownValue(cloud_control_group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CloudControlGroupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLOUD_CONTROL_GROUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BUILT_IN" => Self::BuiltIn,
                "CUSTOM" => Self::Custom,
                _ => Self::UnknownValue(cloud_control_group_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CloudControlGroupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BuiltIn => serializer.serialize_i32(1),
                Self::Custom => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CloudControlGroupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudControlGroupType>::new(
                ".google.cloud.cloudsecuritycompliance.v1.CloudControlGroup.CloudControlGroupType",
            ))
        }
    }
}

/// CloudControlDetails contains the details of a CloudControl.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudControlDetails {
    /// Required. The name of the CloudControl in the format:
    /// “organizations/{organization}/locations/{location}/
    /// cloudControls/{cloud-control}”
    pub name: std::string::String,

    /// Required. Major revision of cloudcontrol
    pub major_revision_id: i64,

    /// Optional. Parameters is a key-value pair that is required by the
    /// CloudControl. The specification of these parameters will be present in
    /// cloudcontrol.Eg: { "name": "location","value": "us-west-1"}.
    pub parameters: std::vec::Vec<crate::model::Parameter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudControlDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudControlDetails::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [major_revision_id][crate::model::CloudControlDetails::major_revision_id].
    pub fn set_major_revision_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.major_revision_id = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::CloudControlDetails::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudControlDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CloudControlDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudControlDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __major_revision_id,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudControlDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "majorRevisionId" => Ok(__FieldTag::__major_revision_id),
                            "major_revision_id" => Ok(__FieldTag::__major_revision_id),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudControlDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudControlDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__major_revision_id => {
                            if !fields.insert(__FieldTag::__major_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_revision_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.major_revision_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Parameter>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudControlDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.major_revision_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("majorRevisionId", &__With(&self.major_revision_id))?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudControlDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudControlDetails");
        debug_struct.field("name", &self.name);
        debug_struct.field("major_revision_id", &self.major_revision_id);
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// FrameworkReference contains the reference of a framework.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FrameworkReference {
    /// Required. In the format:
    /// organizations/{org}/locations/{location}/frameworks/{framework}
    pub framework: std::string::String,

    /// Optional. Major revision id of the framework. If not specified, corresponds
    /// to the latest revision of the framework.
    pub major_revision_id: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FrameworkReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [framework][crate::model::FrameworkReference::framework].
    pub fn set_framework<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.framework = v.into();
        self
    }

    /// Sets the value of [major_revision_id][crate::model::FrameworkReference::major_revision_id].
    pub fn set_major_revision_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.major_revision_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [major_revision_id][crate::model::FrameworkReference::major_revision_id].
    pub fn set_or_clear_major_revision_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.major_revision_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FrameworkReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.FrameworkReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FrameworkReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __framework,
            __major_revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FrameworkReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "framework" => Ok(__FieldTag::__framework),
                            "majorRevisionId" => Ok(__FieldTag::__major_revision_id),
                            "major_revision_id" => Ok(__FieldTag::__major_revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FrameworkReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FrameworkReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__framework => {
                            if !fields.insert(__FieldTag::__framework) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework",
                                ));
                            }
                            result.framework = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__major_revision_id => {
                            if !fields.insert(__FieldTag::__major_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_revision_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.major_revision_id = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FrameworkReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.framework.is_empty() {
            state.serialize_entry("framework", &self.framework)?;
        }
        if self.major_revision_id.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("majorRevisionId", &__With(&self.major_revision_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FrameworkReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FrameworkReference");
        debug_struct.field("framework", &self.framework);
        debug_struct.field("major_revision_id", &self.major_revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Parameters is a key-value pair.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Parameter {
    /// Required. The name of the parameter.
    pub name: std::string::String,

    /// Required. The value of the parameter
    pub parameter_value: std::option::Option<std::boxed::Box<crate::model::ParamValue>>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Parameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Parameter::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [parameter_value][crate::model::Parameter::parameter_value].
    pub fn set_parameter_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ParamValue>,
    {
        self.parameter_value = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [parameter_value][crate::model::Parameter::parameter_value].
    pub fn set_or_clear_parameter_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ParamValue>,
    {
        self.parameter_value = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }
}

impl wkt::message::Message for Parameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.Parameter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Parameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __parameter_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Parameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "parameterValue" => Ok(__FieldTag::__parameter_value),
                            "parameter_value" => Ok(__FieldTag::__parameter_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Parameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Parameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameter_value => {
                            if !fields.insert(__FieldTag::__parameter_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_value",
                                ));
                            }
                            result.parameter_value = map.next_value::<std::option::Option<std::boxed::Box<crate::model::ParamValue>>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Parameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.parameter_value.is_some() {
            state.serialize_entry("parameterValue", &self.parameter_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Parameter");
        debug_struct.field("name", &self.name);
        debug_struct.field("parameter_value", &self.parameter_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A CloudControl is a GCP-provided parameterized concept which is used to
/// satisfy a Security or Compliance intent.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudControl {
    /// Required. Identifier. The resource name of the cloud control.
    /// Format:
    /// organizations/{organization}/locations/{location}/cloudControls/{cloud_control_id}
    pub name: std::string::String,

    /// Output only. Major revision of the cloud control incremented in ascending
    /// order.
    pub major_revision_id: i64,

    /// Optional. A description of the cloud control. The maximum length is 2000
    /// characters.
    pub description: std::string::String,

    /// Optional. The display name of the cloud control. The maximum length is 200
    /// characters.
    pub display_name: std::string::String,

    /// Output only. The supported enforcement mode of the cloud control. Default
    /// is DETECTIVE.
    pub supported_enforcement_modes: std::vec::Vec<crate::model::EnforcementMode>,

    /// Optional. The parameter spec of the cloud control.
    pub parameter_spec: std::vec::Vec<crate::model::ParameterSpec>,

    /// Optional. The Policy to be enforced to prevent/detect resource
    /// non-compliance.
    pub rules: std::vec::Vec<crate::model::Rule>,

    /// Optional. The severity of findings generated by the cloud control.
    pub severity: crate::model::Severity,

    /// Optional. The finding_category of the cloud control. The maximum length is
    /// 255 characters.
    pub finding_category: std::string::String,

    /// Optional. cloud providers supported
    pub supported_cloud_providers: std::vec::Vec<crate::model::CloudProvider>,

    /// Output only. The Frameworks that include this CloudControl
    pub related_frameworks: std::vec::Vec<std::string::String>,

    /// Optional. The remediation steps for the findings generated by the cloud
    /// control. The maximum length is 400 characters.
    pub remediation_steps: std::string::String,

    /// Optional. The categories of the cloud control.
    pub categories: std::vec::Vec<crate::model::CloudControlCategory>,

    /// Output only. The last updated time of the cloud control.
    /// The create_time is used because a new CC is created whenever we update an
    /// existing CC.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. target resource types supported by the CloudControl.
    pub supported_target_resource_types: std::vec::Vec<crate::model::TargetResourceType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudControl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudControl::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [major_revision_id][crate::model::CloudControl::major_revision_id].
    pub fn set_major_revision_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.major_revision_id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::CloudControl::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CloudControl::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [supported_enforcement_modes][crate::model::CloudControl::supported_enforcement_modes].
    pub fn set_supported_enforcement_modes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnforcementMode>,
    {
        use std::iter::Iterator;
        self.supported_enforcement_modes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parameter_spec][crate::model::CloudControl::parameter_spec].
    pub fn set_parameter_spec<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ParameterSpec>,
    {
        use std::iter::Iterator;
        self.parameter_spec = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::CloudControl::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Rule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [severity][crate::model::CloudControl::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [finding_category][crate::model::CloudControl::finding_category].
    pub fn set_finding_category<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.finding_category = v.into();
        self
    }

    /// Sets the value of [supported_cloud_providers][crate::model::CloudControl::supported_cloud_providers].
    pub fn set_supported_cloud_providers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudProvider>,
    {
        use std::iter::Iterator;
        self.supported_cloud_providers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_frameworks][crate::model::CloudControl::related_frameworks].
    pub fn set_related_frameworks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_frameworks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [remediation_steps][crate::model::CloudControl::remediation_steps].
    pub fn set_remediation_steps<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.remediation_steps = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::CloudControl::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlCategory>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudControl::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudControl::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [supported_target_resource_types][crate::model::CloudControl::supported_target_resource_types].
    pub fn set_supported_target_resource_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetResourceType>,
    {
        use std::iter::Iterator;
        self.supported_target_resource_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudControl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CloudControl"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudControl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __major_revision_id,
            __description,
            __display_name,
            __supported_enforcement_modes,
            __parameter_spec,
            __rules,
            __severity,
            __finding_category,
            __supported_cloud_providers,
            __related_frameworks,
            __remediation_steps,
            __categories,
            __create_time,
            __supported_target_resource_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudControl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "majorRevisionId" => Ok(__FieldTag::__major_revision_id),
                            "major_revision_id" => Ok(__FieldTag::__major_revision_id),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "supportedEnforcementModes" => {
                                Ok(__FieldTag::__supported_enforcement_modes)
                            }
                            "supported_enforcement_modes" => {
                                Ok(__FieldTag::__supported_enforcement_modes)
                            }
                            "parameterSpec" => Ok(__FieldTag::__parameter_spec),
                            "parameter_spec" => Ok(__FieldTag::__parameter_spec),
                            "rules" => Ok(__FieldTag::__rules),
                            "severity" => Ok(__FieldTag::__severity),
                            "findingCategory" => Ok(__FieldTag::__finding_category),
                            "finding_category" => Ok(__FieldTag::__finding_category),
                            "supportedCloudProviders" => {
                                Ok(__FieldTag::__supported_cloud_providers)
                            }
                            "supported_cloud_providers" => {
                                Ok(__FieldTag::__supported_cloud_providers)
                            }
                            "relatedFrameworks" => Ok(__FieldTag::__related_frameworks),
                            "related_frameworks" => Ok(__FieldTag::__related_frameworks),
                            "remediationSteps" => Ok(__FieldTag::__remediation_steps),
                            "remediation_steps" => Ok(__FieldTag::__remediation_steps),
                            "categories" => Ok(__FieldTag::__categories),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "supportedTargetResourceTypes" => {
                                Ok(__FieldTag::__supported_target_resource_types)
                            }
                            "supported_target_resource_types" => {
                                Ok(__FieldTag::__supported_target_resource_types)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudControl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudControl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__major_revision_id => {
                            if !fields.insert(__FieldTag::__major_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_revision_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.major_revision_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_enforcement_modes => {
                            if !fields.insert(__FieldTag::__supported_enforcement_modes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_enforcement_modes",
                                ));
                            }
                            result.supported_enforcement_modes =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EnforcementMode>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameter_spec => {
                            if !fields.insert(__FieldTag::__parameter_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_spec",
                                ));
                            }
                            result.parameter_spec = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ParameterSpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rules => {
                            if !fields.insert(__FieldTag::__rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules",
                                ));
                            }
                            result.rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Rule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finding_category => {
                            if !fields.insert(__FieldTag::__finding_category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finding_category",
                                ));
                            }
                            result.finding_category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_cloud_providers => {
                            if !fields.insert(__FieldTag::__supported_cloud_providers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_cloud_providers",
                                ));
                            }
                            result.supported_cloud_providers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloudProvider>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__related_frameworks => {
                            if !fields.insert(__FieldTag::__related_frameworks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_frameworks",
                                ));
                            }
                            result.related_frameworks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__remediation_steps => {
                            if !fields.insert(__FieldTag::__remediation_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation_steps",
                                ));
                            }
                            result.remediation_steps = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlCategory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__supported_target_resource_types => {
                            if !fields.insert(__FieldTag::__supported_target_resource_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_target_resource_types",
                                ));
                            }
                            result.supported_target_resource_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TargetResourceType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.major_revision_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("majorRevisionId", &__With(&self.major_revision_id))?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.supported_enforcement_modes.is_empty() {
            state.serialize_entry(
                "supportedEnforcementModes",
                &self.supported_enforcement_modes,
            )?;
        }
        if !self.parameter_spec.is_empty() {
            state.serialize_entry("parameterSpec", &self.parameter_spec)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.finding_category.is_empty() {
            state.serialize_entry("findingCategory", &self.finding_category)?;
        }
        if !self.supported_cloud_providers.is_empty() {
            state.serialize_entry("supportedCloudProviders", &self.supported_cloud_providers)?;
        }
        if !self.related_frameworks.is_empty() {
            state.serialize_entry("relatedFrameworks", &self.related_frameworks)?;
        }
        if !self.remediation_steps.is_empty() {
            state.serialize_entry("remediationSteps", &self.remediation_steps)?;
        }
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.supported_target_resource_types.is_empty() {
            state.serialize_entry(
                "supportedTargetResourceTypes",
                &self.supported_target_resource_types,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudControl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudControl");
        debug_struct.field("name", &self.name);
        debug_struct.field("major_revision_id", &self.major_revision_id);
        debug_struct.field("description", &self.description);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field(
            "supported_enforcement_modes",
            &self.supported_enforcement_modes,
        );
        debug_struct.field("parameter_spec", &self.parameter_spec);
        debug_struct.field("rules", &self.rules);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("finding_category", &self.finding_category);
        debug_struct.field("supported_cloud_providers", &self.supported_cloud_providers);
        debug_struct.field("related_frameworks", &self.related_frameworks);
        debug_struct.field("remediation_steps", &self.remediation_steps);
        debug_struct.field("categories", &self.categories);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field(
            "supported_target_resource_types",
            &self.supported_target_resource_types,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A parameter spec of the cloud control.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ParameterSpec {
    /// Required. The name of the parameter.
    pub name: std::string::String,

    /// Optional. The display name of the parameter. The maximum length is 200
    /// characters.
    pub display_name: std::string::String,

    /// Optional. The description of the parameter. The maximum length is 2000
    /// characters.
    pub description: std::string::String,

    /// Required. if the parameter is required
    pub is_required: bool,

    /// Required. Parameter value type.
    pub value_type: crate::model::parameter_spec::ValueType,

    /// Optional. The default value of the parameter.
    pub default_value: std::option::Option<crate::model::ParamValue>,

    /// Optional. List of parameter substitutions.
    pub substitution_rules: std::vec::Vec<crate::model::ParameterSubstitutionRule>,

    /// Optional. ParameterSpec for oneof attributes.
    pub sub_parameters: std::vec::Vec<crate::model::ParameterSpec>,

    /// Optional. The allowed set of values for the parameter.
    pub validation: std::option::Option<crate::model::Validation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParameterSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ParameterSpec::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ParameterSpec::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ParameterSpec::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [is_required][crate::model::ParameterSpec::is_required].
    pub fn set_is_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_required = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::ParameterSpec::value_type].
    pub fn set_value_type<T: std::convert::Into<crate::model::parameter_spec::ValueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::ParameterSpec::default_value].
    pub fn set_default_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ParamValue>,
    {
        self.default_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_value][crate::model::ParameterSpec::default_value].
    pub fn set_or_clear_default_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ParamValue>,
    {
        self.default_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [substitution_rules][crate::model::ParameterSpec::substitution_rules].
    pub fn set_substitution_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ParameterSubstitutionRule>,
    {
        use std::iter::Iterator;
        self.substitution_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sub_parameters][crate::model::ParameterSpec::sub_parameters].
    pub fn set_sub_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ParameterSpec>,
    {
        use std::iter::Iterator;
        self.sub_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [validation][crate::model::ParameterSpec::validation].
    pub fn set_validation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Validation>,
    {
        self.validation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [validation][crate::model::ParameterSpec::validation].
    pub fn set_or_clear_validation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Validation>,
    {
        self.validation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ParameterSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ParameterSpec"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ParameterSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __is_required,
            __value_type,
            __default_value,
            __substitution_rules,
            __sub_parameters,
            __validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParameterSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "isRequired" => Ok(__FieldTag::__is_required),
                            "is_required" => Ok(__FieldTag::__is_required),
                            "valueType" => Ok(__FieldTag::__value_type),
                            "value_type" => Ok(__FieldTag::__value_type),
                            "defaultValue" => Ok(__FieldTag::__default_value),
                            "default_value" => Ok(__FieldTag::__default_value),
                            "substitutionRules" => Ok(__FieldTag::__substitution_rules),
                            "substitution_rules" => Ok(__FieldTag::__substitution_rules),
                            "subParameters" => Ok(__FieldTag::__sub_parameters),
                            "sub_parameters" => Ok(__FieldTag::__sub_parameters),
                            "validation" => Ok(__FieldTag::__validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ParameterSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParameterSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_required => {
                            if !fields.insert(__FieldTag::__is_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_required",
                                ));
                            }
                            result.is_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value_type => {
                            if !fields.insert(__FieldTag::__value_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_type",
                                ));
                            }
                            result.value_type = map.next_value::<std::option::Option<crate::model::parameter_spec::ValueType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_value => {
                            if !fields.insert(__FieldTag::__default_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_value",
                                ));
                            }
                            result.default_value =
                                map.next_value::<std::option::Option<crate::model::ParamValue>>()?;
                        }
                        __FieldTag::__substitution_rules => {
                            if !fields.insert(__FieldTag::__substitution_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitution_rules",
                                ));
                            }
                            result.substitution_rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ParameterSubstitutionRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sub_parameters => {
                            if !fields.insert(__FieldTag::__sub_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sub_parameters",
                                ));
                            }
                            result.sub_parameters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ParameterSpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__validation => {
                            if !fields.insert(__FieldTag::__validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation",
                                ));
                            }
                            result.validation =
                                map.next_value::<std::option::Option<crate::model::Validation>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ParameterSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.is_required) {
            state.serialize_entry("isRequired", &self.is_required)?;
        }
        if !wkt::internal::is_default(&self.value_type) {
            state.serialize_entry("valueType", &self.value_type)?;
        }
        if self.default_value.is_some() {
            state.serialize_entry("defaultValue", &self.default_value)?;
        }
        if !self.substitution_rules.is_empty() {
            state.serialize_entry("substitutionRules", &self.substitution_rules)?;
        }
        if !self.sub_parameters.is_empty() {
            state.serialize_entry("subParameters", &self.sub_parameters)?;
        }
        if self.validation.is_some() {
            state.serialize_entry("validation", &self.validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ParameterSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParameterSpec");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("is_required", &self.is_required);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("default_value", &self.default_value);
        debug_struct.field("substitution_rules", &self.substitution_rules);
        debug_struct.field("sub_parameters", &self.sub_parameters);
        debug_struct.field("validation", &self.validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ParameterSpec].
pub mod parameter_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the parameter value.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// Default value. This value is unused.
        Unspecified,
        /// String value.
        String,
        /// Boolean value.
        Boolean,
        /// String list value.
        Stringlist,
        /// Numeric value.
        Number,
        /// OneOf value.
        Oneof,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(3),
                Self::Boolean => std::option::Option::Some(4),
                Self::Stringlist => std::option::Option::Some(5),
                Self::Number => std::option::Option::Some(6),
                Self::Oneof => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Boolean => std::option::Option::Some("BOOLEAN"),
                Self::Stringlist => std::option::Option::Some("STRINGLIST"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Oneof => std::option::Option::Some("ONEOF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                3 => Self::String,
                4 => Self::Boolean,
                5 => Self::Stringlist,
                6 => Self::Number,
                7 => Self::Oneof,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "BOOLEAN" => Self::Boolean,
                "STRINGLIST" => Self::Stringlist,
                "NUMBER" => Self::Number,
                "ONEOF" => Self::Oneof,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(3),
                Self::Boolean => serializer.serialize_i32(4),
                Self::Stringlist => serializer.serialize_i32(5),
                Self::Number => serializer.serialize_i32(6),
                Self::Oneof => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.cloudsecuritycompliance.v1.ParameterSpec.ValueType",
            ))
        }
    }
}

/// Validation of the parameter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Validation {
    /// Defines validators for parameter values.
    pub constraint: std::option::Option<crate::model::validation::Constraint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Validation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraint][crate::model::Validation::constraint].
    ///
    /// Note that all the setters affecting `constraint` are mutually
    /// exclusive.
    pub fn set_constraint<
        T: std::convert::Into<std::option::Option<crate::model::validation::Constraint>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = v.into();
        self
    }

    /// The value of [constraint][crate::model::Validation::constraint]
    /// if it holds a `AllowedValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn allowed_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AllowedValues>> {
        #[allow(unreachable_patterns)]
        self.constraint.as_ref().and_then(|v| match v {
            crate::model::validation::Constraint::AllowedValues(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint][crate::model::Validation::constraint]
    /// to hold a `AllowedValues`.
    ///
    /// Note that all the setters affecting `constraint` are
    /// mutually exclusive.
    pub fn set_allowed_values<
        T: std::convert::Into<std::boxed::Box<crate::model::AllowedValues>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = std::option::Option::Some(
            crate::model::validation::Constraint::AllowedValues(v.into()),
        );
        self
    }

    /// The value of [constraint][crate::model::Validation::constraint]
    /// if it holds a `IntRange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_range(&self) -> std::option::Option<&std::boxed::Box<crate::model::IntRange>> {
        #[allow(unreachable_patterns)]
        self.constraint.as_ref().and_then(|v| match v {
            crate::model::validation::Constraint::IntRange(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint][crate::model::Validation::constraint]
    /// to hold a `IntRange`.
    ///
    /// Note that all the setters affecting `constraint` are
    /// mutually exclusive.
    pub fn set_int_range<T: std::convert::Into<std::boxed::Box<crate::model::IntRange>>>(
        mut self,
        v: T,
    ) -> Self {
        self.constraint =
            std::option::Option::Some(crate::model::validation::Constraint::IntRange(v.into()));
        self
    }

    /// The value of [constraint][crate::model::Validation::constraint]
    /// if it holds a `RegexpPattern`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regexp_pattern(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RegexpPattern>> {
        #[allow(unreachable_patterns)]
        self.constraint.as_ref().and_then(|v| match v {
            crate::model::validation::Constraint::RegexpPattern(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [constraint][crate::model::Validation::constraint]
    /// to hold a `RegexpPattern`.
    ///
    /// Note that all the setters affecting `constraint` are
    /// mutually exclusive.
    pub fn set_regexp_pattern<
        T: std::convert::Into<std::boxed::Box<crate::model::RegexpPattern>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint = std::option::Option::Some(
            crate::model::validation::Constraint::RegexpPattern(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Validation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.Validation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Validation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_values,
            __int_range,
            __regexp_pattern,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Validation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedValues" => Ok(__FieldTag::__allowed_values),
                            "allowed_values" => Ok(__FieldTag::__allowed_values),
                            "intRange" => Ok(__FieldTag::__int_range),
                            "int_range" => Ok(__FieldTag::__int_range),
                            "regexpPattern" => Ok(__FieldTag::__regexp_pattern),
                            "regexp_pattern" => Ok(__FieldTag::__regexp_pattern),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Validation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Validation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_values => {
                            if !fields.insert(__FieldTag::__allowed_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_values",
                                ));
                            }
                            if result.constraint.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `constraint`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.Validation.allowed_values, latest field was allowedValues",
                                ));
                            }
                            result.constraint = std::option::Option::Some(
                                crate::model::validation::Constraint::AllowedValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AllowedValues>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int_range => {
                            if !fields.insert(__FieldTag::__int_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int_range",
                                ));
                            }
                            if result.constraint.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `constraint`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.Validation.int_range, latest field was intRange",
                                ));
                            }
                            result.constraint = std::option::Option::Some(
                                crate::model::validation::Constraint::IntRange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IntRange>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__regexp_pattern => {
                            if !fields.insert(__FieldTag::__regexp_pattern) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regexp_pattern",
                                ));
                            }
                            if result.constraint.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `constraint`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.Validation.regexp_pattern, latest field was regexpPattern",
                                ));
                            }
                            result.constraint = std::option::Option::Some(
                                crate::model::validation::Constraint::RegexpPattern(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RegexpPattern>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Validation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.allowed_values() {
            state.serialize_entry("allowedValues", value)?;
        }
        if let Some(value) = self.int_range() {
            state.serialize_entry("intRange", value)?;
        }
        if let Some(value) = self.regexp_pattern() {
            state.serialize_entry("regexpPattern", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Validation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Validation");
        debug_struct.field("constraint", &self.constraint);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Validation].
pub mod validation {
    #[allow(unused_imports)]
    use super::*;

    /// Defines validators for parameter values.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Constraint {
        /// Allowed set of values for the parameter.
        AllowedValues(std::boxed::Box<crate::model::AllowedValues>),
        /// Allowed range for numeric parameters.
        IntRange(std::boxed::Box<crate::model::IntRange>),
        /// Regular expression for string parameters.
        RegexpPattern(std::boxed::Box<crate::model::RegexpPattern>),
    }
}

/// Allowed set of values for the parameter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AllowedValues {
    /// Required. List of allowed values for the parameter.
    pub values: std::vec::Vec<crate::model::ParamValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllowedValues {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::AllowedValues::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ParamValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AllowedValues {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.AllowedValues"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllowedValues {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllowedValues")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllowedValues;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllowedValues")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ParamValue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllowedValues {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AllowedValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AllowedValues");
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Regular Expression Validator for parameter values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegexpPattern {
    /// Required. Regex Pattern to match the value(s) of parameter.
    pub pattern: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RegexpPattern {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pattern][crate::model::RegexpPattern::pattern].
    pub fn set_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pattern = v.into();
        self
    }
}

impl wkt::message::Message for RegexpPattern {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.RegexpPattern"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RegexpPattern {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pattern,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RegexpPattern")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pattern" => Ok(__FieldTag::__pattern),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RegexpPattern;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RegexpPattern")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pattern => {
                            if !fields.insert(__FieldTag::__pattern) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pattern",
                                ));
                            }
                            result.pattern = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RegexpPattern {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pattern.is_empty() {
            state.serialize_entry("pattern", &self.pattern)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RegexpPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RegexpPattern");
        debug_struct.field("pattern", &self.pattern);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Number range for number parameters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IntRange {
    /// Required. Minimum allowed value for the numeric parameter (inclusive).
    pub min: i64,

    /// Required. Maximum allowed value for the numeric parameter (inclusive).
    pub max: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IntRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min][crate::model::IntRange::min].
    pub fn set_min<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.min = v.into();
        self
    }

    /// Sets the value of [max][crate::model::IntRange::max].
    pub fn set_max<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max = v.into();
        self
    }
}

impl wkt::message::Message for IntRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.IntRange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min,
            __max,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "min" => Ok(__FieldTag::__min),
                            "max" => Ok(__FieldTag::__max),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min => {
                            if !fields.insert(__FieldTag::__min) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max => {
                            if !fields.insert(__FieldTag::__max) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IntRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("min", &__With(&self.min))?;
        }
        if !wkt::internal::is_default(&self.max) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("max", &__With(&self.max))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IntRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntRange");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A list of strings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StringList {
    /// Required. The strings in the list.
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StringList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::StringList::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StringList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.StringList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StringList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StringList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StringList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StringList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StringList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StringList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StringList");
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Possible parameter value types.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ParamValue {
    /// The kind of value.
    pub kind: std::option::Option<crate::model::param_value::Kind>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParamValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::ParamValue::kind].
    ///
    /// Note that all the setters affecting `kind` are mutually
    /// exclusive.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::param_value::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::ParamValue::kind]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::param_value::Kind::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::ParamValue::kind]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::param_value::Kind::StringValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::ParamValue::kind]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::param_value::Kind::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::ParamValue::kind]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.kind = std::option::Option::Some(crate::model::param_value::Kind::BoolValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::ParamValue::kind]
    /// if it holds a `StringListValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_list_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StringList>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::param_value::Kind::StringListValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::ParamValue::kind]
    /// to hold a `StringListValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_string_list_value<
        T: std::convert::Into<std::boxed::Box<crate::model::StringList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::param_value::Kind::StringListValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::ParamValue::kind]
    /// if it holds a `NumberValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn number_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::param_value::Kind::NumberValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::ParamValue::kind]
    /// to hold a `NumberValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_number_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::param_value::Kind::NumberValue(v.into()));
        self
    }

    /// The value of [kind][crate::model::ParamValue::kind]
    /// if it holds a `OneofValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneof_value(&self) -> std::option::Option<&std::boxed::Box<crate::model::Parameter>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::param_value::Kind::OneofValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::ParamValue::kind]
    /// to hold a `OneofValue`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_oneof_value<T: std::convert::Into<std::boxed::Box<crate::model::Parameter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind =
            std::option::Option::Some(crate::model::param_value::Kind::OneofValue(v.into()));
        self
    }
}

impl wkt::message::Message for ParamValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ParamValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ParamValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __string_value,
            __bool_value,
            __string_list_value,
            __number_value,
            __oneof_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParamValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "stringListValue" => Ok(__FieldTag::__string_list_value),
                            "string_list_value" => Ok(__FieldTag::__string_list_value),
                            "numberValue" => Ok(__FieldTag::__number_value),
                            "number_value" => Ok(__FieldTag::__number_value),
                            "oneofValue" => Ok(__FieldTag::__oneof_value),
                            "oneof_value" => Ok(__FieldTag::__oneof_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ParamValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParamValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.ParamValue.string_value, latest field was stringValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::param_value::Kind::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.ParamValue.bool_value, latest field was boolValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::param_value::Kind::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_list_value => {
                            if !fields.insert(__FieldTag::__string_list_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_list_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.ParamValue.string_list_value, latest field was stringListValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::param_value::Kind::StringListValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StringList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__number_value => {
                            if !fields.insert(__FieldTag::__number_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for number_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.ParamValue.number_value, latest field was numberValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::param_value::Kind::NumberValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oneof_value => {
                            if !fields.insert(__FieldTag::__oneof_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneof_value",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.ParamValue.oneof_value, latest field was oneofValue",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::param_value::Kind::OneofValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Parameter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ParamValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.string_list_value() {
            state.serialize_entry("stringListValue", value)?;
        }
        if let Some(value) = self.number_value() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numberValue", &__With(value))?;
        }
        if let Some(value) = self.oneof_value() {
            state.serialize_entry("oneofValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ParamValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParamValue");
        debug_struct.field("kind", &self.kind);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ParamValue].
pub mod param_value {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of value.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Represents a string value.
        StringValue(std::string::String),
        /// Represents a boolean value.
        BoolValue(bool),
        /// Represents a repeated string.
        StringListValue(std::boxed::Box<crate::model::StringList>),
        /// Represents a double value.
        NumberValue(f64),
        /// Represents sub-parameter values.
        OneofValue(std::boxed::Box<crate::model::Parameter>),
    }
}

/// Parameter substitution rules.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ParameterSubstitutionRule {
    /// The type of substitution.
    pub substitution_type:
        std::option::Option<crate::model::parameter_substitution_rule::SubstitutionType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParameterSubstitutionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [substitution_type][crate::model::ParameterSubstitutionRule::substitution_type].
    ///
    /// Note that all the setters affecting `substitution_type` are mutually
    /// exclusive.
    pub fn set_substitution_type<
        T: std::convert::Into<
                std::option::Option<crate::model::parameter_substitution_rule::SubstitutionType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.substitution_type = v.into();
        self
    }

    /// The value of [substitution_type][crate::model::ParameterSubstitutionRule::substitution_type]
    /// if it holds a `PlaceholderSubstitutionRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn placeholder_substitution_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PlaceholderSubstitutionRule>> {
        #[allow(unreachable_patterns)]
        self.substitution_type.as_ref().and_then(|v| match v {
            crate::model::parameter_substitution_rule::SubstitutionType::PlaceholderSubstitutionRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [substitution_type][crate::model::ParameterSubstitutionRule::substitution_type]
    /// to hold a `PlaceholderSubstitutionRule`.
    ///
    /// Note that all the setters affecting `substitution_type` are
    /// mutually exclusive.
    pub fn set_placeholder_substitution_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::PlaceholderSubstitutionRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.substitution_type = std::option::Option::Some(
            crate::model::parameter_substitution_rule::SubstitutionType::PlaceholderSubstitutionRule(
                v.into()
            )
        );
        self
    }

    /// The value of [substitution_type][crate::model::ParameterSubstitutionRule::substitution_type]
    /// if it holds a `AttributeSubstitutionRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn attribute_substitution_rule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AttributeSubstitutionRule>> {
        #[allow(unreachable_patterns)]
        self.substitution_type.as_ref().and_then(|v| match v {
            crate::model::parameter_substitution_rule::SubstitutionType::AttributeSubstitutionRule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [substitution_type][crate::model::ParameterSubstitutionRule::substitution_type]
    /// to hold a `AttributeSubstitutionRule`.
    ///
    /// Note that all the setters affecting `substitution_type` are
    /// mutually exclusive.
    pub fn set_attribute_substitution_rule<
        T: std::convert::Into<std::boxed::Box<crate::model::AttributeSubstitutionRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.substitution_type = std::option::Option::Some(
            crate::model::parameter_substitution_rule::SubstitutionType::AttributeSubstitutionRule(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ParameterSubstitutionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ParameterSubstitutionRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ParameterSubstitutionRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __placeholder_substitution_rule,
            __attribute_substitution_rule,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParameterSubstitutionRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "placeholderSubstitutionRule" => {
                                Ok(__FieldTag::__placeholder_substitution_rule)
                            }
                            "placeholder_substitution_rule" => {
                                Ok(__FieldTag::__placeholder_substitution_rule)
                            }
                            "attributeSubstitutionRule" => {
                                Ok(__FieldTag::__attribute_substitution_rule)
                            }
                            "attribute_substitution_rule" => {
                                Ok(__FieldTag::__attribute_substitution_rule)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ParameterSubstitutionRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParameterSubstitutionRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__placeholder_substitution_rule => {
                            if !fields.insert(__FieldTag::__placeholder_substitution_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placeholder_substitution_rule",
                                ));
                            }
                            if result.substitution_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `substitution_type`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.ParameterSubstitutionRule.placeholder_substitution_rule, latest field was placeholderSubstitutionRule",
                                ));
                            }
                            result.substitution_type = std::option::Option::Some(
                                crate::model::parameter_substitution_rule::SubstitutionType::PlaceholderSubstitutionRule(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PlaceholderSubstitutionRule>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__attribute_substitution_rule => {
                            if !fields.insert(__FieldTag::__attribute_substitution_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute_substitution_rule",
                                ));
                            }
                            if result.substitution_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `substitution_type`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.ParameterSubstitutionRule.attribute_substitution_rule, latest field was attributeSubstitutionRule",
                                ));
                            }
                            result.substitution_type = std::option::Option::Some(
                                crate::model::parameter_substitution_rule::SubstitutionType::AttributeSubstitutionRule(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AttributeSubstitutionRule>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ParameterSubstitutionRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.placeholder_substitution_rule() {
            state.serialize_entry("placeholderSubstitutionRule", value)?;
        }
        if let Some(value) = self.attribute_substitution_rule() {
            state.serialize_entry("attributeSubstitutionRule", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ParameterSubstitutionRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParameterSubstitutionRule");
        debug_struct.field("substitution_type", &self.substitution_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ParameterSubstitutionRule].
pub mod parameter_substitution_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The type of substitution.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SubstitutionType {
        /// Placeholder substitution rule.
        PlaceholderSubstitutionRule(std::boxed::Box<crate::model::PlaceholderSubstitutionRule>),
        /// Attribute substitution rule.
        AttributeSubstitutionRule(std::boxed::Box<crate::model::AttributeSubstitutionRule>),
    }
}

/// Attribute at the given path is substituted entirely.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttributeSubstitutionRule {
    /// Fully qualified proto attribute path (in dot notation).
    /// Example: rules[0].cel_expression.resource_types_values
    pub attribute: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttributeSubstitutionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::AttributeSubstitutionRule::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }
}

impl wkt::message::Message for AttributeSubstitutionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.AttributeSubstitutionRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttributeSubstitutionRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attribute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributeSubstitutionRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attribute" => Ok(__FieldTag::__attribute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttributeSubstitutionRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributeSubstitutionRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttributeSubstitutionRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute.is_empty() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AttributeSubstitutionRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttributeSubstitutionRule");
        debug_struct.field("attribute", &self.attribute);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Placeholder is substituted in the rendered string.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PlaceholderSubstitutionRule {
    /// Fully qualified proto attribute path (e.g., dot notation)
    pub attribute: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlaceholderSubstitutionRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attribute][crate::model::PlaceholderSubstitutionRule::attribute].
    pub fn set_attribute<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.attribute = v.into();
        self
    }
}

impl wkt::message::Message for PlaceholderSubstitutionRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.PlaceholderSubstitutionRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PlaceholderSubstitutionRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attribute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PlaceholderSubstitutionRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attribute" => Ok(__FieldTag::__attribute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PlaceholderSubstitutionRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PlaceholderSubstitutionRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attribute => {
                            if !fields.insert(__FieldTag::__attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute",
                                ));
                            }
                            result.attribute = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PlaceholderSubstitutionRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attribute.is_empty() {
            state.serialize_entry("attribute", &self.attribute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PlaceholderSubstitutionRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PlaceholderSubstitutionRule");
        debug_struct.field("attribute", &self.attribute);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A rule of the cloud control.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Rule {
    /// Optional. Description of the Rule. The maximum length is 2000 characters.
    pub description: std::string::String,

    /// Required. The functionality enabled by the Rule.
    pub rule_action_types: std::vec::Vec<crate::model::RuleActionType>,

    /// The implementation of the rule.
    pub implementation: std::option::Option<crate::model::rule::Implementation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::Rule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [rule_action_types][crate::model::Rule::rule_action_types].
    pub fn set_rule_action_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RuleActionType>,
    {
        use std::iter::Iterator;
        self.rule_action_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [implementation][crate::model::Rule::implementation].
    ///
    /// Note that all the setters affecting `implementation` are mutually
    /// exclusive.
    pub fn set_implementation<
        T: std::convert::Into<std::option::Option<crate::model::rule::Implementation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.implementation = v.into();
        self
    }

    /// The value of [implementation][crate::model::Rule::implementation]
    /// if it holds a `CelExpression`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cel_expression(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CELExpression>> {
        #[allow(unreachable_patterns)]
        self.implementation.as_ref().and_then(|v| match v {
            crate::model::rule::Implementation::CelExpression(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [implementation][crate::model::Rule::implementation]
    /// to hold a `CelExpression`.
    ///
    /// Note that all the setters affecting `implementation` are
    /// mutually exclusive.
    pub fn set_cel_expression<
        T: std::convert::Into<std::boxed::Box<crate::model::CELExpression>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.implementation =
            std::option::Option::Some(crate::model::rule::Implementation::CelExpression(v.into()));
        self
    }
}

impl wkt::message::Message for Rule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.Rule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Rule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cel_expression,
            __description,
            __rule_action_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "celExpression" => Ok(__FieldTag::__cel_expression),
                            "cel_expression" => Ok(__FieldTag::__cel_expression),
                            "description" => Ok(__FieldTag::__description),
                            "ruleActionTypes" => Ok(__FieldTag::__rule_action_types),
                            "rule_action_types" => Ok(__FieldTag::__rule_action_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Rule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cel_expression => {
                            if !fields.insert(__FieldTag::__cel_expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cel_expression",
                                ));
                            }
                            if result.implementation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `implementation`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.Rule.cel_expression, latest field was celExpression",
                                ));
                            }
                            result.implementation = std::option::Option::Some(
                                crate::model::rule::Implementation::CelExpression(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CELExpression>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_action_types => {
                            if !fields.insert(__FieldTag::__rule_action_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_action_types",
                                ));
                            }
                            result.rule_action_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RuleActionType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Rule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cel_expression() {
            state.serialize_entry("celExpression", value)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.rule_action_types.is_empty() {
            state.serialize_entry("ruleActionTypes", &self.rule_action_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Rule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Rule");
        debug_struct.field("description", &self.description);
        debug_struct.field("rule_action_types", &self.rule_action_types);
        debug_struct.field("implementation", &self.implementation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Rule].
pub mod rule {
    #[allow(unused_imports)]
    use super::*;

    /// The implementation of the rule.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Implementation {
        /// Logic expression in CEL language.
        CelExpression(std::boxed::Box<crate::model::CELExpression>),
    }
}

/// A [CEL
/// expression](https://cloud.google.com/certificate-authority-service/docs/using-cel).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CELExpression {
    /// Required. Logic expression in CEL language.
    /// The max length of the condition is 1000 characters.
    pub expression: std::string::String,

    /// The criteria of the CEL expression.
    pub criteria: std::option::Option<crate::model::cel_expression::Criteria>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CELExpression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expression][crate::model::CELExpression::expression].
    pub fn set_expression<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expression = v.into();
        self
    }

    /// Sets the value of [criteria][crate::model::CELExpression::criteria].
    ///
    /// Note that all the setters affecting `criteria` are mutually
    /// exclusive.
    pub fn set_criteria<
        T: std::convert::Into<std::option::Option<crate::model::cel_expression::Criteria>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.criteria = v.into();
        self
    }

    /// The value of [criteria][crate::model::CELExpression::criteria]
    /// if it holds a `ResourceTypesValues`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource_types_values(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StringList>> {
        #[allow(unreachable_patterns)]
        self.criteria.as_ref().and_then(|v| match v {
            crate::model::cel_expression::Criteria::ResourceTypesValues(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [criteria][crate::model::CELExpression::criteria]
    /// to hold a `ResourceTypesValues`.
    ///
    /// Note that all the setters affecting `criteria` are
    /// mutually exclusive.
    pub fn set_resource_types_values<
        T: std::convert::Into<std::boxed::Box<crate::model::StringList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.criteria = std::option::Option::Some(
            crate::model::cel_expression::Criteria::ResourceTypesValues(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CELExpression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CELExpression"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CELExpression {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_types_values,
            __expression,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CELExpression")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceTypesValues" => Ok(__FieldTag::__resource_types_values),
                            "resource_types_values" => Ok(__FieldTag::__resource_types_values),
                            "expression" => Ok(__FieldTag::__expression),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CELExpression;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CELExpression")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_types_values => {
                            if !fields.insert(__FieldTag::__resource_types_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_types_values",
                                ));
                            }
                            if result.criteria.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `criteria`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.CELExpression.resource_types_values, latest field was resourceTypesValues",
                                ));
                            }
                            result.criteria = std::option::Option::Some(
                                crate::model::cel_expression::Criteria::ResourceTypesValues(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StringList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__expression => {
                            if !fields.insert(__FieldTag::__expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expression",
                                ));
                            }
                            result.expression = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CELExpression {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.resource_types_values() {
            state.serialize_entry("resourceTypesValues", value)?;
        }
        if !self.expression.is_empty() {
            state.serialize_entry("expression", &self.expression)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CELExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CELExpression");
        debug_struct.field("expression", &self.expression);
        debug_struct.field("criteria", &self.criteria);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CELExpression].
pub mod cel_expression {
    #[allow(unused_imports)]
    use super::*;

    /// The criteria of the CEL expression.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Criteria {
        /// The resource instance types on which this expression is defined.
        /// Format will be of the form : `<canonical service name>/<type>`
        /// Example: `compute.googleapis.com/Instance`.
        ResourceTypesValues(std::boxed::Box<crate::model::StringList>),
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a Regulatory control.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Control {
    /// Output only. The name of a Control. Format:
    /// 'organizations/{organization}/locations/{location}/controls/{control}''
    pub name: std::string::String,

    /// Output only. display_name
    pub display_name: std::string::String,

    /// Output only. The description of the control.
    pub description: std::string::String,

    /// Output only. Group where the control belongs. E.g. Access Control.
    pub family: crate::model::control::Family,

    /// Output only. Regulatory Family of the control E.g. Access Control
    pub control_family: std::option::Option<crate::model::ControlFamily>,

    /// Output only. The control comes under whoose responsibility e.g. GOOGLE,
    /// CUSTOMER or SHARED.
    pub responsibility_type: crate::model::RegulatoryControlResponsibilityType,

    /// Output only. Google responsibility description of regulatory control.
    pub google_responsibility_description: std::string::String,

    /// Output only. Google responsibility implementation of regulatory control.
    pub google_responsibility_implementation: std::string::String,

    /// Output only. Customer responsibility description of regulatory control.
    pub customer_responsibility_description: std::string::String,

    /// Output only. Customer responsibility implementation of regulatory control.
    pub customer_responsibility_implementation: std::string::String,

    /// Output only. Description of shared Responsibility between Google and
    /// Customer in implementing this control
    pub shared_responsibility_description: std::string::String,

    /// Output only. Link to the public documentation related to this control
    pub additional_content_uri: std::string::String,

    /// Output only. The Frameworks that include this CloudControl
    pub related_frameworks: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Control {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Control::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Control::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Control::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [family][crate::model::Control::family].
    pub fn set_family<T: std::convert::Into<crate::model::control::Family>>(
        mut self,
        v: T,
    ) -> Self {
        self.family = v.into();
        self
    }

    /// Sets the value of [control_family][crate::model::Control::control_family].
    pub fn set_control_family<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ControlFamily>,
    {
        self.control_family = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_family][crate::model::Control::control_family].
    pub fn set_or_clear_control_family<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ControlFamily>,
    {
        self.control_family = v.map(|x| x.into());
        self
    }

    /// Sets the value of [responsibility_type][crate::model::Control::responsibility_type].
    pub fn set_responsibility_type<
        T: std::convert::Into<crate::model::RegulatoryControlResponsibilityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.responsibility_type = v.into();
        self
    }

    /// Sets the value of [google_responsibility_description][crate::model::Control::google_responsibility_description].
    pub fn set_google_responsibility_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_responsibility_description = v.into();
        self
    }

    /// Sets the value of [google_responsibility_implementation][crate::model::Control::google_responsibility_implementation].
    pub fn set_google_responsibility_implementation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.google_responsibility_implementation = v.into();
        self
    }

    /// Sets the value of [customer_responsibility_description][crate::model::Control::customer_responsibility_description].
    pub fn set_customer_responsibility_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.customer_responsibility_description = v.into();
        self
    }

    /// Sets the value of [customer_responsibility_implementation][crate::model::Control::customer_responsibility_implementation].
    pub fn set_customer_responsibility_implementation<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_responsibility_implementation = v.into();
        self
    }

    /// Sets the value of [shared_responsibility_description][crate::model::Control::shared_responsibility_description].
    pub fn set_shared_responsibility_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.shared_responsibility_description = v.into();
        self
    }

    /// Sets the value of [additional_content_uri][crate::model::Control::additional_content_uri].
    pub fn set_additional_content_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_content_uri = v.into();
        self
    }

    /// Sets the value of [related_frameworks][crate::model::Control::related_frameworks].
    pub fn set_related_frameworks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_frameworks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Control {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.Control"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Control {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __family,
            __control_family,
            __responsibility_type,
            __google_responsibility_description,
            __google_responsibility_implementation,
            __customer_responsibility_description,
            __customer_responsibility_implementation,
            __shared_responsibility_description,
            __additional_content_uri,
            __related_frameworks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Control")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "family" => Ok(__FieldTag::__family),
                            "controlFamily" => Ok(__FieldTag::__control_family),
                            "control_family" => Ok(__FieldTag::__control_family),
                            "responsibilityType" => Ok(__FieldTag::__responsibility_type),
                            "responsibility_type" => Ok(__FieldTag::__responsibility_type),
                            "googleResponsibilityDescription" => {
                                Ok(__FieldTag::__google_responsibility_description)
                            }
                            "google_responsibility_description" => {
                                Ok(__FieldTag::__google_responsibility_description)
                            }
                            "googleResponsibilityImplementation" => {
                                Ok(__FieldTag::__google_responsibility_implementation)
                            }
                            "google_responsibility_implementation" => {
                                Ok(__FieldTag::__google_responsibility_implementation)
                            }
                            "customerResponsibilityDescription" => {
                                Ok(__FieldTag::__customer_responsibility_description)
                            }
                            "customer_responsibility_description" => {
                                Ok(__FieldTag::__customer_responsibility_description)
                            }
                            "customerResponsibilityImplementation" => {
                                Ok(__FieldTag::__customer_responsibility_implementation)
                            }
                            "customer_responsibility_implementation" => {
                                Ok(__FieldTag::__customer_responsibility_implementation)
                            }
                            "sharedResponsibilityDescription" => {
                                Ok(__FieldTag::__shared_responsibility_description)
                            }
                            "shared_responsibility_description" => {
                                Ok(__FieldTag::__shared_responsibility_description)
                            }
                            "additionalContentUri" => Ok(__FieldTag::__additional_content_uri),
                            "additional_content_uri" => Ok(__FieldTag::__additional_content_uri),
                            "relatedFrameworks" => Ok(__FieldTag::__related_frameworks),
                            "related_frameworks" => Ok(__FieldTag::__related_frameworks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Control;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Control")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__family => {
                            if !fields.insert(__FieldTag::__family) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for family",
                                ));
                            }
                            result.family = map
                                .next_value::<std::option::Option<crate::model::control::Family>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_family => {
                            if !fields.insert(__FieldTag::__control_family) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_family",
                                ));
                            }
                            result.control_family = map
                                .next_value::<std::option::Option<crate::model::ControlFamily>>()?;
                        }
                        __FieldTag::__responsibility_type => {
                            if !fields.insert(__FieldTag::__responsibility_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responsibility_type",
                                ));
                            }
                            result.responsibility_type = map
                                .next_value::<std::option::Option<
                                    crate::model::RegulatoryControlResponsibilityType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__google_responsibility_description => {
                            if !fields.insert(__FieldTag::__google_responsibility_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_responsibility_description",
                                ));
                            }
                            result.google_responsibility_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__google_responsibility_implementation => {
                            if !fields.insert(__FieldTag::__google_responsibility_implementation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for google_responsibility_implementation",
                                ));
                            }
                            result.google_responsibility_implementation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customer_responsibility_description => {
                            if !fields.insert(__FieldTag::__customer_responsibility_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_responsibility_description",
                                ));
                            }
                            result.customer_responsibility_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customer_responsibility_implementation => {
                            if !fields.insert(__FieldTag::__customer_responsibility_implementation)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_responsibility_implementation",
                                ));
                            }
                            result.customer_responsibility_implementation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shared_responsibility_description => {
                            if !fields.insert(__FieldTag::__shared_responsibility_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shared_responsibility_description",
                                ));
                            }
                            result.shared_responsibility_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_content_uri => {
                            if !fields.insert(__FieldTag::__additional_content_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_content_uri",
                                ));
                            }
                            result.additional_content_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__related_frameworks => {
                            if !fields.insert(__FieldTag::__related_frameworks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for related_frameworks",
                                ));
                            }
                            result.related_frameworks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Control {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.family) {
            state.serialize_entry("family", &self.family)?;
        }
        if self.control_family.is_some() {
            state.serialize_entry("controlFamily", &self.control_family)?;
        }
        if !wkt::internal::is_default(&self.responsibility_type) {
            state.serialize_entry("responsibilityType", &self.responsibility_type)?;
        }
        if !self.google_responsibility_description.is_empty() {
            state.serialize_entry(
                "googleResponsibilityDescription",
                &self.google_responsibility_description,
            )?;
        }
        if !self.google_responsibility_implementation.is_empty() {
            state.serialize_entry(
                "googleResponsibilityImplementation",
                &self.google_responsibility_implementation,
            )?;
        }
        if !self.customer_responsibility_description.is_empty() {
            state.serialize_entry(
                "customerResponsibilityDescription",
                &self.customer_responsibility_description,
            )?;
        }
        if !self.customer_responsibility_implementation.is_empty() {
            state.serialize_entry(
                "customerResponsibilityImplementation",
                &self.customer_responsibility_implementation,
            )?;
        }
        if !self.shared_responsibility_description.is_empty() {
            state.serialize_entry(
                "sharedResponsibilityDescription",
                &self.shared_responsibility_description,
            )?;
        }
        if !self.additional_content_uri.is_empty() {
            state.serialize_entry("additionalContentUri", &self.additional_content_uri)?;
        }
        if !self.related_frameworks.is_empty() {
            state.serialize_entry("relatedFrameworks", &self.related_frameworks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Control {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Control");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("family", &self.family);
        debug_struct.field("control_family", &self.control_family);
        debug_struct.field("responsibility_type", &self.responsibility_type);
        debug_struct.field(
            "google_responsibility_description",
            &self.google_responsibility_description,
        );
        debug_struct.field(
            "google_responsibility_implementation",
            &self.google_responsibility_implementation,
        );
        debug_struct.field(
            "customer_responsibility_description",
            &self.customer_responsibility_description,
        );
        debug_struct.field(
            "customer_responsibility_implementation",
            &self.customer_responsibility_implementation,
        );
        debug_struct.field(
            "shared_responsibility_description",
            &self.shared_responsibility_description,
        );
        debug_struct.field("additional_content_uri", &self.additional_content_uri);
        debug_struct.field("related_frameworks", &self.related_frameworks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Control].
pub mod control {
    #[allow(unused_imports)]
    use super::*;

    /// Family of the control. E.g. Access Control
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Family {
        /// Unspecified. Invalid state.
        Unspecified,
        /// Access Control
        Ac,
        /// Awareness and Training
        At,
        /// Audit and Accountability
        Au,
        /// Certification, Accreditation and Security Assessments
        Ca,
        /// Configuration Management
        Cm,
        /// Contingency Planning
        Cp,
        /// Identification and Authentication
        Ia,
        /// Incident Response
        Ir,
        /// Maintenance
        Ma,
        /// Media Protection
        Mp,
        /// Physical and Environmental Protection
        Pe,
        /// Security Planning
        Pl,
        /// Personnel Security
        Ps,
        /// Risk Assessment
        Ra,
        /// System Services and Acquisition
        Sa,
        /// System and Communications Protection
        Sc,
        /// System and Information Integrity
        Si,
        /// Supply Chain Risk Management
        Sr,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Family::value] or
        /// [Family::name].
        UnknownValue(family::UnknownValue),
    }

    #[doc(hidden)]
    pub mod family {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Family {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ac => std::option::Option::Some(1),
                Self::At => std::option::Option::Some(2),
                Self::Au => std::option::Option::Some(3),
                Self::Ca => std::option::Option::Some(4),
                Self::Cm => std::option::Option::Some(5),
                Self::Cp => std::option::Option::Some(6),
                Self::Ia => std::option::Option::Some(7),
                Self::Ir => std::option::Option::Some(8),
                Self::Ma => std::option::Option::Some(9),
                Self::Mp => std::option::Option::Some(10),
                Self::Pe => std::option::Option::Some(11),
                Self::Pl => std::option::Option::Some(12),
                Self::Ps => std::option::Option::Some(13),
                Self::Ra => std::option::Option::Some(14),
                Self::Sa => std::option::Option::Some(15),
                Self::Sc => std::option::Option::Some(16),
                Self::Si => std::option::Option::Some(17),
                Self::Sr => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAMILY_UNSPECIFIED"),
                Self::Ac => std::option::Option::Some("AC"),
                Self::At => std::option::Option::Some("AT"),
                Self::Au => std::option::Option::Some("AU"),
                Self::Ca => std::option::Option::Some("CA"),
                Self::Cm => std::option::Option::Some("CM"),
                Self::Cp => std::option::Option::Some("CP"),
                Self::Ia => std::option::Option::Some("IA"),
                Self::Ir => std::option::Option::Some("IR"),
                Self::Ma => std::option::Option::Some("MA"),
                Self::Mp => std::option::Option::Some("MP"),
                Self::Pe => std::option::Option::Some("PE"),
                Self::Pl => std::option::Option::Some("PL"),
                Self::Ps => std::option::Option::Some("PS"),
                Self::Ra => std::option::Option::Some("RA"),
                Self::Sa => std::option::Option::Some("SA"),
                Self::Sc => std::option::Option::Some("SC"),
                Self::Si => std::option::Option::Some("SI"),
                Self::Sr => std::option::Option::Some("SR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Family {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Family {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Family {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ac,
                2 => Self::At,
                3 => Self::Au,
                4 => Self::Ca,
                5 => Self::Cm,
                6 => Self::Cp,
                7 => Self::Ia,
                8 => Self::Ir,
                9 => Self::Ma,
                10 => Self::Mp,
                11 => Self::Pe,
                12 => Self::Pl,
                13 => Self::Ps,
                14 => Self::Ra,
                15 => Self::Sa,
                16 => Self::Sc,
                17 => Self::Si,
                18 => Self::Sr,
                _ => Self::UnknownValue(family::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Family {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAMILY_UNSPECIFIED" => Self::Unspecified,
                "AC" => Self::Ac,
                "AT" => Self::At,
                "AU" => Self::Au,
                "CA" => Self::Ca,
                "CM" => Self::Cm,
                "CP" => Self::Cp,
                "IA" => Self::Ia,
                "IR" => Self::Ir,
                "MA" => Self::Ma,
                "MP" => Self::Mp,
                "PE" => Self::Pe,
                "PL" => Self::Pl,
                "PS" => Self::Ps,
                "RA" => Self::Ra,
                "SA" => Self::Sa,
                "SC" => Self::Sc,
                "SI" => Self::Si,
                "SR" => Self::Sr,
                _ => Self::UnknownValue(family::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Family {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ac => serializer.serialize_i32(1),
                Self::At => serializer.serialize_i32(2),
                Self::Au => serializer.serialize_i32(3),
                Self::Ca => serializer.serialize_i32(4),
                Self::Cm => serializer.serialize_i32(5),
                Self::Cp => serializer.serialize_i32(6),
                Self::Ia => serializer.serialize_i32(7),
                Self::Ir => serializer.serialize_i32(8),
                Self::Ma => serializer.serialize_i32(9),
                Self::Mp => serializer.serialize_i32(10),
                Self::Pe => serializer.serialize_i32(11),
                Self::Pl => serializer.serialize_i32(12),
                Self::Ps => serializer.serialize_i32(13),
                Self::Ra => serializer.serialize_i32(14),
                Self::Sa => serializer.serialize_i32(15),
                Self::Sc => serializer.serialize_i32(16),
                Self::Si => serializer.serialize_i32(17),
                Self::Sr => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Family {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Family>::new(
                ".google.cloud.cloudsecuritycompliance.v1.Control.Family",
            ))
        }
    }
}

/// Regulatory Family of the control
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ControlFamily {
    /// ID of the regulatory control family.
    pub family_id: std::string::String,

    /// Display name of the regulatory control family.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ControlFamily {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [family_id][crate::model::ControlFamily::family_id].
    pub fn set_family_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.family_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ControlFamily::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for ControlFamily {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ControlFamily"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ControlFamily {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __family_id,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ControlFamily")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "familyId" => Ok(__FieldTag::__family_id),
                            "family_id" => Ok(__FieldTag::__family_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ControlFamily;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ControlFamily")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__family_id => {
                            if !fields.insert(__FieldTag::__family_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for family_id",
                                ));
                            }
                            result.family_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ControlFamily {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.family_id.is_empty() {
            state.serialize_entry("familyId", &self.family_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ControlFamily {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ControlFamily");
        debug_struct.field("family_id", &self.family_id);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for [ListFrameworks][].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFrameworksRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of frameworks to return. The default value is
    /// `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    pub page_size: i32,

    /// Optional. A pagination token returned from a previous request to list
    /// frameworks. Provide this token to retrieve the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFrameworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFrameworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFrameworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFrameworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFrameworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListFrameworksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFrameworksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFrameworksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFrameworksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFrameworksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFrameworksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFrameworksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFrameworksRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for [ListFrameworks][].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFrameworksResponse {
    /// The list of [Framework][google.cloud.cloudsecuritycompliance.v1.Framework]
    /// resources.
    ///
    /// [google.cloud.cloudsecuritycompliance.v1.Framework]: crate::model::Framework
    pub frameworks: std::vec::Vec<crate::model::Framework>,

    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFrameworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frameworks][crate::model::ListFrameworksResponse::frameworks].
    pub fn set_frameworks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Framework>,
    {
        use std::iter::Iterator;
        self.frameworks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFrameworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFrameworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListFrameworksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFrameworksResponse {
    type PageItem = crate::model::Framework;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.frameworks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFrameworksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __frameworks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFrameworksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "frameworks" => Ok(__FieldTag::__frameworks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFrameworksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFrameworksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__frameworks => {
                            if !fields.insert(__FieldTag::__frameworks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frameworks",
                                ));
                            }
                            result.frameworks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Framework>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFrameworksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.frameworks.is_empty() {
            state.serialize_entry("frameworks", &self.frameworks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFrameworksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFrameworksResponse");
        debug_struct.field("frameworks", &self.frameworks);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a Framework.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFrameworkRequest {
    /// Required. The name of the framework to retrieve.
    /// Format:
    /// organizations/{organization}/locations/{location}/frameworks/{framework_id}
    pub name: std::string::String,

    /// Optional. The Framework major revision to retrieve. If not specified, the
    /// most recently updated revision_id is retrieved.
    pub major_revision_id: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFrameworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFrameworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [major_revision_id][crate::model::GetFrameworkRequest::major_revision_id].
    pub fn set_major_revision_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.major_revision_id = v.into();
        self
    }
}

impl wkt::message::Message for GetFrameworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.GetFrameworkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFrameworkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __major_revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFrameworkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "majorRevisionId" => Ok(__FieldTag::__major_revision_id),
                            "major_revision_id" => Ok(__FieldTag::__major_revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFrameworkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFrameworkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__major_revision_id => {
                            if !fields.insert(__FieldTag::__major_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_revision_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.major_revision_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFrameworkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.major_revision_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("majorRevisionId", &__With(&self.major_revision_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetFrameworkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFrameworkRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("major_revision_id", &self.major_revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for creating a Framework
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFrameworkRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. ID of the framework.
    /// This is not the full name of the framework.
    /// This is the last part of the full name of the framework.
    pub framework_id: std::string::String,

    /// Required. The resource being created
    pub framework: std::option::Option<crate::model::Framework>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFrameworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFrameworkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [framework_id][crate::model::CreateFrameworkRequest::framework_id].
    pub fn set_framework_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.framework_id = v.into();
        self
    }

    /// Sets the value of [framework][crate::model::CreateFrameworkRequest::framework].
    pub fn set_framework<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Framework>,
    {
        self.framework = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [framework][crate::model::CreateFrameworkRequest::framework].
    pub fn set_or_clear_framework<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Framework>,
    {
        self.framework = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateFrameworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CreateFrameworkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateFrameworkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __framework_id,
            __framework,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateFrameworkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "frameworkId" => Ok(__FieldTag::__framework_id),
                            "framework_id" => Ok(__FieldTag::__framework_id),
                            "framework" => Ok(__FieldTag::__framework),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateFrameworkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateFrameworkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__framework_id => {
                            if !fields.insert(__FieldTag::__framework_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_id",
                                ));
                            }
                            result.framework_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__framework => {
                            if !fields.insert(__FieldTag::__framework) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework",
                                ));
                            }
                            result.framework =
                                map.next_value::<std::option::Option<crate::model::Framework>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateFrameworkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.framework_id.is_empty() {
            state.serialize_entry("frameworkId", &self.framework_id)?;
        }
        if self.framework.is_some() {
            state.serialize_entry("framework", &self.framework)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateFrameworkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateFrameworkRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("framework_id", &self.framework_id);
        debug_struct.field("framework", &self.framework);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for updating a Framework
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFrameworkRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Framework resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields present in the request will be
    /// overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub framework: std::option::Option<crate::model::Framework>,

    /// Optional. The major revision ID of the framework to update.
    pub major_revision_id: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateFrameworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateFrameworkRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFrameworkRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [framework][crate::model::UpdateFrameworkRequest::framework].
    pub fn set_framework<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Framework>,
    {
        self.framework = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [framework][crate::model::UpdateFrameworkRequest::framework].
    pub fn set_or_clear_framework<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Framework>,
    {
        self.framework = v.map(|x| x.into());
        self
    }

    /// Sets the value of [major_revision_id][crate::model::UpdateFrameworkRequest::major_revision_id].
    pub fn set_major_revision_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.major_revision_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateFrameworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.UpdateFrameworkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFrameworkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __framework,
            __major_revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFrameworkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "framework" => Ok(__FieldTag::__framework),
                            "majorRevisionId" => Ok(__FieldTag::__major_revision_id),
                            "major_revision_id" => Ok(__FieldTag::__major_revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFrameworkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFrameworkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__framework => {
                            if !fields.insert(__FieldTag::__framework) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework",
                                ));
                            }
                            result.framework =
                                map.next_value::<std::option::Option<crate::model::Framework>>()?;
                        }
                        __FieldTag::__major_revision_id => {
                            if !fields.insert(__FieldTag::__major_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for major_revision_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.major_revision_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateFrameworkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.framework.is_some() {
            state.serialize_entry("framework", &self.framework)?;
        }
        if !wkt::internal::is_default(&self.major_revision_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("majorRevisionId", &__With(&self.major_revision_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateFrameworkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateFrameworkRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("framework", &self.framework);
        debug_struct.field("major_revision_id", &self.major_revision_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for deleting a Framework
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFrameworkRequest {
    /// Required. Name of the resource, in the format
    /// `organizations/{organization}/locations/{location}/frameworks/{framework}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFrameworkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFrameworkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFrameworkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.DeleteFrameworkRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteFrameworkRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteFrameworkRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteFrameworkRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteFrameworkRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteFrameworkRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteFrameworkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteFrameworkRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for [ListCloudControls][].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudControlsRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of CloudControls to return. The default value
    /// is `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    pub page_size: i32,

    /// Optional. A pagination token returned from a previous request to list
    /// CloudControls. Provide this token to retrieve the next page of results.
    ///
    /// When paginating, parent provided to
    /// ListCloudControls request must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudControlsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudControlsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudControlsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudControlsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudControlsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListCloudControlsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudControlsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudControlsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudControlsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudControlsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudControlsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudControlsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudControlsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for ListCloudControls.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudControlsResponse {
    /// The list of CloudControl resources.
    pub cloud_controls: std::vec::Vec<crate::model::CloudControl>,

    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudControlsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_controls][crate::model::ListCloudControlsResponse::cloud_controls].
    pub fn set_cloud_controls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControl>,
    {
        use std::iter::Iterator;
        self.cloud_controls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudControlsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudControlsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListCloudControlsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudControlsResponse {
    type PageItem = crate::model::CloudControl;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_controls
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudControlsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_controls,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudControlsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudControls" => Ok(__FieldTag::__cloud_controls),
                            "cloud_controls" => Ok(__FieldTag::__cloud_controls),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudControlsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudControlsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_controls => {
                            if !fields.insert(__FieldTag::__cloud_controls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_controls",
                                ));
                            }
                            result.cloud_controls = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloudControl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudControlsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_controls.is_empty() {
            state.serialize_entry("cloudControls", &self.cloud_controls)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudControlsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudControlsResponse");
        debug_struct.field("cloud_controls", &self.cloud_controls);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a CloudControl.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloudControlRequest {
    /// Required. The name of the cloudcontrol to retrieve in the format:
    /// organizations/{organization}/locations/{location}/cloudControls/{cloud_control}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudControlRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.GetCloudControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCloudControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloudControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCloudControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloudControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCloudControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCloudControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCloudControlRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for creating a CloudControl
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCloudControlRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    pub parent: std::string::String,

    /// Required. ID of the CloudControl.
    /// This is the last segment of the CloudControl resource name.
    /// Format: `^[a-zA-Z][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$`.
    pub cloud_control_id: std::string::String,

    /// Required. The resource being created
    pub cloud_control: std::option::Option<crate::model::CloudControl>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloudControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloudControlRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cloud_control_id][crate::model::CreateCloudControlRequest::cloud_control_id].
    pub fn set_cloud_control_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_control_id = v.into();
        self
    }

    /// Sets the value of [cloud_control][crate::model::CreateCloudControlRequest::cloud_control].
    pub fn set_cloud_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudControl>,
    {
        self.cloud_control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_control][crate::model::CreateCloudControlRequest::cloud_control].
    pub fn set_or_clear_cloud_control<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudControl>,
    {
        self.cloud_control = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCloudControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CreateCloudControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCloudControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cloud_control_id,
            __cloud_control,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCloudControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cloudControlId" => Ok(__FieldTag::__cloud_control_id),
                            "cloud_control_id" => Ok(__FieldTag::__cloud_control_id),
                            "cloudControl" => Ok(__FieldTag::__cloud_control),
                            "cloud_control" => Ok(__FieldTag::__cloud_control),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCloudControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCloudControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_control_id => {
                            if !fields.insert(__FieldTag::__cloud_control_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_id",
                                ));
                            }
                            result.cloud_control_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_control => {
                            if !fields.insert(__FieldTag::__cloud_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control",
                                ));
                            }
                            result.cloud_control = map
                                .next_value::<std::option::Option<crate::model::CloudControl>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCloudControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cloud_control_id.is_empty() {
            state.serialize_entry("cloudControlId", &self.cloud_control_id)?;
        }
        if self.cloud_control.is_some() {
            state.serialize_entry("cloudControl", &self.cloud_control)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCloudControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCloudControlRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("cloud_control_id", &self.cloud_control_id);
        debug_struct.field("cloud_control", &self.cloud_control);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for updating a CloudControl.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCloudControlRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// CloudControl resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields present in the request will be
    /// overwritten. The fields that can be updated are:
    ///
    /// 1. Display_name
    /// 1. Description
    /// 1. Parameters
    /// 1. Rules
    /// 1. ParameterSpec.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub cloud_control: std::option::Option<crate::model::CloudControl>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCloudControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateCloudControlRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCloudControlRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_control][crate::model::UpdateCloudControlRequest::cloud_control].
    pub fn set_cloud_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudControl>,
    {
        self.cloud_control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_control][crate::model::UpdateCloudControlRequest::cloud_control].
    pub fn set_or_clear_cloud_control<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudControl>,
    {
        self.cloud_control = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCloudControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.UpdateCloudControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCloudControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __cloud_control,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCloudControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "cloudControl" => Ok(__FieldTag::__cloud_control),
                            "cloud_control" => Ok(__FieldTag::__cloud_control),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCloudControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCloudControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__cloud_control => {
                            if !fields.insert(__FieldTag::__cloud_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control",
                                ));
                            }
                            result.cloud_control = map
                                .next_value::<std::option::Option<crate::model::CloudControl>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCloudControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.cloud_control.is_some() {
            state.serialize_entry("cloudControl", &self.cloud_control)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateCloudControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCloudControlRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("cloud_control", &self.cloud_control);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for deleting a CloudControl.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCloudControlRequest {
    /// Required. Name of the resource, in the format
    /// `organizations/{organization}/locations/{location}/CloudControls/{CloudControl}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCloudControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCloudControlRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCloudControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.DeleteCloudControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCloudControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCloudControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCloudControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCloudControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCloudControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteCloudControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCloudControlRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// FrameworkDeployment is a resource that represents a deployment using a
/// framework.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FrameworkDeployment {
    /// Identifier. FrameworkDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    pub name: std::string::String,

    /// Required. target_resource_config referencing either an already existing
    /// target_resource or contains config for a target_resource to be created
    pub target_resource_config: std::option::Option<crate::model::TargetResourceConfig>,

    /// Output only. The resource on which the Framework is deployed based on the
    /// provided TargetResourceConfig. In format organizations/{organization},
    /// folders/{folder}, projects/{project} or
    /// projects/{project}/locations/{location}/applications/{application}.
    pub computed_target_resource: std::string::String,

    /// Required. Framework resource reference
    pub framework: std::option::Option<crate::model::FrameworkReference>,

    /// Optional. User provided description of the deployment
    pub description: std::string::String,

    /// Required. Deployment mode and parameters for each of the cloud_controls
    /// part of the framework.
    pub cloud_control_metadata: std::vec::Vec<crate::model::CloudControlMetadata>,

    /// Output only. State of the deployment
    pub deployment_state: crate::model::DeploymentState,

    /// Output only. This field is inlined just for cloudNext because the one
    /// platform apis of CCDeployment does not exist. Beyond cloud
    /// next it will be replaced with the field below which is the
    /// references of cloud control deployment
    #[deprecated]
    pub cc_deployments: std::vec::Vec<crate::model::CloudControlDeployment>,

    /// Output only. The time at which the resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the resource last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. To prevent concurrent updates from overwriting each other, always
    /// provide the `etag` when you update a CustomComplianceFramework. You can
    /// also provide the `etag` when you delete a CustomComplianceFramework, to
    /// help ensure that you're deleting the intended version of the
    /// CustomComplianceFramework.
    pub etag: std::string::String,

    /// Output only. Similarly we'll also have a field for CloudControlGroups
    pub cc_group_deployments: std::vec::Vec<crate::model::CloudControlGroupDeployment>,

    /// Output only. The display name of the target resource.
    pub target_resource_display_name: std::string::String,

    /// Output only. The references to the cloud control deployments.
    /// Example: If a framework deployment deploys two cloud controls,
    /// cc-deployment-1 and cc-deployment-2, then the
    /// cloud_control_deployment_references will be:
    /// {
    /// cloud_control_deployment_reference: {
    /// cloud_control_deployment:
    /// "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-1"
    /// },
    /// cloud_control_deployment_reference: {
    /// cloud_control_deployment:
    /// "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-2"
    /// }
    pub cloud_control_deployment_references:
        std::vec::Vec<crate::model::CloudControlDeploymentReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FrameworkDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FrameworkDeployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_resource_config][crate::model::FrameworkDeployment::target_resource_config].
    pub fn set_target_resource_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetResourceConfig>,
    {
        self.target_resource_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_resource_config][crate::model::FrameworkDeployment::target_resource_config].
    pub fn set_or_clear_target_resource_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetResourceConfig>,
    {
        self.target_resource_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [computed_target_resource][crate::model::FrameworkDeployment::computed_target_resource].
    pub fn set_computed_target_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.computed_target_resource = v.into();
        self
    }

    /// Sets the value of [framework][crate::model::FrameworkDeployment::framework].
    pub fn set_framework<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FrameworkReference>,
    {
        self.framework = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [framework][crate::model::FrameworkDeployment::framework].
    pub fn set_or_clear_framework<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FrameworkReference>,
    {
        self.framework = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::FrameworkDeployment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [cloud_control_metadata][crate::model::FrameworkDeployment::cloud_control_metadata].
    pub fn set_cloud_control_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlMetadata>,
    {
        use std::iter::Iterator;
        self.cloud_control_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deployment_state][crate::model::FrameworkDeployment::deployment_state].
    pub fn set_deployment_state<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_state = v.into();
        self
    }

    /// Sets the value of [cc_deployments][crate::model::FrameworkDeployment::cc_deployments].
    #[deprecated]
    pub fn set_cc_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlDeployment>,
    {
        use std::iter::Iterator;
        self.cc_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::FrameworkDeployment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::FrameworkDeployment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::FrameworkDeployment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FrameworkDeployment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::FrameworkDeployment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [cc_group_deployments][crate::model::FrameworkDeployment::cc_group_deployments].
    pub fn set_cc_group_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlGroupDeployment>,
    {
        use std::iter::Iterator;
        self.cc_group_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_resource_display_name][crate::model::FrameworkDeployment::target_resource_display_name].
    pub fn set_target_resource_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_display_name = v.into();
        self
    }

    /// Sets the value of [cloud_control_deployment_references][crate::model::FrameworkDeployment::cloud_control_deployment_references].
    pub fn set_cloud_control_deployment_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlDeploymentReference>,
    {
        use std::iter::Iterator;
        self.cloud_control_deployment_references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FrameworkDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.FrameworkDeployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FrameworkDeployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_resource_config,
            __computed_target_resource,
            __framework,
            __description,
            __cloud_control_metadata,
            __deployment_state,
            __cc_deployments,
            __create_time,
            __update_time,
            __etag,
            __cc_group_deployments,
            __target_resource_display_name,
            __cloud_control_deployment_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FrameworkDeployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetResourceConfig" => Ok(__FieldTag::__target_resource_config),
                            "target_resource_config" => Ok(__FieldTag::__target_resource_config),
                            "computedTargetResource" => Ok(__FieldTag::__computed_target_resource),
                            "computed_target_resource" => {
                                Ok(__FieldTag::__computed_target_resource)
                            }
                            "framework" => Ok(__FieldTag::__framework),
                            "description" => Ok(__FieldTag::__description),
                            "cloudControlMetadata" => Ok(__FieldTag::__cloud_control_metadata),
                            "cloud_control_metadata" => Ok(__FieldTag::__cloud_control_metadata),
                            "deploymentState" => Ok(__FieldTag::__deployment_state),
                            "deployment_state" => Ok(__FieldTag::__deployment_state),
                            "ccDeployments" => Ok(__FieldTag::__cc_deployments),
                            "cc_deployments" => Ok(__FieldTag::__cc_deployments),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "ccGroupDeployments" => Ok(__FieldTag::__cc_group_deployments),
                            "cc_group_deployments" => Ok(__FieldTag::__cc_group_deployments),
                            "targetResourceDisplayName" => {
                                Ok(__FieldTag::__target_resource_display_name)
                            }
                            "target_resource_display_name" => {
                                Ok(__FieldTag::__target_resource_display_name)
                            }
                            "cloudControlDeploymentReferences" => {
                                Ok(__FieldTag::__cloud_control_deployment_references)
                            }
                            "cloud_control_deployment_references" => {
                                Ok(__FieldTag::__cloud_control_deployment_references)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FrameworkDeployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FrameworkDeployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_resource_config => {
                            if !fields.insert(__FieldTag::__target_resource_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_config",
                                ));
                            }
                            result.target_resource_config = map.next_value::<std::option::Option<crate::model::TargetResourceConfig>>()?
                                ;
                        }
                        __FieldTag::__computed_target_resource => {
                            if !fields.insert(__FieldTag::__computed_target_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for computed_target_resource",
                                ));
                            }
                            result.computed_target_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__framework => {
                            if !fields.insert(__FieldTag::__framework) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework",
                                ));
                            }
                            result.framework = map.next_value::<std::option::Option<crate::model::FrameworkReference>>()?
                                ;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_control_metadata => {
                            if !fields.insert(__FieldTag::__cloud_control_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_metadata",
                                ));
                            }
                            result.cloud_control_metadata = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment_state => {
                            if !fields.insert(__FieldTag::__deployment_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_state",
                                ));
                            }
                            result.deployment_state = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cc_deployments => {
                            if !fields.insert(__FieldTag::__cc_deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cc_deployments",
                                ));
                            }
                            result.cc_deployments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlDeployment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cc_group_deployments => {
                            if !fields.insert(__FieldTag::__cc_group_deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cc_group_deployments",
                                ));
                            }
                            result.cc_group_deployments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlGroupDeployment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_resource_display_name => {
                            if !fields.insert(__FieldTag::__target_resource_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_display_name",
                                ));
                            }
                            result.target_resource_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_control_deployment_references => {
                            if !fields.insert(__FieldTag::__cloud_control_deployment_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_deployment_references",
                                ));
                            }
                            result.cloud_control_deployment_references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlDeploymentReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FrameworkDeployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.target_resource_config.is_some() {
            state.serialize_entry("targetResourceConfig", &self.target_resource_config)?;
        }
        if !self.computed_target_resource.is_empty() {
            state.serialize_entry("computedTargetResource", &self.computed_target_resource)?;
        }
        if self.framework.is_some() {
            state.serialize_entry("framework", &self.framework)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.cloud_control_metadata.is_empty() {
            state.serialize_entry("cloudControlMetadata", &self.cloud_control_metadata)?;
        }
        if !wkt::internal::is_default(&self.deployment_state) {
            state.serialize_entry("deploymentState", &self.deployment_state)?;
        }
        if !self.cc_deployments.is_empty() {
            state.serialize_entry("ccDeployments", &self.cc_deployments)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.cc_group_deployments.is_empty() {
            state.serialize_entry("ccGroupDeployments", &self.cc_group_deployments)?;
        }
        if !self.target_resource_display_name.is_empty() {
            state.serialize_entry(
                "targetResourceDisplayName",
                &self.target_resource_display_name,
            )?;
        }
        if !self.cloud_control_deployment_references.is_empty() {
            state.serialize_entry(
                "cloudControlDeploymentReferences",
                &self.cloud_control_deployment_references,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FrameworkDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FrameworkDeployment");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_resource_config", &self.target_resource_config);
        debug_struct.field("computed_target_resource", &self.computed_target_resource);
        debug_struct.field("framework", &self.framework);
        debug_struct.field("description", &self.description);
        debug_struct.field("cloud_control_metadata", &self.cloud_control_metadata);
        debug_struct.field("deployment_state", &self.deployment_state);
        debug_struct.field("cc_deployments", &self.cc_deployments);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("cc_group_deployments", &self.cc_group_deployments);
        debug_struct.field(
            "target_resource_display_name",
            &self.target_resource_display_name,
        );
        debug_struct.field(
            "cloud_control_deployment_references",
            &self.cloud_control_deployment_references,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CloudControlDeployment is a resource that represents a deployment using a
/// cloud control.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudControlDeployment {
    /// Identifier. CloudControlDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    pub name: std::string::String,

    /// Required. target_resource_config referencing either an already existing
    /// target_resource or contains config for a target_resource to be created
    pub target_resource_config: std::option::Option<crate::model::TargetResourceConfig>,

    /// Output only. The resource on which the CloudControl is deployed based on
    /// the provided TargetResourceConfig. In format organizations/{organization},
    /// folders/{folder} or projects/{project}.
    pub target_resource: std::string::String,

    /// Required. CloudControlReference, Deployment mode and parameters for the
    /// cloud_control
    pub cloud_control_metadata: std::option::Option<crate::model::CloudControlMetadata>,

    /// Optional. User provided description of the deployment
    pub description: std::string::String,

    /// Output only. State of the deployment
    pub deployment_state: crate::model::DeploymentState,

    /// Output only. The time at which the resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which the resource last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. To prevent concurrent updates from overwriting each other, always
    /// provide the `etag` when you update a CustomComplianceCloudControl. You can
    /// also provide the `etag` when you delete a CustomComplianceCloudControl, to
    /// help ensure that you're deleting the intended version of the
    /// CustomComplianceCloudControl.
    pub etag: std::string::String,

    /// Output only. The cloud control after parameter substitution.
    pub parameter_substituted_cloud_control: std::option::Option<crate::model::CloudControl>,

    /// Output only. The references to the framework deployments that this cloud
    /// control deployment is part of.
    pub framework_deployment_references: std::vec::Vec<crate::model::FrameworkDeploymentReference>,

    /// Output only. The name of the application, project, folder, or organization
    /// that the cloud control is deployed on.
    pub target_resource_display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudControlDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloudControlDeployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_resource_config][crate::model::CloudControlDeployment::target_resource_config].
    pub fn set_target_resource_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetResourceConfig>,
    {
        self.target_resource_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_resource_config][crate::model::CloudControlDeployment::target_resource_config].
    pub fn set_or_clear_target_resource_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetResourceConfig>,
    {
        self.target_resource_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_resource][crate::model::CloudControlDeployment::target_resource].
    pub fn set_target_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_resource = v.into();
        self
    }

    /// Sets the value of [cloud_control_metadata][crate::model::CloudControlDeployment::cloud_control_metadata].
    pub fn set_cloud_control_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudControlMetadata>,
    {
        self.cloud_control_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_control_metadata][crate::model::CloudControlDeployment::cloud_control_metadata].
    pub fn set_or_clear_cloud_control_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudControlMetadata>,
    {
        self.cloud_control_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::CloudControlDeployment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [deployment_state][crate::model::CloudControlDeployment::deployment_state].
    pub fn set_deployment_state<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CloudControlDeployment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloudControlDeployment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CloudControlDeployment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CloudControlDeployment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::CloudControlDeployment::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [parameter_substituted_cloud_control][crate::model::CloudControlDeployment::parameter_substituted_cloud_control].
    pub fn set_parameter_substituted_cloud_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudControl>,
    {
        self.parameter_substituted_cloud_control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameter_substituted_cloud_control][crate::model::CloudControlDeployment::parameter_substituted_cloud_control].
    pub fn set_or_clear_parameter_substituted_cloud_control<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CloudControl>,
    {
        self.parameter_substituted_cloud_control = v.map(|x| x.into());
        self
    }

    /// Sets the value of [framework_deployment_references][crate::model::CloudControlDeployment::framework_deployment_references].
    pub fn set_framework_deployment_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FrameworkDeploymentReference>,
    {
        use std::iter::Iterator;
        self.framework_deployment_references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_resource_display_name][crate::model::CloudControlDeployment::target_resource_display_name].
    pub fn set_target_resource_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_resource_display_name = v.into();
        self
    }
}

impl wkt::message::Message for CloudControlDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CloudControlDeployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudControlDeployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_resource_config,
            __target_resource,
            __cloud_control_metadata,
            __description,
            __deployment_state,
            __create_time,
            __update_time,
            __etag,
            __parameter_substituted_cloud_control,
            __framework_deployment_references,
            __target_resource_display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudControlDeployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetResourceConfig" => Ok(__FieldTag::__target_resource_config),
                            "target_resource_config" => Ok(__FieldTag::__target_resource_config),
                            "targetResource" => Ok(__FieldTag::__target_resource),
                            "target_resource" => Ok(__FieldTag::__target_resource),
                            "cloudControlMetadata" => Ok(__FieldTag::__cloud_control_metadata),
                            "cloud_control_metadata" => Ok(__FieldTag::__cloud_control_metadata),
                            "description" => Ok(__FieldTag::__description),
                            "deploymentState" => Ok(__FieldTag::__deployment_state),
                            "deployment_state" => Ok(__FieldTag::__deployment_state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "parameterSubstitutedCloudControl" => {
                                Ok(__FieldTag::__parameter_substituted_cloud_control)
                            }
                            "parameter_substituted_cloud_control" => {
                                Ok(__FieldTag::__parameter_substituted_cloud_control)
                            }
                            "frameworkDeploymentReferences" => {
                                Ok(__FieldTag::__framework_deployment_references)
                            }
                            "framework_deployment_references" => {
                                Ok(__FieldTag::__framework_deployment_references)
                            }
                            "targetResourceDisplayName" => {
                                Ok(__FieldTag::__target_resource_display_name)
                            }
                            "target_resource_display_name" => {
                                Ok(__FieldTag::__target_resource_display_name)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudControlDeployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudControlDeployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_resource_config => {
                            if !fields.insert(__FieldTag::__target_resource_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_config",
                                ));
                            }
                            result.target_resource_config = map.next_value::<std::option::Option<crate::model::TargetResourceConfig>>()?
                                ;
                        }
                        __FieldTag::__target_resource => {
                            if !fields.insert(__FieldTag::__target_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource",
                                ));
                            }
                            result.target_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cloud_control_metadata => {
                            if !fields.insert(__FieldTag::__cloud_control_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_metadata",
                                ));
                            }
                            result.cloud_control_metadata = map.next_value::<std::option::Option<crate::model::CloudControlMetadata>>()?
                                ;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment_state => {
                            if !fields.insert(__FieldTag::__deployment_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_state",
                                ));
                            }
                            result.deployment_state = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameter_substituted_cloud_control => {
                            if !fields.insert(__FieldTag::__parameter_substituted_cloud_control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameter_substituted_cloud_control",
                                ));
                            }
                            result.parameter_substituted_cloud_control = map
                                .next_value::<std::option::Option<crate::model::CloudControl>>()?;
                        }
                        __FieldTag::__framework_deployment_references => {
                            if !fields.insert(__FieldTag::__framework_deployment_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_deployment_references",
                                ));
                            }
                            result.framework_deployment_references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FrameworkDeploymentReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_resource_display_name => {
                            if !fields.insert(__FieldTag::__target_resource_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_display_name",
                                ));
                            }
                            result.target_resource_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudControlDeployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.target_resource_config.is_some() {
            state.serialize_entry("targetResourceConfig", &self.target_resource_config)?;
        }
        if !self.target_resource.is_empty() {
            state.serialize_entry("targetResource", &self.target_resource)?;
        }
        if self.cloud_control_metadata.is_some() {
            state.serialize_entry("cloudControlMetadata", &self.cloud_control_metadata)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.deployment_state) {
            state.serialize_entry("deploymentState", &self.deployment_state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.parameter_substituted_cloud_control.is_some() {
            state.serialize_entry(
                "parameterSubstitutedCloudControl",
                &self.parameter_substituted_cloud_control,
            )?;
        }
        if !self.framework_deployment_references.is_empty() {
            state.serialize_entry(
                "frameworkDeploymentReferences",
                &self.framework_deployment_references,
            )?;
        }
        if !self.target_resource_display_name.is_empty() {
            state.serialize_entry(
                "targetResourceDisplayName",
                &self.target_resource_display_name,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudControlDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudControlDeployment");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_resource_config", &self.target_resource_config);
        debug_struct.field("target_resource", &self.target_resource);
        debug_struct.field("cloud_control_metadata", &self.cloud_control_metadata);
        debug_struct.field("description", &self.description);
        debug_struct.field("deployment_state", &self.deployment_state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("etag", &self.etag);
        debug_struct.field(
            "parameter_substituted_cloud_control",
            &self.parameter_substituted_cloud_control,
        );
        debug_struct.field(
            "framework_deployment_references",
            &self.framework_deployment_references,
        );
        debug_struct.field(
            "target_resource_display_name",
            &self.target_resource_display_name,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// TargetResourceConfig contains either the name of the target_resource or
/// contains the config to create a new target_resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetResourceConfig {
    /// Resource config for the target_resource
    pub resource_config: std::option::Option<crate::model::target_resource_config::ResourceConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetResourceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_config][crate::model::TargetResourceConfig::resource_config].
    ///
    /// Note that all the setters affecting `resource_config` are mutually
    /// exclusive.
    pub fn set_resource_config<
        T: std::convert::Into<
                std::option::Option<crate::model::target_resource_config::ResourceConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_config = v.into();
        self
    }

    /// The value of [resource_config][crate::model::TargetResourceConfig::resource_config]
    /// if it holds a `ExistingTargetResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn existing_target_resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.resource_config.as_ref().and_then(|v| match v {
            crate::model::target_resource_config::ResourceConfig::ExistingTargetResource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_config][crate::model::TargetResourceConfig::resource_config]
    /// to hold a `ExistingTargetResource`.
    ///
    /// Note that all the setters affecting `resource_config` are
    /// mutually exclusive.
    pub fn set_existing_target_resource<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_config = std::option::Option::Some(
            crate::model::target_resource_config::ResourceConfig::ExistingTargetResource(v.into()),
        );
        self
    }

    /// The value of [resource_config][crate::model::TargetResourceConfig::resource_config]
    /// if it holds a `TargetResourceCreationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_resource_creation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TargetResourceCreationConfig>> {
        #[allow(unreachable_patterns)]
        self.resource_config.as_ref().and_then(|v| match v {
            crate::model::target_resource_config::ResourceConfig::TargetResourceCreationConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_config][crate::model::TargetResourceConfig::resource_config]
    /// to hold a `TargetResourceCreationConfig`.
    ///
    /// Note that all the setters affecting `resource_config` are
    /// mutually exclusive.
    pub fn set_target_resource_creation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::TargetResourceCreationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_config = std::option::Option::Some(
            crate::model::target_resource_config::ResourceConfig::TargetResourceCreationConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for TargetResourceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.TargetResourceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetResourceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __existing_target_resource,
            __target_resource_creation_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetResourceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "existingTargetResource" => Ok(__FieldTag::__existing_target_resource),
                            "existing_target_resource" => {
                                Ok(__FieldTag::__existing_target_resource)
                            }
                            "targetResourceCreationConfig" => {
                                Ok(__FieldTag::__target_resource_creation_config)
                            }
                            "target_resource_creation_config" => {
                                Ok(__FieldTag::__target_resource_creation_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetResourceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetResourceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__existing_target_resource => {
                            if !fields.insert(__FieldTag::__existing_target_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for existing_target_resource",
                                ));
                            }
                            if result.resource_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_config`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.TargetResourceConfig.existing_target_resource, latest field was existingTargetResource",
                                ));
                            }
                            result.resource_config = std::option::Option::Some(
                                crate::model::target_resource_config::ResourceConfig::ExistingTargetResource(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__target_resource_creation_config => {
                            if !fields.insert(__FieldTag::__target_resource_creation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resource_creation_config",
                                ));
                            }
                            if result.resource_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_config`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.TargetResourceConfig.target_resource_creation_config, latest field was targetResourceCreationConfig",
                                ));
                            }
                            result.resource_config = std::option::Option::Some(
                                crate::model::target_resource_config::ResourceConfig::TargetResourceCreationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TargetResourceCreationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetResourceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.existing_target_resource() {
            state.serialize_entry("existingTargetResource", value)?;
        }
        if let Some(value) = self.target_resource_creation_config() {
            state.serialize_entry("targetResourceCreationConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetResourceConfig");
        debug_struct.field("resource_config", &self.resource_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TargetResourceConfig].
pub mod target_resource_config {
    #[allow(unused_imports)]
    use super::*;

    /// Resource config for the target_resource
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceConfig {
        /// Optional. CRM node in format organizations/{organization},
        /// folders/{folder}, projects/{project} or
        /// projects/{project}/locations/{location}/applications/{application}.
        ExistingTargetResource(std::string::String),
        /// Optional. Config to create a new resource and use that as the
        /// target_resource for deployment
        TargetResourceCreationConfig(std::boxed::Box<crate::model::TargetResourceCreationConfig>),
    }
}

/// TargetResourceCreationConfig contains the config to create a new resource
/// and use that as the target_resource for deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetResourceCreationConfig {
    /// Resource creation config for the target_resource
    pub resource_creation_config:
        std::option::Option<crate::model::target_resource_creation_config::ResourceCreationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetResourceCreationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_creation_config][crate::model::TargetResourceCreationConfig::resource_creation_config].
    ///
    /// Note that all the setters affecting `resource_creation_config` are mutually
    /// exclusive.
    pub fn set_resource_creation_config<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::target_resource_creation_config::ResourceCreationConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_creation_config = v.into();
        self
    }

    /// The value of [resource_creation_config][crate::model::TargetResourceCreationConfig::resource_creation_config]
    /// if it holds a `FolderCreationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn folder_creation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FolderCreationConfig>> {
        #[allow(unreachable_patterns)]
        self.resource_creation_config.as_ref().and_then(|v| match v {
            crate::model::target_resource_creation_config::ResourceCreationConfig::FolderCreationConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_creation_config][crate::model::TargetResourceCreationConfig::resource_creation_config]
    /// to hold a `FolderCreationConfig`.
    ///
    /// Note that all the setters affecting `resource_creation_config` are
    /// mutually exclusive.
    pub fn set_folder_creation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::FolderCreationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_creation_config = std::option::Option::Some(
            crate::model::target_resource_creation_config::ResourceCreationConfig::FolderCreationConfig(
                v.into()
            )
        );
        self
    }

    /// The value of [resource_creation_config][crate::model::TargetResourceCreationConfig::resource_creation_config]
    /// if it holds a `ProjectCreationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn project_creation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProjectCreationConfig>> {
        #[allow(unreachable_patterns)]
        self.resource_creation_config.as_ref().and_then(|v| match v {
            crate::model::target_resource_creation_config::ResourceCreationConfig::ProjectCreationConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_creation_config][crate::model::TargetResourceCreationConfig::resource_creation_config]
    /// to hold a `ProjectCreationConfig`.
    ///
    /// Note that all the setters affecting `resource_creation_config` are
    /// mutually exclusive.
    pub fn set_project_creation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ProjectCreationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_creation_config = std::option::Option::Some(
            crate::model::target_resource_creation_config::ResourceCreationConfig::ProjectCreationConfig(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for TargetResourceCreationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.TargetResourceCreationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetResourceCreationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __folder_creation_config,
            __project_creation_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetResourceCreationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "folderCreationConfig" => Ok(__FieldTag::__folder_creation_config),
                            "folder_creation_config" => Ok(__FieldTag::__folder_creation_config),
                            "projectCreationConfig" => Ok(__FieldTag::__project_creation_config),
                            "project_creation_config" => Ok(__FieldTag::__project_creation_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetResourceCreationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetResourceCreationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__folder_creation_config => {
                            if !fields.insert(__FieldTag::__folder_creation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folder_creation_config",
                                ));
                            }
                            if result.resource_creation_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_creation_config`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.TargetResourceCreationConfig.folder_creation_config, latest field was folderCreationConfig",
                                ));
                            }
                            result.resource_creation_config = std::option::Option::Some(
                                crate::model::target_resource_creation_config::ResourceCreationConfig::FolderCreationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FolderCreationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__project_creation_config => {
                            if !fields.insert(__FieldTag::__project_creation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_creation_config",
                                ));
                            }
                            if result.resource_creation_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `resource_creation_config`, a oneof with full ID .google.cloud.cloudsecuritycompliance.v1.TargetResourceCreationConfig.project_creation_config, latest field was projectCreationConfig",
                                ));
                            }
                            result.resource_creation_config = std::option::Option::Some(
                                crate::model::target_resource_creation_config::ResourceCreationConfig::ProjectCreationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ProjectCreationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetResourceCreationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.folder_creation_config() {
            state.serialize_entry("folderCreationConfig", value)?;
        }
        if let Some(value) = self.project_creation_config() {
            state.serialize_entry("projectCreationConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetResourceCreationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetResourceCreationConfig");
        debug_struct.field("resource_creation_config", &self.resource_creation_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TargetResourceCreationConfig].
pub mod target_resource_creation_config {
    #[allow(unused_imports)]
    use super::*;

    /// Resource creation config for the target_resource
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceCreationConfig {
        /// Optional. Config to create a new folder
        FolderCreationConfig(std::boxed::Box<crate::model::FolderCreationConfig>),
        /// Optional. Config to create a new project
        ProjectCreationConfig(std::boxed::Box<crate::model::ProjectCreationConfig>),
    }
}

/// FolderCreationConfig contains the config to create a new folder.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FolderCreationConfig {
    /// Required. organizations/{org} or folders/{folder}
    pub parent: std::string::String,

    /// Required. Display name of the folder to be created
    pub folder_display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FolderCreationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::FolderCreationConfig::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [folder_display_name][crate::model::FolderCreationConfig::folder_display_name].
    pub fn set_folder_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.folder_display_name = v.into();
        self
    }
}

impl wkt::message::Message for FolderCreationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.FolderCreationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FolderCreationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __folder_display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FolderCreationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "folderDisplayName" => Ok(__FieldTag::__folder_display_name),
                            "folder_display_name" => Ok(__FieldTag::__folder_display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FolderCreationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FolderCreationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__folder_display_name => {
                            if !fields.insert(__FieldTag::__folder_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folder_display_name",
                                ));
                            }
                            result.folder_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FolderCreationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.folder_display_name.is_empty() {
            state.serialize_entry("folderDisplayName", &self.folder_display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FolderCreationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FolderCreationConfig");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("folder_display_name", &self.folder_display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ProjectCreationConfig contains the config to create a new project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProjectCreationConfig {
    /// Required. organizations/{org} or folders/{folder}
    pub parent: std::string::String,

    /// Required. Display name of the project to be created
    pub project_display_name: std::string::String,

    /// Required. Billing account id to be used for the project
    pub billing_account_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectCreationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ProjectCreationConfig::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [project_display_name][crate::model::ProjectCreationConfig::project_display_name].
    pub fn set_project_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.project_display_name = v.into();
        self
    }

    /// Sets the value of [billing_account_id][crate::model::ProjectCreationConfig::billing_account_id].
    pub fn set_billing_account_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.billing_account_id = v.into();
        self
    }
}

impl wkt::message::Message for ProjectCreationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ProjectCreationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProjectCreationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __project_display_name,
            __billing_account_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProjectCreationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "projectDisplayName" => Ok(__FieldTag::__project_display_name),
                            "project_display_name" => Ok(__FieldTag::__project_display_name),
                            "billingAccountId" => Ok(__FieldTag::__billing_account_id),
                            "billing_account_id" => Ok(__FieldTag::__billing_account_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProjectCreationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProjectCreationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_display_name => {
                            if !fields.insert(__FieldTag::__project_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_display_name",
                                ));
                            }
                            result.project_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__billing_account_id => {
                            if !fields.insert(__FieldTag::__billing_account_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_account_id",
                                ));
                            }
                            result.billing_account_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProjectCreationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.project_display_name.is_empty() {
            state.serialize_entry("projectDisplayName", &self.project_display_name)?;
        }
        if !self.billing_account_id.is_empty() {
            state.serialize_entry("billingAccountId", &self.billing_account_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProjectCreationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProjectCreationConfig");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("project_display_name", &self.project_display_name);
        debug_struct.field("billing_account_id", &self.billing_account_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CloudControlMetadata contains the metadata for each of the cloud controls
/// part of the framework.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudControlMetadata {
    /// Required. Cloud control details
    pub cloud_control_details: std::option::Option<crate::model::CloudControlDetails>,

    /// Required. Enforcement mode of the cloud control
    pub enforcement_mode: crate::model::EnforcementMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudControlMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_control_details][crate::model::CloudControlMetadata::cloud_control_details].
    pub fn set_cloud_control_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudControlDetails>,
    {
        self.cloud_control_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_control_details][crate::model::CloudControlMetadata::cloud_control_details].
    pub fn set_or_clear_cloud_control_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudControlDetails>,
    {
        self.cloud_control_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enforcement_mode][crate::model::CloudControlMetadata::enforcement_mode].
    pub fn set_enforcement_mode<T: std::convert::Into<crate::model::EnforcementMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.enforcement_mode = v.into();
        self
    }
}

impl wkt::message::Message for CloudControlMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CloudControlMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudControlMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_control_details,
            __enforcement_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudControlMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudControlDetails" => Ok(__FieldTag::__cloud_control_details),
                            "cloud_control_details" => Ok(__FieldTag::__cloud_control_details),
                            "enforcementMode" => Ok(__FieldTag::__enforcement_mode),
                            "enforcement_mode" => Ok(__FieldTag::__enforcement_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudControlMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudControlMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_control_details => {
                            if !fields.insert(__FieldTag::__cloud_control_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_details",
                                ));
                            }
                            result.cloud_control_details = map.next_value::<std::option::Option<crate::model::CloudControlDetails>>()?
                                ;
                        }
                        __FieldTag::__enforcement_mode => {
                            if !fields.insert(__FieldTag::__enforcement_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enforcement_mode",
                                ));
                            }
                            result.enforcement_mode = map
                                .next_value::<std::option::Option<crate::model::EnforcementMode>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudControlMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cloud_control_details.is_some() {
            state.serialize_entry("cloudControlDetails", &self.cloud_control_details)?;
        }
        if !wkt::internal::is_default(&self.enforcement_mode) {
            state.serialize_entry("enforcementMode", &self.enforcement_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudControlMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudControlMetadata");
        debug_struct.field("cloud_control_details", &self.cloud_control_details);
        debug_struct.field("enforcement_mode", &self.enforcement_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CloudControlGroupDeployment contains the cloud control group and the cloud
/// control deployments in the group.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudControlGroupDeployment {
    /// Required. Cloud control group
    pub cloud_control_group: std::option::Option<crate::model::CloudControlGroup>,

    /// Required. Cloud control deployments in the group
    #[deprecated]
    pub cc_deployments: std::vec::Vec<crate::model::CloudControlDeployment>,

    /// Output only. The references to the cloud control deployments in the cloud
    /// control group. For example, if a cloud control group has two cloud
    /// controls, `cloud-control-1` and `cloud-control-2`, and the cloud control
    /// deployments for these cloud controls are `cloud-control-deployment-1` and
    /// `cloud-control-deployment-2` respectively, then the
    /// references are:
    ///
    /// ```norust
    ///  cloud_control_deployment_reference: {
    ///    cloud_control_deployment:
    ///    "organizations/{organization}/locations/{location}/cloudControlDeployments/cloud-control-deployment-1"
    ///  },
    ///  cloud_control_deployment_reference: {
    ///   cloud_control_deployment:
    ///   "organizations/{organization}/locations/{location}/cloudControlDeployments/cloud-control-deployment-2"
    ///  }
    /// ```
    pub cc_deployment_references: std::vec::Vec<crate::model::CloudControlDeploymentReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudControlGroupDeployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_control_group][crate::model::CloudControlGroupDeployment::cloud_control_group].
    pub fn set_cloud_control_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudControlGroup>,
    {
        self.cloud_control_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_control_group][crate::model::CloudControlGroupDeployment::cloud_control_group].
    pub fn set_or_clear_cloud_control_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudControlGroup>,
    {
        self.cloud_control_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cc_deployments][crate::model::CloudControlGroupDeployment::cc_deployments].
    #[deprecated]
    pub fn set_cc_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlDeployment>,
    {
        use std::iter::Iterator;
        self.cc_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cc_deployment_references][crate::model::CloudControlGroupDeployment::cc_deployment_references].
    pub fn set_cc_deployment_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlDeploymentReference>,
    {
        use std::iter::Iterator;
        self.cc_deployment_references = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudControlGroupDeployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CloudControlGroupDeployment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudControlGroupDeployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_control_group,
            __cc_deployments,
            __cc_deployment_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudControlGroupDeployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudControlGroup" => Ok(__FieldTag::__cloud_control_group),
                            "cloud_control_group" => Ok(__FieldTag::__cloud_control_group),
                            "ccDeployments" => Ok(__FieldTag::__cc_deployments),
                            "cc_deployments" => Ok(__FieldTag::__cc_deployments),
                            "ccDeploymentReferences" => Ok(__FieldTag::__cc_deployment_references),
                            "cc_deployment_references" => {
                                Ok(__FieldTag::__cc_deployment_references)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudControlGroupDeployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudControlGroupDeployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_control_group => {
                            if !fields.insert(__FieldTag::__cloud_control_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_group",
                                ));
                            }
                            result.cloud_control_group = map
                                .next_value::<std::option::Option<crate::model::CloudControlGroup>>(
                                )?;
                        }
                        __FieldTag::__cc_deployments => {
                            if !fields.insert(__FieldTag::__cc_deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cc_deployments",
                                ));
                            }
                            result.cc_deployments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlDeployment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cc_deployment_references => {
                            if !fields.insert(__FieldTag::__cc_deployment_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cc_deployment_references",
                                ));
                            }
                            result.cc_deployment_references = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlDeploymentReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudControlGroupDeployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cloud_control_group.is_some() {
            state.serialize_entry("cloudControlGroup", &self.cloud_control_group)?;
        }
        if !self.cc_deployments.is_empty() {
            state.serialize_entry("ccDeployments", &self.cc_deployments)?;
        }
        if !self.cc_deployment_references.is_empty() {
            state.serialize_entry("ccDeploymentReferences", &self.cc_deployment_references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudControlGroupDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudControlGroupDeployment");
        debug_struct.field("cloud_control_group", &self.cloud_control_group);
        debug_struct.field("cc_deployments", &self.cc_deployments);
        debug_struct.field("cc_deployment_references", &self.cc_deployment_references);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for CreateFrameworkDeployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFrameworkDeploymentRequest {
    /// Required. Value for parent. Supported formats:
    /// organizations/{organization}/locations/{location}
    /// Only global location is supported.
    pub parent: std::string::String,

    /// Optional. User provided identifier. It should be unique in scope of a
    /// parent Please note that this is optional and if not provided, a random UUID
    /// will be generated.
    pub framework_deployment_id: std::string::String,

    /// Required. The resource being created.
    pub framework_deployment: std::option::Option<crate::model::FrameworkDeployment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateFrameworkDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFrameworkDeploymentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [framework_deployment_id][crate::model::CreateFrameworkDeploymentRequest::framework_deployment_id].
    pub fn set_framework_deployment_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.framework_deployment_id = v.into();
        self
    }

    /// Sets the value of [framework_deployment][crate::model::CreateFrameworkDeploymentRequest::framework_deployment].
    pub fn set_framework_deployment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FrameworkDeployment>,
    {
        self.framework_deployment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [framework_deployment][crate::model::CreateFrameworkDeploymentRequest::framework_deployment].
    pub fn set_or_clear_framework_deployment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FrameworkDeployment>,
    {
        self.framework_deployment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateFrameworkDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CreateFrameworkDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateFrameworkDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __framework_deployment_id,
            __framework_deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateFrameworkDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "frameworkDeploymentId" => Ok(__FieldTag::__framework_deployment_id),
                            "framework_deployment_id" => Ok(__FieldTag::__framework_deployment_id),
                            "frameworkDeployment" => Ok(__FieldTag::__framework_deployment),
                            "framework_deployment" => Ok(__FieldTag::__framework_deployment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateFrameworkDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateFrameworkDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__framework_deployment_id => {
                            if !fields.insert(__FieldTag::__framework_deployment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_deployment_id",
                                ));
                            }
                            result.framework_deployment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__framework_deployment => {
                            if !fields.insert(__FieldTag::__framework_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_deployment",
                                ));
                            }
                            result.framework_deployment = map.next_value::<std::option::Option<crate::model::FrameworkDeployment>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateFrameworkDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.framework_deployment_id.is_empty() {
            state.serialize_entry("frameworkDeploymentId", &self.framework_deployment_id)?;
        }
        if self.framework_deployment.is_some() {
            state.serialize_entry("frameworkDeployment", &self.framework_deployment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateFrameworkDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateFrameworkDeploymentRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("framework_deployment_id", &self.framework_deployment_id);
        debug_struct.field("framework_deployment", &self.framework_deployment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for DeleteFrameworkDeployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFrameworkDeploymentRequest {
    /// Required. Name of the framework deployment to be deleted
    /// FrameworkDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    pub name: std::string::String,

    /// Optional. An opaque identifier for the current version of the resource.
    ///
    /// If you provide this value, then it must match the existing value. If the
    /// values don't match, then the request fails with an
    /// [ABORTED][google.rpc.Code.ABORTED] error.
    ///
    /// If you omit this value, then the resource is deleted regardless of its
    /// current `etag` value.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteFrameworkDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFrameworkDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteFrameworkDeploymentRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteFrameworkDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.DeleteFrameworkDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteFrameworkDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteFrameworkDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteFrameworkDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteFrameworkDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteFrameworkDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteFrameworkDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteFrameworkDeploymentRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for GetFrameworkDeployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFrameworkDeploymentRequest {
    /// Required. FrameworkDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetFrameworkDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFrameworkDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetFrameworkDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.GetFrameworkDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFrameworkDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFrameworkDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFrameworkDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFrameworkDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetFrameworkDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetFrameworkDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetFrameworkDeploymentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ListFrameworkDeployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFrameworkDeploymentsRequest {
    /// Required. Parent value for ListFrameworkDeploymentsRequest.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filter to be applied on the resource, defined by EBNF grammar
    /// <https://google.aip.dev/assets/misc/ebnf-filtering.txt>.
    pub filter: std::string::String,

    /// Optional. Sort results. Supported are "name", "name desc" or "" (unsorted).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFrameworkDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFrameworkDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFrameworkDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFrameworkDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListFrameworkDeploymentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListFrameworkDeploymentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListFrameworkDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListFrameworkDeploymentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFrameworkDeploymentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFrameworkDeploymentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFrameworkDeploymentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFrameworkDeploymentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFrameworkDeploymentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFrameworkDeploymentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFrameworkDeploymentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing FrameworkDeployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFrameworkDeploymentsResponse {
    /// The list of FrameworkDeployments.
    pub framework_deployments: std::vec::Vec<crate::model::FrameworkDeployment>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListFrameworkDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [framework_deployments][crate::model::ListFrameworkDeploymentsResponse::framework_deployments].
    pub fn set_framework_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FrameworkDeployment>,
    {
        use std::iter::Iterator;
        self.framework_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFrameworkDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListFrameworkDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListFrameworkDeploymentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFrameworkDeploymentsResponse {
    type PageItem = crate::model::FrameworkDeployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.framework_deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFrameworkDeploymentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __framework_deployments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFrameworkDeploymentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "frameworkDeployments" => Ok(__FieldTag::__framework_deployments),
                            "framework_deployments" => Ok(__FieldTag::__framework_deployments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFrameworkDeploymentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFrameworkDeploymentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__framework_deployments => {
                            if !fields.insert(__FieldTag::__framework_deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_deployments",
                                ));
                            }
                            result.framework_deployments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FrameworkDeployment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListFrameworkDeploymentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.framework_deployments.is_empty() {
            state.serialize_entry("frameworkDeployments", &self.framework_deployments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListFrameworkDeploymentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListFrameworkDeploymentsResponse");
        debug_struct.field("framework_deployments", &self.framework_deployments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for GetCloudControlDeployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloudControlDeploymentRequest {
    /// Required. CloudControlDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloudControlDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloudControlDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloudControlDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.GetCloudControlDeploymentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCloudControlDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloudControlDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCloudControlDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloudControlDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCloudControlDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCloudControlDeploymentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCloudControlDeploymentRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ListCloudControlDeployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudControlDeploymentsRequest {
    /// Required. Parent value for ListCloudControlDeploymentsRequest.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filter to be applied on the resource, defined by EBNF grammar
    /// <https://google.aip.dev/assets/misc/ebnf-filtering.txt>.
    pub filter: std::string::String,

    /// Optional. Sort results. Supported are "name", "name desc" or "" (unsorted).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudControlDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloudControlDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloudControlDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloudControlDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloudControlDeploymentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCloudControlDeploymentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudControlDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListCloudControlDeploymentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudControlDeploymentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudControlDeploymentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudControlDeploymentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudControlDeploymentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudControlDeploymentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudControlDeploymentsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudControlDeploymentsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing CloudControlDeployments.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloudControlDeploymentsResponse {
    /// The list of CloudControlDeployments.
    pub cloud_control_deployments: std::vec::Vec<crate::model::CloudControlDeployment>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloudControlDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_control_deployments][crate::model::ListCloudControlDeploymentsResponse::cloud_control_deployments].
    pub fn set_cloud_control_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloudControlDeployment>,
    {
        use std::iter::Iterator;
        self.cloud_control_deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloudControlDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCloudControlDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.ListCloudControlDeploymentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloudControlDeploymentsResponse {
    type PageItem = crate::model::CloudControlDeployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cloud_control_deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloudControlDeploymentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_control_deployments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloudControlDeploymentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudControlDeployments" => {
                                Ok(__FieldTag::__cloud_control_deployments)
                            }
                            "cloud_control_deployments" => {
                                Ok(__FieldTag::__cloud_control_deployments)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloudControlDeploymentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloudControlDeploymentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_control_deployments => {
                            if !fields.insert(__FieldTag::__cloud_control_deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_deployments",
                                ));
                            }
                            result.cloud_control_deployments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CloudControlDeployment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloudControlDeploymentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_control_deployments.is_empty() {
            state.serialize_entry("cloudControlDeployments", &self.cloud_control_deployments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloudControlDeploymentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloudControlDeploymentsResponse");
        debug_struct.field("cloud_control_deployments", &self.cloud_control_deployments);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The reference to the cloud control deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudControlDeploymentReference {
    /// Output only. The name of the cloud control deployment. The format is:
    /// organizations/{org}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    pub cloud_control_deployment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudControlDeploymentReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_control_deployment][crate::model::CloudControlDeploymentReference::cloud_control_deployment].
    pub fn set_cloud_control_deployment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_control_deployment = v.into();
        self
    }
}

impl wkt::message::Message for CloudControlDeploymentReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.CloudControlDeploymentReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudControlDeploymentReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_control_deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudControlDeploymentReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudControlDeployment" => Ok(__FieldTag::__cloud_control_deployment),
                            "cloud_control_deployment" => {
                                Ok(__FieldTag::__cloud_control_deployment)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudControlDeploymentReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudControlDeploymentReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_control_deployment => {
                            if !fields.insert(__FieldTag::__cloud_control_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_control_deployment",
                                ));
                            }
                            result.cloud_control_deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudControlDeploymentReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_control_deployment.is_empty() {
            state.serialize_entry("cloudControlDeployment", &self.cloud_control_deployment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudControlDeploymentReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudControlDeploymentReference");
        debug_struct.field("cloud_control_deployment", &self.cloud_control_deployment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The reference to the framework deployment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FrameworkDeploymentReference {
    /// Output only. The name of the framework. The format is:
    /// organizations/{org}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    pub framework_deployment: std::string::String,

    /// Optional. The reference to the framework that this deployment is for.
    /// Example: {
    /// framework:
    /// "organizations/{org}/locations/{location}/frameworks/{framework}",
    /// major_revision_id: 1
    /// }
    pub framework_reference: std::option::Option<crate::model::FrameworkReference>,

    /// Optional. The display name of the framework.
    pub framework_display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FrameworkDeploymentReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [framework_deployment][crate::model::FrameworkDeploymentReference::framework_deployment].
    pub fn set_framework_deployment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.framework_deployment = v.into();
        self
    }

    /// Sets the value of [framework_reference][crate::model::FrameworkDeploymentReference::framework_reference].
    pub fn set_framework_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FrameworkReference>,
    {
        self.framework_reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [framework_reference][crate::model::FrameworkDeploymentReference::framework_reference].
    pub fn set_or_clear_framework_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FrameworkReference>,
    {
        self.framework_reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [framework_display_name][crate::model::FrameworkDeploymentReference::framework_display_name].
    pub fn set_framework_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.framework_display_name = v.into();
        self
    }
}

impl wkt::message::Message for FrameworkDeploymentReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudsecuritycompliance.v1.FrameworkDeploymentReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FrameworkDeploymentReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __framework_deployment,
            __framework_reference,
            __framework_display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FrameworkDeploymentReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "frameworkDeployment" => Ok(__FieldTag::__framework_deployment),
                            "framework_deployment" => Ok(__FieldTag::__framework_deployment),
                            "frameworkReference" => Ok(__FieldTag::__framework_reference),
                            "framework_reference" => Ok(__FieldTag::__framework_reference),
                            "frameworkDisplayName" => Ok(__FieldTag::__framework_display_name),
                            "framework_display_name" => Ok(__FieldTag::__framework_display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FrameworkDeploymentReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FrameworkDeploymentReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__framework_deployment => {
                            if !fields.insert(__FieldTag::__framework_deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_deployment",
                                ));
                            }
                            result.framework_deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__framework_reference => {
                            if !fields.insert(__FieldTag::__framework_reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_reference",
                                ));
                            }
                            result.framework_reference = map.next_value::<std::option::Option<crate::model::FrameworkReference>>()?
                                ;
                        }
                        __FieldTag::__framework_display_name => {
                            if !fields.insert(__FieldTag::__framework_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework_display_name",
                                ));
                            }
                            result.framework_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FrameworkDeploymentReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.framework_deployment.is_empty() {
            state.serialize_entry("frameworkDeployment", &self.framework_deployment)?;
        }
        if self.framework_reference.is_some() {
            state.serialize_entry("frameworkReference", &self.framework_reference)?;
        }
        if !self.framework_display_name.is_empty() {
            state.serialize_entry("frameworkDisplayName", &self.framework_display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FrameworkDeploymentReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FrameworkDeploymentReference");
        debug_struct.field("framework_deployment", &self.framework_deployment);
        debug_struct.field("framework_reference", &self.framework_reference);
        debug_struct.field("framework_display_name", &self.framework_display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Regulatory Control Responsibility Type
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RegulatoryControlResponsibilityType {
    /// Unspecified. Invalid state.
    Unspecified,
    /// Google responsibility.
    Google,
    /// Customer responsibility.
    Customer,
    /// Shared responsibility.
    Shared,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RegulatoryControlResponsibilityType::value] or
    /// [RegulatoryControlResponsibilityType::name].
    UnknownValue(regulatory_control_responsibility_type::UnknownValue),
}

#[doc(hidden)]
pub mod regulatory_control_responsibility_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RegulatoryControlResponsibilityType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Google => std::option::Option::Some(1),
            Self::Customer => std::option::Option::Some(2),
            Self::Shared => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("REGULATORY_CONTROL_RESPONSIBILITY_TYPE_UNSPECIFIED")
            }
            Self::Google => std::option::Option::Some("GOOGLE"),
            Self::Customer => std::option::Option::Some("CUSTOMER"),
            Self::Shared => std::option::Option::Some("SHARED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RegulatoryControlResponsibilityType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RegulatoryControlResponsibilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RegulatoryControlResponsibilityType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Google,
            2 => Self::Customer,
            3 => Self::Shared,
            _ => Self::UnknownValue(regulatory_control_responsibility_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RegulatoryControlResponsibilityType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "REGULATORY_CONTROL_RESPONSIBILITY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "GOOGLE" => Self::Google,
            "CUSTOMER" => Self::Customer,
            "SHARED" => Self::Shared,
            _ => Self::UnknownValue(regulatory_control_responsibility_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RegulatoryControlResponsibilityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Google => serializer.serialize_i32(1),
            Self::Customer => serializer.serialize_i32(2),
            Self::Shared => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RegulatoryControlResponsibilityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<
            RegulatoryControlResponsibilityType,
        >::new(
            ".google.cloud.cloudsecuritycompliance.v1.RegulatoryControlResponsibilityType",
        ))
    }
}

/// The enforcement mode of the cloud control.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EnforcementMode {
    /// Default value. This value is unused.
    Unspecified,
    /// The cloud control is enforced to prevent resource non-compliance.
    Preventive,
    /// The cloud control is enforced to detect resource non-compliance.
    Detective,
    /// The cloud control is enforced to audit resource non-compliance.
    Audit,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EnforcementMode::value] or
    /// [EnforcementMode::name].
    UnknownValue(enforcement_mode::UnknownValue),
}

#[doc(hidden)]
pub mod enforcement_mode {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EnforcementMode {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Preventive => std::option::Option::Some(1),
            Self::Detective => std::option::Option::Some(2),
            Self::Audit => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENFORCEMENT_MODE_UNSPECIFIED"),
            Self::Preventive => std::option::Option::Some("PREVENTIVE"),
            Self::Detective => std::option::Option::Some("DETECTIVE"),
            Self::Audit => std::option::Option::Some("AUDIT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EnforcementMode {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EnforcementMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EnforcementMode {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Preventive,
            2 => Self::Detective,
            3 => Self::Audit,
            _ => Self::UnknownValue(enforcement_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EnforcementMode {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENFORCEMENT_MODE_UNSPECIFIED" => Self::Unspecified,
            "PREVENTIVE" => Self::Preventive,
            "DETECTIVE" => Self::Detective,
            "AUDIT" => Self::Audit,
            _ => Self::UnknownValue(enforcement_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EnforcementMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Preventive => serializer.serialize_i32(1),
            Self::Detective => serializer.serialize_i32(2),
            Self::Audit => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EnforcementMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EnforcementMode>::new(
            ".google.cloud.cloudsecuritycompliance.v1.EnforcementMode",
        ))
    }
}

/// The category of the framework.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FrameworkCategory {
    /// Default value. This value is unused.
    Unspecified,
    /// Standard framework
    IndustryDefinedStandard,
    /// Assured Workloads framework
    AssuredWorkloads,
    /// Data Security framework
    DataSecurity,
    /// Google Best Practices framework
    GoogleBestPractices,
    /// User created framework.
    CustomFramework,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FrameworkCategory::value] or
    /// [FrameworkCategory::name].
    UnknownValue(framework_category::UnknownValue),
}

#[doc(hidden)]
pub mod framework_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FrameworkCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::IndustryDefinedStandard => std::option::Option::Some(1),
            Self::AssuredWorkloads => std::option::Option::Some(2),
            Self::DataSecurity => std::option::Option::Some(3),
            Self::GoogleBestPractices => std::option::Option::Some(4),
            Self::CustomFramework => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FRAMEWORK_CATEGORY_UNSPECIFIED"),
            Self::IndustryDefinedStandard => std::option::Option::Some("INDUSTRY_DEFINED_STANDARD"),
            Self::AssuredWorkloads => std::option::Option::Some("ASSURED_WORKLOADS"),
            Self::DataSecurity => std::option::Option::Some("DATA_SECURITY"),
            Self::GoogleBestPractices => std::option::Option::Some("GOOGLE_BEST_PRACTICES"),
            Self::CustomFramework => std::option::Option::Some("CUSTOM_FRAMEWORK"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FrameworkCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FrameworkCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FrameworkCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::IndustryDefinedStandard,
            2 => Self::AssuredWorkloads,
            3 => Self::DataSecurity,
            4 => Self::GoogleBestPractices,
            5 => Self::CustomFramework,
            _ => Self::UnknownValue(framework_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FrameworkCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FRAMEWORK_CATEGORY_UNSPECIFIED" => Self::Unspecified,
            "INDUSTRY_DEFINED_STANDARD" => Self::IndustryDefinedStandard,
            "ASSURED_WORKLOADS" => Self::AssuredWorkloads,
            "DATA_SECURITY" => Self::DataSecurity,
            "GOOGLE_BEST_PRACTICES" => Self::GoogleBestPractices,
            "CUSTOM_FRAMEWORK" => Self::CustomFramework,
            _ => Self::UnknownValue(framework_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FrameworkCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::IndustryDefinedStandard => serializer.serialize_i32(1),
            Self::AssuredWorkloads => serializer.serialize_i32(2),
            Self::DataSecurity => serializer.serialize_i32(3),
            Self::GoogleBestPractices => serializer.serialize_i32(4),
            Self::CustomFramework => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FrameworkCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FrameworkCategory>::new(
            ".google.cloud.cloudsecuritycompliance.v1.FrameworkCategory",
        ))
    }
}

/// The category of the cloud control.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CloudControlCategory {
    /// Default value. This value is unused.
    Unspecified,
    /// Infrastructure
    CcCategoryInfrastructure,
    /// Artificial Intelligence
    CcCategoryArtificialIntelligence,
    /// Physical Security
    CcCategoryPhysicalSecurity,
    /// Data Security
    CcCategoryDataSecurity,
    /// Network Security
    CcCategoryNetworkSecurity,
    /// Incident Management
    CcCategoryIncidentManagement,
    /// Identity & Access Management
    CcCategoryIdentityAndAccessManagement,
    /// Encryption
    CcCategoryEncryption,
    /// Logs Management & Infrastructure
    CcCategoryLogsManagementAndInfrastructure,
    /// HR, Admin & Processes
    CcCategoryHrAdminAndProcesses,
    /// Third Party & Sub-Processor Management
    CcCategoryThirdPartyAndSubProcessorManagement,
    /// Legal & Disclosures
    CcCategoryLegalAndDisclosures,
    /// Vulnerability Management
    CcCategoryVulnerabilityManagement,
    /// Privacy
    CcCategoryPrivacy,
    /// BCDR (Business Continuity and Disaster Recovery)
    CcCategoryBcdr,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CloudControlCategory::value] or
    /// [CloudControlCategory::name].
    UnknownValue(cloud_control_category::UnknownValue),
}

#[doc(hidden)]
pub mod cloud_control_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CloudControlCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CcCategoryInfrastructure => std::option::Option::Some(1),
            Self::CcCategoryArtificialIntelligence => std::option::Option::Some(2),
            Self::CcCategoryPhysicalSecurity => std::option::Option::Some(3),
            Self::CcCategoryDataSecurity => std::option::Option::Some(4),
            Self::CcCategoryNetworkSecurity => std::option::Option::Some(5),
            Self::CcCategoryIncidentManagement => std::option::Option::Some(6),
            Self::CcCategoryIdentityAndAccessManagement => std::option::Option::Some(7),
            Self::CcCategoryEncryption => std::option::Option::Some(8),
            Self::CcCategoryLogsManagementAndInfrastructure => std::option::Option::Some(9),
            Self::CcCategoryHrAdminAndProcesses => std::option::Option::Some(10),
            Self::CcCategoryThirdPartyAndSubProcessorManagement => std::option::Option::Some(11),
            Self::CcCategoryLegalAndDisclosures => std::option::Option::Some(12),
            Self::CcCategoryVulnerabilityManagement => std::option::Option::Some(13),
            Self::CcCategoryPrivacy => std::option::Option::Some(14),
            Self::CcCategoryBcdr => std::option::Option::Some(15),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CLOUD_CONTROL_CATEGORY_UNSPECIFIED"),
            Self::CcCategoryInfrastructure => {
                std::option::Option::Some("CC_CATEGORY_INFRASTRUCTURE")
            }
            Self::CcCategoryArtificialIntelligence => {
                std::option::Option::Some("CC_CATEGORY_ARTIFICIAL_INTELLIGENCE")
            }
            Self::CcCategoryPhysicalSecurity => {
                std::option::Option::Some("CC_CATEGORY_PHYSICAL_SECURITY")
            }
            Self::CcCategoryDataSecurity => std::option::Option::Some("CC_CATEGORY_DATA_SECURITY"),
            Self::CcCategoryNetworkSecurity => {
                std::option::Option::Some("CC_CATEGORY_NETWORK_SECURITY")
            }
            Self::CcCategoryIncidentManagement => {
                std::option::Option::Some("CC_CATEGORY_INCIDENT_MANAGEMENT")
            }
            Self::CcCategoryIdentityAndAccessManagement => {
                std::option::Option::Some("CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT")
            }
            Self::CcCategoryEncryption => std::option::Option::Some("CC_CATEGORY_ENCRYPTION"),
            Self::CcCategoryLogsManagementAndInfrastructure => {
                std::option::Option::Some("CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE")
            }
            Self::CcCategoryHrAdminAndProcesses => {
                std::option::Option::Some("CC_CATEGORY_HR_ADMIN_AND_PROCESSES")
            }
            Self::CcCategoryThirdPartyAndSubProcessorManagement => {
                std::option::Option::Some("CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT")
            }
            Self::CcCategoryLegalAndDisclosures => {
                std::option::Option::Some("CC_CATEGORY_LEGAL_AND_DISCLOSURES")
            }
            Self::CcCategoryVulnerabilityManagement => {
                std::option::Option::Some("CC_CATEGORY_VULNERABILITY_MANAGEMENT")
            }
            Self::CcCategoryPrivacy => std::option::Option::Some("CC_CATEGORY_PRIVACY"),
            Self::CcCategoryBcdr => std::option::Option::Some("CC_CATEGORY_BCDR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CloudControlCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CloudControlCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CloudControlCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CcCategoryInfrastructure,
            2 => Self::CcCategoryArtificialIntelligence,
            3 => Self::CcCategoryPhysicalSecurity,
            4 => Self::CcCategoryDataSecurity,
            5 => Self::CcCategoryNetworkSecurity,
            6 => Self::CcCategoryIncidentManagement,
            7 => Self::CcCategoryIdentityAndAccessManagement,
            8 => Self::CcCategoryEncryption,
            9 => Self::CcCategoryLogsManagementAndInfrastructure,
            10 => Self::CcCategoryHrAdminAndProcesses,
            11 => Self::CcCategoryThirdPartyAndSubProcessorManagement,
            12 => Self::CcCategoryLegalAndDisclosures,
            13 => Self::CcCategoryVulnerabilityManagement,
            14 => Self::CcCategoryPrivacy,
            15 => Self::CcCategoryBcdr,
            _ => Self::UnknownValue(cloud_control_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CloudControlCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CLOUD_CONTROL_CATEGORY_UNSPECIFIED" => Self::Unspecified,
            "CC_CATEGORY_INFRASTRUCTURE" => Self::CcCategoryInfrastructure,
            "CC_CATEGORY_ARTIFICIAL_INTELLIGENCE" => Self::CcCategoryArtificialIntelligence,
            "CC_CATEGORY_PHYSICAL_SECURITY" => Self::CcCategoryPhysicalSecurity,
            "CC_CATEGORY_DATA_SECURITY" => Self::CcCategoryDataSecurity,
            "CC_CATEGORY_NETWORK_SECURITY" => Self::CcCategoryNetworkSecurity,
            "CC_CATEGORY_INCIDENT_MANAGEMENT" => Self::CcCategoryIncidentManagement,
            "CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT" => {
                Self::CcCategoryIdentityAndAccessManagement
            }
            "CC_CATEGORY_ENCRYPTION" => Self::CcCategoryEncryption,
            "CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE" => {
                Self::CcCategoryLogsManagementAndInfrastructure
            }
            "CC_CATEGORY_HR_ADMIN_AND_PROCESSES" => Self::CcCategoryHrAdminAndProcesses,
            "CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT" => {
                Self::CcCategoryThirdPartyAndSubProcessorManagement
            }
            "CC_CATEGORY_LEGAL_AND_DISCLOSURES" => Self::CcCategoryLegalAndDisclosures,
            "CC_CATEGORY_VULNERABILITY_MANAGEMENT" => Self::CcCategoryVulnerabilityManagement,
            "CC_CATEGORY_PRIVACY" => Self::CcCategoryPrivacy,
            "CC_CATEGORY_BCDR" => Self::CcCategoryBcdr,
            _ => Self::UnknownValue(cloud_control_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CloudControlCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CcCategoryInfrastructure => serializer.serialize_i32(1),
            Self::CcCategoryArtificialIntelligence => serializer.serialize_i32(2),
            Self::CcCategoryPhysicalSecurity => serializer.serialize_i32(3),
            Self::CcCategoryDataSecurity => serializer.serialize_i32(4),
            Self::CcCategoryNetworkSecurity => serializer.serialize_i32(5),
            Self::CcCategoryIncidentManagement => serializer.serialize_i32(6),
            Self::CcCategoryIdentityAndAccessManagement => serializer.serialize_i32(7),
            Self::CcCategoryEncryption => serializer.serialize_i32(8),
            Self::CcCategoryLogsManagementAndInfrastructure => serializer.serialize_i32(9),
            Self::CcCategoryHrAdminAndProcesses => serializer.serialize_i32(10),
            Self::CcCategoryThirdPartyAndSubProcessorManagement => serializer.serialize_i32(11),
            Self::CcCategoryLegalAndDisclosures => serializer.serialize_i32(12),
            Self::CcCategoryVulnerabilityManagement => serializer.serialize_i32(13),
            Self::CcCategoryPrivacy => serializer.serialize_i32(14),
            Self::CcCategoryBcdr => serializer.serialize_i32(15),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CloudControlCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudControlCategory>::new(
            ".google.cloud.cloudsecuritycompliance.v1.CloudControlCategory",
        ))
    }
}

/// The cloud platform.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CloudProvider {
    /// Default value. This value is unused.
    Unspecified,
    /// Amazon Web Services (AWS).
    Aws,
    /// Microsoft Azure.
    Azure,
    /// Google Cloud.
    Gcp,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CloudProvider::value] or
    /// [CloudProvider::name].
    UnknownValue(cloud_provider::UnknownValue),
}

#[doc(hidden)]
pub mod cloud_provider {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CloudProvider {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Aws => std::option::Option::Some(1),
            Self::Azure => std::option::Option::Some(2),
            Self::Gcp => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CLOUD_PROVIDER_UNSPECIFIED"),
            Self::Aws => std::option::Option::Some("AWS"),
            Self::Azure => std::option::Option::Some("AZURE"),
            Self::Gcp => std::option::Option::Some("GCP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CloudProvider {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CloudProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CloudProvider {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Aws,
            2 => Self::Azure,
            3 => Self::Gcp,
            _ => Self::UnknownValue(cloud_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CloudProvider {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CLOUD_PROVIDER_UNSPECIFIED" => Self::Unspecified,
            "AWS" => Self::Aws,
            "AZURE" => Self::Azure,
            "GCP" => Self::Gcp,
            _ => Self::UnknownValue(cloud_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CloudProvider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Aws => serializer.serialize_i32(1),
            Self::Azure => serializer.serialize_i32(2),
            Self::Gcp => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CloudProvider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CloudProvider>::new(
            ".google.cloud.cloudsecuritycompliance.v1.CloudProvider",
        ))
    }
}

/// The severity of the finding.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Severity {
    /// This value is used for findings when a source doesn't write a severity
    /// value.
    Unspecified,
    /// Vulnerability:
    /// A critical vulnerability is easily discoverable by an external actor,
    /// exploitable, and results in the direct ability to execute arbitrary code,
    /// exfiltrate data, and otherwise gain additional access and privileges to
    /// cloud resources and workloads. Examples include publicly accessible
    /// unprotected user data and public SSH access with weak or no
    /// passwords.
    ///
    /// Threat:
    /// Indicates a threat that is able to access, modify, or delete data or
    /// execute unauthorized code within existing resources.
    Critical,
    /// Vulnerability:
    /// A high risk vulnerability can be easily discovered and exploited in
    /// combination with other vulnerabilities in order to gain direct access and
    /// the ability to execute arbitrary code, exfiltrate data, and otherwise
    /// gain additional access and privileges to cloud resources and workloads.
    /// An example is a database with weak or no passwords that is only
    /// accessible internally. This database could easily be compromised by an
    /// actor that had access to the internal network.
    ///
    /// Threat:
    /// Indicates a threat that is able to create new computational resources in
    /// an environment but not able to access data or execute code in existing
    /// resources.
    High,
    /// Vulnerability:
    /// A medium risk vulnerability could be used by an actor to gain access to
    /// resources or privileges that enable them to eventually (through multiple
    /// steps or a complex exploit) gain access and the ability to execute
    /// arbitrary code or exfiltrate data. An example is a service account with
    /// access to more projects than it should have. If an actor gains access to
    /// the service account, they could potentially use that access to manipulate
    /// a project the service account was not intended to.
    ///
    /// Threat:
    /// Indicates a threat that is able to cause operational impact but may not
    /// access data or execute unauthorized code.
    Medium,
    /// Vulnerability:
    /// A low risk vulnerability hampers a security organization's ability to
    /// detect vulnerabilities or active threats in their deployment, or prevents
    /// the root cause investigation of security issues. An example is monitoring
    /// and logs being disabled for resource configurations and access.
    ///
    /// Threat:
    /// Indicates a threat that has obtained minimal access to an environment but
    /// is not able to access data, execute code, or create resources.
    Low,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Severity::value] or
    /// [Severity::name].
    UnknownValue(severity::UnknownValue),
}

#[doc(hidden)]
pub mod severity {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Severity {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Critical => std::option::Option::Some(1),
            Self::High => std::option::Option::Some(2),
            Self::Medium => std::option::Option::Some(3),
            Self::Low => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
            Self::Critical => std::option::Option::Some("CRITICAL"),
            Self::High => std::option::Option::Some("HIGH"),
            Self::Medium => std::option::Option::Some("MEDIUM"),
            Self::Low => std::option::Option::Some("LOW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Severity {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Severity {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Critical,
            2 => Self::High,
            3 => Self::Medium,
            4 => Self::Low,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Severity {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEVERITY_UNSPECIFIED" => Self::Unspecified,
            "CRITICAL" => Self::Critical,
            "HIGH" => Self::High,
            "MEDIUM" => Self::Medium,
            "LOW" => Self::Low,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Severity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Critical => serializer.serialize_i32(1),
            Self::High => serializer.serialize_i32(2),
            Self::Medium => serializer.serialize_i32(3),
            Self::Low => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Severity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
            ".google.cloud.cloudsecuritycompliance.v1.Severity",
        ))
    }
}

/// The action type of the rule.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RuleActionType {
    /// Default value. This value is unused.
    Unspecified,
    /// Preventative action type.
    Preventive,
    /// Detective action type.
    Detective,
    /// Audit action type.
    Audit,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RuleActionType::value] or
    /// [RuleActionType::name].
    UnknownValue(rule_action_type::UnknownValue),
}

#[doc(hidden)]
pub mod rule_action_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RuleActionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Preventive => std::option::Option::Some(1),
            Self::Detective => std::option::Option::Some(2),
            Self::Audit => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RULE_ACTION_TYPE_UNSPECIFIED"),
            Self::Preventive => std::option::Option::Some("RULE_ACTION_TYPE_PREVENTIVE"),
            Self::Detective => std::option::Option::Some("RULE_ACTION_TYPE_DETECTIVE"),
            Self::Audit => std::option::Option::Some("RULE_ACTION_TYPE_AUDIT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RuleActionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RuleActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RuleActionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Preventive,
            2 => Self::Detective,
            3 => Self::Audit,
            _ => Self::UnknownValue(rule_action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RuleActionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RULE_ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "RULE_ACTION_TYPE_PREVENTIVE" => Self::Preventive,
            "RULE_ACTION_TYPE_DETECTIVE" => Self::Detective,
            "RULE_ACTION_TYPE_AUDIT" => Self::Audit,
            _ => Self::UnknownValue(rule_action_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RuleActionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Preventive => serializer.serialize_i32(1),
            Self::Detective => serializer.serialize_i32(2),
            Self::Audit => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RuleActionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RuleActionType>::new(
            ".google.cloud.cloudsecuritycompliance.v1.RuleActionType",
        ))
    }
}

/// TargetResourceType represents the type of resource that a control or
/// framework can be applied to.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TargetResourceType {
    /// Default value. This value is unused.
    Unspecified,
    /// Target resource is an Organization.
    TargetResourceCrmTypeOrg,
    /// Target resource is a Folder.
    TargetResourceCrmTypeFolder,
    /// Target resource is a Project.
    TargetResourceCrmTypeProject,
    /// Target resource is an Application.
    Application,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TargetResourceType::value] or
    /// [TargetResourceType::name].
    UnknownValue(target_resource_type::UnknownValue),
}

#[doc(hidden)]
pub mod target_resource_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TargetResourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::TargetResourceCrmTypeOrg => std::option::Option::Some(1),
            Self::TargetResourceCrmTypeFolder => std::option::Option::Some(2),
            Self::TargetResourceCrmTypeProject => std::option::Option::Some(3),
            Self::Application => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TARGET_RESOURCE_TYPE_UNSPECIFIED"),
            Self::TargetResourceCrmTypeOrg => {
                std::option::Option::Some("TARGET_RESOURCE_CRM_TYPE_ORG")
            }
            Self::TargetResourceCrmTypeFolder => {
                std::option::Option::Some("TARGET_RESOURCE_CRM_TYPE_FOLDER")
            }
            Self::TargetResourceCrmTypeProject => {
                std::option::Option::Some("TARGET_RESOURCE_CRM_TYPE_PROJECT")
            }
            Self::Application => std::option::Option::Some("TARGET_RESOURCE_TYPE_APPLICATION"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TargetResourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TargetResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TargetResourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::TargetResourceCrmTypeOrg,
            2 => Self::TargetResourceCrmTypeFolder,
            3 => Self::TargetResourceCrmTypeProject,
            4 => Self::Application,
            _ => Self::UnknownValue(target_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TargetResourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TARGET_RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TARGET_RESOURCE_CRM_TYPE_ORG" => Self::TargetResourceCrmTypeOrg,
            "TARGET_RESOURCE_CRM_TYPE_FOLDER" => Self::TargetResourceCrmTypeFolder,
            "TARGET_RESOURCE_CRM_TYPE_PROJECT" => Self::TargetResourceCrmTypeProject,
            "TARGET_RESOURCE_TYPE_APPLICATION" => Self::Application,
            _ => Self::UnknownValue(target_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TargetResourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::TargetResourceCrmTypeOrg => serializer.serialize_i32(1),
            Self::TargetResourceCrmTypeFolder => serializer.serialize_i32(2),
            Self::TargetResourceCrmTypeProject => serializer.serialize_i32(3),
            Self::Application => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TargetResourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetResourceType>::new(
            ".google.cloud.cloudsecuritycompliance.v1.TargetResourceType",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DeploymentState {
    /// Unspecified. Invalid state.
    Unspecified,
    /// Validating the deployment.
    Validating,
    /// Deployment is in CREATING state.
    Creating,
    /// Deployment is in DELETING state.
    Deleting,
    /// Deployment has failed.
    Failed,
    /// Deployment is ready.
    Ready,
    /// Deployment is partially deployed.
    PartiallyDeployed,
    /// Deployment is partially deleted.
    PartiallyDeleted,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DeploymentState::value] or
    /// [DeploymentState::name].
    UnknownValue(deployment_state::UnknownValue),
}

#[doc(hidden)]
pub mod deployment_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DeploymentState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Validating => std::option::Option::Some(1),
            Self::Creating => std::option::Option::Some(2),
            Self::Deleting => std::option::Option::Some(3),
            Self::Failed => std::option::Option::Some(4),
            Self::Ready => std::option::Option::Some(5),
            Self::PartiallyDeployed => std::option::Option::Some(6),
            Self::PartiallyDeleted => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DEPLOYMENT_STATE_UNSPECIFIED"),
            Self::Validating => std::option::Option::Some("DEPLOYMENT_STATE_VALIDATING"),
            Self::Creating => std::option::Option::Some("DEPLOYMENT_STATE_CREATING"),
            Self::Deleting => std::option::Option::Some("DEPLOYMENT_STATE_DELETING"),
            Self::Failed => std::option::Option::Some("DEPLOYMENT_STATE_FAILED"),
            Self::Ready => std::option::Option::Some("DEPLOYMENT_STATE_READY"),
            Self::PartiallyDeployed => {
                std::option::Option::Some("DEPLOYMENT_STATE_PARTIALLY_DEPLOYED")
            }
            Self::PartiallyDeleted => {
                std::option::Option::Some("DEPLOYMENT_STATE_PARTIALLY_DELETED")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DeploymentState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DeploymentState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DeploymentState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Validating,
            2 => Self::Creating,
            3 => Self::Deleting,
            4 => Self::Failed,
            5 => Self::Ready,
            6 => Self::PartiallyDeployed,
            7 => Self::PartiallyDeleted,
            _ => Self::UnknownValue(deployment_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DeploymentState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DEPLOYMENT_STATE_UNSPECIFIED" => Self::Unspecified,
            "DEPLOYMENT_STATE_VALIDATING" => Self::Validating,
            "DEPLOYMENT_STATE_CREATING" => Self::Creating,
            "DEPLOYMENT_STATE_DELETING" => Self::Deleting,
            "DEPLOYMENT_STATE_FAILED" => Self::Failed,
            "DEPLOYMENT_STATE_READY" => Self::Ready,
            "DEPLOYMENT_STATE_PARTIALLY_DEPLOYED" => Self::PartiallyDeployed,
            "DEPLOYMENT_STATE_PARTIALLY_DELETED" => Self::PartiallyDeleted,
            _ => Self::UnknownValue(deployment_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DeploymentState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Validating => serializer.serialize_i32(1),
            Self::Creating => serializer.serialize_i32(2),
            Self::Deleting => serializer.serialize_i32(3),
            Self::Failed => serializer.serialize_i32(4),
            Self::Ready => serializer.serialize_i32(5),
            Self::PartiallyDeployed => serializer.serialize_i32(6),
            Self::PartiallyDeleted => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DeploymentState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeploymentState>::new(
            ".google.cloud.cloudsecuritycompliance.v1.DeploymentState",
        ))
    }
}
