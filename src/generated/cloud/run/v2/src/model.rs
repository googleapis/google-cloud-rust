// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for submitting a Build.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitBuildRequest {
    /// Required. The project and location to build in. Location must be a region,
    /// e.g., 'us-central1' or 'global' if the global builder is to be used.
    /// Format:
    /// `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. Artifact Registry URI to store the built image.
    pub image_uri: std::string::String,

    /// Optional. The service account to use for the build. If not set, the default
    /// Cloud Build service account for the project will be used.
    pub service_account: std::string::String,

    /// Optional. Name of the Cloud Build Custom Worker Pool that should be used to
    /// build the function. The format of this field is
    /// `projects/{project}/locations/{region}/workerPools/{workerPool}` where
    /// `{project}` and `{region}` are the project id and region respectively where
    /// the worker pool is defined and `{workerPool}` is the short name of the
    /// worker pool.
    pub worker_pool: std::string::String,

    /// Optional. Additional tags to annotate the build.
    pub tags: std::vec::Vec<std::string::String>,

    /// Location of source.
    pub source: std::option::Option<crate::model::submit_build_request::Source>,

    /// Build type must be one of the following.
    pub build_type: std::option::Option<crate::model::submit_build_request::BuildType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitBuildRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::SubmitBuildRequest::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::SubmitBuildRequest::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::SubmitBuildRequest::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::SubmitBuildRequest::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source][crate::model::SubmitBuildRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::submit_build_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::SubmitBuildRequest::source]
    /// if it holds a `StorageSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::submit_build_request::Source::StorageSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SubmitBuildRequest::source]
    /// to hold a `StorageSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::submit_build_request::Source::StorageSource(v.into()),
        );
        self
    }

    /// Sets the value of [build_type][crate::model::SubmitBuildRequest::build_type].
    ///
    /// Note that all the setters affecting `build_type` are mutually
    /// exclusive.
    pub fn set_build_type<
        T: std::convert::Into<std::option::Option<crate::model::submit_build_request::BuildType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_type = v.into();
        self
    }

    /// The value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// if it holds a `BuildpackBuild`, `None` if the field is not set or
    /// holds a different branch.
    pub fn buildpack_build(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::submit_build_request::BuildpacksBuild>>
    {
        #[allow(unreachable_patterns)]
        self.build_type.as_ref().and_then(|v| match v {
            crate::model::submit_build_request::BuildType::BuildpackBuild(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// to hold a `BuildpackBuild`.
    ///
    /// Note that all the setters affecting `build_type` are
    /// mutually exclusive.
    pub fn set_buildpack_build<
        T: std::convert::Into<std::boxed::Box<crate::model::submit_build_request::BuildpacksBuild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_type = std::option::Option::Some(
            crate::model::submit_build_request::BuildType::BuildpackBuild(v.into()),
        );
        self
    }

    /// The value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// if it holds a `DockerBuild`, `None` if the field is not set or
    /// holds a different branch.
    pub fn docker_build(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::submit_build_request::DockerBuild>>
    {
        #[allow(unreachable_patterns)]
        self.build_type.as_ref().and_then(|v| match v {
            crate::model::submit_build_request::BuildType::DockerBuild(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// to hold a `DockerBuild`.
    ///
    /// Note that all the setters affecting `build_type` are
    /// mutually exclusive.
    pub fn set_docker_build<
        T: std::convert::Into<std::boxed::Box<crate::model::submit_build_request::DockerBuild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_type = std::option::Option::Some(
            crate::model::submit_build_request::BuildType::DockerBuild(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SubmitBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SubmitBuildRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitBuildRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __storage_source,
            __image_uri,
            __buildpack_build,
            __docker_build,
            __service_account,
            __worker_pool,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitBuildRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "storageSource" => Ok(__FieldTag::__storage_source),
                            "storage_source" => Ok(__FieldTag::__storage_source),
                            "imageUri" => Ok(__FieldTag::__image_uri),
                            "image_uri" => Ok(__FieldTag::__image_uri),
                            "buildpackBuild" => Ok(__FieldTag::__buildpack_build),
                            "buildpack_build" => Ok(__FieldTag::__buildpack_build),
                            "dockerBuild" => Ok(__FieldTag::__docker_build),
                            "docker_build" => Ok(__FieldTag::__docker_build),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitBuildRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitBuildRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_source => {
                            if !fields.insert(__FieldTag::__storage_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.run.v2.SubmitBuildRequest.storage_source, latest field was storageSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::submit_build_request::Source::StorageSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StorageSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__image_uri => {
                            if !fields.insert(__FieldTag::__image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_uri",
                                ));
                            }
                            result.image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__buildpack_build => {
                            if !fields.insert(__FieldTag::__buildpack_build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for buildpack_build",
                                ));
                            }
                            if result.build_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_type`, a oneof with full ID .google.cloud.run.v2.SubmitBuildRequest.buildpack_build, latest field was buildpackBuild",
                                ));
                            }
                            result.build_type = std::option::Option::Some(
                                crate::model::submit_build_request::BuildType::BuildpackBuild(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::submit_build_request::BuildpacksBuild,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__docker_build => {
                            if !fields.insert(__FieldTag::__docker_build) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for docker_build",
                                ));
                            }
                            if result.build_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `build_type`, a oneof with full ID .google.cloud.run.v2.SubmitBuildRequest.docker_build, latest field was dockerBuild",
                                ));
                            }
                            result.build_type = std::option::Option::Some(
                                crate::model::submit_build_request::BuildType::DockerBuild(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::submit_build_request::DockerBuild,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitBuildRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.storage_source() {
            state.serialize_entry("storageSource", value)?;
        }
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if let Some(value) = self.buildpack_build() {
            state.serialize_entry("buildpackBuild", value)?;
        }
        if let Some(value) = self.docker_build() {
            state.serialize_entry("dockerBuild", value)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SubmitBuildRequest].
pub mod submit_build_request {
    #[allow(unused_imports)]
    use super::*;

    /// Build the source using Docker. This means the source has a Dockerfile.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DockerBuild {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DockerBuild {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for DockerBuild {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.SubmitBuildRequest.DockerBuild"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DockerBuild {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DockerBuild")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DockerBuild;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DockerBuild")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DockerBuild {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Build the source using Buildpacks.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BuildpacksBuild {
        /// The runtime name, e.g. 'go113'. Leave blank for generic builds.
        #[deprecated]
        pub runtime: std::string::String,

        /// Optional. Name of the function target if the source is a function source.
        /// Required for function builds.
        pub function_target: std::string::String,

        /// Optional. cache_image_uri is the GCR/AR URL where the cache image will be
        /// stored. cache_image_uri is optional and omitting it will disable caching.
        /// This URL must be stable across builds. It is used to derive a
        /// build-specific temporary URL by substituting the tag with the build ID.
        /// The build will clean up the temporary image on a best-effort basis.
        pub cache_image_uri: std::string::String,

        /// Optional. The base image to use for the build.
        pub base_image: std::string::String,

        /// Optional. User-provided build-time environment variables.
        pub environment_variables:
            std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. Whether or not the application container will be enrolled in
        /// automatic base image updates. When true, the application will be built on
        /// a scratch base image, so the base layers can be appended at run time.
        pub enable_automatic_updates: bool,

        /// Optional. project_descriptor stores the path to the project descriptor
        /// file. When empty, it means that there is no project descriptor file in
        /// the source.
        pub project_descriptor: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildpacksBuild {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [runtime][crate::model::submit_build_request::BuildpacksBuild::runtime].
        #[deprecated]
        pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.runtime = v.into();
            self
        }

        /// Sets the value of [function_target][crate::model::submit_build_request::BuildpacksBuild::function_target].
        pub fn set_function_target<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.function_target = v.into();
            self
        }

        /// Sets the value of [cache_image_uri][crate::model::submit_build_request::BuildpacksBuild::cache_image_uri].
        pub fn set_cache_image_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cache_image_uri = v.into();
            self
        }

        /// Sets the value of [base_image][crate::model::submit_build_request::BuildpacksBuild::base_image].
        pub fn set_base_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.base_image = v.into();
            self
        }

        /// Sets the value of [environment_variables][crate::model::submit_build_request::BuildpacksBuild::environment_variables].
        pub fn set_environment_variables<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.environment_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [enable_automatic_updates][crate::model::submit_build_request::BuildpacksBuild::enable_automatic_updates].
        pub fn set_enable_automatic_updates<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_automatic_updates = v.into();
            self
        }

        /// Sets the value of [project_descriptor][crate::model::submit_build_request::BuildpacksBuild::project_descriptor].
        pub fn set_project_descriptor<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.project_descriptor = v.into();
            self
        }
    }

    impl wkt::message::Message for BuildpacksBuild {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.SubmitBuildRequest.BuildpacksBuild"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BuildpacksBuild {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __runtime,
                __function_target,
                __cache_image_uri,
                __base_image,
                __environment_variables,
                __enable_automatic_updates,
                __project_descriptor,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BuildpacksBuild")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "runtime" => Ok(__FieldTag::__runtime),
                                "functionTarget" => Ok(__FieldTag::__function_target),
                                "function_target" => Ok(__FieldTag::__function_target),
                                "cacheImageUri" => Ok(__FieldTag::__cache_image_uri),
                                "cache_image_uri" => Ok(__FieldTag::__cache_image_uri),
                                "baseImage" => Ok(__FieldTag::__base_image),
                                "base_image" => Ok(__FieldTag::__base_image),
                                "environmentVariables" => Ok(__FieldTag::__environment_variables),
                                "environment_variables" => Ok(__FieldTag::__environment_variables),
                                "enableAutomaticUpdates" => {
                                    Ok(__FieldTag::__enable_automatic_updates)
                                }
                                "enable_automatic_updates" => {
                                    Ok(__FieldTag::__enable_automatic_updates)
                                }
                                "projectDescriptor" => Ok(__FieldTag::__project_descriptor),
                                "project_descriptor" => Ok(__FieldTag::__project_descriptor),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BuildpacksBuild;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BuildpacksBuild")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__runtime => {
                                if !fields.insert(__FieldTag::__runtime) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for runtime",
                                    ));
                                }
                                result.runtime = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__function_target => {
                                if !fields.insert(__FieldTag::__function_target) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for function_target",
                                    ));
                                }
                                result.function_target = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cache_image_uri => {
                                if !fields.insert(__FieldTag::__cache_image_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cache_image_uri",
                                    ));
                                }
                                result.cache_image_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__base_image => {
                                if !fields.insert(__FieldTag::__base_image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for base_image",
                                    ));
                                }
                                result.base_image = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__environment_variables => {
                                if !fields.insert(__FieldTag::__environment_variables) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for environment_variables",
                                    ));
                                }
                                result.environment_variables = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_automatic_updates => {
                                if !fields.insert(__FieldTag::__enable_automatic_updates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_automatic_updates",
                                    ));
                                }
                                result.enable_automatic_updates = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__project_descriptor => {
                                if !fields.insert(__FieldTag::__project_descriptor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_descriptor",
                                    ));
                                }
                                result.project_descriptor = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BuildpacksBuild {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.runtime.is_empty() {
                state.serialize_entry("runtime", &self.runtime)?;
            }
            if !self.function_target.is_empty() {
                state.serialize_entry("functionTarget", &self.function_target)?;
            }
            if !self.cache_image_uri.is_empty() {
                state.serialize_entry("cacheImageUri", &self.cache_image_uri)?;
            }
            if !self.base_image.is_empty() {
                state.serialize_entry("baseImage", &self.base_image)?;
            }
            if !self.environment_variables.is_empty() {
                state.serialize_entry("environmentVariables", &self.environment_variables)?;
            }
            if !wkt::internal::is_default(&self.enable_automatic_updates) {
                state.serialize_entry("enableAutomaticUpdates", &self.enable_automatic_updates)?;
            }
            if !self.project_descriptor.is_empty() {
                state.serialize_entry("projectDescriptor", &self.project_descriptor)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Location of source.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Required. Source for the build.
        StorageSource(std::boxed::Box<crate::model::StorageSource>),
    }

    /// Build type must be one of the following.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BuildType {
        /// Build the source using Buildpacks.
        BuildpackBuild(std::boxed::Box<crate::model::submit_build_request::BuildpacksBuild>),
        /// Build the source using Docker. This means the source has a Dockerfile.
        DockerBuild(std::boxed::Box<crate::model::submit_build_request::DockerBuild>),
    }
}

/// Response message for submitting a Build.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitBuildResponse {
    /// Cloud Build operation to be polled via CloudBuild API.
    pub build_operation: std::option::Option<longrunning::model::Operation>,

    /// URI of the base builder image in Artifact Registry being used in the build.
    /// Used to opt into automatic base image updates.
    pub base_image_uri: std::string::String,

    /// Warning message for the base image.
    pub base_image_warning: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitBuildResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build_operation][crate::model::SubmitBuildResponse::build_operation].
    pub fn set_build_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<longrunning::model::Operation>,
    {
        self.build_operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_operation][crate::model::SubmitBuildResponse::build_operation].
    pub fn set_or_clear_build_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<longrunning::model::Operation>,
    {
        self.build_operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [base_image_uri][crate::model::SubmitBuildResponse::base_image_uri].
    pub fn set_base_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_image_uri = v.into();
        self
    }

    /// Sets the value of [base_image_warning][crate::model::SubmitBuildResponse::base_image_warning].
    pub fn set_base_image_warning<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.base_image_warning = v.into();
        self
    }
}

impl wkt::message::Message for SubmitBuildResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SubmitBuildResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitBuildResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __build_operation,
            __base_image_uri,
            __base_image_warning,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitBuildResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "buildOperation" => Ok(__FieldTag::__build_operation),
                            "build_operation" => Ok(__FieldTag::__build_operation),
                            "baseImageUri" => Ok(__FieldTag::__base_image_uri),
                            "base_image_uri" => Ok(__FieldTag::__base_image_uri),
                            "baseImageWarning" => Ok(__FieldTag::__base_image_warning),
                            "base_image_warning" => Ok(__FieldTag::__base_image_warning),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitBuildResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitBuildResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__build_operation => {
                            if !fields.insert(__FieldTag::__build_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_operation",
                                ));
                            }
                            result.build_operation = map
                                .next_value::<std::option::Option<longrunning::model::Operation>>(
                                )?;
                        }
                        __FieldTag::__base_image_uri => {
                            if !fields.insert(__FieldTag::__base_image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_image_uri",
                                ));
                            }
                            result.base_image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_image_warning => {
                            if !fields.insert(__FieldTag::__base_image_warning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_image_warning",
                                ));
                            }
                            result.base_image_warning = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitBuildResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.build_operation.is_some() {
            state.serialize_entry("buildOperation", &self.build_operation)?;
        }
        if !self.base_image_uri.is_empty() {
            state.serialize_entry("baseImageUri", &self.base_image_uri)?;
        }
        if !self.base_image_warning.is_empty() {
            state.serialize_entry("baseImageWarning", &self.base_image_warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Location of the source in an archive file in Google Cloud Storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StorageSource {
    /// Required. Google Cloud Storage bucket containing the source (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    pub bucket: std::string::String,

    /// Required. Google Cloud Storage object containing the source.
    ///
    /// This object must be a gzipped archive file (`.tar.gz`) containing source to
    /// build.
    pub object: std::string::String,

    /// Optional. Google Cloud Storage generation for the object. If the generation
    /// is omitted, the latest generation will be used.
    pub generation: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSource::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSource::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }
}

impl wkt::message::Message for StorageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.StorageSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StorageSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __object,
            __generation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StorageSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "object" => Ok(__FieldTag::__object),
                            "generation" => Ok(__FieldTag::__generation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StorageSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StorageSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__object => {
                            if !fields.insert(__FieldTag::__object) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object",
                                ));
                            }
                            result.object = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StorageSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.object.is_empty() {
            state.serialize_entry("object", &self.object)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines a status condition for a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Condition {
    /// type is used to communicate the status of the reconciliation process.
    /// See also:
    /// <https://github.com/knative/serving/blob/main/docs/spec/errors.md#error-conditions-and-reporting>
    /// Types common to all resources include:
    ///
    /// * "Ready": True when the Resource is ready.
    pub r#type: std::string::String,

    /// State of the condition.
    pub state: crate::model::condition::State,

    /// Human readable message indicating details about the current status.
    pub message: std::string::String,

    /// Last time the condition transitioned from one status to another.
    pub last_transition_time: std::option::Option<wkt::Timestamp>,

    /// How to interpret failures of this condition, one of Error, Warning, Info
    pub severity: crate::model::condition::Severity,

    /// The reason for this condition. Depending on the condition type,
    /// it will populate one of these fields.
    /// Successful conditions cannot have a reason.
    pub reasons: std::option::Option<crate::model::condition::Reasons>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Condition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Condition::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Condition::state].
    pub fn set_state<T: std::convert::Into<crate::model::condition::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Condition::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [last_transition_time][crate::model::Condition::last_transition_time].
    pub fn set_last_transition_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_transition_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_transition_time][crate::model::Condition::last_transition_time].
    pub fn set_or_clear_last_transition_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_transition_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [severity][crate::model::Condition::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::condition::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons].
    ///
    /// Note that all the setters affecting `reasons` are mutually
    /// exclusive.
    pub fn set_reasons<
        T: std::convert::Into<std::option::Option<crate::model::condition::Reasons>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reasons = v.into();
        self
    }

    /// The value of [reasons][crate::model::Condition::reasons]
    /// if it holds a `Reason`, `None` if the field is not set or
    /// holds a different branch.
    pub fn reason(&self) -> std::option::Option<&crate::model::condition::CommonReason> {
        #[allow(unreachable_patterns)]
        self.reasons.as_ref().and_then(|v| match v {
            crate::model::condition::Reasons::Reason(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons]
    /// to hold a `Reason`.
    ///
    /// Note that all the setters affecting `reasons` are
    /// mutually exclusive.
    pub fn set_reason<T: std::convert::Into<crate::model::condition::CommonReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reasons =
            std::option::Option::Some(crate::model::condition::Reasons::Reason(v.into()));
        self
    }

    /// The value of [reasons][crate::model::Condition::reasons]
    /// if it holds a `RevisionReason`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_reason(&self) -> std::option::Option<&crate::model::condition::RevisionReason> {
        #[allow(unreachable_patterns)]
        self.reasons.as_ref().and_then(|v| match v {
            crate::model::condition::Reasons::RevisionReason(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons]
    /// to hold a `RevisionReason`.
    ///
    /// Note that all the setters affecting `reasons` are
    /// mutually exclusive.
    pub fn set_revision_reason<T: std::convert::Into<crate::model::condition::RevisionReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reasons =
            std::option::Option::Some(crate::model::condition::Reasons::RevisionReason(v.into()));
        self
    }

    /// The value of [reasons][crate::model::Condition::reasons]
    /// if it holds a `ExecutionReason`, `None` if the field is not set or
    /// holds a different branch.
    pub fn execution_reason(
        &self,
    ) -> std::option::Option<&crate::model::condition::ExecutionReason> {
        #[allow(unreachable_patterns)]
        self.reasons.as_ref().and_then(|v| match v {
            crate::model::condition::Reasons::ExecutionReason(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons]
    /// to hold a `ExecutionReason`.
    ///
    /// Note that all the setters affecting `reasons` are
    /// mutually exclusive.
    pub fn set_execution_reason<T: std::convert::Into<crate::model::condition::ExecutionReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reasons =
            std::option::Option::Some(crate::model::condition::Reasons::ExecutionReason(v.into()));
        self
    }
}

impl wkt::message::Message for Condition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Condition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Condition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __state,
            __message,
            __last_transition_time,
            __severity,
            __reason,
            __revision_reason,
            __execution_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Condition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "state" => Ok(__FieldTag::__state),
                            "message" => Ok(__FieldTag::__message),
                            "lastTransitionTime" => Ok(__FieldTag::__last_transition_time),
                            "last_transition_time" => Ok(__FieldTag::__last_transition_time),
                            "severity" => Ok(__FieldTag::__severity),
                            "reason" => Ok(__FieldTag::__reason),
                            "revisionReason" => Ok(__FieldTag::__revision_reason),
                            "revision_reason" => Ok(__FieldTag::__revision_reason),
                            "executionReason" => Ok(__FieldTag::__execution_reason),
                            "execution_reason" => Ok(__FieldTag::__execution_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Condition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Condition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::condition::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_transition_time => {
                            if !fields.insert(__FieldTag::__last_transition_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_transition_time",
                                ));
                            }
                            result.last_transition_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<crate::model::condition::Severity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            if result.reasons.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `reasons`, a oneof with full ID .google.cloud.run.v2.Condition.reason, latest field was reason",
                                ));
                            }
                            result.reasons =
                                std::option::Option::Some(
                                    crate::model::condition::Reasons::Reason(
                                        map.next_value::<std::option::Option<
                                            crate::model::condition::CommonReason,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__revision_reason => {
                            if !fields.insert(__FieldTag::__revision_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_reason",
                                ));
                            }
                            if result.reasons.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `reasons`, a oneof with full ID .google.cloud.run.v2.Condition.revision_reason, latest field was revisionReason",
                                ));
                            }
                            result.reasons = std::option::Option::Some(
                                crate::model::condition::Reasons::RevisionReason(
                                    map.next_value::<std::option::Option<
                                        crate::model::condition::RevisionReason,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__execution_reason => {
                            if !fields.insert(__FieldTag::__execution_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_reason",
                                ));
                            }
                            if result.reasons.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `reasons`, a oneof with full ID .google.cloud.run.v2.Condition.execution_reason, latest field was executionReason",
                                ));
                            }
                            result.reasons = std::option::Option::Some(
                                crate::model::condition::Reasons::ExecutionReason(
                                    map.next_value::<std::option::Option<
                                        crate::model::condition::ExecutionReason,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Condition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if self.last_transition_time.is_some() {
            state.serialize_entry("lastTransitionTime", &self.last_transition_time)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if let Some(value) = self.reason() {
            state.serialize_entry("reason", value)?;
        }
        if let Some(value) = self.revision_reason() {
            state.serialize_entry("revisionReason", value)?;
        }
        if let Some(value) = self.execution_reason() {
            state.serialize_entry("executionReason", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Condition].
pub mod condition {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the possible Condition states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// Transient state: Reconciliation has not started yet.
        ConditionPending,
        /// Transient state: reconciliation is still in progress.
        ConditionReconciling,
        /// Terminal state: Reconciliation did not succeed.
        ConditionFailed,
        /// Terminal state: Reconciliation completed successfully.
        ConditionSucceeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConditionPending => std::option::Option::Some(1),
                Self::ConditionReconciling => std::option::Option::Some(2),
                Self::ConditionFailed => std::option::Option::Some(3),
                Self::ConditionSucceeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::ConditionPending => std::option::Option::Some("CONDITION_PENDING"),
                Self::ConditionReconciling => std::option::Option::Some("CONDITION_RECONCILING"),
                Self::ConditionFailed => std::option::Option::Some("CONDITION_FAILED"),
                Self::ConditionSucceeded => std::option::Option::Some("CONDITION_SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConditionPending,
                2 => Self::ConditionReconciling,
                3 => Self::ConditionFailed,
                4 => Self::ConditionSucceeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CONDITION_PENDING" => Self::ConditionPending,
                "CONDITION_RECONCILING" => Self::ConditionReconciling,
                "CONDITION_FAILED" => Self::ConditionFailed,
                "CONDITION_SUCCEEDED" => Self::ConditionSucceeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConditionPending => serializer.serialize_i32(1),
                Self::ConditionReconciling => serializer.serialize_i32(2),
                Self::ConditionFailed => serializer.serialize_i32(3),
                Self::ConditionSucceeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.run.v2.Condition.State",
            ))
        }
    }

    /// Represents the severity of the condition failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Unspecified severity
        Unspecified,
        /// Error severity.
        Error,
        /// Warning severity.
        Warning,
        /// Info severity.
        Info,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Error => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Info => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Error,
                2 => Self::Warning,
                3 => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "ERROR" => Self::Error,
                "WARNING" => Self::Warning,
                "INFO" => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Error => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Info => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.run.v2.Condition.Severity",
            ))
        }
    }

    /// Reasons common to all types of conditions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommonReason {
        /// Default value.
        Undefined,
        /// Reason unknown. Further details will be in message.
        Unknown,
        /// Revision creation process failed.
        RevisionFailed,
        /// Timed out waiting for completion.
        ProgressDeadlineExceeded,
        /// The container image path is incorrect.
        ContainerMissing,
        /// Insufficient permissions on the container image.
        ContainerPermissionDenied,
        /// Container image is not authorized by policy.
        ContainerImageUnauthorized,
        /// Container image policy authorization check failed.
        ContainerImageAuthorizationCheckFailed,
        /// Insufficient permissions on encryption key.
        EncryptionKeyPermissionDenied,
        /// Permission check on encryption key failed.
        EncryptionKeyCheckFailed,
        /// At least one Access check on secrets failed.
        SecretsAccessCheckFailed,
        /// Waiting for operation to complete.
        WaitingForOperation,
        /// System will retry immediately.
        ImmediateRetry,
        /// System will retry later; current attempt failed.
        PostponedRetry,
        /// An internal error occurred. Further information may be in the message.
        Internal,
        /// User-provided VPC network was not found.
        VpcNetworkNotFound,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommonReason::value] or
        /// [CommonReason::name].
        UnknownValue(common_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod common_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommonReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Undefined => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::RevisionFailed => std::option::Option::Some(3),
                Self::ProgressDeadlineExceeded => std::option::Option::Some(4),
                Self::ContainerMissing => std::option::Option::Some(6),
                Self::ContainerPermissionDenied => std::option::Option::Some(7),
                Self::ContainerImageUnauthorized => std::option::Option::Some(8),
                Self::ContainerImageAuthorizationCheckFailed => std::option::Option::Some(9),
                Self::EncryptionKeyPermissionDenied => std::option::Option::Some(10),
                Self::EncryptionKeyCheckFailed => std::option::Option::Some(11),
                Self::SecretsAccessCheckFailed => std::option::Option::Some(12),
                Self::WaitingForOperation => std::option::Option::Some(13),
                Self::ImmediateRetry => std::option::Option::Some(14),
                Self::PostponedRetry => std::option::Option::Some(15),
                Self::Internal => std::option::Option::Some(16),
                Self::VpcNetworkNotFound => std::option::Option::Some(17),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Undefined => std::option::Option::Some("COMMON_REASON_UNDEFINED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::RevisionFailed => std::option::Option::Some("REVISION_FAILED"),
                Self::ProgressDeadlineExceeded => {
                    std::option::Option::Some("PROGRESS_DEADLINE_EXCEEDED")
                }
                Self::ContainerMissing => std::option::Option::Some("CONTAINER_MISSING"),
                Self::ContainerPermissionDenied => {
                    std::option::Option::Some("CONTAINER_PERMISSION_DENIED")
                }
                Self::ContainerImageUnauthorized => {
                    std::option::Option::Some("CONTAINER_IMAGE_UNAUTHORIZED")
                }
                Self::ContainerImageAuthorizationCheckFailed => {
                    std::option::Option::Some("CONTAINER_IMAGE_AUTHORIZATION_CHECK_FAILED")
                }
                Self::EncryptionKeyPermissionDenied => {
                    std::option::Option::Some("ENCRYPTION_KEY_PERMISSION_DENIED")
                }
                Self::EncryptionKeyCheckFailed => {
                    std::option::Option::Some("ENCRYPTION_KEY_CHECK_FAILED")
                }
                Self::SecretsAccessCheckFailed => {
                    std::option::Option::Some("SECRETS_ACCESS_CHECK_FAILED")
                }
                Self::WaitingForOperation => std::option::Option::Some("WAITING_FOR_OPERATION"),
                Self::ImmediateRetry => std::option::Option::Some("IMMEDIATE_RETRY"),
                Self::PostponedRetry => std::option::Option::Some("POSTPONED_RETRY"),
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::VpcNetworkNotFound => std::option::Option::Some("VPC_NETWORK_NOT_FOUND"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommonReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommonReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommonReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Undefined,
                1 => Self::Unknown,
                3 => Self::RevisionFailed,
                4 => Self::ProgressDeadlineExceeded,
                6 => Self::ContainerMissing,
                7 => Self::ContainerPermissionDenied,
                8 => Self::ContainerImageUnauthorized,
                9 => Self::ContainerImageAuthorizationCheckFailed,
                10 => Self::EncryptionKeyPermissionDenied,
                11 => Self::EncryptionKeyCheckFailed,
                12 => Self::SecretsAccessCheckFailed,
                13 => Self::WaitingForOperation,
                14 => Self::ImmediateRetry,
                15 => Self::PostponedRetry,
                16 => Self::Internal,
                17 => Self::VpcNetworkNotFound,
                _ => Self::UnknownValue(common_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommonReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMON_REASON_UNDEFINED" => Self::Undefined,
                "UNKNOWN" => Self::Unknown,
                "REVISION_FAILED" => Self::RevisionFailed,
                "PROGRESS_DEADLINE_EXCEEDED" => Self::ProgressDeadlineExceeded,
                "CONTAINER_MISSING" => Self::ContainerMissing,
                "CONTAINER_PERMISSION_DENIED" => Self::ContainerPermissionDenied,
                "CONTAINER_IMAGE_UNAUTHORIZED" => Self::ContainerImageUnauthorized,
                "CONTAINER_IMAGE_AUTHORIZATION_CHECK_FAILED" => {
                    Self::ContainerImageAuthorizationCheckFailed
                }
                "ENCRYPTION_KEY_PERMISSION_DENIED" => Self::EncryptionKeyPermissionDenied,
                "ENCRYPTION_KEY_CHECK_FAILED" => Self::EncryptionKeyCheckFailed,
                "SECRETS_ACCESS_CHECK_FAILED" => Self::SecretsAccessCheckFailed,
                "WAITING_FOR_OPERATION" => Self::WaitingForOperation,
                "IMMEDIATE_RETRY" => Self::ImmediateRetry,
                "POSTPONED_RETRY" => Self::PostponedRetry,
                "INTERNAL" => Self::Internal,
                "VPC_NETWORK_NOT_FOUND" => Self::VpcNetworkNotFound,
                _ => Self::UnknownValue(common_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommonReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Undefined => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::RevisionFailed => serializer.serialize_i32(3),
                Self::ProgressDeadlineExceeded => serializer.serialize_i32(4),
                Self::ContainerMissing => serializer.serialize_i32(6),
                Self::ContainerPermissionDenied => serializer.serialize_i32(7),
                Self::ContainerImageUnauthorized => serializer.serialize_i32(8),
                Self::ContainerImageAuthorizationCheckFailed => serializer.serialize_i32(9),
                Self::EncryptionKeyPermissionDenied => serializer.serialize_i32(10),
                Self::EncryptionKeyCheckFailed => serializer.serialize_i32(11),
                Self::SecretsAccessCheckFailed => serializer.serialize_i32(12),
                Self::WaitingForOperation => serializer.serialize_i32(13),
                Self::ImmediateRetry => serializer.serialize_i32(14),
                Self::PostponedRetry => serializer.serialize_i32(15),
                Self::Internal => serializer.serialize_i32(16),
                Self::VpcNetworkNotFound => serializer.serialize_i32(17),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommonReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommonReason>::new(
                ".google.cloud.run.v2.Condition.CommonReason",
            ))
        }
    }

    /// Reasons specific to Revision resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RevisionReason {
        /// Default value.
        Undefined,
        /// Revision in Pending state.
        Pending,
        /// Revision is in Reserve state.
        Reserve,
        /// Revision is Retired.
        Retired,
        /// Revision is being retired.
        Retiring,
        /// Revision is being recreated.
        Recreating,
        /// There was a health check error.
        HealthCheckContainerError,
        /// Health check failed due to user error from customized path of the
        /// container. System will retry.
        CustomizedPathResponsePending,
        /// A revision with min_instance_count > 0 was created and is reserved, but
        /// it was not configured to serve traffic, so it's not live. This can also
        /// happen momentarily during traffic migration.
        MinInstancesNotProvisioned,
        /// The maximum allowed number of active revisions has been reached.
        ActiveRevisionLimitReached,
        /// There was no deployment defined.
        /// This value is no longer used, but Services created in older versions of
        /// the API might contain this value.
        NoDeployment,
        /// A revision's container has no port specified since the revision is of a
        /// manually scaled service with 0 instance count
        HealthCheckSkipped,
        /// A revision with min_instance_count > 0 was created and is waiting for
        /// enough instances to begin a traffic migration.
        MinInstancesWarming,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RevisionReason::value] or
        /// [RevisionReason::name].
        UnknownValue(revision_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod revision_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RevisionReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Undefined => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Reserve => std::option::Option::Some(2),
                Self::Retired => std::option::Option::Some(3),
                Self::Retiring => std::option::Option::Some(4),
                Self::Recreating => std::option::Option::Some(5),
                Self::HealthCheckContainerError => std::option::Option::Some(6),
                Self::CustomizedPathResponsePending => std::option::Option::Some(7),
                Self::MinInstancesNotProvisioned => std::option::Option::Some(8),
                Self::ActiveRevisionLimitReached => std::option::Option::Some(9),
                Self::NoDeployment => std::option::Option::Some(10),
                Self::HealthCheckSkipped => std::option::Option::Some(11),
                Self::MinInstancesWarming => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Undefined => std::option::Option::Some("REVISION_REASON_UNDEFINED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Reserve => std::option::Option::Some("RESERVE"),
                Self::Retired => std::option::Option::Some("RETIRED"),
                Self::Retiring => std::option::Option::Some("RETIRING"),
                Self::Recreating => std::option::Option::Some("RECREATING"),
                Self::HealthCheckContainerError => {
                    std::option::Option::Some("HEALTH_CHECK_CONTAINER_ERROR")
                }
                Self::CustomizedPathResponsePending => {
                    std::option::Option::Some("CUSTOMIZED_PATH_RESPONSE_PENDING")
                }
                Self::MinInstancesNotProvisioned => {
                    std::option::Option::Some("MIN_INSTANCES_NOT_PROVISIONED")
                }
                Self::ActiveRevisionLimitReached => {
                    std::option::Option::Some("ACTIVE_REVISION_LIMIT_REACHED")
                }
                Self::NoDeployment => std::option::Option::Some("NO_DEPLOYMENT"),
                Self::HealthCheckSkipped => std::option::Option::Some("HEALTH_CHECK_SKIPPED"),
                Self::MinInstancesWarming => std::option::Option::Some("MIN_INSTANCES_WARMING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RevisionReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RevisionReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RevisionReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Undefined,
                1 => Self::Pending,
                2 => Self::Reserve,
                3 => Self::Retired,
                4 => Self::Retiring,
                5 => Self::Recreating,
                6 => Self::HealthCheckContainerError,
                7 => Self::CustomizedPathResponsePending,
                8 => Self::MinInstancesNotProvisioned,
                9 => Self::ActiveRevisionLimitReached,
                10 => Self::NoDeployment,
                11 => Self::HealthCheckSkipped,
                12 => Self::MinInstancesWarming,
                _ => Self::UnknownValue(revision_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RevisionReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REVISION_REASON_UNDEFINED" => Self::Undefined,
                "PENDING" => Self::Pending,
                "RESERVE" => Self::Reserve,
                "RETIRED" => Self::Retired,
                "RETIRING" => Self::Retiring,
                "RECREATING" => Self::Recreating,
                "HEALTH_CHECK_CONTAINER_ERROR" => Self::HealthCheckContainerError,
                "CUSTOMIZED_PATH_RESPONSE_PENDING" => Self::CustomizedPathResponsePending,
                "MIN_INSTANCES_NOT_PROVISIONED" => Self::MinInstancesNotProvisioned,
                "ACTIVE_REVISION_LIMIT_REACHED" => Self::ActiveRevisionLimitReached,
                "NO_DEPLOYMENT" => Self::NoDeployment,
                "HEALTH_CHECK_SKIPPED" => Self::HealthCheckSkipped,
                "MIN_INSTANCES_WARMING" => Self::MinInstancesWarming,
                _ => Self::UnknownValue(revision_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RevisionReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Undefined => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Reserve => serializer.serialize_i32(2),
                Self::Retired => serializer.serialize_i32(3),
                Self::Retiring => serializer.serialize_i32(4),
                Self::Recreating => serializer.serialize_i32(5),
                Self::HealthCheckContainerError => serializer.serialize_i32(6),
                Self::CustomizedPathResponsePending => serializer.serialize_i32(7),
                Self::MinInstancesNotProvisioned => serializer.serialize_i32(8),
                Self::ActiveRevisionLimitReached => serializer.serialize_i32(9),
                Self::NoDeployment => serializer.serialize_i32(10),
                Self::HealthCheckSkipped => serializer.serialize_i32(11),
                Self::MinInstancesWarming => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RevisionReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RevisionReason>::new(
                ".google.cloud.run.v2.Condition.RevisionReason",
            ))
        }
    }

    /// Reasons specific to Execution resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionReason {
        /// Default value.
        Undefined,
        /// Internal system error getting execution status. System will retry.
        JobStatusServicePollingError,
        /// A task reached its retry limit and the last attempt failed due to the
        /// user container exiting with a non-zero exit code.
        NonZeroExitCode,
        /// The execution was cancelled by users.
        Cancelled,
        /// The execution is in the process of being cancelled.
        Cancelling,
        /// The execution was deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionReason::value] or
        /// [ExecutionReason::name].
        UnknownValue(execution_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Undefined => std::option::Option::Some(0),
                Self::JobStatusServicePollingError => std::option::Option::Some(1),
                Self::NonZeroExitCode => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Deleted => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Undefined => std::option::Option::Some("EXECUTION_REASON_UNDEFINED"),
                Self::JobStatusServicePollingError => {
                    std::option::Option::Some("JOB_STATUS_SERVICE_POLLING_ERROR")
                }
                Self::NonZeroExitCode => std::option::Option::Some("NON_ZERO_EXIT_CODE"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Undefined,
                1 => Self::JobStatusServicePollingError,
                2 => Self::NonZeroExitCode,
                3 => Self::Cancelled,
                4 => Self::Cancelling,
                5 => Self::Deleted,
                _ => Self::UnknownValue(execution_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_REASON_UNDEFINED" => Self::Undefined,
                "JOB_STATUS_SERVICE_POLLING_ERROR" => Self::JobStatusServicePollingError,
                "NON_ZERO_EXIT_CODE" => Self::NonZeroExitCode,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(execution_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Undefined => serializer.serialize_i32(0),
                Self::JobStatusServicePollingError => serializer.serialize_i32(1),
                Self::NonZeroExitCode => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Deleted => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionReason>::new(
                ".google.cloud.run.v2.Condition.ExecutionReason",
            ))
        }
    }

    /// The reason for this condition. Depending on the condition type,
    /// it will populate one of these fields.
    /// Successful conditions cannot have a reason.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reasons {
        /// Output only. A common (service-level) reason for this condition.
        Reason(crate::model::condition::CommonReason),
        /// Output only. A reason for the revision condition.
        RevisionReason(crate::model::condition::RevisionReason),
        /// Output only. A reason for the execution condition.
        ExecutionReason(crate::model::condition::ExecutionReason),
    }
}

/// Request message for obtaining a Execution by its full name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetExecutionRequest {
    /// Required. The full name of the Execution.
    /// Format:
    /// `projects/{project}/locations/{location}/jobs/{job}/executions/{execution}`,
    /// where `{project}` can be project id or number.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetExecutionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetExecutionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetExecutionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetExecutionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetExecutionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetExecutionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for retrieving a list of Executions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExecutionsRequest {
    /// Required. The Execution from which the Executions should be listed.
    /// To list all Executions across Jobs, use "-" instead of Job name.
    /// Format: `projects/{project}/locations/{location}/jobs/{job}`, where
    /// `{project}` can be project id or number.
    pub parent: std::string::String,

    /// Maximum number of Executions to return in this call.
    pub page_size: i32,

    /// A page token received from a previous call to ListExecutions.
    /// All other parameters must match.
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExecutionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExecutionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExecutionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListExecutionsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListExecutionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExecutionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExecutionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExecutionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExecutionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExecutionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing a list of Executions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExecutionsResponse {
    /// The resulting list of Executions.
    pub executions: std::vec::Vec<crate::model::Execution>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListExecutions request to continue.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [executions][crate::model::ListExecutionsResponse::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Execution>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExecutionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListExecutionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExecutionsResponse {
    type PageItem = crate::model::Execution;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.executions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExecutionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __executions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExecutionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executions" => Ok(__FieldTag::__executions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExecutionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExecutionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__executions => {
                            if !fields.insert(__FieldTag::__executions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for executions",
                                ));
                            }
                            result.executions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Execution>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExecutionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.executions.is_empty() {
            state.serialize_entry("executions", &self.executions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting an Execution.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteExecutionRequest {
    /// Required. The name of the Execution to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/jobs/{job}/executions/{execution}`,
    /// where `{project}` can be project id or number.
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the resource.
    /// This may be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteExecutionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteExecutionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteExecutionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteExecutionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteExecutionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteExecutionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteExecutionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteExecutionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting an Execution.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelExecutionRequest {
    /// Required. The name of the Execution to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/jobs/{job}/executions/{execution}`,
    /// where `{project}` can be project id or number.
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// cancelling any resources.
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the resource.
    /// This may be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CancelExecutionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::CancelExecutionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for CancelExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CancelExecutionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelExecutionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelExecutionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelExecutionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelExecutionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelExecutionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Execution represents the configuration of a single execution. A execution an
/// immutable resource that references a container image which is run to
/// completion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Execution {
    /// Output only. The unique name of this Execution.
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Execution. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. Email address of the authenticated creator.
    pub creator: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    pub generation: i64,

    /// Output only. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Represents time when the execution was acknowledged by the
    /// execution controller. It is not guaranteed to be set in happens-before
    /// order across separate operations.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the execution started to run.
    /// It is not guaranteed to be set in happens-before order across separate
    /// operations.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the execution was completed. It is not
    /// guaranteed to be set in happens-before order across separate operations.
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the deletion time. It is only
    /// populated as a response to a Delete request.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted. It is only populated as a response to a Delete
    /// request.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// The least stable launch stage needed to create this resource, as defined by
    /// [Google Cloud Platform Launch
    /// Stages](https://cloud.google.com/terms/launch-stages). Cloud Run supports
    /// `ALPHA`, `BETA`, and `GA`.
    ///
    /// Note that this value might not be what was used
    /// as input. For example, if ALPHA was provided as input in the parent
    /// resource, but only BETA and GA-level features are were, this field will be
    /// BETA.
    pub launch_stage: api::model::LaunchStage,

    /// Output only. The name of the parent Job.
    pub job: std::string::String,

    /// Output only. Specifies the maximum desired number of tasks the execution
    /// should run at any given time. Must be <= task_count. The actual number of
    /// tasks running in steady state will be less than this number when
    /// ((.spec.task_count - .status.successful) < .spec.parallelism), i.e. when
    /// the work left to do is less than max parallelism.
    pub parallelism: i32,

    /// Output only. Specifies the desired number of tasks the execution should
    /// run. Setting to 1 means that parallelism is limited to 1 and the success of
    /// that task signals the success of the execution.
    pub task_count: i32,

    /// Output only. The template used to create tasks for this execution.
    pub template: std::option::Option<crate::model::TaskTemplate>,

    /// Output only. Indicates whether the resource's reconciliation is still in
    /// progress. See comments in `Job.reconciling` for additional information on
    /// reconciliation process in Cloud Run.
    pub reconciling: bool,

    /// Output only. The Condition of this Execution, containing its readiness
    /// status, and detailed error information in case it did not reach the desired
    /// state.
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. The generation of this Execution. See comments in
    /// `reconciling` for additional information on reconciliation process in Cloud
    /// Run.
    pub observed_generation: i64,

    /// Output only. The number of actively running tasks.
    pub running_count: i32,

    /// Output only. The number of tasks which reached phase Succeeded.
    pub succeeded_count: i32,

    /// Output only. The number of tasks which reached phase Failed.
    pub failed_count: i32,

    /// Output only. The number of tasks which reached phase Cancelled.
    pub cancelled_count: i32,

    /// Output only. The number of tasks which have retried at least once.
    pub retried_count: i32,

    /// Output only. URI where logs for this execution can be found in Cloud
    /// Console.
    pub log_uri: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Execution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Execution::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Execution::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::Execution::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Execution::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Execution::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Execution::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Execution::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Execution::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Execution::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Execution::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_time][crate::model::Execution::completion_time].
    pub fn set_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_time][crate::model::Execution::completion_time].
    pub fn set_or_clear_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Execution::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Execution::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Execution::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Execution::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Execution::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Execution::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [launch_stage][crate::model::Execution::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [job][crate::model::Execution::job].
    pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [parallelism][crate::model::Execution::parallelism].
    pub fn set_parallelism<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.parallelism = v.into();
        self
    }

    /// Sets the value of [task_count][crate::model::Execution::task_count].
    pub fn set_task_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.task_count = v.into();
        self
    }

    /// Sets the value of [template][crate::model::Execution::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TaskTemplate>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::Execution::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TaskTemplate>,
    {
        self.template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reconciling][crate::model::Execution::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Execution::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Execution::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [running_count][crate::model::Execution::running_count].
    pub fn set_running_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.running_count = v.into();
        self
    }

    /// Sets the value of [succeeded_count][crate::model::Execution::succeeded_count].
    pub fn set_succeeded_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.succeeded_count = v.into();
        self
    }

    /// Sets the value of [failed_count][crate::model::Execution::failed_count].
    pub fn set_failed_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failed_count = v.into();
        self
    }

    /// Sets the value of [cancelled_count][crate::model::Execution::cancelled_count].
    pub fn set_cancelled_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cancelled_count = v.into();
        self
    }

    /// Sets the value of [retried_count][crate::model::Execution::retried_count].
    pub fn set_retried_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retried_count = v.into();
        self
    }

    /// Sets the value of [log_uri][crate::model::Execution::log_uri].
    pub fn set_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Execution::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Execution::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Execution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Execution"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Execution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __creator,
            __generation,
            __labels,
            __annotations,
            __create_time,
            __start_time,
            __completion_time,
            __update_time,
            __delete_time,
            __expire_time,
            __launch_stage,
            __job,
            __parallelism,
            __task_count,
            __template,
            __reconciling,
            __conditions,
            __observed_generation,
            __running_count,
            __succeeded_count,
            __failed_count,
            __cancelled_count,
            __retried_count,
            __log_uri,
            __satisfies_pzs,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Execution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "creator" => Ok(__FieldTag::__creator),
                            "generation" => Ok(__FieldTag::__generation),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "completionTime" => Ok(__FieldTag::__completion_time),
                            "completion_time" => Ok(__FieldTag::__completion_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            "job" => Ok(__FieldTag::__job),
                            "parallelism" => Ok(__FieldTag::__parallelism),
                            "taskCount" => Ok(__FieldTag::__task_count),
                            "task_count" => Ok(__FieldTag::__task_count),
                            "template" => Ok(__FieldTag::__template),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "observedGeneration" => Ok(__FieldTag::__observed_generation),
                            "observed_generation" => Ok(__FieldTag::__observed_generation),
                            "runningCount" => Ok(__FieldTag::__running_count),
                            "running_count" => Ok(__FieldTag::__running_count),
                            "succeededCount" => Ok(__FieldTag::__succeeded_count),
                            "succeeded_count" => Ok(__FieldTag::__succeeded_count),
                            "failedCount" => Ok(__FieldTag::__failed_count),
                            "failed_count" => Ok(__FieldTag::__failed_count),
                            "cancelledCount" => Ok(__FieldTag::__cancelled_count),
                            "cancelled_count" => Ok(__FieldTag::__cancelled_count),
                            "retriedCount" => Ok(__FieldTag::__retried_count),
                            "retried_count" => Ok(__FieldTag::__retried_count),
                            "logUri" => Ok(__FieldTag::__log_uri),
                            "log_uri" => Ok(__FieldTag::__log_uri),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Execution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Execution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_time => {
                            if !fields.insert(__FieldTag::__completion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_time",
                                ));
                            }
                            result.completion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<api::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parallelism => {
                            if !fields.insert(__FieldTag::__parallelism) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parallelism",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.parallelism = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__task_count => {
                            if !fields.insert(__FieldTag::__task_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.task_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<crate::model::TaskTemplate>>()?;
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Condition>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__observed_generation => {
                            if !fields.insert(__FieldTag::__observed_generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observed_generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.observed_generation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__running_count => {
                            if !fields.insert(__FieldTag::__running_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for running_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.running_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__succeeded_count => {
                            if !fields.insert(__FieldTag::__succeeded_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for succeeded_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.succeeded_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_count => {
                            if !fields.insert(__FieldTag::__failed_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cancelled_count => {
                            if !fields.insert(__FieldTag::__cancelled_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancelled_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cancelled_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__retried_count => {
                            if !fields.insert(__FieldTag::__retried_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retried_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retried_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__log_uri => {
                            if !fields.insert(__FieldTag::__log_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_uri",
                                ));
                            }
                            result.log_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Execution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.completion_time.is_some() {
            state.serialize_entry("completionTime", &self.completion_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if !self.job.is_empty() {
            state.serialize_entry("job", &self.job)?;
        }
        if !wkt::internal::is_default(&self.parallelism) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("parallelism", &__With(&self.parallelism))?;
        }
        if !wkt::internal::is_default(&self.task_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("taskCount", &__With(&self.task_count))?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !wkt::internal::is_default(&self.observed_generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("observedGeneration", &__With(&self.observed_generation))?;
        }
        if !wkt::internal::is_default(&self.running_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("runningCount", &__With(&self.running_count))?;
        }
        if !wkt::internal::is_default(&self.succeeded_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("succeededCount", &__With(&self.succeeded_count))?;
        }
        if !wkt::internal::is_default(&self.failed_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedCount", &__With(&self.failed_count))?;
        }
        if !wkt::internal::is_default(&self.cancelled_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cancelledCount", &__With(&self.cancelled_count))?;
        }
        if !wkt::internal::is_default(&self.retried_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retriedCount", &__With(&self.retried_count))?;
        }
        if !self.log_uri.is_empty() {
            state.serialize_entry("logUri", &self.log_uri)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ExecutionTemplate describes the data an execution should have when created
/// from a template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutionTemplate {
    /// Unstructured key value map that can be used to organize and categorize
    /// objects.
    /// User-provided labels are shared with Google's billing system, so they can
    /// be used to filter, or break down billing charges by team, component,
    /// environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Unstructured key value map that may be set by external tools to store and
    /// arbitrary metadata. They are not queryable and should be preserved
    /// when modifying objects.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Specifies the maximum desired number of tasks the execution
    /// should run at given time. When the job is run, if this field is 0 or unset,
    /// the maximum possible value will be used for that execution. The actual
    /// number of tasks running in steady state will be less than this number when
    /// there are fewer tasks waiting to be completed remaining, i.e. when the work
    /// left to do is less than max parallelism.
    pub parallelism: i32,

    /// Specifies the desired number of tasks the execution should run.
    /// Setting to 1 means that parallelism is limited to 1 and the success of
    /// that task signals the success of the execution. Defaults to 1.
    pub task_count: i32,

    /// Required. Describes the task(s) that will be created when executing an
    /// execution.
    pub template: std::option::Option<crate::model::TaskTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::ExecutionTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::ExecutionTemplate::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [parallelism][crate::model::ExecutionTemplate::parallelism].
    pub fn set_parallelism<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.parallelism = v.into();
        self
    }

    /// Sets the value of [task_count][crate::model::ExecutionTemplate::task_count].
    pub fn set_task_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.task_count = v.into();
        self
    }

    /// Sets the value of [template][crate::model::ExecutionTemplate::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TaskTemplate>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::ExecutionTemplate::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TaskTemplate>,
    {
        self.template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExecutionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ExecutionTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutionTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            __annotations,
            __parallelism,
            __task_count,
            __template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutionTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "parallelism" => Ok(__FieldTag::__parallelism),
                            "taskCount" => Ok(__FieldTag::__task_count),
                            "task_count" => Ok(__FieldTag::__task_count),
                            "template" => Ok(__FieldTag::__template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutionTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutionTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parallelism => {
                            if !fields.insert(__FieldTag::__parallelism) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parallelism",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.parallelism = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__task_count => {
                            if !fields.insert(__FieldTag::__task_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for task_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.task_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<crate::model::TaskTemplate>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutionTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !wkt::internal::is_default(&self.parallelism) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("parallelism", &__With(&self.parallelism))?;
        }
        if !wkt::internal::is_default(&self.task_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("taskCount", &__With(&self.task_count))?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for creating a Job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateJobRequest {
    /// Required. The location and project in which this Job should be created.
    /// Format: projects/{project}/locations/{location}, where {project} can be
    /// project id or number.
    pub parent: std::string::String,

    /// Required. The Job instance to create.
    pub job: std::option::Option<crate::model::Job>,

    /// Required. The unique identifier for the Job. The name of the job becomes
    /// {parent}/jobs/{job_id}.
    pub job_id: std::string::String,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or creating any resources.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CreateJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::CreateJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job_id][crate::model::CreateJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CreateJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __job,
            __job_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "job" => Ok(__FieldTag::__job),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for obtaining a Job by its full name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The full name of the Job.
    /// Format: projects/{project}/locations/{location}/jobs/{job}, where {project}
    /// can be project id or number.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for updating a Job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateJobRequest {
    /// Required. The Job to be updated.
    pub job: std::option::Option<crate::model::Job>,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or updating any resources.
    pub validate_only: bool,

    /// Optional. If set to true, and if the Job does not exist, it will create a
    /// new one. Caller must have both create and update permissions for this call
    /// if this is set to true.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateJobRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.UpdateJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "job" => Ok(__FieldTag::__job),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for retrieving a list of Jobs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The location and project to list resources on.
    /// Format: projects/{project}/locations/{location}, where {project} can be
    /// project id or number.
    pub parent: std::string::String,

    /// Maximum number of Jobs to return in this call.
    pub page_size: i32,

    /// A page token received from a previous call to ListJobs.
    /// All other parameters must match.
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListJobsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing a list of Jobs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// The resulting list of Jobs.
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListJobs request to continue.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __jobs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobs" => Ok(__FieldTag::__jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message to delete a Job by its full name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteJobRequest {
    /// Required. The full name of the Job.
    /// Format: projects/{project}/locations/{location}/jobs/{job}, where {project}
    /// can be project id or number.
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteJobRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message to create a new Execution of a Job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunJobRequest {
    /// Required. The full name of the Job.
    /// Format: projects/{project}/locations/{location}/jobs/{job}, where {project}
    /// can be project id or number.
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    /// Overrides specification for a given execution of a job. If provided,
    /// overrides will be applied to update the execution or task spec.
    pub overrides: std::option::Option<crate::model::run_job_request::Overrides>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RunJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::RunJobRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [overrides][crate::model::RunJobRequest::overrides].
    pub fn set_overrides<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::run_job_request::Overrides>,
    {
        self.overrides = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [overrides][crate::model::RunJobRequest::overrides].
    pub fn set_or_clear_overrides<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::run_job_request::Overrides>,
    {
        self.overrides = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RunJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RunJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            __overrides,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            "overrides" => Ok(__FieldTag::__overrides),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__overrides => {
                            if !fields.insert(__FieldTag::__overrides) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overrides",
                                ));
                            }
                            result.overrides = map.next_value::<std::option::Option<crate::model::run_job_request::Overrides>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.overrides.is_some() {
            state.serialize_entry("overrides", &self.overrides)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RunJobRequest].
pub mod run_job_request {
    #[allow(unused_imports)]
    use super::*;

    /// RunJob Overrides that contains Execution fields to be overridden.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Overrides {
        /// Per container override specification.
        pub container_overrides:
            std::vec::Vec<crate::model::run_job_request::overrides::ContainerOverride>,

        /// Optional. The desired number of tasks the execution should run. Will
        /// replace existing task_count value.
        pub task_count: i32,

        /// Duration in seconds the task may be active before the system will
        /// actively try to mark it failed and kill associated containers. Will
        /// replace existing timeout_seconds value.
        pub timeout: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Overrides {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [container_overrides][crate::model::run_job_request::Overrides::container_overrides].
        pub fn set_container_overrides<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::run_job_request::overrides::ContainerOverride>,
        {
            use std::iter::Iterator;
            self.container_overrides = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [task_count][crate::model::run_job_request::Overrides::task_count].
        pub fn set_task_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.task_count = v.into();
            self
        }

        /// Sets the value of [timeout][crate::model::run_job_request::Overrides::timeout].
        pub fn set_timeout<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.timeout = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [timeout][crate::model::run_job_request::Overrides::timeout].
        pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.timeout = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Overrides {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.RunJobRequest.Overrides"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Overrides {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __container_overrides,
                __task_count,
                __timeout,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Overrides")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "containerOverrides" => Ok(__FieldTag::__container_overrides),
                                "container_overrides" => Ok(__FieldTag::__container_overrides),
                                "taskCount" => Ok(__FieldTag::__task_count),
                                "task_count" => Ok(__FieldTag::__task_count),
                                "timeout" => Ok(__FieldTag::__timeout),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Overrides;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Overrides")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__container_overrides => {
                                if !fields.insert(__FieldTag::__container_overrides) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for container_overrides",
                                    ));
                                }
                                result.container_overrides = map.next_value::<std::option::Option<std::vec::Vec<crate::model::run_job_request::overrides::ContainerOverride>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__task_count => {
                                if !fields.insert(__FieldTag::__task_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for task_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.task_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__timeout => {
                                if !fields.insert(__FieldTag::__timeout) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for timeout",
                                    ));
                                }
                                result.timeout =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Overrides {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.container_overrides.is_empty() {
                state.serialize_entry("containerOverrides", &self.container_overrides)?;
            }
            if !wkt::internal::is_default(&self.task_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("taskCount", &__With(&self.task_count))?;
            }
            if self.timeout.is_some() {
                state.serialize_entry("timeout", &self.timeout)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Overrides].
    pub mod overrides {
        #[allow(unused_imports)]
        use super::*;

        /// Per-container override specification.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ContainerOverride {
            /// The name of the container specified as a DNS_LABEL.
            pub name: std::string::String,

            /// Optional. Arguments to the entrypoint. Will replace existing args for
            /// override.
            pub args: std::vec::Vec<std::string::String>,

            /// List of environment variables to set in the container. Will be merged
            /// with existing env for override.
            pub env: std::vec::Vec<crate::model::EnvVar>,

            /// Optional. True if the intention is to clear out existing args list.
            pub clear_args: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ContainerOverride {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::run_job_request::overrides::ContainerOverride::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [args][crate::model::run_job_request::overrides::ContainerOverride::args].
            pub fn set_args<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.args = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [env][crate::model::run_job_request::overrides::ContainerOverride::env].
            pub fn set_env<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::EnvVar>,
            {
                use std::iter::Iterator;
                self.env = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [clear_args][crate::model::run_job_request::overrides::ContainerOverride::clear_args].
            pub fn set_clear_args<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.clear_args = v.into();
                self
            }
        }

        impl wkt::message::Message for ContainerOverride {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.run.v2.RunJobRequest.Overrides.ContainerOverride"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ContainerOverride {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __name,
                    __args,
                    __env,
                    __clear_args,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ContainerOverride")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "name" => Ok(__FieldTag::__name),
                                    "args" => Ok(__FieldTag::__args),
                                    "env" => Ok(__FieldTag::__env),
                                    "clearArgs" => Ok(__FieldTag::__clear_args),
                                    "clear_args" => Ok(__FieldTag::__clear_args),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ContainerOverride;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ContainerOverride")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__args => {
                                    if !fields.insert(__FieldTag::__args) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for args"),
                                        );
                                    }
                                    result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__env => {
                                    if !fields.insert(__FieldTag::__env) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for env"),
                                        );
                                    }
                                    result.env =
                                        map.next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::EnvVar>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__clear_args => {
                                    if !fields.insert(__FieldTag::__clear_args) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for clear_args",
                                            ),
                                        );
                                    }
                                    result.clear_args = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ContainerOverride {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self.args.is_empty() {
                    state.serialize_entry("args", &self.args)?;
                }
                if !self.env.is_empty() {
                    state.serialize_entry("env", &self.env)?;
                }
                if !wkt::internal::is_default(&self.clear_args) {
                    state.serialize_entry("clearArgs", &self.clear_args)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// Job represents the configuration of a single job, which references a
/// container image that is run to completion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Job {
    /// The fully qualified name of this Job.
    ///
    /// Format:
    /// projects/{project}/locations/{location}/jobs/{job}
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Execution. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    pub generation: i64,

    /// Unstructured key value map that can be used to organize and categorize
    /// objects.
    /// User-provided labels are shared with Google's billing system, so they can
    /// be used to filter, or break down billing charges by team, component,
    /// environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The deletion time. It is only populated as a response to a
    /// Delete request.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Email address of the authenticated creator.
    pub creator: std::string::String,

    /// Output only. Email address of the last authenticated modifier.
    pub last_modifier: std::string::String,

    /// Arbitrary identifier for the API client.
    pub client: std::string::String,

    /// Arbitrary version identifier for the API client.
    pub client_version: std::string::String,

    /// The launch stage as defined by [Google Cloud Platform
    /// Launch Stages](https://cloud.google.com/terms/launch-stages).
    /// Cloud Run supports `ALPHA`, `BETA`, and `GA`. If no value is specified, GA
    /// is assumed.
    /// Set the launch stage to a preview stage on input to allow use of preview
    /// features in that stage. On read (or output), describes whether the resource
    /// uses preview features.
    ///
    /// For example, if ALPHA is provided as input, but only BETA and GA-level
    /// features are used, this field will be BETA on output.
    pub launch_stage: api::model::LaunchStage,

    /// Settings for the Binary Authorization feature.
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Required. The template used to create executions for this Job.
    pub template: std::option::Option<crate::model::ExecutionTemplate>,

    /// Output only. The generation of this Job. See comments in `reconciling` for
    /// additional information on reconciliation process in Cloud Run.
    pub observed_generation: i64,

    /// Output only. The Condition of this Job, containing its readiness status,
    /// and detailed error information in case it did not reach the desired state.
    pub terminal_condition: std::option::Option<crate::model::Condition>,

    /// Output only. The Conditions of all other associated sub-resources. They
    /// contain additional diagnostics information in case the Job does not reach
    /// its desired state. See comments in `reconciling` for additional information
    /// on reconciliation process in Cloud Run.
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. Number of executions created for this job.
    pub execution_count: i32,

    /// Output only. Name of the last created execution.
    pub latest_created_execution: std::option::Option<crate::model::ExecutionReference>,

    /// Output only. Returns true if the Job is currently being acted upon by the
    /// system to bring it into the desired state.
    ///
    /// When a new Job is created, or an existing one is updated, Cloud Run
    /// will asynchronously perform all necessary steps to bring the Job to the
    /// desired state. This process is called reconciliation.
    /// While reconciliation is in process, `observed_generation` and
    /// `latest_succeeded_execution`, will have transient values that might
    /// mismatch the intended state: Once reconciliation is over (and this field is
    /// false), there are two possible outcomes: reconciliation succeeded and the
    /// state matches the Job, or there was an error,  and reconciliation failed.
    /// This state can be found in `terminal_condition.state`.
    ///
    /// If reconciliation succeeded, the following fields will match:
    /// `observed_generation` and `generation`, `latest_succeeded_execution` and
    /// `latest_created_execution`.
    ///
    /// If reconciliation failed, `observed_generation` and
    /// `latest_succeeded_execution` will have the state of the last succeeded
    /// execution or empty for newly created Job. Additional information on the
    /// failure can be found in `terminal_condition` and `conditions`.
    pub reconciling: bool,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    pub create_execution: std::option::Option<crate::model::job::CreateExecution>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Job::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Job::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Job::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Job::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Job::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Job::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Job::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Job::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Job::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Job::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Job::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Job::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Job::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Job::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [last_modifier][crate::model::Job::last_modifier].
    pub fn set_last_modifier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_modifier = v.into();
        self
    }

    /// Sets the value of [client][crate::model::Job::client].
    pub fn set_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client = v.into();
        self
    }

    /// Sets the value of [client_version][crate::model::Job::client_version].
    pub fn set_client_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_version = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Job::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [binary_authorization][crate::model::Job::binary_authorization].
    pub fn set_binary_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [binary_authorization][crate::model::Job::binary_authorization].
    pub fn set_or_clear_binary_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [template][crate::model::Job::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecutionTemplate>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::Job::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecutionTemplate>,
    {
        self.template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [observed_generation][crate::model::Job::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [terminal_condition][crate::model::Job::terminal_condition].
    pub fn set_terminal_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Condition>,
    {
        self.terminal_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [terminal_condition][crate::model::Job::terminal_condition].
    pub fn set_or_clear_terminal_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Condition>,
    {
        self.terminal_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::Job::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [execution_count][crate::model::Job::execution_count].
    pub fn set_execution_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.execution_count = v.into();
        self
    }

    /// Sets the value of [latest_created_execution][crate::model::Job::latest_created_execution].
    pub fn set_latest_created_execution<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecutionReference>,
    {
        self.latest_created_execution = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_created_execution][crate::model::Job::latest_created_execution].
    pub fn set_or_clear_latest_created_execution<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecutionReference>,
    {
        self.latest_created_execution = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reconciling][crate::model::Job::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Job::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Job::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_execution][crate::model::Job::create_execution].
    ///
    /// Note that all the setters affecting `create_execution` are mutually
    /// exclusive.
    pub fn set_create_execution<
        T: std::convert::Into<std::option::Option<crate::model::job::CreateExecution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.create_execution = v.into();
        self
    }

    /// The value of [create_execution][crate::model::Job::create_execution]
    /// if it holds a `StartExecutionToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn start_execution_token(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.create_execution.as_ref().and_then(|v| match v {
            crate::model::job::CreateExecution::StartExecutionToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [create_execution][crate::model::Job::create_execution]
    /// to hold a `StartExecutionToken`.
    ///
    /// Note that all the setters affecting `create_execution` are
    /// mutually exclusive.
    pub fn set_start_execution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_execution = std::option::Option::Some(
            crate::model::job::CreateExecution::StartExecutionToken(v.into()),
        );
        self
    }

    /// The value of [create_execution][crate::model::Job::create_execution]
    /// if it holds a `RunExecutionToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn run_execution_token(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.create_execution.as_ref().and_then(|v| match v {
            crate::model::job::CreateExecution::RunExecutionToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [create_execution][crate::model::Job::create_execution]
    /// to hold a `RunExecutionToken`.
    ///
    /// Note that all the setters affecting `create_execution` are
    /// mutually exclusive.
    pub fn set_run_execution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_execution = std::option::Option::Some(
            crate::model::job::CreateExecution::RunExecutionToken(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Job"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __generation,
            __labels,
            __annotations,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __creator,
            __last_modifier,
            __client,
            __client_version,
            __launch_stage,
            __binary_authorization,
            __template,
            __observed_generation,
            __terminal_condition,
            __conditions,
            __execution_count,
            __latest_created_execution,
            __reconciling,
            __satisfies_pzs,
            __start_execution_token,
            __run_execution_token,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "generation" => Ok(__FieldTag::__generation),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "creator" => Ok(__FieldTag::__creator),
                            "lastModifier" => Ok(__FieldTag::__last_modifier),
                            "last_modifier" => Ok(__FieldTag::__last_modifier),
                            "client" => Ok(__FieldTag::__client),
                            "clientVersion" => Ok(__FieldTag::__client_version),
                            "client_version" => Ok(__FieldTag::__client_version),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            "binaryAuthorization" => Ok(__FieldTag::__binary_authorization),
                            "binary_authorization" => Ok(__FieldTag::__binary_authorization),
                            "template" => Ok(__FieldTag::__template),
                            "observedGeneration" => Ok(__FieldTag::__observed_generation),
                            "observed_generation" => Ok(__FieldTag::__observed_generation),
                            "terminalCondition" => Ok(__FieldTag::__terminal_condition),
                            "terminal_condition" => Ok(__FieldTag::__terminal_condition),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "executionCount" => Ok(__FieldTag::__execution_count),
                            "execution_count" => Ok(__FieldTag::__execution_count),
                            "latestCreatedExecution" => Ok(__FieldTag::__latest_created_execution),
                            "latest_created_execution" => {
                                Ok(__FieldTag::__latest_created_execution)
                            }
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "startExecutionToken" => Ok(__FieldTag::__start_execution_token),
                            "start_execution_token" => Ok(__FieldTag::__start_execution_token),
                            "runExecutionToken" => Ok(__FieldTag::__run_execution_token),
                            "run_execution_token" => Ok(__FieldTag::__run_execution_token),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_modifier => {
                            if !fields.insert(__FieldTag::__last_modifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modifier",
                                ));
                            }
                            result.last_modifier = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client => {
                            if !fields.insert(__FieldTag::__client) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client",
                                ));
                            }
                            result.client = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_version => {
                            if !fields.insert(__FieldTag::__client_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_version",
                                ));
                            }
                            result.client_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<api::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__binary_authorization => {
                            if !fields.insert(__FieldTag::__binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_authorization",
                                ));
                            }
                            result.binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<crate::model::ExecutionTemplate>>(
                                )?;
                        }
                        __FieldTag::__observed_generation => {
                            if !fields.insert(__FieldTag::__observed_generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observed_generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.observed_generation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__terminal_condition => {
                            if !fields.insert(__FieldTag::__terminal_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for terminal_condition",
                                ));
                            }
                            result.terminal_condition =
                                map.next_value::<std::option::Option<crate::model::Condition>>()?;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Condition>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__execution_count => {
                            if !fields.insert(__FieldTag::__execution_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.execution_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__latest_created_execution => {
                            if !fields.insert(__FieldTag::__latest_created_execution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_created_execution",
                                ));
                            }
                            result.latest_created_execution = map.next_value::<std::option::Option<crate::model::ExecutionReference>>()?
                                ;
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_execution_token => {
                            if !fields.insert(__FieldTag::__start_execution_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_execution_token",
                                ));
                            }
                            if result.create_execution.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `create_execution`, a oneof with full ID .google.cloud.run.v2.Job.start_execution_token, latest field was startExecutionToken",
                                ));
                            }
                            result.create_execution = std::option::Option::Some(
                                crate::model::job::CreateExecution::StartExecutionToken(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__run_execution_token => {
                            if !fields.insert(__FieldTag::__run_execution_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_execution_token",
                                ));
                            }
                            if result.create_execution.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `create_execution`, a oneof with full ID .google.cloud.run.v2.Job.run_execution_token, latest field was runExecutionToken",
                                ));
                            }
                            result.create_execution = std::option::Option::Some(
                                crate::model::job::CreateExecution::RunExecutionToken(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Job {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !self.last_modifier.is_empty() {
            state.serialize_entry("lastModifier", &self.last_modifier)?;
        }
        if !self.client.is_empty() {
            state.serialize_entry("client", &self.client)?;
        }
        if !self.client_version.is_empty() {
            state.serialize_entry("clientVersion", &self.client_version)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if self.binary_authorization.is_some() {
            state.serialize_entry("binaryAuthorization", &self.binary_authorization)?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !wkt::internal::is_default(&self.observed_generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("observedGeneration", &__With(&self.observed_generation))?;
        }
        if self.terminal_condition.is_some() {
            state.serialize_entry("terminalCondition", &self.terminal_condition)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !wkt::internal::is_default(&self.execution_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("executionCount", &__With(&self.execution_count))?;
        }
        if self.latest_created_execution.is_some() {
            state.serialize_entry("latestCreatedExecution", &self.latest_created_execution)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if let Some(value) = self.start_execution_token() {
            state.serialize_entry("startExecutionToken", value)?;
        }
        if let Some(value) = self.run_execution_token() {
            state.serialize_entry("runExecutionToken", value)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CreateExecution {
        /// A unique string used as a suffix creating a new execution. The Job will
        /// become ready when the execution is successfully started.
        /// The sum of job name and token length must be fewer than 63 characters.
        StartExecutionToken(std::string::String),
        /// A unique string used as a suffix for creating a new execution. The Job
        /// will become ready when the execution is successfully completed.
        /// The sum of job name and token length must be fewer than 63 characters.
        RunExecutionToken(std::string::String),
    }
}

/// Reference to an Execution. Use /Executions.GetExecution with the given name
/// to get full execution including the latest status.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutionReference {
    /// Name of the execution.
    pub name: std::string::String,

    /// Creation timestamp of the execution.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Creation timestamp of the execution.
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// The deletion time of the execution. It is only
    /// populated as a response to a Delete request.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Status for the execution completion.
    pub completion_status: crate::model::execution_reference::CompletionStatus,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExecutionReference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ExecutionReference::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExecutionReference::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_time][crate::model::ExecutionReference::completion_time].
    pub fn set_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_time][crate::model::ExecutionReference::completion_time].
    pub fn set_or_clear_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::ExecutionReference::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::ExecutionReference::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_status][crate::model::ExecutionReference::completion_status].
    pub fn set_completion_status<
        T: std::convert::Into<crate::model::execution_reference::CompletionStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completion_status = v.into();
        self
    }
}

impl wkt::message::Message for ExecutionReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ExecutionReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutionReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __completion_time,
            __delete_time,
            __completion_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutionReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "completionTime" => Ok(__FieldTag::__completion_time),
                            "completion_time" => Ok(__FieldTag::__completion_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "completionStatus" => Ok(__FieldTag::__completion_status),
                            "completion_status" => Ok(__FieldTag::__completion_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutionReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutionReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_time => {
                            if !fields.insert(__FieldTag::__completion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_time",
                                ));
                            }
                            result.completion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_status => {
                            if !fields.insert(__FieldTag::__completion_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_status",
                                ));
                            }
                            result.completion_status = map
                                .next_value::<std::option::Option<
                                    crate::model::execution_reference::CompletionStatus,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutionReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.completion_time.is_some() {
            state.serialize_entry("completionTime", &self.completion_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !wkt::internal::is_default(&self.completion_status) {
            state.serialize_entry("completionStatus", &self.completion_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExecutionReference].
pub mod execution_reference {
    #[allow(unused_imports)]
    use super::*;

    /// Possible execution completion status.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompletionStatus {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// Job execution has succeeded.
        ExecutionSucceeded,
        /// Job execution has failed.
        ExecutionFailed,
        /// Job execution is running normally.
        ExecutionRunning,
        /// Waiting for backing resources to be provisioned.
        ExecutionPending,
        /// Job execution has been cancelled by the user.
        ExecutionCancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompletionStatus::value] or
        /// [CompletionStatus::name].
        UnknownValue(completion_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod completion_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompletionStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ExecutionSucceeded => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::ExecutionRunning => std::option::Option::Some(3),
                Self::ExecutionPending => std::option::Option::Some(4),
                Self::ExecutionCancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPLETION_STATUS_UNSPECIFIED"),
                Self::ExecutionSucceeded => std::option::Option::Some("EXECUTION_SUCCEEDED"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::ExecutionRunning => std::option::Option::Some("EXECUTION_RUNNING"),
                Self::ExecutionPending => std::option::Option::Some("EXECUTION_PENDING"),
                Self::ExecutionCancelled => std::option::Option::Some("EXECUTION_CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompletionStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompletionStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompletionStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ExecutionSucceeded,
                2 => Self::ExecutionFailed,
                3 => Self::ExecutionRunning,
                4 => Self::ExecutionPending,
                5 => Self::ExecutionCancelled,
                _ => Self::UnknownValue(completion_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompletionStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPLETION_STATUS_UNSPECIFIED" => Self::Unspecified,
                "EXECUTION_SUCCEEDED" => Self::ExecutionSucceeded,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "EXECUTION_RUNNING" => Self::ExecutionRunning,
                "EXECUTION_PENDING" => Self::ExecutionPending,
                "EXECUTION_CANCELLED" => Self::ExecutionCancelled,
                _ => Self::UnknownValue(completion_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompletionStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ExecutionSucceeded => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::ExecutionRunning => serializer.serialize_i32(3),
                Self::ExecutionPending => serializer.serialize_i32(4),
                Self::ExecutionCancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompletionStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompletionStatus>::new(
                ".google.cloud.run.v2.ExecutionReference.CompletionStatus",
            ))
        }
    }
}

/// A single application container.
/// This specifies both the container to run, the command to run in the container
/// and the arguments to supply to it.
/// Note that additional arguments can be supplied by the system to the container
/// at runtime.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Container {
    /// Name of the container specified as a DNS_LABEL (RFC 1123).
    pub name: std::string::String,

    /// Required. Name of the container image in Dockerhub, Google Artifact
    /// Registry, or Google Container Registry. If the host is not provided,
    /// Dockerhub is assumed.
    pub image: std::string::String,

    /// Entrypoint array. Not executed within a shell.
    /// The docker image's ENTRYPOINT is used if this is not provided.
    pub command: std::vec::Vec<std::string::String>,

    /// Arguments to the entrypoint.
    /// The docker image's CMD is used if this is not provided.
    pub args: std::vec::Vec<std::string::String>,

    /// List of environment variables to set in the container.
    pub env: std::vec::Vec<crate::model::EnvVar>,

    /// Compute Resource requirements by this container.
    pub resources: std::option::Option<crate::model::ResourceRequirements>,

    /// List of ports to expose from the container. Only a single port can be
    /// specified. The specified ports must be listening on all interfaces
    /// (0.0.0.0) within the container to be accessible.
    ///
    /// If omitted, a port number will be chosen and passed to the container
    /// through the PORT environment variable for the container to listen on.
    pub ports: std::vec::Vec<crate::model::ContainerPort>,

    /// Volume to mount into the container's filesystem.
    pub volume_mounts: std::vec::Vec<crate::model::VolumeMount>,

    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    pub working_dir: std::string::String,

    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    pub liveness_probe: std::option::Option<crate::model::Probe>,

    /// Startup probe of application within the container.
    /// All other probes are disabled if a startup probe is provided, until it
    /// succeeds. Container will not be added to service endpoints if the probe
    /// fails.
    pub startup_probe: std::option::Option<crate::model::Probe>,

    /// Names of the containers that must start before this container.
    pub depends_on: std::vec::Vec<std::string::String>,

    /// Base image for this container. Only supported for services. If set, it
    /// indicates that the service is enrolled into automatic base image update.
    pub base_image_uri: std::string::String,

    /// Output only. The build info of the container image.
    pub build_info: std::option::Option<crate::model::BuildInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Container {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Container::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [image][crate::model::Container::image].
    pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = v.into();
        self
    }

    /// Sets the value of [command][crate::model::Container::command].
    pub fn set_command<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.command = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::Container::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::Container::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resources][crate::model::Container::resources].
    pub fn set_resources<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceRequirements>,
    {
        self.resources = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resources][crate::model::Container::resources].
    pub fn set_or_clear_resources<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceRequirements>,
    {
        self.resources = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ports][crate::model::Container::ports].
    pub fn set_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContainerPort>,
    {
        use std::iter::Iterator;
        self.ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volume_mounts][crate::model::Container::volume_mounts].
    pub fn set_volume_mounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeMount>,
    {
        use std::iter::Iterator;
        self.volume_mounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [working_dir][crate::model::Container::working_dir].
    pub fn set_working_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.working_dir = v.into();
        self
    }

    /// Sets the value of [liveness_probe][crate::model::Container::liveness_probe].
    pub fn set_liveness_probe<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Probe>,
    {
        self.liveness_probe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [liveness_probe][crate::model::Container::liveness_probe].
    pub fn set_or_clear_liveness_probe<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Probe>,
    {
        self.liveness_probe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [startup_probe][crate::model::Container::startup_probe].
    pub fn set_startup_probe<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Probe>,
    {
        self.startup_probe = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [startup_probe][crate::model::Container::startup_probe].
    pub fn set_or_clear_startup_probe<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Probe>,
    {
        self.startup_probe = v.map(|x| x.into());
        self
    }

    /// Sets the value of [depends_on][crate::model::Container::depends_on].
    pub fn set_depends_on<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.depends_on = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [base_image_uri][crate::model::Container::base_image_uri].
    pub fn set_base_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_image_uri = v.into();
        self
    }

    /// Sets the value of [build_info][crate::model::Container::build_info].
    pub fn set_build_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildInfo>,
    {
        self.build_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_info][crate::model::Container::build_info].
    pub fn set_or_clear_build_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildInfo>,
    {
        self.build_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Container {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Container"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Container {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __image,
            __command,
            __args,
            __env,
            __resources,
            __ports,
            __volume_mounts,
            __working_dir,
            __liveness_probe,
            __startup_probe,
            __depends_on,
            __base_image_uri,
            __build_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Container")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "image" => Ok(__FieldTag::__image),
                            "command" => Ok(__FieldTag::__command),
                            "args" => Ok(__FieldTag::__args),
                            "env" => Ok(__FieldTag::__env),
                            "resources" => Ok(__FieldTag::__resources),
                            "ports" => Ok(__FieldTag::__ports),
                            "volumeMounts" => Ok(__FieldTag::__volume_mounts),
                            "volume_mounts" => Ok(__FieldTag::__volume_mounts),
                            "workingDir" => Ok(__FieldTag::__working_dir),
                            "working_dir" => Ok(__FieldTag::__working_dir),
                            "livenessProbe" => Ok(__FieldTag::__liveness_probe),
                            "liveness_probe" => Ok(__FieldTag::__liveness_probe),
                            "startupProbe" => Ok(__FieldTag::__startup_probe),
                            "startup_probe" => Ok(__FieldTag::__startup_probe),
                            "dependsOn" => Ok(__FieldTag::__depends_on),
                            "depends_on" => Ok(__FieldTag::__depends_on),
                            "baseImageUri" => Ok(__FieldTag::__base_image_uri),
                            "base_image_uri" => Ok(__FieldTag::__base_image_uri),
                            "buildInfo" => Ok(__FieldTag::__build_info),
                            "build_info" => Ok(__FieldTag::__build_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Container;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Container")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            result.image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__command => {
                            if !fields.insert(__FieldTag::__command) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for command",
                                ));
                            }
                            result.command = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__env => {
                            if !fields.insert(__FieldTag::__env) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for env",
                                ));
                            }
                            result.env = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EnvVar>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources",
                                ));
                            }
                            result.resources = map.next_value::<std::option::Option<crate::model::ResourceRequirements>>()?
                                ;
                        }
                        __FieldTag::__ports => {
                            if !fields.insert(__FieldTag::__ports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ports",
                                ));
                            }
                            result.ports = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ContainerPort>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volume_mounts => {
                            if !fields.insert(__FieldTag::__volume_mounts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_mounts",
                                ));
                            }
                            result.volume_mounts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VolumeMount>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__working_dir => {
                            if !fields.insert(__FieldTag::__working_dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for working_dir",
                                ));
                            }
                            result.working_dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__liveness_probe => {
                            if !fields.insert(__FieldTag::__liveness_probe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for liveness_probe",
                                ));
                            }
                            result.liveness_probe =
                                map.next_value::<std::option::Option<crate::model::Probe>>()?;
                        }
                        __FieldTag::__startup_probe => {
                            if !fields.insert(__FieldTag::__startup_probe) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for startup_probe",
                                ));
                            }
                            result.startup_probe =
                                map.next_value::<std::option::Option<crate::model::Probe>>()?;
                        }
                        __FieldTag::__depends_on => {
                            if !fields.insert(__FieldTag::__depends_on) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for depends_on",
                                ));
                            }
                            result.depends_on = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__base_image_uri => {
                            if !fields.insert(__FieldTag::__base_image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_image_uri",
                                ));
                            }
                            result.base_image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_info => {
                            if !fields.insert(__FieldTag::__build_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_info",
                                ));
                            }
                            result.build_info =
                                map.next_value::<std::option::Option<crate::model::BuildInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Container {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.image.is_empty() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self.command.is_empty() {
            state.serialize_entry("command", &self.command)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.env.is_empty() {
            state.serialize_entry("env", &self.env)?;
        }
        if self.resources.is_some() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if !self.ports.is_empty() {
            state.serialize_entry("ports", &self.ports)?;
        }
        if !self.volume_mounts.is_empty() {
            state.serialize_entry("volumeMounts", &self.volume_mounts)?;
        }
        if !self.working_dir.is_empty() {
            state.serialize_entry("workingDir", &self.working_dir)?;
        }
        if self.liveness_probe.is_some() {
            state.serialize_entry("livenessProbe", &self.liveness_probe)?;
        }
        if self.startup_probe.is_some() {
            state.serialize_entry("startupProbe", &self.startup_probe)?;
        }
        if !self.depends_on.is_empty() {
            state.serialize_entry("dependsOn", &self.depends_on)?;
        }
        if !self.base_image_uri.is_empty() {
            state.serialize_entry("baseImageUri", &self.base_image_uri)?;
        }
        if self.build_info.is_some() {
            state.serialize_entry("buildInfo", &self.build_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ResourceRequirements describes the compute resource requirements.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceRequirements {
    /// Only `memory` and `cpu` keys in the map are supported.
    pub limits: std::collections::HashMap<std::string::String, std::string::String>,

    /// Determines whether CPU is only allocated during requests (true by default).
    /// However, if ResourceRequirements is set, the caller must explicitly
    /// set this field to true to preserve the default behavior.
    pub cpu_idle: bool,

    /// Determines whether CPU should be boosted on startup of a new container
    /// instance above the requested CPU threshold, this can help reduce cold-start
    /// latency.
    pub startup_cpu_boost: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceRequirements {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [limits][crate::model::ResourceRequirements::limits].
    pub fn set_limits<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.limits = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [cpu_idle][crate::model::ResourceRequirements::cpu_idle].
    pub fn set_cpu_idle<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cpu_idle = v.into();
        self
    }

    /// Sets the value of [startup_cpu_boost][crate::model::ResourceRequirements::startup_cpu_boost].
    pub fn set_startup_cpu_boost<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.startup_cpu_boost = v.into();
        self
    }
}

impl wkt::message::Message for ResourceRequirements {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ResourceRequirements"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceRequirements {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __limits,
            __cpu_idle,
            __startup_cpu_boost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceRequirements")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "limits" => Ok(__FieldTag::__limits),
                            "cpuIdle" => Ok(__FieldTag::__cpu_idle),
                            "cpu_idle" => Ok(__FieldTag::__cpu_idle),
                            "startupCpuBoost" => Ok(__FieldTag::__startup_cpu_boost),
                            "startup_cpu_boost" => Ok(__FieldTag::__startup_cpu_boost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceRequirements;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceRequirements")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__limits => {
                            if !fields.insert(__FieldTag::__limits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for limits",
                                ));
                            }
                            result.limits = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_idle => {
                            if !fields.insert(__FieldTag::__cpu_idle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_idle",
                                ));
                            }
                            result.cpu_idle = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__startup_cpu_boost => {
                            if !fields.insert(__FieldTag::__startup_cpu_boost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for startup_cpu_boost",
                                ));
                            }
                            result.startup_cpu_boost = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceRequirements {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.limits.is_empty() {
            state.serialize_entry("limits", &self.limits)?;
        }
        if !wkt::internal::is_default(&self.cpu_idle) {
            state.serialize_entry("cpuIdle", &self.cpu_idle)?;
        }
        if !wkt::internal::is_default(&self.startup_cpu_boost) {
            state.serialize_entry("startupCpuBoost", &self.startup_cpu_boost)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvVar {
    /// Required. Name of the environment variable. Must not exceed 32768
    /// characters.
    pub name: std::string::String,

    pub values: std::option::Option<crate::model::env_var::Values>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvVar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnvVar::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [values][crate::model::EnvVar::values].
    ///
    /// Note that all the setters affecting `values` are mutually
    /// exclusive.
    pub fn set_values<T: std::convert::Into<std::option::Option<crate::model::env_var::Values>>>(
        mut self,
        v: T,
    ) -> Self {
        self.values = v.into();
        self
    }

    /// The value of [values][crate::model::EnvVar::values]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.values.as_ref().and_then(|v| match v {
            crate::model::env_var::Values::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [values][crate::model::EnvVar::values]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `values` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.values = std::option::Option::Some(crate::model::env_var::Values::Value(v.into()));
        self
    }

    /// The value of [values][crate::model::EnvVar::values]
    /// if it holds a `ValueSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EnvVarSource>> {
        #[allow(unreachable_patterns)]
        self.values.as_ref().and_then(|v| match v {
            crate::model::env_var::Values::ValueSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [values][crate::model::EnvVar::values]
    /// to hold a `ValueSource`.
    ///
    /// Note that all the setters affecting `values` are
    /// mutually exclusive.
    pub fn set_value_source<T: std::convert::Into<std::boxed::Box<crate::model::EnvVarSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.values =
            std::option::Option::Some(crate::model::env_var::Values::ValueSource(v.into()));
        self
    }
}

impl wkt::message::Message for EnvVar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.EnvVar"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnvVar {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            __value_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvVar")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            "valueSource" => Ok(__FieldTag::__value_source),
                            "value_source" => Ok(__FieldTag::__value_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnvVar;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvVar")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            if result.values.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `values`, a oneof with full ID .google.cloud.run.v2.EnvVar.value, latest field was value",
                                ));
                            }
                            result.values =
                                std::option::Option::Some(crate::model::env_var::Values::Value(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__value_source => {
                            if !fields.insert(__FieldTag::__value_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_source",
                                ));
                            }
                            if result.values.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `values`, a oneof with full ID .google.cloud.run.v2.EnvVar.value_source, latest field was valueSource",
                                ));
                            }
                            result.values = std::option::Option::Some(
                                crate::model::env_var::Values::ValueSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EnvVarSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnvVar {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.value() {
            state.serialize_entry("value", value)?;
        }
        if let Some(value) = self.value_source() {
            state.serialize_entry("valueSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EnvVar].
pub mod env_var {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Values {
        /// Literal value of the environment variable.
        /// Defaults to "", and the maximum length is 32768 bytes.
        /// Variable references are not supported in Cloud Run.
        Value(std::string::String),
        /// Source for the environment variable's value.
        ValueSource(std::boxed::Box<crate::model::EnvVarSource>),
    }
}

/// EnvVarSource represents a source for the value of an EnvVar.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvVarSource {
    /// Selects a secret and a specific version from Cloud Secret Manager.
    pub secret_key_ref: std::option::Option<crate::model::SecretKeySelector>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvVarSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_key_ref][crate::model::EnvVarSource::secret_key_ref].
    pub fn set_secret_key_ref<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecretKeySelector>,
    {
        self.secret_key_ref = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secret_key_ref][crate::model::EnvVarSource::secret_key_ref].
    pub fn set_or_clear_secret_key_ref<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecretKeySelector>,
    {
        self.secret_key_ref = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EnvVarSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.EnvVarSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnvVarSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret_key_ref,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvVarSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secretKeyRef" => Ok(__FieldTag::__secret_key_ref),
                            "secret_key_ref" => Ok(__FieldTag::__secret_key_ref),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnvVarSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvVarSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret_key_ref => {
                            if !fields.insert(__FieldTag::__secret_key_ref) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_key_ref",
                                ));
                            }
                            result.secret_key_ref = map
                                .next_value::<std::option::Option<crate::model::SecretKeySelector>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnvVarSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.secret_key_ref.is_some() {
            state.serialize_entry("secretKeyRef", &self.secret_key_ref)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// SecretEnvVarSource represents a source for the value of an EnvVar.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretKeySelector {
    /// Required. The name of the secret in Cloud Secret Manager.
    /// Format: {secret_name} if the secret is in the same project.
    /// projects/{project}/secrets/{secret_name} if the secret is
    /// in a different project.
    pub secret: std::string::String,

    /// The Cloud Secret Manager secret version.
    /// Can be 'latest' for the latest version, an integer for a specific version,
    /// or a version alias.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretKeySelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret][crate::model::SecretKeySelector::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SecretKeySelector::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SecretKeySelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SecretKeySelector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretKeySelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretKeySelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secret" => Ok(__FieldTag::__secret),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretKeySelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretKeySelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            result.secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretKeySelector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret.is_empty() {
            state.serialize_entry("secret", &self.secret)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ContainerPort represents a network port in a single container.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContainerPort {
    /// If specified, used to specify which protocol to use.
    /// Allowed values are "http1" and "h2c".
    pub name: std::string::String,

    /// Port number the container listens on.
    /// This must be a valid TCP port number, 0 < container_port < 65536.
    pub container_port: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerPort {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ContainerPort::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [container_port][crate::model::ContainerPort::container_port].
    pub fn set_container_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.container_port = v.into();
        self
    }
}

impl wkt::message::Message for ContainerPort {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ContainerPort"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContainerPort {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __container_port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContainerPort")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "containerPort" => Ok(__FieldTag::__container_port),
                            "container_port" => Ok(__FieldTag::__container_port),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContainerPort;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContainerPort")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_port => {
                            if !fields.insert(__FieldTag::__container_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.container_port =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContainerPort {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.container_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("containerPort", &__With(&self.container_port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// VolumeMount describes a mounting of a Volume within a container.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeMount {
    /// Required. This must match the Name of a Volume.
    pub name: std::string::String,

    /// Required. Path within the container at which the volume should be mounted.
    /// Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must
    /// otherwise be `/cloudsql`. All instances defined in the Volume will be
    /// available as `/cloudsql/[instance]`. For more information on Cloud SQL
    /// volumes, visit <https://cloud.google.com/sql/docs/mysql/connect-run>
    pub mount_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeMount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeMount::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mount_path][crate::model::VolumeMount::mount_path].
    pub fn set_mount_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mount_path = v.into();
        self
    }
}

impl wkt::message::Message for VolumeMount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.VolumeMount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VolumeMount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __mount_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VolumeMount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "mountPath" => Ok(__FieldTag::__mount_path),
                            "mount_path" => Ok(__FieldTag::__mount_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VolumeMount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VolumeMount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mount_path => {
                            if !fields.insert(__FieldTag::__mount_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mount_path",
                                ));
                            }
                            result.mount_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VolumeMount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.mount_path.is_empty() {
            state.serialize_entry("mountPath", &self.mount_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Volume represents a named volume in a container.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Volume {
    /// Required. Volume's name.
    pub name: std::string::String,

    pub volume_type: std::option::Option<crate::model::volume::VolumeType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type].
    ///
    /// Note that all the setters affecting `volume_type` are mutually
    /// exclusive.
    pub fn set_volume_type<
        T: std::convert::Into<std::option::Option<crate::model::volume::VolumeType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type = v.into();
        self
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretVolumeSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::Secret(v.into()));
        self
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `CloudSqlInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_instance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlInstance>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::CloudSqlInstance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `CloudSqlInstance`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_cloud_sql_instance<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::CloudSqlInstance(v.into()));
        self
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `EmptyDir`, `None` if the field is not set or
    /// holds a different branch.
    pub fn empty_dir(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EmptyDirVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::EmptyDir(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `EmptyDir`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_empty_dir<
        T: std::convert::Into<std::boxed::Box<crate::model::EmptyDirVolumeSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::EmptyDir(v.into()));
        self
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `Nfs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn nfs(&self) -> std::option::Option<&std::boxed::Box<crate::model::NFSVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::Nfs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `Nfs`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_nfs<T: std::convert::Into<std::boxed::Box<crate::model::NFSVolumeSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::Nfs(v.into()));
        self
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `Gcs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs(&self) -> std::option::Option<&std::boxed::Box<crate::model::GCSVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::Gcs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `Gcs`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_gcs<T: std::convert::Into<std::boxed::Box<crate::model::GCSVolumeSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::Gcs(v.into()));
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Volume"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Volume {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __secret,
            __cloud_sql_instance,
            __empty_dir,
            __nfs,
            __gcs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Volume")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "secret" => Ok(__FieldTag::__secret),
                            "cloudSqlInstance" => Ok(__FieldTag::__cloud_sql_instance),
                            "cloud_sql_instance" => Ok(__FieldTag::__cloud_sql_instance),
                            "emptyDir" => Ok(__FieldTag::__empty_dir),
                            "empty_dir" => Ok(__FieldTag::__empty_dir),
                            "nfs" => Ok(__FieldTag::__nfs),
                            "gcs" => Ok(__FieldTag::__gcs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Volume;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Volume")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            if result.volume_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `volume_type`, a oneof with full ID .google.cloud.run.v2.Volume.secret, latest field was secret",
                                ));
                            }
                            result.volume_type = std::option::Option::Some(
                                crate::model::volume::VolumeType::Secret(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecretVolumeSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_sql_instance => {
                            if !fields.insert(__FieldTag::__cloud_sql_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_instance",
                                ));
                            }
                            if result.volume_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `volume_type`, a oneof with full ID .google.cloud.run.v2.Volume.cloud_sql_instance, latest field was cloudSqlInstance",
                                ));
                            }
                            result.volume_type = std::option::Option::Some(
                                crate::model::volume::VolumeType::CloudSqlInstance(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSqlInstance>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__empty_dir => {
                            if !fields.insert(__FieldTag::__empty_dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for empty_dir",
                                ));
                            }
                            if result.volume_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `volume_type`, a oneof with full ID .google.cloud.run.v2.Volume.empty_dir, latest field was emptyDir",
                                ));
                            }
                            result.volume_type = std::option::Option::Some(
                                crate::model::volume::VolumeType::EmptyDir(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EmptyDirVolumeSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__nfs => {
                            if !fields.insert(__FieldTag::__nfs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nfs",
                                ));
                            }
                            if result.volume_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `volume_type`, a oneof with full ID .google.cloud.run.v2.Volume.nfs, latest field was nfs",
                                ));
                            }
                            result.volume_type =
                                std::option::Option::Some(crate::model::volume::VolumeType::Nfs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::NFSVolumeSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__gcs => {
                            if !fields.insert(__FieldTag::__gcs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs",
                                ));
                            }
                            if result.volume_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `volume_type`, a oneof with full ID .google.cloud.run.v2.Volume.gcs, latest field was gcs",
                                ));
                            }
                            result.volume_type =
                                std::option::Option::Some(crate::model::volume::VolumeType::Gcs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GCSVolumeSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Volume {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.secret() {
            state.serialize_entry("secret", value)?;
        }
        if let Some(value) = self.cloud_sql_instance() {
            state.serialize_entry("cloudSqlInstance", value)?;
        }
        if let Some(value) = self.empty_dir() {
            state.serialize_entry("emptyDir", value)?;
        }
        if let Some(value) = self.nfs() {
            state.serialize_entry("nfs", value)?;
        }
        if let Some(value) = self.gcs() {
            state.serialize_entry("gcs", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Volume].
pub mod volume {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VolumeType {
        /// Secret represents a secret that should populate this volume.
        Secret(std::boxed::Box<crate::model::SecretVolumeSource>),
        /// For Cloud SQL volumes, contains the specific instances that should be
        /// mounted. Visit <https://cloud.google.com/sql/docs/mysql/connect-run> for
        /// more information on how to connect Cloud SQL and Cloud Run.
        CloudSqlInstance(std::boxed::Box<crate::model::CloudSqlInstance>),
        /// Ephemeral storage used as a shared volume.
        EmptyDir(std::boxed::Box<crate::model::EmptyDirVolumeSource>),
        /// For NFS Voumes, contains the path to the nfs Volume
        Nfs(std::boxed::Box<crate::model::NFSVolumeSource>),
        /// Persistent storage backed by a Google Cloud Storage bucket.
        Gcs(std::boxed::Box<crate::model::GCSVolumeSource>),
    }
}

/// The secret's value will be presented as the content of a file whose
/// name is defined in the item path. If no items are defined, the name of
/// the file is the secret.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretVolumeSource {
    /// Required. The name of the secret in Cloud Secret Manager.
    /// Format: {secret} if the secret is in the same project.
    /// projects/{project}/secrets/{secret} if the secret is
    /// in a different project.
    pub secret: std::string::String,

    /// If unspecified, the volume will expose a file whose name is the
    /// secret, relative to VolumeMount.mount_path.
    /// If specified, the key will be used as the version to fetch from Cloud
    /// Secret Manager and the path will be the name of the file exposed in the
    /// volume. When items are defined, they must specify a path and a version.
    pub items: std::vec::Vec<crate::model::VersionToPath>,

    /// Integer representation of mode bits to use on created files by default.
    /// Must be a value between 0000 and 0777 (octal), defaulting to 0444.
    /// Directories within the path are not affected by  this setting.
    ///
    /// Notes
    ///
    /// * Internally, a umask of 0222 will be applied to any non-zero value.
    /// * This is an integer representation of the mode bits. So, the octal
    ///   integer value should look exactly as the chmod numeric notation with a
    ///   leading zero. Some examples: for chmod 640 (u=rw,g=r), set to 0640 (octal)
    ///   or 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or
    ///   493 (base-10).
    /// * This might be in conflict with other options that affect the
    ///   file mode, like fsGroup, and the result can be other mode bits set.
    ///
    /// This might be in conflict with other options that affect the
    /// file mode, like fsGroup, and as a result, other mode bits could be set.
    pub default_mode: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret][crate::model::SecretVolumeSource::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [items][crate::model::SecretVolumeSource::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionToPath>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_mode][crate::model::SecretVolumeSource::default_mode].
    pub fn set_default_mode<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.default_mode = v.into();
        self
    }
}

impl wkt::message::Message for SecretVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SecretVolumeSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretVolumeSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret,
            __items,
            __default_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretVolumeSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secret" => Ok(__FieldTag::__secret),
                            "items" => Ok(__FieldTag::__items),
                            "defaultMode" => Ok(__FieldTag::__default_mode),
                            "default_mode" => Ok(__FieldTag::__default_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretVolumeSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretVolumeSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret => {
                            if !fields.insert(__FieldTag::__secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret",
                                ));
                            }
                            result.secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VersionToPath>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_mode => {
                            if !fields.insert(__FieldTag::__default_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_mode",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_mode = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretVolumeSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret.is_empty() {
            state.serialize_entry("secret", &self.secret)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !wkt::internal::is_default(&self.default_mode) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("defaultMode", &__With(&self.default_mode))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// VersionToPath maps a specific version of a secret to a relative file to mount
/// to, relative to VolumeMount's mount_path.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VersionToPath {
    /// Required. The relative path of the secret in the container.
    pub path: std::string::String,

    /// The Cloud Secret Manager secret version.
    /// Can be 'latest' for the latest value, or an integer or a secret alias for a
    /// specific version.
    pub version: std::string::String,

    /// Integer octal mode bits to use on this file, must be a value between
    /// 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be
    /// used.
    ///
    /// Notes
    ///
    /// * Internally, a umask of 0222 will be applied to any non-zero value.
    /// * This is an integer representation of the mode bits. So, the octal
    ///   integer value should look exactly as the chmod numeric notation with a
    ///   leading zero. Some examples: for chmod 640 (u=rw,g=r), set to 0640 (octal)
    ///   or 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or
    ///   493 (base-10).
    /// * This might be in conflict with other options that affect the
    ///   file mode, like fsGroup, and the result can be other mode bits set.
    pub mode: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VersionToPath {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::VersionToPath::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [version][crate::model::VersionToPath::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::VersionToPath::mode].
    pub fn set_mode<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for VersionToPath {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.VersionToPath"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VersionToPath {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __version,
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VersionToPath")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "version" => Ok(__FieldTag::__version),
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VersionToPath;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VersionToPath")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mode = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VersionToPath {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.mode) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mode", &__With(&self.mode))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a set of Cloud SQL instances. Each one will be available under
/// /cloudsql/[instance]. Visit
/// <https://cloud.google.com/sql/docs/mysql/connect-run> for more information on
/// how to connect Cloud SQL and Cloud Run.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlInstance {
    /// The Cloud SQL instance connection names, as can be found in
    /// <https://console.cloud.google.com/sql/instances>. Visit
    /// <https://cloud.google.com/sql/docs/mysql/connect-run> for more information on
    /// how to connect Cloud SQL and Cloud Run. Format:
    /// {project}:{location}:{instance}
    pub instances: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::CloudSqlInstance::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudSqlInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CloudSqlInstance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlInstance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlInstance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlInstance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlInstance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlInstance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// In memory (tmpfs) ephemeral storage.
/// It is ephemeral in the sense that when the sandbox is taken down, the data is
/// destroyed with it (it does not persist across sandbox runs).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EmptyDirVolumeSource {
    /// The medium on which the data is stored. Acceptable values today is only
    /// MEMORY or none. When none, the default will currently be backed by memory
    /// but could change over time. +optional
    pub medium: crate::model::empty_dir_volume_source::Medium,

    /// Limit on the storage usable by this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value
    /// between the SizeLimit specified here and the sum of memory limits of all
    /// containers. The default is nil which means that the limit is undefined.
    /// More info:
    /// <https://cloud.google.com/run/docs/configuring/in-memory-volumes#configure-volume>.
    /// Info in Kubernetes:
    /// <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir>
    pub size_limit: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EmptyDirVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [medium][crate::model::EmptyDirVolumeSource::medium].
    pub fn set_medium<T: std::convert::Into<crate::model::empty_dir_volume_source::Medium>>(
        mut self,
        v: T,
    ) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [size_limit][crate::model::EmptyDirVolumeSource::size_limit].
    pub fn set_size_limit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.size_limit = v.into();
        self
    }
}

impl wkt::message::Message for EmptyDirVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.EmptyDirVolumeSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EmptyDirVolumeSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __medium,
            __size_limit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EmptyDirVolumeSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "medium" => Ok(__FieldTag::__medium),
                            "sizeLimit" => Ok(__FieldTag::__size_limit),
                            "size_limit" => Ok(__FieldTag::__size_limit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EmptyDirVolumeSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EmptyDirVolumeSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__medium => {
                            if !fields.insert(__FieldTag::__medium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for medium",
                                ));
                            }
                            result.medium =
                                map.next_value::<std::option::Option<
                                    crate::model::empty_dir_volume_source::Medium,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_limit => {
                            if !fields.insert(__FieldTag::__size_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_limit",
                                ));
                            }
                            result.size_limit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EmptyDirVolumeSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.medium) {
            state.serialize_entry("medium", &self.medium)?;
        }
        if !self.size_limit.is_empty() {
            state.serialize_entry("sizeLimit", &self.size_limit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EmptyDirVolumeSource].
pub mod empty_dir_volume_source {
    #[allow(unused_imports)]
    use super::*;

    /// The different types of medium supported for EmptyDir.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Medium {
        /// When not specified, falls back to the default implementation which
        /// is currently in memory (this may change over time).
        Unspecified,
        /// Explicitly set the EmptyDir to be in memory. Uses tmpfs.
        Memory,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Medium::value] or
        /// [Medium::name].
        UnknownValue(medium::UnknownValue),
    }

    #[doc(hidden)]
    pub mod medium {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Medium {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Memory => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MEDIUM_UNSPECIFIED"),
                Self::Memory => std::option::Option::Some("MEMORY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Medium {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Medium {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Medium {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Memory,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Medium {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MEDIUM_UNSPECIFIED" => Self::Unspecified,
                "MEMORY" => Self::Memory,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Medium {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Memory => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Medium {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Medium>::new(
                ".google.cloud.run.v2.EmptyDirVolumeSource.Medium",
            ))
        }
    }
}

/// Represents an NFS mount.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NFSVolumeSource {
    /// Hostname or IP address of the NFS server
    pub server: std::string::String,

    /// Path that is exported by the NFS server.
    pub path: std::string::String,

    /// If true, the volume will be mounted as read only for all mounts.
    pub read_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NFSVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [server][crate::model::NFSVolumeSource::server].
    pub fn set_server<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server = v.into();
        self
    }

    /// Sets the value of [path][crate::model::NFSVolumeSource::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [read_only][crate::model::NFSVolumeSource::read_only].
    pub fn set_read_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.read_only = v.into();
        self
    }
}

impl wkt::message::Message for NFSVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.NFSVolumeSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NFSVolumeSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __server,
            __path,
            __read_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NFSVolumeSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "server" => Ok(__FieldTag::__server),
                            "path" => Ok(__FieldTag::__path),
                            "readOnly" => Ok(__FieldTag::__read_only),
                            "read_only" => Ok(__FieldTag::__read_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NFSVolumeSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NFSVolumeSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__server => {
                            if !fields.insert(__FieldTag::__server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server",
                                ));
                            }
                            result.server = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_only => {
                            if !fields.insert(__FieldTag::__read_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_only",
                                ));
                            }
                            result.read_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NFSVolumeSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.server.is_empty() {
            state.serialize_entry("server", &self.server)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !wkt::internal::is_default(&self.read_only) {
            state.serialize_entry("readOnly", &self.read_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a volume backed by a Cloud Storage bucket using Cloud Storage
/// FUSE.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GCSVolumeSource {
    /// Cloud Storage Bucket name.
    pub bucket: std::string::String,

    /// If true, the volume will be mounted as read only for all mounts.
    pub read_only: bool,

    /// A list of additional flags to pass to the gcsfuse CLI.
    /// Options should be specified without the leading "--".
    pub mount_options: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GCSVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GCSVolumeSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [read_only][crate::model::GCSVolumeSource::read_only].
    pub fn set_read_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.read_only = v.into();
        self
    }

    /// Sets the value of [mount_options][crate::model::GCSVolumeSource::mount_options].
    pub fn set_mount_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.mount_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GCSVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GCSVolumeSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GCSVolumeSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __read_only,
            __mount_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GCSVolumeSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "readOnly" => Ok(__FieldTag::__read_only),
                            "read_only" => Ok(__FieldTag::__read_only),
                            "mountOptions" => Ok(__FieldTag::__mount_options),
                            "mount_options" => Ok(__FieldTag::__mount_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GCSVolumeSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GCSVolumeSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_only => {
                            if !fields.insert(__FieldTag::__read_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_only",
                                ));
                            }
                            result.read_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mount_options => {
                            if !fields.insert(__FieldTag::__mount_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mount_options",
                                ));
                            }
                            result.mount_options = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GCSVolumeSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !wkt::internal::is_default(&self.read_only) {
            state.serialize_entry("readOnly", &self.read_only)?;
        }
        if !self.mount_options.is_empty() {
            state.serialize_entry("mountOptions", &self.mount_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Probe {
    /// Optional. Number of seconds after the container has started before the
    /// probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum
    /// value for liveness probe is 3600. Maximum value for startup probe is 240.
    pub initial_delay_seconds: i32,

    /// Optional. Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1. Maximum value is 3600.
    /// Must be smaller than period_seconds.
    pub timeout_seconds: i32,

    /// Optional. How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe
    /// is 3600. Maximum value for startup probe is 240.
    /// Must be greater or equal than timeout_seconds.
    pub period_seconds: i32,

    /// Optional. Minimum consecutive failures for the probe to be considered
    /// failed after having succeeded. Defaults to 3. Minimum value is 1.
    pub failure_threshold: i32,

    pub probe_type: std::option::Option<crate::model::probe::ProbeType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Probe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_delay_seconds][crate::model::Probe::initial_delay_seconds].
    pub fn set_initial_delay_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_delay_seconds = v.into();
        self
    }

    /// Sets the value of [timeout_seconds][crate::model::Probe::timeout_seconds].
    pub fn set_timeout_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.timeout_seconds = v.into();
        self
    }

    /// Sets the value of [period_seconds][crate::model::Probe::period_seconds].
    pub fn set_period_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.period_seconds = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::Probe::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type].
    ///
    /// Note that all the setters affecting `probe_type` are mutually
    /// exclusive.
    pub fn set_probe_type<
        T: std::convert::Into<std::option::Option<crate::model::probe::ProbeType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = v.into();
        self
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `HttpGet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_get(&self) -> std::option::Option<&std::boxed::Box<crate::model::HTTPGetAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::HttpGet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `HttpGet`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_http_get<T: std::convert::Into<std::boxed::Box<crate::model::HTTPGetAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::HttpGet(v.into()));
        self
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `TcpSocket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tcp_socket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TCPSocketAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::TcpSocket(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `TcpSocket`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_tcp_socket<T: std::convert::Into<std::boxed::Box<crate::model::TCPSocketAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::TcpSocket(v.into()));
        self
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `Grpc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn grpc(&self) -> std::option::Option<&std::boxed::Box<crate::model::GRPCAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::Grpc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `Grpc`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_grpc<T: std::convert::Into<std::boxed::Box<crate::model::GRPCAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = std::option::Option::Some(crate::model::probe::ProbeType::Grpc(v.into()));
        self
    }
}

impl wkt::message::Message for Probe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Probe"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Probe {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __initial_delay_seconds,
            __timeout_seconds,
            __period_seconds,
            __failure_threshold,
            __http_get,
            __tcp_socket,
            __grpc,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Probe")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "initialDelaySeconds" => Ok(__FieldTag::__initial_delay_seconds),
                            "initial_delay_seconds" => Ok(__FieldTag::__initial_delay_seconds),
                            "timeoutSeconds" => Ok(__FieldTag::__timeout_seconds),
                            "timeout_seconds" => Ok(__FieldTag::__timeout_seconds),
                            "periodSeconds" => Ok(__FieldTag::__period_seconds),
                            "period_seconds" => Ok(__FieldTag::__period_seconds),
                            "failureThreshold" => Ok(__FieldTag::__failure_threshold),
                            "failure_threshold" => Ok(__FieldTag::__failure_threshold),
                            "httpGet" => Ok(__FieldTag::__http_get),
                            "http_get" => Ok(__FieldTag::__http_get),
                            "tcpSocket" => Ok(__FieldTag::__tcp_socket),
                            "tcp_socket" => Ok(__FieldTag::__tcp_socket),
                            "grpc" => Ok(__FieldTag::__grpc),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Probe;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Probe")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__initial_delay_seconds => {
                            if !fields.insert(__FieldTag::__initial_delay_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_delay_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initial_delay_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__timeout_seconds => {
                            if !fields.insert(__FieldTag::__timeout_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.timeout_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__period_seconds => {
                            if !fields.insert(__FieldTag::__period_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for period_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.period_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failure_threshold => {
                            if !fields.insert(__FieldTag::__failure_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_threshold",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failure_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__http_get => {
                            if !fields.insert(__FieldTag::__http_get) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_get",
                                ));
                            }
                            if result.probe_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `probe_type`, a oneof with full ID .google.cloud.run.v2.Probe.http_get, latest field was httpGet",
                                ));
                            }
                            result.probe_type =
                                std::option::Option::Some(crate::model::probe::ProbeType::HttpGet(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HTTPGetAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__tcp_socket => {
                            if !fields.insert(__FieldTag::__tcp_socket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tcp_socket",
                                ));
                            }
                            if result.probe_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `probe_type`, a oneof with full ID .google.cloud.run.v2.Probe.tcp_socket, latest field was tcpSocket",
                                ));
                            }
                            result.probe_type = std::option::Option::Some(
                                crate::model::probe::ProbeType::TcpSocket(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TCPSocketAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__grpc => {
                            if !fields.insert(__FieldTag::__grpc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grpc",
                                ));
                            }
                            if result.probe_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `probe_type`, a oneof with full ID .google.cloud.run.v2.Probe.grpc, latest field was grpc",
                                ));
                            }
                            result.probe_type =
                                std::option::Option::Some(crate::model::probe::ProbeType::Grpc(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GRPCAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Probe {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.initial_delay_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initialDelaySeconds", &__With(&self.initial_delay_seconds))?;
        }
        if !wkt::internal::is_default(&self.timeout_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("timeoutSeconds", &__With(&self.timeout_seconds))?;
        }
        if !wkt::internal::is_default(&self.period_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("periodSeconds", &__With(&self.period_seconds))?;
        }
        if !wkt::internal::is_default(&self.failure_threshold) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureThreshold", &__With(&self.failure_threshold))?;
        }
        if let Some(value) = self.http_get() {
            state.serialize_entry("httpGet", value)?;
        }
        if let Some(value) = self.tcp_socket() {
            state.serialize_entry("tcpSocket", value)?;
        }
        if let Some(value) = self.grpc() {
            state.serialize_entry("grpc", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Probe].
pub mod probe {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProbeType {
        /// Optional. HTTPGet specifies the http request to perform.
        /// Exactly one of httpGet, tcpSocket, or grpc must be specified.
        HttpGet(std::boxed::Box<crate::model::HTTPGetAction>),
        /// Optional. TCPSocket specifies an action involving a TCP port.
        /// Exactly one of httpGet, tcpSocket, or grpc must be specified.
        TcpSocket(std::boxed::Box<crate::model::TCPSocketAction>),
        /// Optional. GRPC specifies an action involving a gRPC port.
        /// Exactly one of httpGet, tcpSocket, or grpc must be specified.
        Grpc(std::boxed::Box<crate::model::GRPCAction>),
    }
}

/// HTTPGetAction describes an action based on HTTP Get requests.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HTTPGetAction {
    /// Optional. Path to access on the HTTP server. Defaults to '/'.
    pub path: std::string::String,

    /// Optional. Custom headers to set in the request. HTTP allows repeated
    /// headers.
    pub http_headers: std::vec::Vec<crate::model::HTTPHeader>,

    /// Optional. Port number to access on the container. Must be in the range 1 to
    /// 65535. If not specified, defaults to the exposed port of the container,
    /// which is the value of container.ports[0].containerPort.
    pub port: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HTTPGetAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::HTTPGetAction::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [http_headers][crate::model::HTTPGetAction::http_headers].
    pub fn set_http_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HTTPHeader>,
    {
        use std::iter::Iterator;
        self.http_headers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [port][crate::model::HTTPGetAction::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }
}

impl wkt::message::Message for HTTPGetAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.HTTPGetAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HTTPGetAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            __http_headers,
            __port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HTTPGetAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            "httpHeaders" => Ok(__FieldTag::__http_headers),
                            "http_headers" => Ok(__FieldTag::__http_headers),
                            "port" => Ok(__FieldTag::__port),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HTTPGetAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HTTPGetAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__http_headers => {
                            if !fields.insert(__FieldTag::__http_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_headers",
                                ));
                            }
                            result.http_headers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::HTTPHeader>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HTTPGetAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.http_headers.is_empty() {
            state.serialize_entry("httpHeaders", &self.http_headers)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HTTPHeader {
    /// Required. The header field name
    pub name: std::string::String,

    /// Optional. The header field value
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HTTPHeader {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HTTPHeader::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::HTTPHeader::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for HTTPHeader {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.HTTPHeader"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HTTPHeader {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HTTPHeader")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HTTPHeader;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HTTPHeader")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HTTPHeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// TCPSocketAction describes an action based on opening a socket
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TCPSocketAction {
    /// Optional. Port number to access on the container. Must be in the range 1 to
    /// 65535. If not specified, defaults to the exposed port of the container,
    /// which is the value of container.ports[0].containerPort.
    pub port: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TCPSocketAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [port][crate::model::TCPSocketAction::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }
}

impl wkt::message::Message for TCPSocketAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TCPSocketAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TCPSocketAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TCPSocketAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "port" => Ok(__FieldTag::__port),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TCPSocketAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TCPSocketAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TCPSocketAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GRPCAction describes an action involving a GRPC port.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GRPCAction {
    /// Optional. Port number of the gRPC service. Number must be in the range 1 to
    /// 65535. If not specified, defaults to the exposed port of the container,
    /// which is the value of container.ports[0].containerPort.
    pub port: i32,

    /// Optional. Service is the name of the service to place in the gRPC
    /// HealthCheckRequest (see
    /// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md> ). If this
    /// is not specified, the default behavior is defined by gRPC.
    pub service: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GRPCAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [port][crate::model::GRPCAction::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [service][crate::model::GRPCAction::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for GRPCAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GRPCAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GRPCAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __port,
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GRPCAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "port" => Ok(__FieldTag::__port),
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GRPCAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GRPCAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GRPCAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Build information of the image.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildInfo {
    /// Output only. Entry point of the function when the image is a Cloud Run
    /// function.
    pub function_target: std::string::String,

    /// Output only. Source code location of the image.
    pub source_location: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [function_target][crate::model::BuildInfo::function_target].
    pub fn set_function_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function_target = v.into();
        self
    }

    /// Sets the value of [source_location][crate::model::BuildInfo::source_location].
    pub fn set_source_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_location = v.into();
        self
    }
}

impl wkt::message::Message for BuildInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.BuildInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __function_target,
            __source_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "functionTarget" => Ok(__FieldTag::__function_target),
                            "function_target" => Ok(__FieldTag::__function_target),
                            "sourceLocation" => Ok(__FieldTag::__source_location),
                            "source_location" => Ok(__FieldTag::__source_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__function_target => {
                            if !fields.insert(__FieldTag::__function_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for function_target",
                                ));
                            }
                            result.function_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_location => {
                            if !fields.insert(__FieldTag::__source_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_location",
                                ));
                            }
                            result.source_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.function_target.is_empty() {
            state.serialize_entry("functionTarget", &self.function_target)?;
        }
        if !self.source_location.is_empty() {
            state.serialize_entry("sourceLocation", &self.source_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for obtaining a Revision by its full name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRevisionRequest {
    /// Required. The full name of the Revision.
    /// Format:
    /// projects/{project}/locations/{location}/services/{service}/revisions/{revision}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for retrieving a list of Revisions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRevisionsRequest {
    /// Required. The Service from which the Revisions should be listed.
    /// To list all Revisions across Services, use "-" instead of Service name.
    /// Format:
    /// projects/{project}/locations/{location}/services/{service}
    pub parent: std::string::String,

    /// Maximum number of revisions to return in this call.
    pub page_size: i32,

    /// A page token received from a previous call to ListRevisions.
    /// All other parameters must match.
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListRevisionsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListRevisionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRevisionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRevisionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRevisionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRevisionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRevisionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing a list of Revisions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRevisionsResponse {
    /// The resulting list of Revisions.
    pub revisions: std::vec::Vec<crate::model::Revision>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListRevisions request to continue.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [revisions][crate::model::ListRevisionsResponse::revisions].
    pub fn set_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Revision>,
    {
        use std::iter::Iterator;
        self.revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRevisionsResponse {
    type PageItem = crate::model::Revision;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.revisions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRevisionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __revisions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRevisionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "revisions" => Ok(__FieldTag::__revisions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRevisionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRevisionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__revisions => {
                            if !fields.insert(__FieldTag::__revisions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revisions",
                                ));
                            }
                            result.revisions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Revision>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRevisionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.revisions.is_empty() {
            state.serialize_entry("revisions", &self.revisions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting a retired Revision.
/// Revision lifecycle is usually managed by making changes to the parent
/// Service. Only retired revisions can be deleted with this API.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRevisionRequest {
    /// Required. The name of the Revision to delete.
    /// Format:
    /// projects/{project}/locations/{location}/services/{service}/revisions/{revision}
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. This may be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteRevisionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRevisionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteRevisionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRevisionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRevisionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRevisionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRevisionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRevisionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Revision is an immutable snapshot of code and configuration.  A Revision
/// references a container image. Revisions are only created by updates to its
/// parent Service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Revision {
    /// Output only. The unique name of this Revision.
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Revision. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    pub generation: i64,

    /// Output only. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the deletion time. It is only
    /// populated as a response to a Delete request.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted. It is only populated as a response to a Delete
    /// request.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// The least stable launch stage needed to create this resource, as defined by
    /// [Google Cloud Platform Launch
    /// Stages](https://cloud.google.com/terms/launch-stages). Cloud Run supports
    /// `ALPHA`, `BETA`, and `GA`.
    ///
    /// Note that this value might not be what was used
    /// as input. For example, if ALPHA was provided as input in the parent
    /// resource, but only BETA and GA-level features are were, this field will be
    /// BETA.
    pub launch_stage: api::model::LaunchStage,

    /// Output only. The name of the parent service.
    pub service: std::string::String,

    /// Scaling settings for this revision.
    pub scaling: std::option::Option<crate::model::RevisionScaling>,

    /// VPC Access configuration for this Revision. For more information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    /// Sets the maximum number of requests that each serving instance can receive.
    pub max_instance_request_concurrency: i32,

    /// Max allowed time for an instance to respond to a request.
    pub timeout: std::option::Option<wkt::Duration>,

    /// Email address of the IAM service account associated with the revision of
    /// the service. The service account represents the identity of the running
    /// revision, and determines what permissions the revision has.
    pub service_account: std::string::String,

    /// Holds the single container that defines the unit of execution for this
    /// Revision.
    pub containers: std::vec::Vec<crate::model::Container>,

    /// A list of Volumes to make available to containers.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// The execution environment being used to host this Revision.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// A reference to a customer managed encryption key (CMEK) to use to encrypt
    /// this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    pub encryption_key: std::string::String,

    /// Enables service mesh connectivity.
    pub service_mesh: std::option::Option<crate::model::ServiceMesh>,

    /// The action to take if the encryption key is revoked.
    pub encryption_key_revocation_action: crate::model::EncryptionKeyRevocationAction,

    /// If encryption_key_revocation_action is SHUTDOWN, the duration before
    /// shutting down all instances. The minimum increment is 1 hour.
    pub encryption_key_shutdown_duration: std::option::Option<wkt::Duration>,

    /// Output only. Indicates whether the resource's reconciliation is still in
    /// progress. See comments in `Service.reconciling` for additional information
    /// on reconciliation process in Cloud Run.
    pub reconciling: bool,

    /// Output only. The Condition of this Revision, containing its readiness
    /// status, and detailed error information in case it did not reach a serving
    /// state.
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. The generation of this Revision currently serving traffic. See
    /// comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run.
    pub observed_generation: i64,

    /// Output only. The Google Console URI to obtain logs for the Revision.
    pub log_uri: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Enable session affinity.
    pub session_affinity: bool,

    /// Output only. The current effective scaling settings for the revision.
    pub scaling_status: std::option::Option<crate::model::RevisionScalingStatus>,

    /// The node selector for the revision.
    pub node_selector: std::option::Option<crate::model::NodeSelector>,

    /// Optional. Output only. True if GPU zonal redundancy is disabled on this
    /// revision.
    pub gpu_zonal_redundancy_disabled: std::option::Option<bool>,

    /// Output only. Email address of the authenticated creator.
    pub creator: std::string::String,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Revision {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Revision::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Revision::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Revision::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Revision::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Revision::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Revision::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Revision::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Revision::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Revision::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Revision::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Revision::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Revision::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Revision::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [launch_stage][crate::model::Revision::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Revision::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [scaling][crate::model::Revision::scaling].
    pub fn set_scaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RevisionScaling>,
    {
        self.scaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scaling][crate::model::Revision::scaling].
    pub fn set_or_clear_scaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RevisionScaling>,
    {
        self.scaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_access][crate::model::Revision::vpc_access].
    pub fn set_vpc_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_access][crate::model::Revision::vpc_access].
    pub fn set_or_clear_vpc_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_instance_request_concurrency][crate::model::Revision::max_instance_request_concurrency].
    pub fn set_max_instance_request_concurrency<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_instance_request_concurrency = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::Revision::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::Revision::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::Revision::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::Revision::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::Revision::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [execution_environment][crate::model::Revision::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::Revision::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [service_mesh][crate::model::Revision::service_mesh].
    pub fn set_service_mesh<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceMesh>,
    {
        self.service_mesh = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_mesh][crate::model::Revision::service_mesh].
    pub fn set_or_clear_service_mesh<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceMesh>,
    {
        self.service_mesh = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_key_revocation_action][crate::model::Revision::encryption_key_revocation_action].
    pub fn set_encryption_key_revocation_action<
        T: std::convert::Into<crate::model::EncryptionKeyRevocationAction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_revocation_action = v.into();
        self
    }

    /// Sets the value of [encryption_key_shutdown_duration][crate::model::Revision::encryption_key_shutdown_duration].
    pub fn set_encryption_key_shutdown_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.encryption_key_shutdown_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key_shutdown_duration][crate::model::Revision::encryption_key_shutdown_duration].
    pub fn set_or_clear_encryption_key_shutdown_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.encryption_key_shutdown_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reconciling][crate::model::Revision::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Revision::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Revision::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [log_uri][crate::model::Revision::log_uri].
    pub fn set_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Revision::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [session_affinity][crate::model::Revision::session_affinity].
    pub fn set_session_affinity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.session_affinity = v.into();
        self
    }

    /// Sets the value of [scaling_status][crate::model::Revision::scaling_status].
    pub fn set_scaling_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RevisionScalingStatus>,
    {
        self.scaling_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scaling_status][crate::model::Revision::scaling_status].
    pub fn set_or_clear_scaling_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RevisionScalingStatus>,
    {
        self.scaling_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_selector][crate::model::Revision::node_selector].
    pub fn set_node_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_selector][crate::model::Revision::node_selector].
    pub fn set_or_clear_node_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gpu_zonal_redundancy_disabled][crate::model::Revision::gpu_zonal_redundancy_disabled].
    pub fn set_gpu_zonal_redundancy_disabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.gpu_zonal_redundancy_disabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gpu_zonal_redundancy_disabled][crate::model::Revision::gpu_zonal_redundancy_disabled].
    pub fn set_or_clear_gpu_zonal_redundancy_disabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.gpu_zonal_redundancy_disabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Revision::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Revision::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Revision {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Revision"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Revision {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __generation,
            __labels,
            __annotations,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __launch_stage,
            __service,
            __scaling,
            __vpc_access,
            __max_instance_request_concurrency,
            __timeout,
            __service_account,
            __containers,
            __volumes,
            __execution_environment,
            __encryption_key,
            __service_mesh,
            __encryption_key_revocation_action,
            __encryption_key_shutdown_duration,
            __reconciling,
            __conditions,
            __observed_generation,
            __log_uri,
            __satisfies_pzs,
            __session_affinity,
            __scaling_status,
            __node_selector,
            __gpu_zonal_redundancy_disabled,
            __creator,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Revision")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "generation" => Ok(__FieldTag::__generation),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            "service" => Ok(__FieldTag::__service),
                            "scaling" => Ok(__FieldTag::__scaling),
                            "vpcAccess" => Ok(__FieldTag::__vpc_access),
                            "vpc_access" => Ok(__FieldTag::__vpc_access),
                            "maxInstanceRequestConcurrency" => {
                                Ok(__FieldTag::__max_instance_request_concurrency)
                            }
                            "max_instance_request_concurrency" => {
                                Ok(__FieldTag::__max_instance_request_concurrency)
                            }
                            "timeout" => Ok(__FieldTag::__timeout),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "containers" => Ok(__FieldTag::__containers),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "executionEnvironment" => Ok(__FieldTag::__execution_environment),
                            "execution_environment" => Ok(__FieldTag::__execution_environment),
                            "encryptionKey" => Ok(__FieldTag::__encryption_key),
                            "encryption_key" => Ok(__FieldTag::__encryption_key),
                            "serviceMesh" => Ok(__FieldTag::__service_mesh),
                            "service_mesh" => Ok(__FieldTag::__service_mesh),
                            "encryptionKeyRevocationAction" => {
                                Ok(__FieldTag::__encryption_key_revocation_action)
                            }
                            "encryption_key_revocation_action" => {
                                Ok(__FieldTag::__encryption_key_revocation_action)
                            }
                            "encryptionKeyShutdownDuration" => {
                                Ok(__FieldTag::__encryption_key_shutdown_duration)
                            }
                            "encryption_key_shutdown_duration" => {
                                Ok(__FieldTag::__encryption_key_shutdown_duration)
                            }
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "observedGeneration" => Ok(__FieldTag::__observed_generation),
                            "observed_generation" => Ok(__FieldTag::__observed_generation),
                            "logUri" => Ok(__FieldTag::__log_uri),
                            "log_uri" => Ok(__FieldTag::__log_uri),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "sessionAffinity" => Ok(__FieldTag::__session_affinity),
                            "session_affinity" => Ok(__FieldTag::__session_affinity),
                            "scalingStatus" => Ok(__FieldTag::__scaling_status),
                            "scaling_status" => Ok(__FieldTag::__scaling_status),
                            "nodeSelector" => Ok(__FieldTag::__node_selector),
                            "node_selector" => Ok(__FieldTag::__node_selector),
                            "gpuZonalRedundancyDisabled" => {
                                Ok(__FieldTag::__gpu_zonal_redundancy_disabled)
                            }
                            "gpu_zonal_redundancy_disabled" => {
                                Ok(__FieldTag::__gpu_zonal_redundancy_disabled)
                            }
                            "creator" => Ok(__FieldTag::__creator),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Revision;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Revision")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<api::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scaling => {
                            if !fields.insert(__FieldTag::__scaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scaling",
                                ));
                            }
                            result.scaling = map
                                .next_value::<std::option::Option<crate::model::RevisionScaling>>(
                                )?;
                        }
                        __FieldTag::__vpc_access => {
                            if !fields.insert(__FieldTag::__vpc_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_access",
                                ));
                            }
                            result.vpc_access =
                                map.next_value::<std::option::Option<crate::model::VpcAccess>>()?;
                        }
                        __FieldTag::__max_instance_request_concurrency => {
                            if !fields.insert(__FieldTag::__max_instance_request_concurrency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_instance_request_concurrency",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_instance_request_concurrency =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__containers => {
                            if !fields.insert(__FieldTag::__containers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containers",
                                ));
                            }
                            result.containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Container>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__execution_environment => {
                            if !fields.insert(__FieldTag::__execution_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_environment",
                                ));
                            }
                            result.execution_environment = map.next_value::<std::option::Option<crate::model::ExecutionEnvironment>>()?.unwrap_or_default();
                        }
                        __FieldTag::__encryption_key => {
                            if !fields.insert(__FieldTag::__encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key",
                                ));
                            }
                            result.encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_mesh => {
                            if !fields.insert(__FieldTag::__service_mesh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_mesh",
                                ));
                            }
                            result.service_mesh =
                                map.next_value::<std::option::Option<crate::model::ServiceMesh>>()?;
                        }
                        __FieldTag::__encryption_key_revocation_action => {
                            if !fields.insert(__FieldTag::__encryption_key_revocation_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key_revocation_action",
                                ));
                            }
                            result.encryption_key_revocation_action =
                                map.next_value::<std::option::Option<
                                    crate::model::EncryptionKeyRevocationAction,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_key_shutdown_duration => {
                            if !fields.insert(__FieldTag::__encryption_key_shutdown_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key_shutdown_duration",
                                ));
                            }
                            result.encryption_key_shutdown_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Condition>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__observed_generation => {
                            if !fields.insert(__FieldTag::__observed_generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observed_generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.observed_generation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__log_uri => {
                            if !fields.insert(__FieldTag::__log_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_uri",
                                ));
                            }
                            result.log_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_affinity => {
                            if !fields.insert(__FieldTag::__session_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_affinity",
                                ));
                            }
                            result.session_affinity = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scaling_status => {
                            if !fields.insert(__FieldTag::__scaling_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scaling_status",
                                ));
                            }
                            result.scaling_status = map.next_value::<std::option::Option<crate::model::RevisionScalingStatus>>()?
                                ;
                        }
                        __FieldTag::__node_selector => {
                            if !fields.insert(__FieldTag::__node_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_selector",
                                ));
                            }
                            result.node_selector = map
                                .next_value::<std::option::Option<crate::model::NodeSelector>>()?;
                        }
                        __FieldTag::__gpu_zonal_redundancy_disabled => {
                            if !fields.insert(__FieldTag::__gpu_zonal_redundancy_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_zonal_redundancy_disabled",
                                ));
                            }
                            result.gpu_zonal_redundancy_disabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Revision {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.scaling.is_some() {
            state.serialize_entry("scaling", &self.scaling)?;
        }
        if self.vpc_access.is_some() {
            state.serialize_entry("vpcAccess", &self.vpc_access)?;
        }
        if !wkt::internal::is_default(&self.max_instance_request_concurrency) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxInstanceRequestConcurrency",
                &__With(&self.max_instance_request_concurrency),
            )?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.containers.is_empty() {
            state.serialize_entry("containers", &self.containers)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !wkt::internal::is_default(&self.execution_environment) {
            state.serialize_entry("executionEnvironment", &self.execution_environment)?;
        }
        if !self.encryption_key.is_empty() {
            state.serialize_entry("encryptionKey", &self.encryption_key)?;
        }
        if self.service_mesh.is_some() {
            state.serialize_entry("serviceMesh", &self.service_mesh)?;
        }
        if !wkt::internal::is_default(&self.encryption_key_revocation_action) {
            state.serialize_entry(
                "encryptionKeyRevocationAction",
                &self.encryption_key_revocation_action,
            )?;
        }
        if self.encryption_key_shutdown_duration.is_some() {
            state.serialize_entry(
                "encryptionKeyShutdownDuration",
                &self.encryption_key_shutdown_duration,
            )?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !wkt::internal::is_default(&self.observed_generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("observedGeneration", &__With(&self.observed_generation))?;
        }
        if !self.log_uri.is_empty() {
            state.serialize_entry("logUri", &self.log_uri)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.session_affinity) {
            state.serialize_entry("sessionAffinity", &self.session_affinity)?;
        }
        if self.scaling_status.is_some() {
            state.serialize_entry("scalingStatus", &self.scaling_status)?;
        }
        if self.node_selector.is_some() {
            state.serialize_entry("nodeSelector", &self.node_selector)?;
        }
        if self.gpu_zonal_redundancy_disabled.is_some() {
            state.serialize_entry(
                "gpuZonalRedundancyDisabled",
                &self.gpu_zonal_redundancy_disabled,
            )?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// RevisionTemplate describes the data a revision should have when created from
/// a template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RevisionTemplate {
    /// Optional. The unique name for the revision. If this field is omitted, it
    /// will be automatically generated based on the Service name.
    pub revision: std::string::String,

    /// Optional. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Unstructured key value map that may be set by external tools to
    /// store and arbitrary metadata. They are not queryable and should be
    /// preserved when modifying objects.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Scaling settings for this Revision.
    pub scaling: std::option::Option<crate::model::RevisionScaling>,

    /// Optional. VPC Access configuration to use for this Revision. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    /// Optional. Max allowed time for an instance to respond to a request.
    pub timeout: std::option::Option<wkt::Duration>,

    /// Optional. Email address of the IAM service account associated with the
    /// revision of the service. The service account represents the identity of the
    /// running revision, and determines what permissions the revision has. If not
    /// provided, the revision will use the project's default service account.
    pub service_account: std::string::String,

    /// Holds the single container that defines the unit of execution for this
    /// Revision.
    pub containers: std::vec::Vec<crate::model::Container>,

    /// Optional. A list of Volumes to make available to containers.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Optional. The sandbox environment to host this Revision.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// A reference to a customer managed encryption key (CMEK) to use to encrypt
    /// this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    pub encryption_key: std::string::String,

    /// Optional. Sets the maximum number of requests that each serving instance
    /// can receive. If not specified or 0, concurrency defaults to 80 when
    /// requested `CPU >= 1` and defaults to 1 when requested `CPU < 1`.
    pub max_instance_request_concurrency: i32,

    /// Optional. Enables service mesh connectivity.
    pub service_mesh: std::option::Option<crate::model::ServiceMesh>,

    /// Optional. The action to take if the encryption key is revoked.
    pub encryption_key_revocation_action: crate::model::EncryptionKeyRevocationAction,

    /// Optional. If encryption_key_revocation_action is SHUTDOWN, the duration
    /// before shutting down all instances. The minimum increment is 1 hour.
    pub encryption_key_shutdown_duration: std::option::Option<wkt::Duration>,

    /// Optional. Enable session affinity.
    pub session_affinity: bool,

    /// Optional. Disables health checking containers during deployment.
    pub health_check_disabled: bool,

    /// Optional. The node selector for the revision template.
    pub node_selector: std::option::Option<crate::model::NodeSelector>,

    /// Optional. True if GPU zonal redundancy is disabled on this revision.
    pub gpu_zonal_redundancy_disabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevisionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [revision][crate::model::RevisionTemplate::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::RevisionTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::RevisionTemplate::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [scaling][crate::model::RevisionTemplate::scaling].
    pub fn set_scaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RevisionScaling>,
    {
        self.scaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scaling][crate::model::RevisionTemplate::scaling].
    pub fn set_or_clear_scaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RevisionScaling>,
    {
        self.scaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_access][crate::model::RevisionTemplate::vpc_access].
    pub fn set_vpc_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_access][crate::model::RevisionTemplate::vpc_access].
    pub fn set_or_clear_vpc_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout][crate::model::RevisionTemplate::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::RevisionTemplate::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::RevisionTemplate::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::RevisionTemplate::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::RevisionTemplate::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [execution_environment][crate::model::RevisionTemplate::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::RevisionTemplate::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [max_instance_request_concurrency][crate::model::RevisionTemplate::max_instance_request_concurrency].
    pub fn set_max_instance_request_concurrency<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_instance_request_concurrency = v.into();
        self
    }

    /// Sets the value of [service_mesh][crate::model::RevisionTemplate::service_mesh].
    pub fn set_service_mesh<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceMesh>,
    {
        self.service_mesh = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_mesh][crate::model::RevisionTemplate::service_mesh].
    pub fn set_or_clear_service_mesh<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceMesh>,
    {
        self.service_mesh = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_key_revocation_action][crate::model::RevisionTemplate::encryption_key_revocation_action].
    pub fn set_encryption_key_revocation_action<
        T: std::convert::Into<crate::model::EncryptionKeyRevocationAction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_revocation_action = v.into();
        self
    }

    /// Sets the value of [encryption_key_shutdown_duration][crate::model::RevisionTemplate::encryption_key_shutdown_duration].
    pub fn set_encryption_key_shutdown_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.encryption_key_shutdown_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key_shutdown_duration][crate::model::RevisionTemplate::encryption_key_shutdown_duration].
    pub fn set_or_clear_encryption_key_shutdown_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.encryption_key_shutdown_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_affinity][crate::model::RevisionTemplate::session_affinity].
    pub fn set_session_affinity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.session_affinity = v.into();
        self
    }

    /// Sets the value of [health_check_disabled][crate::model::RevisionTemplate::health_check_disabled].
    pub fn set_health_check_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.health_check_disabled = v.into();
        self
    }

    /// Sets the value of [node_selector][crate::model::RevisionTemplate::node_selector].
    pub fn set_node_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_selector][crate::model::RevisionTemplate::node_selector].
    pub fn set_or_clear_node_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gpu_zonal_redundancy_disabled][crate::model::RevisionTemplate::gpu_zonal_redundancy_disabled].
    pub fn set_gpu_zonal_redundancy_disabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.gpu_zonal_redundancy_disabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gpu_zonal_redundancy_disabled][crate::model::RevisionTemplate::gpu_zonal_redundancy_disabled].
    pub fn set_or_clear_gpu_zonal_redundancy_disabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.gpu_zonal_redundancy_disabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RevisionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RevisionTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RevisionTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __revision,
            __labels,
            __annotations,
            __scaling,
            __vpc_access,
            __timeout,
            __service_account,
            __containers,
            __volumes,
            __execution_environment,
            __encryption_key,
            __max_instance_request_concurrency,
            __service_mesh,
            __encryption_key_revocation_action,
            __encryption_key_shutdown_duration,
            __session_affinity,
            __health_check_disabled,
            __node_selector,
            __gpu_zonal_redundancy_disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevisionTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "revision" => Ok(__FieldTag::__revision),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "scaling" => Ok(__FieldTag::__scaling),
                            "vpcAccess" => Ok(__FieldTag::__vpc_access),
                            "vpc_access" => Ok(__FieldTag::__vpc_access),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "containers" => Ok(__FieldTag::__containers),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "executionEnvironment" => Ok(__FieldTag::__execution_environment),
                            "execution_environment" => Ok(__FieldTag::__execution_environment),
                            "encryptionKey" => Ok(__FieldTag::__encryption_key),
                            "encryption_key" => Ok(__FieldTag::__encryption_key),
                            "maxInstanceRequestConcurrency" => {
                                Ok(__FieldTag::__max_instance_request_concurrency)
                            }
                            "max_instance_request_concurrency" => {
                                Ok(__FieldTag::__max_instance_request_concurrency)
                            }
                            "serviceMesh" => Ok(__FieldTag::__service_mesh),
                            "service_mesh" => Ok(__FieldTag::__service_mesh),
                            "encryptionKeyRevocationAction" => {
                                Ok(__FieldTag::__encryption_key_revocation_action)
                            }
                            "encryption_key_revocation_action" => {
                                Ok(__FieldTag::__encryption_key_revocation_action)
                            }
                            "encryptionKeyShutdownDuration" => {
                                Ok(__FieldTag::__encryption_key_shutdown_duration)
                            }
                            "encryption_key_shutdown_duration" => {
                                Ok(__FieldTag::__encryption_key_shutdown_duration)
                            }
                            "sessionAffinity" => Ok(__FieldTag::__session_affinity),
                            "session_affinity" => Ok(__FieldTag::__session_affinity),
                            "healthCheckDisabled" => Ok(__FieldTag::__health_check_disabled),
                            "health_check_disabled" => Ok(__FieldTag::__health_check_disabled),
                            "nodeSelector" => Ok(__FieldTag::__node_selector),
                            "node_selector" => Ok(__FieldTag::__node_selector),
                            "gpuZonalRedundancyDisabled" => {
                                Ok(__FieldTag::__gpu_zonal_redundancy_disabled)
                            }
                            "gpu_zonal_redundancy_disabled" => {
                                Ok(__FieldTag::__gpu_zonal_redundancy_disabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RevisionTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevisionTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scaling => {
                            if !fields.insert(__FieldTag::__scaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scaling",
                                ));
                            }
                            result.scaling = map
                                .next_value::<std::option::Option<crate::model::RevisionScaling>>(
                                )?;
                        }
                        __FieldTag::__vpc_access => {
                            if !fields.insert(__FieldTag::__vpc_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_access",
                                ));
                            }
                            result.vpc_access =
                                map.next_value::<std::option::Option<crate::model::VpcAccess>>()?;
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__containers => {
                            if !fields.insert(__FieldTag::__containers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containers",
                                ));
                            }
                            result.containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Container>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__execution_environment => {
                            if !fields.insert(__FieldTag::__execution_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_environment",
                                ));
                            }
                            result.execution_environment = map.next_value::<std::option::Option<crate::model::ExecutionEnvironment>>()?.unwrap_or_default();
                        }
                        __FieldTag::__encryption_key => {
                            if !fields.insert(__FieldTag::__encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key",
                                ));
                            }
                            result.encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_instance_request_concurrency => {
                            if !fields.insert(__FieldTag::__max_instance_request_concurrency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_instance_request_concurrency",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_instance_request_concurrency =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__service_mesh => {
                            if !fields.insert(__FieldTag::__service_mesh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_mesh",
                                ));
                            }
                            result.service_mesh =
                                map.next_value::<std::option::Option<crate::model::ServiceMesh>>()?;
                        }
                        __FieldTag::__encryption_key_revocation_action => {
                            if !fields.insert(__FieldTag::__encryption_key_revocation_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key_revocation_action",
                                ));
                            }
                            result.encryption_key_revocation_action =
                                map.next_value::<std::option::Option<
                                    crate::model::EncryptionKeyRevocationAction,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_key_shutdown_duration => {
                            if !fields.insert(__FieldTag::__encryption_key_shutdown_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key_shutdown_duration",
                                ));
                            }
                            result.encryption_key_shutdown_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__session_affinity => {
                            if !fields.insert(__FieldTag::__session_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_affinity",
                                ));
                            }
                            result.session_affinity = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_check_disabled => {
                            if !fields.insert(__FieldTag::__health_check_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_check_disabled",
                                ));
                            }
                            result.health_check_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_selector => {
                            if !fields.insert(__FieldTag::__node_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_selector",
                                ));
                            }
                            result.node_selector = map
                                .next_value::<std::option::Option<crate::model::NodeSelector>>()?;
                        }
                        __FieldTag::__gpu_zonal_redundancy_disabled => {
                            if !fields.insert(__FieldTag::__gpu_zonal_redundancy_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_zonal_redundancy_disabled",
                                ));
                            }
                            result.gpu_zonal_redundancy_disabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RevisionTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.scaling.is_some() {
            state.serialize_entry("scaling", &self.scaling)?;
        }
        if self.vpc_access.is_some() {
            state.serialize_entry("vpcAccess", &self.vpc_access)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.containers.is_empty() {
            state.serialize_entry("containers", &self.containers)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !wkt::internal::is_default(&self.execution_environment) {
            state.serialize_entry("executionEnvironment", &self.execution_environment)?;
        }
        if !self.encryption_key.is_empty() {
            state.serialize_entry("encryptionKey", &self.encryption_key)?;
        }
        if !wkt::internal::is_default(&self.max_instance_request_concurrency) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxInstanceRequestConcurrency",
                &__With(&self.max_instance_request_concurrency),
            )?;
        }
        if self.service_mesh.is_some() {
            state.serialize_entry("serviceMesh", &self.service_mesh)?;
        }
        if !wkt::internal::is_default(&self.encryption_key_revocation_action) {
            state.serialize_entry(
                "encryptionKeyRevocationAction",
                &self.encryption_key_revocation_action,
            )?;
        }
        if self.encryption_key_shutdown_duration.is_some() {
            state.serialize_entry(
                "encryptionKeyShutdownDuration",
                &self.encryption_key_shutdown_duration,
            )?;
        }
        if !wkt::internal::is_default(&self.session_affinity) {
            state.serialize_entry("sessionAffinity", &self.session_affinity)?;
        }
        if !wkt::internal::is_default(&self.health_check_disabled) {
            state.serialize_entry("healthCheckDisabled", &self.health_check_disabled)?;
        }
        if self.node_selector.is_some() {
            state.serialize_entry("nodeSelector", &self.node_selector)?;
        }
        if self.gpu_zonal_redundancy_disabled.is_some() {
            state.serialize_entry(
                "gpuZonalRedundancyDisabled",
                &self.gpu_zonal_redundancy_disabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for creating a Service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateServiceRequest {
    /// Required. The location and project in which this service should be created.
    /// Format: projects/{project}/locations/{location}, where {project} can be
    /// project id or number. Only lowercase characters, digits, and hyphens.
    pub parent: std::string::String,

    /// Required. The Service instance to create.
    pub service: std::option::Option<crate::model::Service>,

    /// Required. The unique identifier for the Service. It must begin with letter,
    /// and cannot end with hyphen; must contain fewer than 50 characters.
    /// The name of the service becomes {parent}/services/{service_id}.
    pub service_id: std::string::String,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or creating any resources.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateServiceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_id][crate::model::CreateServiceRequest::service_id].
    pub fn set_service_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateServiceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CreateServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __service,
            __service_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "service" => Ok(__FieldTag::__service),
                            "serviceId" => Ok(__FieldTag::__service_id),
                            "service_id" => Ok(__FieldTag::__service_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<crate::model::Service>>()?;
                        }
                        __FieldTag::__service_id => {
                            if !fields.insert(__FieldTag::__service_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_id",
                                ));
                            }
                            result.service_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.service_id.is_empty() {
            state.serialize_entry("serviceId", &self.service_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for updating a service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Optional. The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The Service to be updated.
    pub service: std::option::Option<crate::model::Service>,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or updating any resources.
    pub validate_only: bool,

    /// Optional. If set to true, and if the Service does not exist, it will create
    /// a new one. The caller must have 'run.services.create' permissions if this
    /// is set to true and the Service does not exist.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateServiceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateServiceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.UpdateServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __service,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "service" => Ok(__FieldTag::__service),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<crate::model::Service>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for retrieving a list of Services.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Required. The location and project to list resources on.
    /// Location must be a valid Google Cloud region, and cannot be the "-"
    /// wildcard. Format: projects/{project}/locations/{location}, where {project}
    /// can be project id or number.
    pub parent: std::string::String,

    /// Maximum number of Services to return in this call.
    pub page_size: i32,

    /// A page token received from a previous call to ListServices.
    /// All other parameters must match.
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListServicesRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing a list of Services.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The resulting list of Services.
    pub services: std::vec::Vec<crate::model::Service>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListServices request to continue.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for obtaining a Service by its full name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Required. The full name of the Service.
    /// Format: projects/{project}/locations/{location}/services/{service}, where
    /// {project} can be project id or number.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message to delete a Service by its full name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Required. The full name of the Service.
    /// Format: projects/{project}/locations/{location}/services/{service}, where
    /// {project} can be project id or number.
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteServiceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteServiceRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Service acts as a top-level container that manages a set of
/// configurations and revision templates which implement a network service.
/// Service exists to provide a singular abstraction which can be access
/// controlled, reasoned about, and which encapsulates software lifecycle
/// decisions such as rollout policy and team resource ownership.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Service {
    /// The fully qualified name of this Service. In CreateServiceRequest, this
    /// field is ignored, and instead composed from CreateServiceRequest.parent and
    /// CreateServiceRequest.service_id.
    ///
    /// Format:
    /// projects/{project}/locations/{location}/services/{service_id}
    pub name: std::string::String,

    /// User-provided description of the Service. This field currently has a
    /// 512-character limit.
    pub description: std::string::String,

    /// Output only. Server assigned unique identifier for the trigger. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    /// Please note that unlike v1, this is an int64 value. As with most Google
    /// APIs, its JSON representation will be a `string` instead of an `integer`.
    pub generation: i64,

    /// Optional. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Unstructured key value map that may be set by external tools to
    /// store and arbitrary metadata. They are not queryable and should be
    /// preserved when modifying objects.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The deletion time. It is only populated as a response to a
    /// Delete request.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permanently deleted.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Email address of the authenticated creator.
    pub creator: std::string::String,

    /// Output only. Email address of the last authenticated modifier.
    pub last_modifier: std::string::String,

    /// Arbitrary identifier for the API client.
    pub client: std::string::String,

    /// Arbitrary version identifier for the API client.
    pub client_version: std::string::String,

    /// Optional. Provides the ingress settings for this Service. On output,
    /// returns the currently observed ingress settings, or
    /// INGRESS_TRAFFIC_UNSPECIFIED if no revision is active.
    pub ingress: crate::model::IngressTraffic,

    /// Optional. The launch stage as defined by [Google Cloud Platform
    /// Launch Stages](https://cloud.google.com/terms/launch-stages).
    /// Cloud Run supports `ALPHA`, `BETA`, and `GA`. If no value is specified, GA
    /// is assumed.
    /// Set the launch stage to a preview stage on input to allow use of preview
    /// features in that stage. On read (or output), describes whether the resource
    /// uses preview features.
    ///
    /// For example, if ALPHA is provided as input, but only BETA and GA-level
    /// features are used, this field will be BETA on output.
    pub launch_stage: api::model::LaunchStage,

    /// Optional. Settings for the Binary Authorization feature.
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Required. The template used to create revisions for this Service.
    pub template: std::option::Option<crate::model::RevisionTemplate>,

    /// Optional. Specifies how to distribute traffic over a collection of
    /// Revisions belonging to the Service. If traffic is empty or not provided,
    /// defaults to 100% traffic to the latest `Ready` Revision.
    pub traffic: std::vec::Vec<crate::model::TrafficTarget>,

    /// Optional. Specifies service-level scaling settings
    pub scaling: std::option::Option<crate::model::ServiceScaling>,

    /// Optional. Disables IAM permission check for run.routes.invoke for callers
    /// of this service. This feature is available by invitation only. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/securing/managing-access#invoker_check>.
    pub invoker_iam_disabled: bool,

    /// Optional. Disables public resolution of the default URI of this service.
    pub default_uri_disabled: bool,

    /// Output only. All URLs serving traffic for this Service.
    pub urls: std::vec::Vec<std::string::String>,

    /// One or more custom audiences that you want this service to support. Specify
    /// each custom audience as the full URL in a string. The custom audiences are
    /// encoded in the token and used to authenticate requests. For more
    /// information, see
    /// <https://cloud.google.com/run/docs/configuring/custom-audiences>.
    pub custom_audiences: std::vec::Vec<std::string::String>,

    /// Output only. The generation of this Service currently serving traffic. See
    /// comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run. Please note that unlike v1, this is an int64 value.
    /// As with most Google APIs, its JSON representation will be a `string`
    /// instead of an `integer`.
    pub observed_generation: i64,

    /// Output only. The Condition of this Service, containing its readiness
    /// status, and detailed error information in case it did not reach a serving
    /// state. See comments in `reconciling` for additional information on
    /// reconciliation process in Cloud Run.
    pub terminal_condition: std::option::Option<crate::model::Condition>,

    /// Output only. The Conditions of all other associated sub-resources. They
    /// contain additional diagnostics information in case the Service does not
    /// reach its Serving state. See comments in `reconciling` for additional
    /// information on reconciliation process in Cloud Run.
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. Name of the latest revision that is serving traffic. See
    /// comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run.
    pub latest_ready_revision: std::string::String,

    /// Output only. Name of the last created revision. See comments in
    /// `reconciling` for additional information on reconciliation process in Cloud
    /// Run.
    pub latest_created_revision: std::string::String,

    /// Output only. Detailed status information for corresponding traffic targets.
    /// See comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run.
    pub traffic_statuses: std::vec::Vec<crate::model::TrafficTargetStatus>,

    /// Output only. The main URI in which this Service is serving traffic.
    pub uri: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. Configuration for building a Cloud Run function.
    pub build_config: std::option::Option<crate::model::BuildConfig>,

    /// Output only. Returns true if the Service is currently being acted upon by
    /// the system to bring it into the desired state.
    ///
    /// When a new Service is created, or an existing one is updated, Cloud Run
    /// will asynchronously perform all necessary steps to bring the Service to the
    /// desired serving state. This process is called reconciliation.
    /// While reconciliation is in process, `observed_generation`,
    /// `latest_ready_revision`, `traffic_statuses`, and `uri` will have transient
    /// values that might mismatch the intended state: Once reconciliation is over
    /// (and this field is false), there are two possible outcomes: reconciliation
    /// succeeded and the serving state matches the Service, or there was an error,
    /// and reconciliation failed. This state can be found in
    /// `terminal_condition.state`.
    ///
    /// If reconciliation succeeded, the following fields will match: `traffic` and
    /// `traffic_statuses`, `observed_generation` and `generation`,
    /// `latest_ready_revision` and `latest_created_revision`.
    ///
    /// If reconciliation failed, `traffic_statuses`, `observed_generation`, and
    /// `latest_ready_revision` will have the state of the last serving revision,
    /// or empty for newly created Services. Additional information on the failure
    /// can be found in `terminal_condition` and `conditions`.
    pub reconciling: bool,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Service::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Service::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Service::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Service::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Service::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Service::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Service::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Service::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Service::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Service::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Service::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Service::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Service::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Service::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [last_modifier][crate::model::Service::last_modifier].
    pub fn set_last_modifier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_modifier = v.into();
        self
    }

    /// Sets the value of [client][crate::model::Service::client].
    pub fn set_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client = v.into();
        self
    }

    /// Sets the value of [client_version][crate::model::Service::client_version].
    pub fn set_client_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_version = v.into();
        self
    }

    /// Sets the value of [ingress][crate::model::Service::ingress].
    pub fn set_ingress<T: std::convert::Into<crate::model::IngressTraffic>>(
        mut self,
        v: T,
    ) -> Self {
        self.ingress = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Service::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [binary_authorization][crate::model::Service::binary_authorization].
    pub fn set_binary_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [binary_authorization][crate::model::Service::binary_authorization].
    pub fn set_or_clear_binary_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [template][crate::model::Service::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RevisionTemplate>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::Service::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RevisionTemplate>,
    {
        self.template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [traffic][crate::model::Service::traffic].
    pub fn set_traffic<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrafficTarget>,
    {
        use std::iter::Iterator;
        self.traffic = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scaling][crate::model::Service::scaling].
    pub fn set_scaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceScaling>,
    {
        self.scaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scaling][crate::model::Service::scaling].
    pub fn set_or_clear_scaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceScaling>,
    {
        self.scaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [invoker_iam_disabled][crate::model::Service::invoker_iam_disabled].
    pub fn set_invoker_iam_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invoker_iam_disabled = v.into();
        self
    }

    /// Sets the value of [default_uri_disabled][crate::model::Service::default_uri_disabled].
    pub fn set_default_uri_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_uri_disabled = v.into();
        self
    }

    /// Sets the value of [urls][crate::model::Service::urls].
    pub fn set_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_audiences][crate::model::Service::custom_audiences].
    pub fn set_custom_audiences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.custom_audiences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Service::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [terminal_condition][crate::model::Service::terminal_condition].
    pub fn set_terminal_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Condition>,
    {
        self.terminal_condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [terminal_condition][crate::model::Service::terminal_condition].
    pub fn set_or_clear_terminal_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Condition>,
    {
        self.terminal_condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::Service::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [latest_ready_revision][crate::model::Service::latest_ready_revision].
    pub fn set_latest_ready_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_ready_revision = v.into();
        self
    }

    /// Sets the value of [latest_created_revision][crate::model::Service::latest_created_revision].
    pub fn set_latest_created_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_created_revision = v.into();
        self
    }

    /// Sets the value of [traffic_statuses][crate::model::Service::traffic_statuses].
    pub fn set_traffic_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrafficTargetStatus>,
    {
        use std::iter::Iterator;
        self.traffic_statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uri][crate::model::Service::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Service::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [build_config][crate::model::Service::build_config].
    pub fn set_build_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BuildConfig>,
    {
        self.build_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [build_config][crate::model::Service::build_config].
    pub fn set_or_clear_build_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BuildConfig>,
    {
        self.build_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reconciling][crate::model::Service::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Service::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Service"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Service {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __uid,
            __generation,
            __labels,
            __annotations,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __creator,
            __last_modifier,
            __client,
            __client_version,
            __ingress,
            __launch_stage,
            __binary_authorization,
            __template,
            __traffic,
            __scaling,
            __invoker_iam_disabled,
            __default_uri_disabled,
            __urls,
            __custom_audiences,
            __observed_generation,
            __terminal_condition,
            __conditions,
            __latest_ready_revision,
            __latest_created_revision,
            __traffic_statuses,
            __uri,
            __satisfies_pzs,
            __build_config,
            __reconciling,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Service")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "uid" => Ok(__FieldTag::__uid),
                            "generation" => Ok(__FieldTag::__generation),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "creator" => Ok(__FieldTag::__creator),
                            "lastModifier" => Ok(__FieldTag::__last_modifier),
                            "last_modifier" => Ok(__FieldTag::__last_modifier),
                            "client" => Ok(__FieldTag::__client),
                            "clientVersion" => Ok(__FieldTag::__client_version),
                            "client_version" => Ok(__FieldTag::__client_version),
                            "ingress" => Ok(__FieldTag::__ingress),
                            "launchStage" => Ok(__FieldTag::__launch_stage),
                            "launch_stage" => Ok(__FieldTag::__launch_stage),
                            "binaryAuthorization" => Ok(__FieldTag::__binary_authorization),
                            "binary_authorization" => Ok(__FieldTag::__binary_authorization),
                            "template" => Ok(__FieldTag::__template),
                            "traffic" => Ok(__FieldTag::__traffic),
                            "scaling" => Ok(__FieldTag::__scaling),
                            "invokerIamDisabled" => Ok(__FieldTag::__invoker_iam_disabled),
                            "invoker_iam_disabled" => Ok(__FieldTag::__invoker_iam_disabled),
                            "defaultUriDisabled" => Ok(__FieldTag::__default_uri_disabled),
                            "default_uri_disabled" => Ok(__FieldTag::__default_uri_disabled),
                            "urls" => Ok(__FieldTag::__urls),
                            "customAudiences" => Ok(__FieldTag::__custom_audiences),
                            "custom_audiences" => Ok(__FieldTag::__custom_audiences),
                            "observedGeneration" => Ok(__FieldTag::__observed_generation),
                            "observed_generation" => Ok(__FieldTag::__observed_generation),
                            "terminalCondition" => Ok(__FieldTag::__terminal_condition),
                            "terminal_condition" => Ok(__FieldTag::__terminal_condition),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "latestReadyRevision" => Ok(__FieldTag::__latest_ready_revision),
                            "latest_ready_revision" => Ok(__FieldTag::__latest_ready_revision),
                            "latestCreatedRevision" => Ok(__FieldTag::__latest_created_revision),
                            "latest_created_revision" => Ok(__FieldTag::__latest_created_revision),
                            "trafficStatuses" => Ok(__FieldTag::__traffic_statuses),
                            "traffic_statuses" => Ok(__FieldTag::__traffic_statuses),
                            "uri" => Ok(__FieldTag::__uri),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "buildConfig" => Ok(__FieldTag::__build_config),
                            "build_config" => Ok(__FieldTag::__build_config),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Service;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Service")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_modifier => {
                            if !fields.insert(__FieldTag::__last_modifier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_modifier",
                                ));
                            }
                            result.last_modifier = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client => {
                            if !fields.insert(__FieldTag::__client) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client",
                                ));
                            }
                            result.client = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_version => {
                            if !fields.insert(__FieldTag::__client_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_version",
                                ));
                            }
                            result.client_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ingress => {
                            if !fields.insert(__FieldTag::__ingress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingress",
                                ));
                            }
                            result.ingress = map
                                .next_value::<std::option::Option<crate::model::IngressTraffic>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__launch_stage => {
                            if !fields.insert(__FieldTag::__launch_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for launch_stage",
                                ));
                            }
                            result.launch_stage = map
                                .next_value::<std::option::Option<api::model::LaunchStage>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__binary_authorization => {
                            if !fields.insert(__FieldTag::__binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_authorization",
                                ));
                            }
                            result.binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<crate::model::RevisionTemplate>>(
                                )?;
                        }
                        __FieldTag::__traffic => {
                            if !fields.insert(__FieldTag::__traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for traffic",
                                ));
                            }
                            result.traffic = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TrafficTarget>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__scaling => {
                            if !fields.insert(__FieldTag::__scaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scaling",
                                ));
                            }
                            result.scaling = map
                                .next_value::<std::option::Option<crate::model::ServiceScaling>>(
                                )?;
                        }
                        __FieldTag::__invoker_iam_disabled => {
                            if !fields.insert(__FieldTag::__invoker_iam_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invoker_iam_disabled",
                                ));
                            }
                            result.invoker_iam_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_uri_disabled => {
                            if !fields.insert(__FieldTag::__default_uri_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_uri_disabled",
                                ));
                            }
                            result.default_uri_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__urls => {
                            if !fields.insert(__FieldTag::__urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for urls",
                                ));
                            }
                            result.urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__custom_audiences => {
                            if !fields.insert(__FieldTag::__custom_audiences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_audiences",
                                ));
                            }
                            result.custom_audiences = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__observed_generation => {
                            if !fields.insert(__FieldTag::__observed_generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observed_generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.observed_generation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__terminal_condition => {
                            if !fields.insert(__FieldTag::__terminal_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for terminal_condition",
                                ));
                            }
                            result.terminal_condition =
                                map.next_value::<std::option::Option<crate::model::Condition>>()?;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Condition>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__latest_ready_revision => {
                            if !fields.insert(__FieldTag::__latest_ready_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_ready_revision",
                                ));
                            }
                            result.latest_ready_revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_created_revision => {
                            if !fields.insert(__FieldTag::__latest_created_revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_created_revision",
                                ));
                            }
                            result.latest_created_revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__traffic_statuses => {
                            if !fields.insert(__FieldTag::__traffic_statuses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for traffic_statuses",
                                ));
                            }
                            result.traffic_statuses = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TrafficTargetStatus>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__build_config => {
                            if !fields.insert(__FieldTag::__build_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for build_config",
                                ));
                            }
                            result.build_config =
                                map.next_value::<std::option::Option<crate::model::BuildConfig>>()?;
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Service {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !self.last_modifier.is_empty() {
            state.serialize_entry("lastModifier", &self.last_modifier)?;
        }
        if !self.client.is_empty() {
            state.serialize_entry("client", &self.client)?;
        }
        if !self.client_version.is_empty() {
            state.serialize_entry("clientVersion", &self.client_version)?;
        }
        if !wkt::internal::is_default(&self.ingress) {
            state.serialize_entry("ingress", &self.ingress)?;
        }
        if !wkt::internal::is_default(&self.launch_stage) {
            state.serialize_entry("launchStage", &self.launch_stage)?;
        }
        if self.binary_authorization.is_some() {
            state.serialize_entry("binaryAuthorization", &self.binary_authorization)?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self.traffic.is_empty() {
            state.serialize_entry("traffic", &self.traffic)?;
        }
        if self.scaling.is_some() {
            state.serialize_entry("scaling", &self.scaling)?;
        }
        if !wkt::internal::is_default(&self.invoker_iam_disabled) {
            state.serialize_entry("invokerIamDisabled", &self.invoker_iam_disabled)?;
        }
        if !wkt::internal::is_default(&self.default_uri_disabled) {
            state.serialize_entry("defaultUriDisabled", &self.default_uri_disabled)?;
        }
        if !self.urls.is_empty() {
            state.serialize_entry("urls", &self.urls)?;
        }
        if !self.custom_audiences.is_empty() {
            state.serialize_entry("customAudiences", &self.custom_audiences)?;
        }
        if !wkt::internal::is_default(&self.observed_generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("observedGeneration", &__With(&self.observed_generation))?;
        }
        if self.terminal_condition.is_some() {
            state.serialize_entry("terminalCondition", &self.terminal_condition)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !self.latest_ready_revision.is_empty() {
            state.serialize_entry("latestReadyRevision", &self.latest_ready_revision)?;
        }
        if !self.latest_created_revision.is_empty() {
            state.serialize_entry("latestCreatedRevision", &self.latest_created_revision)?;
        }
        if !self.traffic_statuses.is_empty() {
            state.serialize_entry("trafficStatuses", &self.traffic_statuses)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.build_config.is_some() {
            state.serialize_entry("buildConfig", &self.build_config)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Effective settings for the current revision
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RevisionScalingStatus {
    /// The current number of min instances provisioned for this revision.
    pub desired_min_instance_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevisionScalingStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [desired_min_instance_count][crate::model::RevisionScalingStatus::desired_min_instance_count].
    pub fn set_desired_min_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.desired_min_instance_count = v.into();
        self
    }
}

impl wkt::message::Message for RevisionScalingStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RevisionScalingStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RevisionScalingStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __desired_min_instance_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevisionScalingStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "desiredMinInstanceCount" => {
                                Ok(__FieldTag::__desired_min_instance_count)
                            }
                            "desired_min_instance_count" => {
                                Ok(__FieldTag::__desired_min_instance_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RevisionScalingStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevisionScalingStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__desired_min_instance_count => {
                            if !fields.insert(__FieldTag::__desired_min_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_min_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.desired_min_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RevisionScalingStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.desired_min_instance_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "desiredMinInstanceCount",
                &__With(&self.desired_min_instance_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for obtaining a Task by its full name.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTaskRequest {
    /// Required. The full name of the Task.
    /// Format:
    /// projects/{project}/locations/{location}/jobs/{job}/executions/{execution}/tasks/{task}
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetTaskRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTaskRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTaskRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTaskRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTaskRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTaskRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for retrieving a list of Tasks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTasksRequest {
    /// Required. The Execution from which the Tasks should be listed.
    /// To list all Tasks across Executions of a Job, use "-" instead of Execution
    /// name. To list all Tasks across Jobs, use "-" instead of Job name. Format:
    /// projects/{project}/locations/{location}/jobs/{job}/executions/{execution}
    pub parent: std::string::String,

    /// Maximum number of Tasks to return in this call.
    pub page_size: i32,

    /// A page token received from a previous call to ListTasks.
    /// All other parameters must match.
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListTasksRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListTasksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTasksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTasksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTasksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTasksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTasksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message containing a list of Tasks.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTasksResponse {
    /// The resulting list of Tasks.
    pub tasks: std::vec::Vec<crate::model::Task>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListTasks request to continue.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tasks][crate::model::ListTasksResponse::tasks].
    pub fn set_tasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Task>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListTasksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTasksResponse {
    type PageItem = crate::model::Task;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tasks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTasksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tasks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTasksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tasks" => Ok(__FieldTag::__tasks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTasksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTasksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tasks => {
                            if !fields.insert(__FieldTag::__tasks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tasks",
                                ));
                            }
                            result.tasks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Task>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTasksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tasks.is_empty() {
            state.serialize_entry("tasks", &self.tasks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Task represents a single run of a container to completion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Task {
    /// Output only. The unique name of this Task.
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Task. The value is a
    /// UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    pub generation: i64,

    /// Output only. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Represents time when the task was created by the system.
    /// It is not guaranteed to be set in happens-before order across separate
    /// operations.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the task was scheduled to run by the
    /// system. It is not guaranteed to be set in happens-before order across
    /// separate operations.
    pub scheduled_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the task started to run.
    /// It is not guaranteed to be set in happens-before order across separate
    /// operations.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the Task was completed. It is not
    /// guaranteed to be set in happens-before order across separate operations.
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the deletion time. It is only
    /// populated as a response to a Delete request.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted. It is only populated as a response to a Delete
    /// request.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the parent Job.
    pub job: std::string::String,

    /// Output only. The name of the parent Execution.
    pub execution: std::string::String,

    /// Holds the single container that defines the unit of execution for this
    /// task.
    pub containers: std::vec::Vec<crate::model::Container>,

    /// A list of Volumes to make available to containers.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Number of retries allowed per Task, before marking this Task failed.
    pub max_retries: i32,

    /// Max allowed time duration the Task may be active before the system will
    /// actively try to mark it failed and kill associated containers. This applies
    /// per attempt of a task, meaning each retry can run for the full timeout.
    pub timeout: std::option::Option<wkt::Duration>,

    /// Email address of the IAM service account associated with the Task of a
    /// Job. The service account represents the identity of the
    /// running task, and determines what permissions the task has. If
    /// not provided, the task will use the project's default service account.
    pub service_account: std::string::String,

    /// The execution environment being used to host this Task.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// Output only. Indicates whether the resource's reconciliation is still in
    /// progress. See comments in `Job.reconciling` for additional information on
    /// reconciliation process in Cloud Run.
    pub reconciling: bool,

    /// Output only. The Condition of this Task, containing its readiness status,
    /// and detailed error information in case it did not reach the desired state.
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. The generation of this Task. See comments in `Job.reconciling`
    /// for additional information on reconciliation process in Cloud Run.
    pub observed_generation: i64,

    /// Output only. Index of the Task, unique per execution, and beginning at 0.
    pub index: i32,

    /// Output only. The number of times this Task was retried.
    /// Tasks are retried when they fail up to the maxRetries limit.
    pub retried: i32,

    /// Output only. Result of the last attempt of this Task.
    pub last_attempt_result: std::option::Option<crate::model::TaskAttemptResult>,

    /// Output only. A reference to a customer managed encryption key (CMEK) to use
    /// to encrypt this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    pub encryption_key: std::string::String,

    /// Output only. VPC Access configuration to use for this Task. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    /// Output only. URI where logs for this execution can be found in Cloud
    /// Console.
    pub log_uri: std::string::String,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. The node selector for the task.
    pub node_selector: std::option::Option<crate::model::NodeSelector>,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Task {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Task::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Task::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Task::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Task::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Task::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Task::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Task::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scheduled_time][crate::model::Task::scheduled_time].
    pub fn set_scheduled_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.scheduled_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduled_time][crate::model::Task::scheduled_time].
    pub fn set_or_clear_scheduled_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.scheduled_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Task::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Task::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_time][crate::model::Task::completion_time].
    pub fn set_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_time][crate::model::Task::completion_time].
    pub fn set_or_clear_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Task::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Task::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Task::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Task::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Task::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Task::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job][crate::model::Task::job].
    pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::Task::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::Task::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::Task::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [max_retries][crate::model::Task::max_retries].
    pub fn set_max_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_retries = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::Task::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::Task::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::Task::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::Task::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Task::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Task::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Task::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [index][crate::model::Task::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [retried][crate::model::Task::retried].
    pub fn set_retried<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retried = v.into();
        self
    }

    /// Sets the value of [last_attempt_result][crate::model::Task::last_attempt_result].
    pub fn set_last_attempt_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TaskAttemptResult>,
    {
        self.last_attempt_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_attempt_result][crate::model::Task::last_attempt_result].
    pub fn set_or_clear_last_attempt_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TaskAttemptResult>,
    {
        self.last_attempt_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_key][crate::model::Task::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [vpc_access][crate::model::Task::vpc_access].
    pub fn set_vpc_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_access][crate::model::Task::vpc_access].
    pub fn set_or_clear_vpc_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [log_uri][crate::model::Task::log_uri].
    pub fn set_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Task::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [node_selector][crate::model::Task::node_selector].
    pub fn set_node_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_selector][crate::model::Task::node_selector].
    pub fn set_or_clear_node_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Task::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Task {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Task"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Task {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __generation,
            __labels,
            __annotations,
            __create_time,
            __scheduled_time,
            __start_time,
            __completion_time,
            __update_time,
            __delete_time,
            __expire_time,
            __job,
            __execution,
            __containers,
            __volumes,
            __max_retries,
            __timeout,
            __service_account,
            __execution_environment,
            __reconciling,
            __conditions,
            __observed_generation,
            __index,
            __retried,
            __last_attempt_result,
            __encryption_key,
            __vpc_access,
            __log_uri,
            __satisfies_pzs,
            __node_selector,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Task")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "generation" => Ok(__FieldTag::__generation),
                            "labels" => Ok(__FieldTag::__labels),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "scheduledTime" => Ok(__FieldTag::__scheduled_time),
                            "scheduled_time" => Ok(__FieldTag::__scheduled_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "completionTime" => Ok(__FieldTag::__completion_time),
                            "completion_time" => Ok(__FieldTag::__completion_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "job" => Ok(__FieldTag::__job),
                            "execution" => Ok(__FieldTag::__execution),
                            "containers" => Ok(__FieldTag::__containers),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "maxRetries" => Ok(__FieldTag::__max_retries),
                            "max_retries" => Ok(__FieldTag::__max_retries),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "executionEnvironment" => Ok(__FieldTag::__execution_environment),
                            "execution_environment" => Ok(__FieldTag::__execution_environment),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "observedGeneration" => Ok(__FieldTag::__observed_generation),
                            "observed_generation" => Ok(__FieldTag::__observed_generation),
                            "index" => Ok(__FieldTag::__index),
                            "retried" => Ok(__FieldTag::__retried),
                            "lastAttemptResult" => Ok(__FieldTag::__last_attempt_result),
                            "last_attempt_result" => Ok(__FieldTag::__last_attempt_result),
                            "encryptionKey" => Ok(__FieldTag::__encryption_key),
                            "encryption_key" => Ok(__FieldTag::__encryption_key),
                            "vpcAccess" => Ok(__FieldTag::__vpc_access),
                            "vpc_access" => Ok(__FieldTag::__vpc_access),
                            "logUri" => Ok(__FieldTag::__log_uri),
                            "log_uri" => Ok(__FieldTag::__log_uri),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "nodeSelector" => Ok(__FieldTag::__node_selector),
                            "node_selector" => Ok(__FieldTag::__node_selector),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Task;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Task")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generation => {
                            if !fields.insert(__FieldTag::__generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.generation = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__scheduled_time => {
                            if !fields.insert(__FieldTag::__scheduled_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduled_time",
                                ));
                            }
                            result.scheduled_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_time => {
                            if !fields.insert(__FieldTag::__completion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_time",
                                ));
                            }
                            result.completion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution => {
                            if !fields.insert(__FieldTag::__execution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution",
                                ));
                            }
                            result.execution = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__containers => {
                            if !fields.insert(__FieldTag::__containers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containers",
                                ));
                            }
                            result.containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Container>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_retries => {
                            if !fields.insert(__FieldTag::__max_retries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_retries",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_retries = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_environment => {
                            if !fields.insert(__FieldTag::__execution_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_environment",
                                ));
                            }
                            result.execution_environment = map.next_value::<std::option::Option<crate::model::ExecutionEnvironment>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Condition>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__observed_generation => {
                            if !fields.insert(__FieldTag::__observed_generation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observed_generation",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.observed_generation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__index => {
                            if !fields.insert(__FieldTag::__index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__retried => {
                            if !fields.insert(__FieldTag::__retried) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retried",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retried = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_attempt_result => {
                            if !fields.insert(__FieldTag::__last_attempt_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_attempt_result",
                                ));
                            }
                            result.last_attempt_result = map
                                .next_value::<std::option::Option<crate::model::TaskAttemptResult>>(
                                )?;
                        }
                        __FieldTag::__encryption_key => {
                            if !fields.insert(__FieldTag::__encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key",
                                ));
                            }
                            result.encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_access => {
                            if !fields.insert(__FieldTag::__vpc_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_access",
                                ));
                            }
                            result.vpc_access =
                                map.next_value::<std::option::Option<crate::model::VpcAccess>>()?;
                        }
                        __FieldTag::__log_uri => {
                            if !fields.insert(__FieldTag::__log_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_uri",
                                ));
                            }
                            result.log_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_selector => {
                            if !fields.insert(__FieldTag::__node_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_selector",
                                ));
                            }
                            result.node_selector = map
                                .next_value::<std::option::Option<crate::model::NodeSelector>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Task {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("generation", &__With(&self.generation))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.scheduled_time.is_some() {
            state.serialize_entry("scheduledTime", &self.scheduled_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.completion_time.is_some() {
            state.serialize_entry("completionTime", &self.completion_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.job.is_empty() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self.execution.is_empty() {
            state.serialize_entry("execution", &self.execution)?;
        }
        if !self.containers.is_empty() {
            state.serialize_entry("containers", &self.containers)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if !wkt::internal::is_default(&self.max_retries) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxRetries", &__With(&self.max_retries))?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !wkt::internal::is_default(&self.execution_environment) {
            state.serialize_entry("executionEnvironment", &self.execution_environment)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !wkt::internal::is_default(&self.observed_generation) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("observedGeneration", &__With(&self.observed_generation))?;
        }
        if !wkt::internal::is_default(&self.index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if !wkt::internal::is_default(&self.retried) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retried", &__With(&self.retried))?;
        }
        if self.last_attempt_result.is_some() {
            state.serialize_entry("lastAttemptResult", &self.last_attempt_result)?;
        }
        if !self.encryption_key.is_empty() {
            state.serialize_entry("encryptionKey", &self.encryption_key)?;
        }
        if self.vpc_access.is_some() {
            state.serialize_entry("vpcAccess", &self.vpc_access)?;
        }
        if !self.log_uri.is_empty() {
            state.serialize_entry("logUri", &self.log_uri)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.node_selector.is_some() {
            state.serialize_entry("nodeSelector", &self.node_selector)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Result of a task attempt.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TaskAttemptResult {
    /// Output only. The status of this attempt.
    /// If the status code is OK, then the attempt succeeded.
    pub status: std::option::Option<rpc::model::Status>,

    /// Output only. The exit code of this attempt.
    /// This may be unset if the container was unable to exit cleanly with a code
    /// due to some other failure.
    /// See status field for possible failure details.
    pub exit_code: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaskAttemptResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::TaskAttemptResult::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::TaskAttemptResult::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exit_code][crate::model::TaskAttemptResult::exit_code].
    pub fn set_exit_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.exit_code = v.into();
        self
    }
}

impl wkt::message::Message for TaskAttemptResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TaskAttemptResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TaskAttemptResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __exit_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TaskAttemptResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "exitCode" => Ok(__FieldTag::__exit_code),
                            "exit_code" => Ok(__FieldTag::__exit_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TaskAttemptResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TaskAttemptResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__exit_code => {
                            if !fields.insert(__FieldTag::__exit_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exit_code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.exit_code = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TaskAttemptResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !wkt::internal::is_default(&self.exit_code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exitCode", &__With(&self.exit_code))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// TaskTemplate describes the data a task should have when created
/// from a template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TaskTemplate {
    /// Holds the single container that defines the unit of execution for this
    /// task.
    pub containers: std::vec::Vec<crate::model::Container>,

    /// Optional. A list of Volumes to make available to containers.
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Optional. Max allowed time duration the Task may be active before the
    /// system will actively try to mark it failed and kill associated containers.
    /// This applies per attempt of a task, meaning each retry can run for the full
    /// timeout. Defaults to 600 seconds.
    pub timeout: std::option::Option<wkt::Duration>,

    /// Optional. Email address of the IAM service account associated with the Task
    /// of a Job. The service account represents the identity of the running task,
    /// and determines what permissions the task has. If not provided, the task
    /// will use the project's default service account.
    pub service_account: std::string::String,

    /// Optional. The execution environment being used to host this Task.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// A reference to a customer managed encryption key (CMEK) to use to encrypt
    /// this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    pub encryption_key: std::string::String,

    /// Optional. VPC Access configuration to use for this Task. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    /// Optional. The node selector for the task template.
    pub node_selector: std::option::Option<crate::model::NodeSelector>,

    pub retries: std::option::Option<crate::model::task_template::Retries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaskTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [containers][crate::model::TaskTemplate::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::TaskTemplate::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [timeout][crate::model::TaskTemplate::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::TaskTemplate::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::TaskTemplate::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::TaskTemplate::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::TaskTemplate::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [vpc_access][crate::model::TaskTemplate::vpc_access].
    pub fn set_vpc_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_access][crate::model::TaskTemplate::vpc_access].
    pub fn set_or_clear_vpc_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpcAccess>,
    {
        self.vpc_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_selector][crate::model::TaskTemplate::node_selector].
    pub fn set_node_selector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_selector][crate::model::TaskTemplate::node_selector].
    pub fn set_or_clear_node_selector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeSelector>,
    {
        self.node_selector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retries][crate::model::TaskTemplate::retries].
    ///
    /// Note that all the setters affecting `retries` are mutually
    /// exclusive.
    pub fn set_retries<
        T: std::convert::Into<std::option::Option<crate::model::task_template::Retries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retries = v.into();
        self
    }

    /// The value of [retries][crate::model::TaskTemplate::retries]
    /// if it holds a `MaxRetries`, `None` if the field is not set or
    /// holds a different branch.
    pub fn max_retries(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.retries.as_ref().and_then(|v| match v {
            crate::model::task_template::Retries::MaxRetries(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [retries][crate::model::TaskTemplate::retries]
    /// to hold a `MaxRetries`.
    ///
    /// Note that all the setters affecting `retries` are
    /// mutually exclusive.
    pub fn set_max_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retries =
            std::option::Option::Some(crate::model::task_template::Retries::MaxRetries(v.into()));
        self
    }
}

impl wkt::message::Message for TaskTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TaskTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TaskTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __containers,
            __volumes,
            __max_retries,
            __timeout,
            __service_account,
            __execution_environment,
            __encryption_key,
            __vpc_access,
            __node_selector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TaskTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "containers" => Ok(__FieldTag::__containers),
                            "volumes" => Ok(__FieldTag::__volumes),
                            "maxRetries" => Ok(__FieldTag::__max_retries),
                            "max_retries" => Ok(__FieldTag::__max_retries),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "executionEnvironment" => Ok(__FieldTag::__execution_environment),
                            "execution_environment" => Ok(__FieldTag::__execution_environment),
                            "encryptionKey" => Ok(__FieldTag::__encryption_key),
                            "encryption_key" => Ok(__FieldTag::__encryption_key),
                            "vpcAccess" => Ok(__FieldTag::__vpc_access),
                            "vpc_access" => Ok(__FieldTag::__vpc_access),
                            "nodeSelector" => Ok(__FieldTag::__node_selector),
                            "node_selector" => Ok(__FieldTag::__node_selector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TaskTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TaskTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__containers => {
                            if !fields.insert(__FieldTag::__containers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containers",
                                ));
                            }
                            result.containers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Container>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__volumes => {
                            if !fields.insert(__FieldTag::__volumes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes",
                                ));
                            }
                            result.volumes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Volume>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_retries => {
                            if !fields.insert(__FieldTag::__max_retries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_retries",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.retries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `retries`, a oneof with full ID .google.cloud.run.v2.TaskTemplate.max_retries, latest field was maxRetries",
                                ));
                            }
                            result.retries = std::option::Option::Some(
                                crate::model::task_template::Retries::MaxRetries(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_environment => {
                            if !fields.insert(__FieldTag::__execution_environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_environment",
                                ));
                            }
                            result.execution_environment = map.next_value::<std::option::Option<crate::model::ExecutionEnvironment>>()?.unwrap_or_default();
                        }
                        __FieldTag::__encryption_key => {
                            if !fields.insert(__FieldTag::__encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key",
                                ));
                            }
                            result.encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_access => {
                            if !fields.insert(__FieldTag::__vpc_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_access",
                                ));
                            }
                            result.vpc_access =
                                map.next_value::<std::option::Option<crate::model::VpcAccess>>()?;
                        }
                        __FieldTag::__node_selector => {
                            if !fields.insert(__FieldTag::__node_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_selector",
                                ));
                            }
                            result.node_selector = map
                                .next_value::<std::option::Option<crate::model::NodeSelector>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TaskTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.containers.is_empty() {
            state.serialize_entry("containers", &self.containers)?;
        }
        if !self.volumes.is_empty() {
            state.serialize_entry("volumes", &self.volumes)?;
        }
        if let Some(value) = self.max_retries() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxRetries", &__With(value))?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !wkt::internal::is_default(&self.execution_environment) {
            state.serialize_entry("executionEnvironment", &self.execution_environment)?;
        }
        if !self.encryption_key.is_empty() {
            state.serialize_entry("encryptionKey", &self.encryption_key)?;
        }
        if self.vpc_access.is_some() {
            state.serialize_entry("vpcAccess", &self.vpc_access)?;
        }
        if self.node_selector.is_some() {
            state.serialize_entry("nodeSelector", &self.node_selector)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TaskTemplate].
pub mod task_template {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Retries {
        /// Number of retries allowed per Task, before marking this Task failed.
        /// Defaults to 3.
        MaxRetries(i32),
    }
}

/// Holds a single traffic routing entry for the Service. Allocations can be done
/// to a specific Revision name, or pointing to the latest Ready Revision.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TrafficTarget {
    /// The allocation type for this traffic target.
    pub r#type: crate::model::TrafficTargetAllocationType,

    /// Revision to which to send this portion of traffic, if traffic allocation is
    /// by revision.
    pub revision: std::string::String,

    /// Specifies percent of the traffic to this Revision.
    /// This defaults to zero if unspecified.
    pub percent: i32,

    /// Indicates a string to be part of the URI to exclusively reference this
    /// target.
    pub tag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrafficTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TrafficTarget::type].
    pub fn set_type<T: std::convert::Into<crate::model::TrafficTargetAllocationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::TrafficTarget::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [percent][crate::model::TrafficTarget::percent].
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.percent = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::TrafficTarget::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for TrafficTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TrafficTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrafficTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __revision,
            __percent,
            __tag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrafficTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "revision" => Ok(__FieldTag::__revision),
                            "percent" => Ok(__FieldTag::__percent),
                            "tag" => Ok(__FieldTag::__tag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrafficTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrafficTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::TrafficTargetAllocationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__percent => {
                            if !fields.insert(__FieldTag::__percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            result.tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TrafficTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if !wkt::internal::is_default(&self.percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("percent", &__With(&self.percent))?;
        }
        if !self.tag.is_empty() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the observed state of a single `TrafficTarget` entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TrafficTargetStatus {
    /// The allocation type for this traffic target.
    pub r#type: crate::model::TrafficTargetAllocationType,

    /// Revision to which this traffic is sent.
    pub revision: std::string::String,

    /// Specifies percent of the traffic to this Revision.
    pub percent: i32,

    /// Indicates the string used in the URI to exclusively reference this target.
    pub tag: std::string::String,

    /// Displays the target URI.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrafficTargetStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TrafficTargetStatus::type].
    pub fn set_type<T: std::convert::Into<crate::model::TrafficTargetAllocationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::TrafficTargetStatus::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [percent][crate::model::TrafficTargetStatus::percent].
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.percent = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::TrafficTargetStatus::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::TrafficTargetStatus::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for TrafficTargetStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TrafficTargetStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrafficTargetStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __revision,
            __percent,
            __tag,
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrafficTargetStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "revision" => Ok(__FieldTag::__revision),
                            "percent" => Ok(__FieldTag::__percent),
                            "tag" => Ok(__FieldTag::__tag),
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrafficTargetStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrafficTargetStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::TrafficTargetAllocationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__percent => {
                            if !fields.insert(__FieldTag::__percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.percent = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            result.tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TrafficTargetStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if !wkt::internal::is_default(&self.percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("percent", &__With(&self.percent))?;
        }
        if !self.tag.is_empty() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// VPC Access settings. For more information on sending traffic to a VPC
/// network, visit <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VpcAccess {
    /// VPC Access connector name.
    /// Format: `projects/{project}/locations/{location}/connectors/{connector}`,
    /// where `{project}` can be project id or number.
    /// For more information on sending traffic to a VPC network via a connector,
    /// visit <https://cloud.google.com/run/docs/configuring/vpc-connectors>.
    pub connector: std::string::String,

    /// Optional. Traffic VPC egress settings. If not provided, it defaults to
    /// PRIVATE_RANGES_ONLY.
    pub egress: crate::model::vpc_access::VpcEgress,

    /// Optional. Direct VPC egress settings. Currently only single network
    /// interface is supported.
    pub network_interfaces: std::vec::Vec<crate::model::vpc_access::NetworkInterface>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcAccess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connector][crate::model::VpcAccess::connector].
    pub fn set_connector<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connector = v.into();
        self
    }

    /// Sets the value of [egress][crate::model::VpcAccess::egress].
    pub fn set_egress<T: std::convert::Into<crate::model::vpc_access::VpcEgress>>(
        mut self,
        v: T,
    ) -> Self {
        self.egress = v.into();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::VpcAccess::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vpc_access::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VpcAccess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.VpcAccess"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpcAccess {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connector,
            __egress,
            __network_interfaces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcAccess")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connector" => Ok(__FieldTag::__connector),
                            "egress" => Ok(__FieldTag::__egress),
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpcAccess;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcAccess")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connector => {
                            if !fields.insert(__FieldTag::__connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connector",
                                ));
                            }
                            result.connector = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__egress => {
                            if !fields.insert(__FieldTag::__egress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for egress",
                                ));
                            }
                            result.egress = map.next_value::<std::option::Option<crate::model::vpc_access::VpcEgress>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::vpc_access::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpcAccess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connector.is_empty() {
            state.serialize_entry("connector", &self.connector)?;
        }
        if !wkt::internal::is_default(&self.egress) {
            state.serialize_entry("egress", &self.egress)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VpcAccess].
pub mod vpc_access {
    #[allow(unused_imports)]
    use super::*;

    /// Direct VPC egress settings.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkInterface {
        /// Optional. The VPC network that the Cloud Run resource will be able to
        /// send traffic to. At least one of network or subnetwork must be specified.
        /// If both network and subnetwork are specified, the given VPC subnetwork
        /// must belong to the given VPC network. If network is not specified, it
        /// will be looked up from the subnetwork.
        pub network: std::string::String,

        /// Optional. The VPC subnetwork that the Cloud Run resource will get IPs
        /// from. At least one of network or subnetwork must be specified. If both
        /// network and subnetwork are specified, the given VPC subnetwork must
        /// belong to the given VPC network. If subnetwork is not specified, the
        /// subnetwork with the same name with the network will be used.
        pub subnetwork: std::string::String,

        /// Optional. Network tags applied to this Cloud Run resource.
        pub tags: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::vpc_access::NetworkInterface::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [subnetwork][crate::model::vpc_access::NetworkInterface::subnetwork].
        pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subnetwork = v.into();
            self
        }

        /// Sets the value of [tags][crate::model::vpc_access::NetworkInterface::tags].
        pub fn set_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NetworkInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.VpcAccess.NetworkInterface"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NetworkInterface {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network,
                __subnetwork,
                __tags,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NetworkInterface")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "network" => Ok(__FieldTag::__network),
                                "subnetwork" => Ok(__FieldTag::__subnetwork),
                                "tags" => Ok(__FieldTag::__tags),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NetworkInterface;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NetworkInterface")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network => {
                                if !fields.insert(__FieldTag::__network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network",
                                    ));
                                }
                                result.network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__subnetwork => {
                                if !fields.insert(__FieldTag::__subnetwork) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subnetwork",
                                    ));
                                }
                                result.subnetwork = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tags => {
                                if !fields.insert(__FieldTag::__tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tags",
                                    ));
                                }
                                result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NetworkInterface {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network.is_empty() {
                state.serialize_entry("network", &self.network)?;
            }
            if !self.subnetwork.is_empty() {
                state.serialize_entry("subnetwork", &self.subnetwork)?;
            }
            if !self.tags.is_empty() {
                state.serialize_entry("tags", &self.tags)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Egress options for VPC access.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VpcEgress {
        /// Unspecified
        Unspecified,
        /// All outbound traffic is routed through the VPC connector.
        AllTraffic,
        /// Only private IP ranges are routed through the VPC connector.
        PrivateRangesOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VpcEgress::value] or
        /// [VpcEgress::name].
        UnknownValue(vpc_egress::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vpc_egress {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VpcEgress {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllTraffic => std::option::Option::Some(1),
                Self::PrivateRangesOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VPC_EGRESS_UNSPECIFIED"),
                Self::AllTraffic => std::option::Option::Some("ALL_TRAFFIC"),
                Self::PrivateRangesOnly => std::option::Option::Some("PRIVATE_RANGES_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VpcEgress {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VpcEgress {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VpcEgress {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllTraffic,
                2 => Self::PrivateRangesOnly,
                _ => Self::UnknownValue(vpc_egress::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VpcEgress {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VPC_EGRESS_UNSPECIFIED" => Self::Unspecified,
                "ALL_TRAFFIC" => Self::AllTraffic,
                "PRIVATE_RANGES_ONLY" => Self::PrivateRangesOnly,
                _ => Self::UnknownValue(vpc_egress::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VpcEgress {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllTraffic => serializer.serialize_i32(1),
                Self::PrivateRangesOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VpcEgress {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VpcEgress>::new(
                ".google.cloud.run.v2.VpcAccess.VpcEgress",
            ))
        }
    }
}

/// Settings for Binary Authorization feature.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BinaryAuthorization {
    /// Optional. If present, indicates to use Breakglass using this justification.
    /// If use_default is False, then it must be empty.
    /// For more information on breakglass, see
    /// <https://cloud.google.com/binary-authorization/docs/using-breakglass>
    pub breakglass_justification: std::string::String,

    pub binauthz_method: std::option::Option<crate::model::binary_authorization::BinauthzMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BinaryAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [breakglass_justification][crate::model::BinaryAuthorization::breakglass_justification].
    pub fn set_breakglass_justification<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.breakglass_justification = v.into();
        self
    }

    /// Sets the value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method].
    ///
    /// Note that all the setters affecting `binauthz_method` are mutually
    /// exclusive.
    pub fn set_binauthz_method<
        T: std::convert::Into<std::option::Option<crate::model::binary_authorization::BinauthzMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.binauthz_method = v.into();
        self
    }

    /// The value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// if it holds a `UseDefault`, `None` if the field is not set or
    /// holds a different branch.
    pub fn use_default(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.binauthz_method.as_ref().and_then(|v| match v {
            crate::model::binary_authorization::BinauthzMethod::UseDefault(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// to hold a `UseDefault`.
    ///
    /// Note that all the setters affecting `binauthz_method` are
    /// mutually exclusive.
    pub fn set_use_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.binauthz_method = std::option::Option::Some(
            crate::model::binary_authorization::BinauthzMethod::UseDefault(v.into()),
        );
        self
    }

    /// The value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// if it holds a `Policy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn policy(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.binauthz_method.as_ref().and_then(|v| match v {
            crate::model::binary_authorization::BinauthzMethod::Policy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// to hold a `Policy`.
    ///
    /// Note that all the setters affecting `binauthz_method` are
    /// mutually exclusive.
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.binauthz_method = std::option::Option::Some(
            crate::model::binary_authorization::BinauthzMethod::Policy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BinaryAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.BinaryAuthorization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BinaryAuthorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_default,
            __policy,
            __breakglass_justification,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BinaryAuthorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useDefault" => Ok(__FieldTag::__use_default),
                            "use_default" => Ok(__FieldTag::__use_default),
                            "policy" => Ok(__FieldTag::__policy),
                            "breakglassJustification" => Ok(__FieldTag::__breakglass_justification),
                            "breakglass_justification" => {
                                Ok(__FieldTag::__breakglass_justification)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BinaryAuthorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BinaryAuthorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_default => {
                            if !fields.insert(__FieldTag::__use_default) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_default",
                                ));
                            }
                            if result.binauthz_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `binauthz_method`, a oneof with full ID .google.cloud.run.v2.BinaryAuthorization.use_default, latest field was useDefault",
                                ));
                            }
                            result.binauthz_method = std::option::Option::Some(
                                crate::model::binary_authorization::BinauthzMethod::UseDefault(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            if result.binauthz_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `binauthz_method`, a oneof with full ID .google.cloud.run.v2.BinaryAuthorization.policy, latest field was policy",
                                ));
                            }
                            result.binauthz_method = std::option::Option::Some(
                                crate::model::binary_authorization::BinauthzMethod::Policy(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__breakglass_justification => {
                            if !fields.insert(__FieldTag::__breakglass_justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for breakglass_justification",
                                ));
                            }
                            result.breakglass_justification = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BinaryAuthorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.use_default() {
            state.serialize_entry("useDefault", value)?;
        }
        if let Some(value) = self.policy() {
            state.serialize_entry("policy", value)?;
        }
        if !self.breakglass_justification.is_empty() {
            state.serialize_entry("breakglassJustification", &self.breakglass_justification)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BinaryAuthorization].
pub mod binary_authorization {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BinauthzMethod {
        /// Optional. If True, indicates to use the default project's binary
        /// authorization policy. If False, binary authorization will be disabled.
        UseDefault(bool),
        /// Optional. The path to a binary authorization policy.
        /// Format: `projects/{project}/platforms/cloudRun/{policy-name}`
        Policy(std::string::String),
    }
}

/// Settings for revision-level scaling settings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RevisionScaling {
    /// Optional. Minimum number of serving instances that this resource should
    /// have.
    pub min_instance_count: i32,

    /// Optional. Maximum number of serving instances that this resource should
    /// have. When unspecified, the field is set to the server default value of
    /// 100. For more information see
    /// <https://cloud.google.com/run/docs/configuring/max-instances>
    pub max_instance_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevisionScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_instance_count][crate::model::RevisionScaling::min_instance_count].
    pub fn set_min_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instance_count = v.into();
        self
    }

    /// Sets the value of [max_instance_count][crate::model::RevisionScaling::max_instance_count].
    pub fn set_max_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instance_count = v.into();
        self
    }
}

impl wkt::message::Message for RevisionScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RevisionScaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RevisionScaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_instance_count,
            __max_instance_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevisionScaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minInstanceCount" => Ok(__FieldTag::__min_instance_count),
                            "min_instance_count" => Ok(__FieldTag::__min_instance_count),
                            "maxInstanceCount" => Ok(__FieldTag::__max_instance_count),
                            "max_instance_count" => Ok(__FieldTag::__max_instance_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RevisionScaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevisionScaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_instance_count => {
                            if !fields.insert(__FieldTag::__min_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_instance_count => {
                            if !fields.insert(__FieldTag::__max_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RevisionScaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_instance_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minInstanceCount", &__With(&self.min_instance_count))?;
        }
        if !wkt::internal::is_default(&self.max_instance_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxInstanceCount", &__With(&self.max_instance_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings for Cloud Service Mesh. For more information see
/// <https://cloud.google.com/service-mesh/docs/overview>.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceMesh {
    /// The Mesh resource name. Format:
    /// `projects/{project}/locations/global/meshes/{mesh}`, where `{project}` can
    /// be project id or number.
    pub mesh: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceMesh {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mesh][crate::model::ServiceMesh::mesh].
    pub fn set_mesh<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mesh = v.into();
        self
    }
}

impl wkt::message::Message for ServiceMesh {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ServiceMesh"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceMesh {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mesh,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceMesh")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mesh" => Ok(__FieldTag::__mesh),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceMesh;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceMesh")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mesh => {
                            if !fields.insert(__FieldTag::__mesh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mesh",
                                ));
                            }
                            result.mesh = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceMesh {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mesh.is_empty() {
            state.serialize_entry("mesh", &self.mesh)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Scaling settings applied at the service level rather than
/// at the revision level.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceScaling {
    /// Optional. total min instances for the service. This number of instances is
    /// divided among all revisions with specified traffic based on the percent
    /// of traffic they are receiving.
    pub min_instance_count: i32,

    /// Optional. The scaling mode for the service.
    pub scaling_mode: crate::model::service_scaling::ScalingMode,

    /// Optional. total instance count for the service in manual scaling mode. This
    /// number of instances is divided among all revisions with specified traffic
    /// based on the percent of traffic they are receiving.
    pub manual_instance_count: std::option::Option<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_instance_count][crate::model::ServiceScaling::min_instance_count].
    pub fn set_min_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instance_count = v.into();
        self
    }

    /// Sets the value of [scaling_mode][crate::model::ServiceScaling::scaling_mode].
    pub fn set_scaling_mode<T: std::convert::Into<crate::model::service_scaling::ScalingMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.scaling_mode = v.into();
        self
    }

    /// Sets the value of [manual_instance_count][crate::model::ServiceScaling::manual_instance_count].
    pub fn set_manual_instance_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.manual_instance_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [manual_instance_count][crate::model::ServiceScaling::manual_instance_count].
    pub fn set_or_clear_manual_instance_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.manual_instance_count = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ServiceScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ServiceScaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceScaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_instance_count,
            __scaling_mode,
            __manual_instance_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceScaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minInstanceCount" => Ok(__FieldTag::__min_instance_count),
                            "min_instance_count" => Ok(__FieldTag::__min_instance_count),
                            "scalingMode" => Ok(__FieldTag::__scaling_mode),
                            "scaling_mode" => Ok(__FieldTag::__scaling_mode),
                            "manualInstanceCount" => Ok(__FieldTag::__manual_instance_count),
                            "manual_instance_count" => Ok(__FieldTag::__manual_instance_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceScaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceScaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_instance_count => {
                            if !fields.insert(__FieldTag::__min_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_instance_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scaling_mode => {
                            if !fields.insert(__FieldTag::__scaling_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scaling_mode",
                                ));
                            }
                            result.scaling_mode = map.next_value::<std::option::Option<crate::model::service_scaling::ScalingMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__manual_instance_count => {
                            if !fields.insert(__FieldTag::__manual_instance_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_instance_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.manual_instance_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceScaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_instance_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minInstanceCount", &__With(&self.min_instance_count))?;
        }
        if !wkt::internal::is_default(&self.scaling_mode) {
            state.serialize_entry("scalingMode", &self.scaling_mode)?;
        }
        if self.manual_instance_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("manualInstanceCount", &__With(&self.manual_instance_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ServiceScaling].
pub mod service_scaling {
    #[allow(unused_imports)]
    use super::*;

    /// The scaling mode for the service. If not provided, it defaults to
    /// AUTOMATIC.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScalingMode {
        /// Unspecified.
        Unspecified,
        /// Scale based on traffic between min and max instances.
        Automatic,
        /// Scale to exactly min instances and ignore max instances.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ScalingMode::value] or
        /// [ScalingMode::name].
        UnknownValue(scaling_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scaling_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ScalingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCALING_MODE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ScalingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ScalingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ScalingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(scaling_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ScalingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCALING_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(scaling_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ScalingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ScalingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScalingMode>::new(
                ".google.cloud.run.v2.ServiceScaling.ScalingMode",
            ))
        }
    }
}

/// Hardware constraints configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeSelector {
    /// Required. GPU accelerator type to attach to an instance.
    pub accelerator: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator][crate::model::NodeSelector::accelerator].
    pub fn set_accelerator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.accelerator = v.into();
        self
    }
}

impl wkt::message::Message for NodeSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.NodeSelector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeSelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accelerator,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeSelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accelerator" => Ok(__FieldTag::__accelerator),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeSelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeSelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accelerator => {
                            if !fields.insert(__FieldTag::__accelerator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator",
                                ));
                            }
                            result.accelerator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeSelector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerator.is_empty() {
            state.serialize_entry("accelerator", &self.accelerator)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the Build step of the function that builds a container from the
/// given source.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BuildConfig {
    /// Output only. The Cloud Build name of the latest successful deployment of
    /// the function.
    pub name: std::string::String,

    /// The Cloud Storage bucket URI where the function source code is located.
    pub source_location: std::string::String,

    /// Optional. The name of the function (as defined in source code) that will be
    /// executed. Defaults to the resource name suffix, if not specified. For
    /// backward compatibility, if function with given name is not found, then the
    /// system will try to use function named "function".
    pub function_target: std::string::String,

    /// Optional. Artifact Registry URI to store the built image.
    pub image_uri: std::string::String,

    /// Optional. The base image used to build the function.
    pub base_image: std::string::String,

    /// Optional. Sets whether the function will receive automatic base image
    /// updates.
    pub enable_automatic_updates: bool,

    /// Optional. Name of the Cloud Build Custom Worker Pool that should be used to
    /// build the Cloud Run function. The format of this field is
    /// `projects/{project}/locations/{region}/workerPools/{workerPool}` where
    /// `{project}` and `{region}` are the project id and region respectively where
    /// the worker pool is defined and `{workerPool}` is the short name of the
    /// worker pool.
    pub worker_pool: std::string::String,

    /// Optional. User-provided build-time environment variables for the function
    pub environment_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Service account to be used for building the container. The format
    /// of this field is
    /// `projects/{projectId}/serviceAccounts/{serviceAccountEmail}`.
    pub service_account: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuildConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_location][crate::model::BuildConfig::source_location].
    pub fn set_source_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_location = v.into();
        self
    }

    /// Sets the value of [function_target][crate::model::BuildConfig::function_target].
    pub fn set_function_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function_target = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::BuildConfig::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [base_image][crate::model::BuildConfig::base_image].
    pub fn set_base_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_image = v.into();
        self
    }

    /// Sets the value of [enable_automatic_updates][crate::model::BuildConfig::enable_automatic_updates].
    pub fn set_enable_automatic_updates<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_automatic_updates = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::BuildConfig::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [environment_variables][crate::model::BuildConfig::environment_variables].
    pub fn set_environment_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.environment_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::BuildConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

impl wkt::message::Message for BuildConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.BuildConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BuildConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_location,
            __function_target,
            __image_uri,
            __base_image,
            __enable_automatic_updates,
            __worker_pool,
            __environment_variables,
            __service_account,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BuildConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceLocation" => Ok(__FieldTag::__source_location),
                            "source_location" => Ok(__FieldTag::__source_location),
                            "functionTarget" => Ok(__FieldTag::__function_target),
                            "function_target" => Ok(__FieldTag::__function_target),
                            "imageUri" => Ok(__FieldTag::__image_uri),
                            "image_uri" => Ok(__FieldTag::__image_uri),
                            "baseImage" => Ok(__FieldTag::__base_image),
                            "base_image" => Ok(__FieldTag::__base_image),
                            "enableAutomaticUpdates" => Ok(__FieldTag::__enable_automatic_updates),
                            "enable_automatic_updates" => {
                                Ok(__FieldTag::__enable_automatic_updates)
                            }
                            "workerPool" => Ok(__FieldTag::__worker_pool),
                            "worker_pool" => Ok(__FieldTag::__worker_pool),
                            "environmentVariables" => Ok(__FieldTag::__environment_variables),
                            "environment_variables" => Ok(__FieldTag::__environment_variables),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BuildConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BuildConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_location => {
                            if !fields.insert(__FieldTag::__source_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_location",
                                ));
                            }
                            result.source_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__function_target => {
                            if !fields.insert(__FieldTag::__function_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for function_target",
                                ));
                            }
                            result.function_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_uri => {
                            if !fields.insert(__FieldTag::__image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_uri",
                                ));
                            }
                            result.image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_image => {
                            if !fields.insert(__FieldTag::__base_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_image",
                                ));
                            }
                            result.base_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_automatic_updates => {
                            if !fields.insert(__FieldTag::__enable_automatic_updates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_automatic_updates",
                                ));
                            }
                            result.enable_automatic_updates = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__worker_pool => {
                            if !fields.insert(__FieldTag::__worker_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_pool",
                                ));
                            }
                            result.worker_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment_variables => {
                            if !fields.insert(__FieldTag::__environment_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment_variables",
                                ));
                            }
                            result.environment_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BuildConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_location.is_empty() {
            state.serialize_entry("sourceLocation", &self.source_location)?;
        }
        if !self.function_target.is_empty() {
            state.serialize_entry("functionTarget", &self.function_target)?;
        }
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if !self.base_image.is_empty() {
            state.serialize_entry("baseImage", &self.base_image)?;
        }
        if !wkt::internal::is_default(&self.enable_automatic_updates) {
            state.serialize_entry("enableAutomaticUpdates", &self.enable_automatic_updates)?;
        }
        if !self.worker_pool.is_empty() {
            state.serialize_entry("workerPool", &self.worker_pool)?;
        }
        if !self.environment_variables.is_empty() {
            state.serialize_entry("environmentVariables", &self.environment_variables)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The type of instance allocation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TrafficTargetAllocationType {
    /// Unspecified instance allocation type.
    Unspecified,
    /// Allocates instances to the Service's latest ready Revision.
    Latest,
    /// Allocates instances to a Revision by name.
    Revision,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TrafficTargetAllocationType::value] or
    /// [TrafficTargetAllocationType::name].
    UnknownValue(traffic_target_allocation_type::UnknownValue),
}

#[doc(hidden)]
pub mod traffic_target_allocation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TrafficTargetAllocationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Latest => std::option::Option::Some(1),
            Self::Revision => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("TRAFFIC_TARGET_ALLOCATION_TYPE_UNSPECIFIED")
            }
            Self::Latest => std::option::Option::Some("TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST"),
            Self::Revision => std::option::Option::Some("TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TrafficTargetAllocationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TrafficTargetAllocationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TrafficTargetAllocationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Latest,
            2 => Self::Revision,
            _ => Self::UnknownValue(traffic_target_allocation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TrafficTargetAllocationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRAFFIC_TARGET_ALLOCATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST" => Self::Latest,
            "TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION" => Self::Revision,
            _ => Self::UnknownValue(traffic_target_allocation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TrafficTargetAllocationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Latest => serializer.serialize_i32(1),
            Self::Revision => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TrafficTargetAllocationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<TrafficTargetAllocationType>::new(
                ".google.cloud.run.v2.TrafficTargetAllocationType",
            ),
        )
    }
}

/// Allowed ingress traffic for the Container.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IngressTraffic {
    /// Unspecified
    Unspecified,
    /// All inbound traffic is allowed.
    All,
    /// Only internal traffic is allowed.
    InternalOnly,
    /// Both internal and Google Cloud Load Balancer traffic is allowed.
    InternalLoadBalancer,
    /// No ingress traffic is allowed.
    None,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IngressTraffic::value] or
    /// [IngressTraffic::name].
    UnknownValue(ingress_traffic::UnknownValue),
}

#[doc(hidden)]
pub mod ingress_traffic {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IngressTraffic {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::All => std::option::Option::Some(1),
            Self::InternalOnly => std::option::Option::Some(2),
            Self::InternalLoadBalancer => std::option::Option::Some(3),
            Self::None => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INGRESS_TRAFFIC_UNSPECIFIED"),
            Self::All => std::option::Option::Some("INGRESS_TRAFFIC_ALL"),
            Self::InternalOnly => std::option::Option::Some("INGRESS_TRAFFIC_INTERNAL_ONLY"),
            Self::InternalLoadBalancer => {
                std::option::Option::Some("INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER")
            }
            Self::None => std::option::Option::Some("INGRESS_TRAFFIC_NONE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IngressTraffic {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IngressTraffic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IngressTraffic {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::All,
            2 => Self::InternalOnly,
            3 => Self::InternalLoadBalancer,
            4 => Self::None,
            _ => Self::UnknownValue(ingress_traffic::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IngressTraffic {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INGRESS_TRAFFIC_UNSPECIFIED" => Self::Unspecified,
            "INGRESS_TRAFFIC_ALL" => Self::All,
            "INGRESS_TRAFFIC_INTERNAL_ONLY" => Self::InternalOnly,
            "INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER" => Self::InternalLoadBalancer,
            "INGRESS_TRAFFIC_NONE" => Self::None,
            _ => Self::UnknownValue(ingress_traffic::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IngressTraffic {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::All => serializer.serialize_i32(1),
            Self::InternalOnly => serializer.serialize_i32(2),
            Self::InternalLoadBalancer => serializer.serialize_i32(3),
            Self::None => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IngressTraffic {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IngressTraffic>::new(
            ".google.cloud.run.v2.IngressTraffic",
        ))
    }
}

/// Alternatives for execution environments.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ExecutionEnvironment {
    /// Unspecified
    Unspecified,
    /// Uses the First Generation environment.
    Gen1,
    /// Uses Second Generation environment.
    Gen2,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ExecutionEnvironment::value] or
    /// [ExecutionEnvironment::name].
    UnknownValue(execution_environment::UnknownValue),
}

#[doc(hidden)]
pub mod execution_environment {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ExecutionEnvironment {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Gen1 => std::option::Option::Some(1),
            Self::Gen2 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("EXECUTION_ENVIRONMENT_UNSPECIFIED"),
            Self::Gen1 => std::option::Option::Some("EXECUTION_ENVIRONMENT_GEN1"),
            Self::Gen2 => std::option::Option::Some("EXECUTION_ENVIRONMENT_GEN2"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ExecutionEnvironment {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ExecutionEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ExecutionEnvironment {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Gen1,
            2 => Self::Gen2,
            _ => Self::UnknownValue(execution_environment::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ExecutionEnvironment {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "EXECUTION_ENVIRONMENT_UNSPECIFIED" => Self::Unspecified,
            "EXECUTION_ENVIRONMENT_GEN1" => Self::Gen1,
            "EXECUTION_ENVIRONMENT_GEN2" => Self::Gen2,
            _ => Self::UnknownValue(execution_environment::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ExecutionEnvironment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Gen1 => serializer.serialize_i32(1),
            Self::Gen2 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ExecutionEnvironment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionEnvironment>::new(
            ".google.cloud.run.v2.ExecutionEnvironment",
        ))
    }
}

/// Specifies behavior if an encryption key used by a resource is revoked.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncryptionKeyRevocationAction {
    /// Unspecified
    Unspecified,
    /// Prevents the creation of new instances.
    PreventNew,
    /// Shuts down existing instances, and prevents creation of new ones.
    Shutdown,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncryptionKeyRevocationAction::value] or
    /// [EncryptionKeyRevocationAction::name].
    UnknownValue(encryption_key_revocation_action::UnknownValue),
}

#[doc(hidden)]
pub mod encryption_key_revocation_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncryptionKeyRevocationAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PreventNew => std::option::Option::Some(1),
            Self::Shutdown => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED")
            }
            Self::PreventNew => std::option::Option::Some("PREVENT_NEW"),
            Self::Shutdown => std::option::Option::Some("SHUTDOWN"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncryptionKeyRevocationAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncryptionKeyRevocationAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncryptionKeyRevocationAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PreventNew,
            2 => Self::Shutdown,
            _ => Self::UnknownValue(encryption_key_revocation_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncryptionKeyRevocationAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED" => Self::Unspecified,
            "PREVENT_NEW" => Self::PreventNew,
            "SHUTDOWN" => Self::Shutdown,
            _ => Self::UnknownValue(encryption_key_revocation_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncryptionKeyRevocationAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PreventNew => serializer.serialize_i32(1),
            Self::Shutdown => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncryptionKeyRevocationAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<EncryptionKeyRevocationAction>::new(
                ".google.cloud.run.v2.EncryptionKeyRevocationAction",
            ),
        )
    }
}
