// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for submitting a Build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitBuildRequest {
    /// Required. The project and location to build in. Location must be a region,
    /// e.g., 'us-central1' or 'global' if the global builder is to be used.
    /// Format:
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Artifact Registry URI to store the built image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Optional. The service account to use for the build. If not set, the default
    /// Cloud Build service account for the project will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. Name of the Cloud Build Custom Worker Pool that should be used to
    /// build the function. The format of this field is
    /// `projects/{project}/locations/{region}/workerPools/{workerPool}` where
    /// `{project}` and `{region}` are the project id and region respectively where
    /// the worker pool is defined and `{workerPool}` is the short name of the
    /// worker pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool: std::string::String,

    /// Optional. Additional tags to annotate the build.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Location of source.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::submit_build_request::Source>,

    /// Build type must be one of the following.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub build_type: std::option::Option<crate::model::submit_build_request::BuildType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitBuildRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SubmitBuildRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::SubmitBuildRequest::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::SubmitBuildRequest::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::SubmitBuildRequest::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::SubmitBuildRequest::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source][crate::model::SubmitBuildRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::submit_build_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::SubmitBuildRequest::source]
    /// if it holds a `StorageSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StorageSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::submit_build_request::Source::StorageSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::SubmitBuildRequest::source]
    /// to hold a `StorageSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_storage_source<
        T: std::convert::Into<std::boxed::Box<crate::model::StorageSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::submit_build_request::Source::StorageSource(v.into()),
        );
        self
    }

    /// Sets the value of [build_type][crate::model::SubmitBuildRequest::build_type].
    ///
    /// Note that all the setters affecting `build_type` are mutually
    /// exclusive.
    pub fn set_build_type<
        T: std::convert::Into<std::option::Option<crate::model::submit_build_request::BuildType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_type = v.into();
        self
    }

    /// The value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// if it holds a `BuildpackBuild`, `None` if the field is not set or
    /// holds a different branch.
    pub fn buildpack_build(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::submit_build_request::BuildpacksBuild>>
    {
        #[allow(unreachable_patterns)]
        self.build_type.as_ref().and_then(|v| match v {
            crate::model::submit_build_request::BuildType::BuildpackBuild(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// if it holds a `DockerBuild`, `None` if the field is not set or
    /// holds a different branch.
    pub fn docker_build(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::submit_build_request::DockerBuild>>
    {
        #[allow(unreachable_patterns)]
        self.build_type.as_ref().and_then(|v| match v {
            crate::model::submit_build_request::BuildType::DockerBuild(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// to hold a `BuildpackBuild`.
    ///
    /// Note that all the setters affecting `build_type` are
    /// mutually exclusive.
    pub fn set_buildpack_build<
        T: std::convert::Into<std::boxed::Box<crate::model::submit_build_request::BuildpacksBuild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_type = std::option::Option::Some(
            crate::model::submit_build_request::BuildType::BuildpackBuild(v.into()),
        );
        self
    }

    /// Sets the value of [build_type][crate::model::SubmitBuildRequest::build_type]
    /// to hold a `DockerBuild`.
    ///
    /// Note that all the setters affecting `build_type` are
    /// mutually exclusive.
    pub fn set_docker_build<
        T: std::convert::Into<std::boxed::Box<crate::model::submit_build_request::DockerBuild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_type = std::option::Option::Some(
            crate::model::submit_build_request::BuildType::DockerBuild(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SubmitBuildRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SubmitBuildRequest"
    }
}

/// Defines additional types related to [SubmitBuildRequest].
pub mod submit_build_request {
    #[allow(unused_imports)]
    use super::*;

    /// Build the source using Docker. This means the source has a Dockerfile.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DockerBuild {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DockerBuild {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for DockerBuild {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.SubmitBuildRequest.DockerBuild"
        }
    }

    /// Build the source using Buildpacks.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BuildpacksBuild {
        /// The runtime name, e.g. 'go113'. Leave blank for generic builds.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[deprecated]
        pub runtime: std::string::String,

        /// Optional. Name of the function target if the source is a function source.
        /// Required for function builds.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub function_target: std::string::String,

        /// Optional. cache_image_uri is the GCR/AR URL where the cache image will be
        /// stored. cache_image_uri is optional and omitting it will disable caching.
        /// This URL must be stable across builds. It is used to derive a
        /// build-specific temporary URL by substituting the tag with the build ID.
        /// The build will clean up the temporary image on a best-effort basis.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cache_image_uri: std::string::String,

        /// Optional. The base image to use for the build.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub base_image: std::string::String,

        /// Optional. User-provided build-time environment variables.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub environment_variables:
            std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. Whether or not the application container will be enrolled in
        /// automatic base image updates. When true, the application will be built on
        /// a scratch base image, so the base layers can be appended at run time.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enable_automatic_updates: bool,

        /// Optional. project_descriptor stores the path to the project descriptor
        /// file. When empty, it means that there is no project descriptor file in
        /// the source.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_descriptor: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BuildpacksBuild {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [runtime][crate::model::submit_build_request::BuildpacksBuild::runtime].
        #[deprecated]
        pub fn set_runtime<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.runtime = v.into();
            self
        }

        /// Sets the value of [function_target][crate::model::submit_build_request::BuildpacksBuild::function_target].
        pub fn set_function_target<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.function_target = v.into();
            self
        }

        /// Sets the value of [cache_image_uri][crate::model::submit_build_request::BuildpacksBuild::cache_image_uri].
        pub fn set_cache_image_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cache_image_uri = v.into();
            self
        }

        /// Sets the value of [base_image][crate::model::submit_build_request::BuildpacksBuild::base_image].
        pub fn set_base_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.base_image = v.into();
            self
        }

        /// Sets the value of [enable_automatic_updates][crate::model::submit_build_request::BuildpacksBuild::enable_automatic_updates].
        pub fn set_enable_automatic_updates<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_automatic_updates = v.into();
            self
        }

        /// Sets the value of [project_descriptor][crate::model::submit_build_request::BuildpacksBuild::project_descriptor].
        pub fn set_project_descriptor<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.project_descriptor = v.into();
            self
        }

        /// Sets the value of [environment_variables][crate::model::submit_build_request::BuildpacksBuild::environment_variables].
        pub fn set_environment_variables<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.environment_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for BuildpacksBuild {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.SubmitBuildRequest.BuildpacksBuild"
        }
    }

    /// Location of source.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Required. Source for the build.
        StorageSource(std::boxed::Box<crate::model::StorageSource>),
    }

    /// Build type must be one of the following.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BuildType {
        /// Build the source using Buildpacks.
        BuildpackBuild(std::boxed::Box<crate::model::submit_build_request::BuildpacksBuild>),
        /// Build the source using Docker. This means the source has a Dockerfile.
        DockerBuild(std::boxed::Box<crate::model::submit_build_request::DockerBuild>),
    }
}

/// Response message for submitting a Build.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitBuildResponse {
    /// Cloud Build operation to be polled via CloudBuild API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_operation: std::option::Option<longrunning::model::Operation>,

    /// URI of the base builder image in Artifact Registry being used in the build.
    /// Used to opt into automatic base image updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_image_uri: std::string::String,

    /// Warning message for the base image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_image_warning: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitBuildResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [build_operation][crate::model::SubmitBuildResponse::build_operation].
    pub fn set_build_operation<
        T: std::convert::Into<std::option::Option<longrunning::model::Operation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_operation = v.into();
        self
    }

    /// Sets the value of [base_image_uri][crate::model::SubmitBuildResponse::base_image_uri].
    pub fn set_base_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_image_uri = v.into();
        self
    }

    /// Sets the value of [base_image_warning][crate::model::SubmitBuildResponse::base_image_warning].
    pub fn set_base_image_warning<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.base_image_warning = v.into();
        self
    }
}

impl wkt::message::Message for SubmitBuildResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SubmitBuildResponse"
    }
}

/// Location of the source in an archive file in Google Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageSource {
    /// Required. Google Cloud Storage bucket containing the source (see
    /// [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Required. Google Cloud Storage object containing the source.
    ///
    /// This object must be a gzipped archive file (`.tar.gz`) containing source to
    /// build.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub object: std::string::String,

    /// Optional. Google Cloud Storage generation for the object. If the generation
    /// is omitted, the latest generation will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::StorageSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [object][crate::model::StorageSource::object].
    pub fn set_object<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.object = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::StorageSource::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }
}

impl wkt::message::Message for StorageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.StorageSource"
    }
}

/// Defines a status condition for a resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Condition {
    /// type is used to communicate the status of the reconciliation process.
    /// See also:
    /// <https://github.com/knative/serving/blob/main/docs/spec/errors.md#error-conditions-and-reporting>
    /// Types common to all resources include:
    ///
    /// * "Ready": True when the Resource is ready.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// State of the condition.
    pub state: crate::model::condition::State,

    /// Human readable message indicating details about the current status.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Last time the condition transitioned from one status to another.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_transition_time: std::option::Option<wkt::Timestamp>,

    /// How to interpret failures of this condition, one of Error, Warning, Info
    pub severity: crate::model::condition::Severity,

    /// The reason for this condition. Depending on the condition type,
    /// it will populate one of these fields.
    /// Successful conditions cannot have a reason.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub reasons: std::option::Option<crate::model::condition::Reasons>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Condition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Condition::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Condition::state].
    pub fn set_state<T: std::convert::Into<crate::model::condition::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Condition::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [last_transition_time][crate::model::Condition::last_transition_time].
    pub fn set_last_transition_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_transition_time = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Condition::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::condition::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons].
    ///
    /// Note that all the setters affecting `reasons` are mutually
    /// exclusive.
    pub fn set_reasons<
        T: std::convert::Into<std::option::Option<crate::model::condition::Reasons>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reasons = v.into();
        self
    }

    /// The value of [reasons][crate::model::Condition::reasons]
    /// if it holds a `Reason`, `None` if the field is not set or
    /// holds a different branch.
    pub fn reason(&self) -> std::option::Option<&crate::model::condition::CommonReason> {
        #[allow(unreachable_patterns)]
        self.reasons.as_ref().and_then(|v| match v {
            crate::model::condition::Reasons::Reason(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [reasons][crate::model::Condition::reasons]
    /// if it holds a `RevisionReason`, `None` if the field is not set or
    /// holds a different branch.
    pub fn revision_reason(&self) -> std::option::Option<&crate::model::condition::RevisionReason> {
        #[allow(unreachable_patterns)]
        self.reasons.as_ref().and_then(|v| match v {
            crate::model::condition::Reasons::RevisionReason(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [reasons][crate::model::Condition::reasons]
    /// if it holds a `ExecutionReason`, `None` if the field is not set or
    /// holds a different branch.
    pub fn execution_reason(
        &self,
    ) -> std::option::Option<&crate::model::condition::ExecutionReason> {
        #[allow(unreachable_patterns)]
        self.reasons.as_ref().and_then(|v| match v {
            crate::model::condition::Reasons::ExecutionReason(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons]
    /// to hold a `Reason`.
    ///
    /// Note that all the setters affecting `reasons` are
    /// mutually exclusive.
    pub fn set_reason<T: std::convert::Into<crate::model::condition::CommonReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reasons =
            std::option::Option::Some(crate::model::condition::Reasons::Reason(v.into()));
        self
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons]
    /// to hold a `RevisionReason`.
    ///
    /// Note that all the setters affecting `reasons` are
    /// mutually exclusive.
    pub fn set_revision_reason<T: std::convert::Into<crate::model::condition::RevisionReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reasons =
            std::option::Option::Some(crate::model::condition::Reasons::RevisionReason(v.into()));
        self
    }

    /// Sets the value of [reasons][crate::model::Condition::reasons]
    /// to hold a `ExecutionReason`.
    ///
    /// Note that all the setters affecting `reasons` are
    /// mutually exclusive.
    pub fn set_execution_reason<T: std::convert::Into<crate::model::condition::ExecutionReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reasons =
            std::option::Option::Some(crate::model::condition::Reasons::ExecutionReason(v.into()));
        self
    }
}

impl wkt::message::Message for Condition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Condition"
    }
}

/// Defines additional types related to [Condition].
pub mod condition {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the possible Condition states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// Transient state: Reconciliation has not started yet.
        ConditionPending,
        /// Transient state: reconciliation is still in progress.
        ConditionReconciling,
        /// Terminal state: Reconciliation did not succeed.
        ConditionFailed,
        /// Terminal state: Reconciliation completed successfully.
        ConditionSucceeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConditionPending => std::option::Option::Some(1),
                Self::ConditionReconciling => std::option::Option::Some(2),
                Self::ConditionFailed => std::option::Option::Some(3),
                Self::ConditionSucceeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::ConditionPending => std::option::Option::Some("CONDITION_PENDING"),
                Self::ConditionReconciling => std::option::Option::Some("CONDITION_RECONCILING"),
                Self::ConditionFailed => std::option::Option::Some("CONDITION_FAILED"),
                Self::ConditionSucceeded => std::option::Option::Some("CONDITION_SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConditionPending,
                2 => Self::ConditionReconciling,
                3 => Self::ConditionFailed,
                4 => Self::ConditionSucceeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CONDITION_PENDING" => Self::ConditionPending,
                "CONDITION_RECONCILING" => Self::ConditionReconciling,
                "CONDITION_FAILED" => Self::ConditionFailed,
                "CONDITION_SUCCEEDED" => Self::ConditionSucceeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConditionPending => serializer.serialize_i32(1),
                Self::ConditionReconciling => serializer.serialize_i32(2),
                Self::ConditionFailed => serializer.serialize_i32(3),
                Self::ConditionSucceeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.run.v2.Condition.State",
            ))
        }
    }

    /// Represents the severity of the condition failures.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Unspecified severity
        Unspecified,
        /// Error severity.
        Error,
        /// Warning severity.
        Warning,
        /// Info severity.
        Info,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Error => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Info => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Error,
                2 => Self::Warning,
                3 => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "ERROR" => Self::Error,
                "WARNING" => Self::Warning,
                "INFO" => Self::Info,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Error => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Info => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.run.v2.Condition.Severity",
            ))
        }
    }

    /// Reasons common to all types of conditions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CommonReason {
        /// Default value.
        Undefined,
        /// Reason unknown. Further details will be in message.
        Unknown,
        /// Revision creation process failed.
        RevisionFailed,
        /// Timed out waiting for completion.
        ProgressDeadlineExceeded,
        /// The container image path is incorrect.
        ContainerMissing,
        /// Insufficient permissions on the container image.
        ContainerPermissionDenied,
        /// Container image is not authorized by policy.
        ContainerImageUnauthorized,
        /// Container image policy authorization check failed.
        ContainerImageAuthorizationCheckFailed,
        /// Insufficient permissions on encryption key.
        EncryptionKeyPermissionDenied,
        /// Permission check on encryption key failed.
        EncryptionKeyCheckFailed,
        /// At least one Access check on secrets failed.
        SecretsAccessCheckFailed,
        /// Waiting for operation to complete.
        WaitingForOperation,
        /// System will retry immediately.
        ImmediateRetry,
        /// System will retry later; current attempt failed.
        PostponedRetry,
        /// An internal error occurred. Further information may be in the message.
        Internal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CommonReason::value] or
        /// [CommonReason::name].
        UnknownValue(common_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod common_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CommonReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Undefined => std::option::Option::Some(0),
                Self::Unknown => std::option::Option::Some(1),
                Self::RevisionFailed => std::option::Option::Some(3),
                Self::ProgressDeadlineExceeded => std::option::Option::Some(4),
                Self::ContainerMissing => std::option::Option::Some(6),
                Self::ContainerPermissionDenied => std::option::Option::Some(7),
                Self::ContainerImageUnauthorized => std::option::Option::Some(8),
                Self::ContainerImageAuthorizationCheckFailed => std::option::Option::Some(9),
                Self::EncryptionKeyPermissionDenied => std::option::Option::Some(10),
                Self::EncryptionKeyCheckFailed => std::option::Option::Some(11),
                Self::SecretsAccessCheckFailed => std::option::Option::Some(12),
                Self::WaitingForOperation => std::option::Option::Some(13),
                Self::ImmediateRetry => std::option::Option::Some(14),
                Self::PostponedRetry => std::option::Option::Some(15),
                Self::Internal => std::option::Option::Some(16),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Undefined => std::option::Option::Some("COMMON_REASON_UNDEFINED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::RevisionFailed => std::option::Option::Some("REVISION_FAILED"),
                Self::ProgressDeadlineExceeded => {
                    std::option::Option::Some("PROGRESS_DEADLINE_EXCEEDED")
                }
                Self::ContainerMissing => std::option::Option::Some("CONTAINER_MISSING"),
                Self::ContainerPermissionDenied => {
                    std::option::Option::Some("CONTAINER_PERMISSION_DENIED")
                }
                Self::ContainerImageUnauthorized => {
                    std::option::Option::Some("CONTAINER_IMAGE_UNAUTHORIZED")
                }
                Self::ContainerImageAuthorizationCheckFailed => {
                    std::option::Option::Some("CONTAINER_IMAGE_AUTHORIZATION_CHECK_FAILED")
                }
                Self::EncryptionKeyPermissionDenied => {
                    std::option::Option::Some("ENCRYPTION_KEY_PERMISSION_DENIED")
                }
                Self::EncryptionKeyCheckFailed => {
                    std::option::Option::Some("ENCRYPTION_KEY_CHECK_FAILED")
                }
                Self::SecretsAccessCheckFailed => {
                    std::option::Option::Some("SECRETS_ACCESS_CHECK_FAILED")
                }
                Self::WaitingForOperation => std::option::Option::Some("WAITING_FOR_OPERATION"),
                Self::ImmediateRetry => std::option::Option::Some("IMMEDIATE_RETRY"),
                Self::PostponedRetry => std::option::Option::Some("POSTPONED_RETRY"),
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CommonReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CommonReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CommonReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Undefined,
                1 => Self::Unknown,
                3 => Self::RevisionFailed,
                4 => Self::ProgressDeadlineExceeded,
                6 => Self::ContainerMissing,
                7 => Self::ContainerPermissionDenied,
                8 => Self::ContainerImageUnauthorized,
                9 => Self::ContainerImageAuthorizationCheckFailed,
                10 => Self::EncryptionKeyPermissionDenied,
                11 => Self::EncryptionKeyCheckFailed,
                12 => Self::SecretsAccessCheckFailed,
                13 => Self::WaitingForOperation,
                14 => Self::ImmediateRetry,
                15 => Self::PostponedRetry,
                16 => Self::Internal,
                _ => Self::UnknownValue(common_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CommonReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMMON_REASON_UNDEFINED" => Self::Undefined,
                "UNKNOWN" => Self::Unknown,
                "REVISION_FAILED" => Self::RevisionFailed,
                "PROGRESS_DEADLINE_EXCEEDED" => Self::ProgressDeadlineExceeded,
                "CONTAINER_MISSING" => Self::ContainerMissing,
                "CONTAINER_PERMISSION_DENIED" => Self::ContainerPermissionDenied,
                "CONTAINER_IMAGE_UNAUTHORIZED" => Self::ContainerImageUnauthorized,
                "CONTAINER_IMAGE_AUTHORIZATION_CHECK_FAILED" => {
                    Self::ContainerImageAuthorizationCheckFailed
                }
                "ENCRYPTION_KEY_PERMISSION_DENIED" => Self::EncryptionKeyPermissionDenied,
                "ENCRYPTION_KEY_CHECK_FAILED" => Self::EncryptionKeyCheckFailed,
                "SECRETS_ACCESS_CHECK_FAILED" => Self::SecretsAccessCheckFailed,
                "WAITING_FOR_OPERATION" => Self::WaitingForOperation,
                "IMMEDIATE_RETRY" => Self::ImmediateRetry,
                "POSTPONED_RETRY" => Self::PostponedRetry,
                "INTERNAL" => Self::Internal,
                _ => Self::UnknownValue(common_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CommonReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Undefined => serializer.serialize_i32(0),
                Self::Unknown => serializer.serialize_i32(1),
                Self::RevisionFailed => serializer.serialize_i32(3),
                Self::ProgressDeadlineExceeded => serializer.serialize_i32(4),
                Self::ContainerMissing => serializer.serialize_i32(6),
                Self::ContainerPermissionDenied => serializer.serialize_i32(7),
                Self::ContainerImageUnauthorized => serializer.serialize_i32(8),
                Self::ContainerImageAuthorizationCheckFailed => serializer.serialize_i32(9),
                Self::EncryptionKeyPermissionDenied => serializer.serialize_i32(10),
                Self::EncryptionKeyCheckFailed => serializer.serialize_i32(11),
                Self::SecretsAccessCheckFailed => serializer.serialize_i32(12),
                Self::WaitingForOperation => serializer.serialize_i32(13),
                Self::ImmediateRetry => serializer.serialize_i32(14),
                Self::PostponedRetry => serializer.serialize_i32(15),
                Self::Internal => serializer.serialize_i32(16),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CommonReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommonReason>::new(
                ".google.cloud.run.v2.Condition.CommonReason",
            ))
        }
    }

    /// Reasons specific to Revision resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RevisionReason {
        /// Default value.
        Undefined,
        /// Revision in Pending state.
        Pending,
        /// Revision is in Reserve state.
        Reserve,
        /// Revision is Retired.
        Retired,
        /// Revision is being retired.
        Retiring,
        /// Revision is being recreated.
        Recreating,
        /// There was a health check error.
        HealthCheckContainerError,
        /// Health check failed due to user error from customized path of the
        /// container. System will retry.
        CustomizedPathResponsePending,
        /// A revision with min_instance_count > 0 was created and is reserved, but
        /// it was not configured to serve traffic, so it's not live. This can also
        /// happen momentarily during traffic migration.
        MinInstancesNotProvisioned,
        /// The maximum allowed number of active revisions has been reached.
        ActiveRevisionLimitReached,
        /// There was no deployment defined.
        /// This value is no longer used, but Services created in older versions of
        /// the API might contain this value.
        NoDeployment,
        /// A revision's container has no port specified since the revision is of a
        /// manually scaled service with 0 instance count
        HealthCheckSkipped,
        /// A revision with min_instance_count > 0 was created and is waiting for
        /// enough instances to begin a traffic migration.
        MinInstancesWarming,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RevisionReason::value] or
        /// [RevisionReason::name].
        UnknownValue(revision_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod revision_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RevisionReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Undefined => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Reserve => std::option::Option::Some(2),
                Self::Retired => std::option::Option::Some(3),
                Self::Retiring => std::option::Option::Some(4),
                Self::Recreating => std::option::Option::Some(5),
                Self::HealthCheckContainerError => std::option::Option::Some(6),
                Self::CustomizedPathResponsePending => std::option::Option::Some(7),
                Self::MinInstancesNotProvisioned => std::option::Option::Some(8),
                Self::ActiveRevisionLimitReached => std::option::Option::Some(9),
                Self::NoDeployment => std::option::Option::Some(10),
                Self::HealthCheckSkipped => std::option::Option::Some(11),
                Self::MinInstancesWarming => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Undefined => std::option::Option::Some("REVISION_REASON_UNDEFINED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Reserve => std::option::Option::Some("RESERVE"),
                Self::Retired => std::option::Option::Some("RETIRED"),
                Self::Retiring => std::option::Option::Some("RETIRING"),
                Self::Recreating => std::option::Option::Some("RECREATING"),
                Self::HealthCheckContainerError => {
                    std::option::Option::Some("HEALTH_CHECK_CONTAINER_ERROR")
                }
                Self::CustomizedPathResponsePending => {
                    std::option::Option::Some("CUSTOMIZED_PATH_RESPONSE_PENDING")
                }
                Self::MinInstancesNotProvisioned => {
                    std::option::Option::Some("MIN_INSTANCES_NOT_PROVISIONED")
                }
                Self::ActiveRevisionLimitReached => {
                    std::option::Option::Some("ACTIVE_REVISION_LIMIT_REACHED")
                }
                Self::NoDeployment => std::option::Option::Some("NO_DEPLOYMENT"),
                Self::HealthCheckSkipped => std::option::Option::Some("HEALTH_CHECK_SKIPPED"),
                Self::MinInstancesWarming => std::option::Option::Some("MIN_INSTANCES_WARMING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RevisionReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RevisionReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RevisionReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Undefined,
                1 => Self::Pending,
                2 => Self::Reserve,
                3 => Self::Retired,
                4 => Self::Retiring,
                5 => Self::Recreating,
                6 => Self::HealthCheckContainerError,
                7 => Self::CustomizedPathResponsePending,
                8 => Self::MinInstancesNotProvisioned,
                9 => Self::ActiveRevisionLimitReached,
                10 => Self::NoDeployment,
                11 => Self::HealthCheckSkipped,
                12 => Self::MinInstancesWarming,
                _ => Self::UnknownValue(revision_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RevisionReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REVISION_REASON_UNDEFINED" => Self::Undefined,
                "PENDING" => Self::Pending,
                "RESERVE" => Self::Reserve,
                "RETIRED" => Self::Retired,
                "RETIRING" => Self::Retiring,
                "RECREATING" => Self::Recreating,
                "HEALTH_CHECK_CONTAINER_ERROR" => Self::HealthCheckContainerError,
                "CUSTOMIZED_PATH_RESPONSE_PENDING" => Self::CustomizedPathResponsePending,
                "MIN_INSTANCES_NOT_PROVISIONED" => Self::MinInstancesNotProvisioned,
                "ACTIVE_REVISION_LIMIT_REACHED" => Self::ActiveRevisionLimitReached,
                "NO_DEPLOYMENT" => Self::NoDeployment,
                "HEALTH_CHECK_SKIPPED" => Self::HealthCheckSkipped,
                "MIN_INSTANCES_WARMING" => Self::MinInstancesWarming,
                _ => Self::UnknownValue(revision_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RevisionReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Undefined => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Reserve => serializer.serialize_i32(2),
                Self::Retired => serializer.serialize_i32(3),
                Self::Retiring => serializer.serialize_i32(4),
                Self::Recreating => serializer.serialize_i32(5),
                Self::HealthCheckContainerError => serializer.serialize_i32(6),
                Self::CustomizedPathResponsePending => serializer.serialize_i32(7),
                Self::MinInstancesNotProvisioned => serializer.serialize_i32(8),
                Self::ActiveRevisionLimitReached => serializer.serialize_i32(9),
                Self::NoDeployment => serializer.serialize_i32(10),
                Self::HealthCheckSkipped => serializer.serialize_i32(11),
                Self::MinInstancesWarming => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RevisionReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RevisionReason>::new(
                ".google.cloud.run.v2.Condition.RevisionReason",
            ))
        }
    }

    /// Reasons specific to Execution resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionReason {
        /// Default value.
        Undefined,
        /// Internal system error getting execution status. System will retry.
        JobStatusServicePollingError,
        /// A task reached its retry limit and the last attempt failed due to the
        /// user container exiting with a non-zero exit code.
        NonZeroExitCode,
        /// The execution was cancelled by users.
        Cancelled,
        /// The execution is in the process of being cancelled.
        Cancelling,
        /// The execution was deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionReason::value] or
        /// [ExecutionReason::name].
        UnknownValue(execution_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Undefined => std::option::Option::Some(0),
                Self::JobStatusServicePollingError => std::option::Option::Some(1),
                Self::NonZeroExitCode => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Deleted => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Undefined => std::option::Option::Some("EXECUTION_REASON_UNDEFINED"),
                Self::JobStatusServicePollingError => {
                    std::option::Option::Some("JOB_STATUS_SERVICE_POLLING_ERROR")
                }
                Self::NonZeroExitCode => std::option::Option::Some("NON_ZERO_EXIT_CODE"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Undefined,
                1 => Self::JobStatusServicePollingError,
                2 => Self::NonZeroExitCode,
                3 => Self::Cancelled,
                4 => Self::Cancelling,
                5 => Self::Deleted,
                _ => Self::UnknownValue(execution_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_REASON_UNDEFINED" => Self::Undefined,
                "JOB_STATUS_SERVICE_POLLING_ERROR" => Self::JobStatusServicePollingError,
                "NON_ZERO_EXIT_CODE" => Self::NonZeroExitCode,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(execution_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Undefined => serializer.serialize_i32(0),
                Self::JobStatusServicePollingError => serializer.serialize_i32(1),
                Self::NonZeroExitCode => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Deleted => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionReason>::new(
                ".google.cloud.run.v2.Condition.ExecutionReason",
            ))
        }
    }

    /// The reason for this condition. Depending on the condition type,
    /// it will populate one of these fields.
    /// Successful conditions cannot have a reason.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Reasons {
        /// Output only. A common (service-level) reason for this condition.
        Reason(crate::model::condition::CommonReason),
        /// Output only. A reason for the revision condition.
        RevisionReason(crate::model::condition::RevisionReason),
        /// Output only. A reason for the execution condition.
        ExecutionReason(crate::model::condition::ExecutionReason),
    }
}

/// Request message for obtaining a Execution by its full name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetExecutionRequest {
    /// Required. The full name of the Execution.
    /// Format:
    /// `projects/{project}/locations/{location}/jobs/{job}/executions/{execution}`,
    /// where `{project}` can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetExecutionRequest"
    }
}

/// Request message for retrieving a list of Executions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExecutionsRequest {
    /// Required. The Execution from which the Executions should be listed.
    /// To list all Executions across Jobs, use "-" instead of Job name.
    /// Format: `projects/{project}/locations/{location}/jobs/{job}`, where
    /// `{project}` can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of Executions to return in this call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token received from a previous call to ListExecutions.
    /// All other parameters must match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExecutionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExecutionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExecutionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExecutionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListExecutionsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListExecutionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListExecutionsRequest"
    }
}

/// Response message containing a list of Executions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExecutionsResponse {
    /// The resulting list of Executions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub executions: std::vec::Vec<crate::model::Execution>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListExecutions request to continue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExecutionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListExecutionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [executions][crate::model::ListExecutionsResponse::executions].
    pub fn set_executions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Execution>,
    {
        use std::iter::Iterator;
        self.executions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListExecutionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListExecutionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExecutionsResponse {
    type PageItem = crate::model::Execution;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.executions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for deleting an Execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteExecutionRequest {
    /// Required. The name of the Execution to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/jobs/{job}/executions/{execution}`,
    /// where `{project}` can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the resource.
    /// This may be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteExecutionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteExecutionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteExecutionRequest"
    }
}

/// Request message for deleting an Execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelExecutionRequest {
    /// Required. The name of the Execution to cancel.
    /// Format:
    /// `projects/{project}/locations/{location}/jobs/{job}/executions/{execution}`,
    /// where `{project}` can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// cancelling any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the resource.
    /// This may be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelExecutionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelExecutionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CancelExecutionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::CancelExecutionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for CancelExecutionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CancelExecutionRequest"
    }
}

/// Execution represents the configuration of a single execution. A execution an
/// immutable resource that references a container image which is run to
/// completion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Execution {
    /// Output only. The unique name of this Execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Execution. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Email address of the authenticated creator.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Output only. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Represents time when the execution was acknowledged by the
    /// execution controller. It is not guaranteed to be set in happens-before
    /// order across separate operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the execution started to run.
    /// It is not guaranteed to be set in happens-before order across separate
    /// operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the execution was completed. It is not
    /// guaranteed to be set in happens-before order across separate operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the deletion time. It is only
    /// populated as a response to a Delete request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted. It is only populated as a response to a Delete
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// The least stable launch stage needed to create this resource, as defined by
    /// [Google Cloud Platform Launch
    /// Stages](https://cloud.google.com/terms/launch-stages). Cloud Run supports
    /// `ALPHA`, `BETA`, and `GA`.
    ///
    /// Note that this value might not be what was used
    /// as input. For example, if ALPHA was provided as input in the parent
    /// resource, but only BETA and GA-level features are were, this field will be
    /// BETA.
    pub launch_stage: api::model::LaunchStage,

    /// Output only. The name of the parent Job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job: std::string::String,

    /// Output only. Specifies the maximum desired number of tasks the execution
    /// should run at any given time. Must be <= task_count. The actual number of
    /// tasks running in steady state will be less than this number when
    /// ((.spec.task_count - .status.successful) < .spec.parallelism), i.e. when
    /// the work left to do is less than max parallelism.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub parallelism: i32,

    /// Output only. Specifies the desired number of tasks the execution should
    /// run. Setting to 1 means that parallelism is limited to 1 and the success of
    /// that task signals the success of the execution.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub task_count: i32,

    /// Output only. The template used to create tasks for this execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::TaskTemplate>,

    /// Output only. Indicates whether the resource's reconciliation is still in
    /// progress. See comments in `Job.reconciling` for additional information on
    /// reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Output only. The Condition of this Execution, containing its readiness
    /// status, and detailed error information in case it did not reach the desired
    /// state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. The generation of this Execution. See comments in
    /// `reconciling` for additional information on reconciliation process in Cloud
    /// Run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub observed_generation: i64,

    /// Output only. The number of actively running tasks.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub running_count: i32,

    /// Output only. The number of tasks which reached phase Succeeded.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub succeeded_count: i32,

    /// Output only. The number of tasks which reached phase Failed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub failed_count: i32,

    /// Output only. The number of tasks which reached phase Cancelled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub cancelled_count: i32,

    /// Output only. The number of tasks which have retried at least once.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub retried_count: i32,

    /// Output only. URI where logs for this execution can be found in Cloud
    /// Console.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_uri: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Execution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Execution::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Execution::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::Execution::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Execution::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Execution::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Execution::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [completion_time][crate::model::Execution::completion_time].
    pub fn set_completion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Execution::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Execution::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Execution::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Execution::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [job][crate::model::Execution::job].
    pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [parallelism][crate::model::Execution::parallelism].
    pub fn set_parallelism<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.parallelism = v.into();
        self
    }

    /// Sets the value of [task_count][crate::model::Execution::task_count].
    pub fn set_task_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.task_count = v.into();
        self
    }

    /// Sets the value of [template][crate::model::Execution::template].
    pub fn set_template<T: std::convert::Into<std::option::Option<crate::model::TaskTemplate>>>(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Execution::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Execution::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [running_count][crate::model::Execution::running_count].
    pub fn set_running_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.running_count = v.into();
        self
    }

    /// Sets the value of [succeeded_count][crate::model::Execution::succeeded_count].
    pub fn set_succeeded_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.succeeded_count = v.into();
        self
    }

    /// Sets the value of [failed_count][crate::model::Execution::failed_count].
    pub fn set_failed_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failed_count = v.into();
        self
    }

    /// Sets the value of [cancelled_count][crate::model::Execution::cancelled_count].
    pub fn set_cancelled_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cancelled_count = v.into();
        self
    }

    /// Sets the value of [retried_count][crate::model::Execution::retried_count].
    pub fn set_retried_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retried_count = v.into();
        self
    }

    /// Sets the value of [log_uri][crate::model::Execution::log_uri].
    pub fn set_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Execution::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Execution::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Execution::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Execution::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Execution::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Execution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Execution"
    }
}

/// ExecutionTemplate describes the data an execution should have when created
/// from a template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutionTemplate {
    /// Unstructured key value map that can be used to organize and categorize
    /// objects.
    /// User-provided labels are shared with Google's billing system, so they can
    /// be used to filter, or break down billing charges by team, component,
    /// environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Unstructured key value map that may be set by external tools to store and
    /// arbitrary metadata. They are not queryable and should be preserved
    /// when modifying objects.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Specifies the maximum desired number of tasks the execution should run at
    /// given time. Must be <= task_count.
    /// When the job is run, if this field is 0 or unset, the maximum possible
    /// value will be used for that execution.
    /// The actual number of tasks running in steady state will be less than this
    /// number when there are fewer tasks waiting to be completed remaining,
    /// i.e. when the work left to do is less than max parallelism.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub parallelism: i32,

    /// Specifies the desired number of tasks the execution should run.
    /// Setting to 1 means that parallelism is limited to 1 and the success of
    /// that task signals the success of the execution. Defaults to 1.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub task_count: i32,

    /// Required. Describes the task(s) that will be created when executing an
    /// execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::TaskTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parallelism][crate::model::ExecutionTemplate::parallelism].
    pub fn set_parallelism<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.parallelism = v.into();
        self
    }

    /// Sets the value of [task_count][crate::model::ExecutionTemplate::task_count].
    pub fn set_task_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.task_count = v.into();
        self
    }

    /// Sets the value of [template][crate::model::ExecutionTemplate::template].
    pub fn set_template<T: std::convert::Into<std::option::Option<crate::model::TaskTemplate>>>(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ExecutionTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::ExecutionTemplate::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ExecutionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ExecutionTemplate"
    }
}

/// Request message for creating a Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateJobRequest {
    /// Required. The location and project in which this Job should be created.
    /// Format: projects/{project}/locations/{location}, where {project} can be
    /// project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Job instance to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::Job>,

    /// Required. The unique identifier for the Job. The name of the job becomes
    /// {parent}/jobs/{job_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or creating any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CreateJobRequest::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::CreateJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CreateJobRequest"
    }
}

/// Request message for obtaining a Job by its full name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The full name of the Job.
    /// Format: projects/{project}/locations/{location}/jobs/{job}, where {project}
    /// can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetJobRequest"
    }
}

/// Request message for updating a Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateJobRequest {
    /// Required. The Job to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::Job>,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or updating any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. If set to true, and if the Job does not exist, it will create a
    /// new one. Caller must have both create and update permissions for this call
    /// if this is set to true.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateJobRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.UpdateJobRequest"
    }
}

/// Request message for retrieving a list of Jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The location and project to list resources on.
    /// Format: projects/{project}/locations/{location}, where {project} can be
    /// project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of Jobs to return in this call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token received from a previous call to ListJobs.
    /// All other parameters must match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListJobsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListJobsRequest"
    }
}

/// Response message containing a list of Jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// The resulting list of Jobs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListJobs request to continue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message to delete a Job by its full name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteJobRequest {
    /// Required. The full name of the Job.
    /// Format: projects/{project}/locations/{location}/jobs/{job}, where {project}
    /// can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteJobRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteJobRequest"
    }
}

/// Request message to create a new Execution of a Job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunJobRequest {
    /// Required. The full name of the Job.
    /// Format: projects/{project}/locations/{location}/jobs/{job}, where {project}
    /// can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Overrides specification for a given execution of a job. If provided,
    /// overrides will be applied to update the execution or task spec.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub overrides: std::option::Option<crate::model::run_job_request::Overrides>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RunJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::RunJobRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [overrides][crate::model::RunJobRequest::overrides].
    pub fn set_overrides<
        T: std::convert::Into<std::option::Option<crate::model::run_job_request::Overrides>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.overrides = v.into();
        self
    }
}

impl wkt::message::Message for RunJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RunJobRequest"
    }
}

/// Defines additional types related to [RunJobRequest].
pub mod run_job_request {
    #[allow(unused_imports)]
    use super::*;

    /// RunJob Overrides that contains Execution fields to be overridden.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Overrides {
        /// Per container override specification.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub container_overrides:
            std::vec::Vec<crate::model::run_job_request::overrides::ContainerOverride>,

        /// Optional. The desired number of tasks the execution should run. Will
        /// replace existing task_count value.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub task_count: i32,

        /// Duration in seconds the task may be active before the system will
        /// actively try to mark it failed and kill associated containers. Will
        /// replace existing timeout_seconds value.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub timeout: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Overrides {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [task_count][crate::model::run_job_request::Overrides::task_count].
        pub fn set_task_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.task_count = v.into();
            self
        }

        /// Sets the value of [timeout][crate::model::run_job_request::Overrides::timeout].
        pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.timeout = v.into();
            self
        }

        /// Sets the value of [container_overrides][crate::model::run_job_request::Overrides::container_overrides].
        pub fn set_container_overrides<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::run_job_request::overrides::ContainerOverride>,
        {
            use std::iter::Iterator;
            self.container_overrides = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Overrides {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.RunJobRequest.Overrides"
        }
    }

    /// Defines additional types related to [Overrides].
    pub mod overrides {
        #[allow(unused_imports)]
        use super::*;

        /// Per-container override specification.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ContainerOverride {
            /// The name of the container specified as a DNS_LABEL.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,

            /// Optional. Arguments to the entrypoint. Will replace existing args for
            /// override.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub args: std::vec::Vec<std::string::String>,

            /// List of environment variables to set in the container. Will be merged
            /// with existing env for override.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub env: std::vec::Vec<crate::model::EnvVar>,

            /// Optional. True if the intention is to clear out existing args list.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub clear_args: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ContainerOverride {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::run_job_request::overrides::ContainerOverride::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [clear_args][crate::model::run_job_request::overrides::ContainerOverride::clear_args].
            pub fn set_clear_args<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.clear_args = v.into();
                self
            }

            /// Sets the value of [args][crate::model::run_job_request::overrides::ContainerOverride::args].
            pub fn set_args<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.args = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [env][crate::model::run_job_request::overrides::ContainerOverride::env].
            pub fn set_env<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::EnvVar>,
            {
                use std::iter::Iterator;
                self.env = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ContainerOverride {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.run.v2.RunJobRequest.Overrides.ContainerOverride"
            }
        }
    }
}

/// Job represents the configuration of a single job, which references a
/// container image that is run to completion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Job {
    /// The fully qualified name of this Job.
    ///
    /// Format:
    /// projects/{project}/locations/{location}/jobs/{job}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Execution. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Unstructured key value map that can be used to organize and categorize
    /// objects.
    /// User-provided labels are shared with Google's billing system, so they can
    /// be used to filter, or break down billing charges by team, component,
    /// environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The deletion time. It is only populated as a response to a
    /// Delete request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Email address of the authenticated creator.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// Output only. Email address of the last authenticated modifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub last_modifier: std::string::String,

    /// Arbitrary identifier for the API client.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client: std::string::String,

    /// Arbitrary version identifier for the API client.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_version: std::string::String,

    /// The launch stage as defined by [Google Cloud Platform
    /// Launch Stages](https://cloud.google.com/terms/launch-stages).
    /// Cloud Run supports `ALPHA`, `BETA`, and `GA`. If no value is specified, GA
    /// is assumed.
    /// Set the launch stage to a preview stage on input to allow use of preview
    /// features in that stage. On read (or output), describes whether the resource
    /// uses preview features.
    ///
    /// For example, if ALPHA is provided as input, but only BETA and GA-level
    /// features are used, this field will be BETA on output.
    pub launch_stage: api::model::LaunchStage,

    /// Settings for the Binary Authorization feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Required. The template used to create executions for this Job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::ExecutionTemplate>,

    /// Output only. The generation of this Job. See comments in `reconciling` for
    /// additional information on reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub observed_generation: i64,

    /// Output only. The Condition of this Job, containing its readiness status,
    /// and detailed error information in case it did not reach the desired state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub terminal_condition: std::option::Option<crate::model::Condition>,

    /// Output only. The Conditions of all other associated sub-resources. They
    /// contain additional diagnostics information in case the Job does not reach
    /// its desired state. See comments in `reconciling` for additional information
    /// on reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. Number of executions created for this job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub execution_count: i32,

    /// Output only. Name of the last created execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_created_execution: std::option::Option<crate::model::ExecutionReference>,

    /// Output only. Returns true if the Job is currently being acted upon by the
    /// system to bring it into the desired state.
    ///
    /// When a new Job is created, or an existing one is updated, Cloud Run
    /// will asynchronously perform all necessary steps to bring the Job to the
    /// desired state. This process is called reconciliation.
    /// While reconciliation is in process, `observed_generation` and
    /// `latest_succeeded_execution`, will have transient values that might
    /// mismatch the intended state: Once reconciliation is over (and this field is
    /// false), there are two possible outcomes: reconciliation succeeded and the
    /// state matches the Job, or there was an error,  and reconciliation failed.
    /// This state can be found in `terminal_condition.state`.
    ///
    /// If reconciliation succeeded, the following fields will match:
    /// `observed_generation` and `generation`, `latest_succeeded_execution` and
    /// `latest_created_execution`.
    ///
    /// If reconciliation failed, `observed_generation` and
    /// `latest_succeeded_execution` will have the state of the last succeeded
    /// execution or empty for newly created Job. Additional information on the
    /// failure can be found in `terminal_condition` and `conditions`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub create_execution: std::option::Option<crate::model::job::CreateExecution>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Job::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Job::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Job::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Job::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Job::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Job::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Job::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::Job::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [last_modifier][crate::model::Job::last_modifier].
    pub fn set_last_modifier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_modifier = v.into();
        self
    }

    /// Sets the value of [client][crate::model::Job::client].
    pub fn set_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client = v.into();
        self
    }

    /// Sets the value of [client_version][crate::model::Job::client_version].
    pub fn set_client_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_version = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Job::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [binary_authorization][crate::model::Job::binary_authorization].
    pub fn set_binary_authorization<
        T: std::convert::Into<std::option::Option<crate::model::BinaryAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.binary_authorization = v.into();
        self
    }

    /// Sets the value of [template][crate::model::Job::template].
    pub fn set_template<
        T: std::convert::Into<std::option::Option<crate::model::ExecutionTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Job::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [terminal_condition][crate::model::Job::terminal_condition].
    pub fn set_terminal_condition<
        T: std::convert::Into<std::option::Option<crate::model::Condition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.terminal_condition = v.into();
        self
    }

    /// Sets the value of [execution_count][crate::model::Job::execution_count].
    pub fn set_execution_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.execution_count = v.into();
        self
    }

    /// Sets the value of [latest_created_execution][crate::model::Job::latest_created_execution].
    pub fn set_latest_created_execution<
        T: std::convert::Into<std::option::Option<crate::model::ExecutionReference>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.latest_created_execution = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Job::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Job::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Job::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Job::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Job::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Job::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_execution][crate::model::Job::create_execution].
    ///
    /// Note that all the setters affecting `create_execution` are mutually
    /// exclusive.
    pub fn set_create_execution<
        T: std::convert::Into<std::option::Option<crate::model::job::CreateExecution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.create_execution = v.into();
        self
    }

    /// The value of [create_execution][crate::model::Job::create_execution]
    /// if it holds a `StartExecutionToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn start_execution_token(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.create_execution.as_ref().and_then(|v| match v {
            crate::model::job::CreateExecution::StartExecutionToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [create_execution][crate::model::Job::create_execution]
    /// if it holds a `RunExecutionToken`, `None` if the field is not set or
    /// holds a different branch.
    pub fn run_execution_token(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.create_execution.as_ref().and_then(|v| match v {
            crate::model::job::CreateExecution::RunExecutionToken(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [create_execution][crate::model::Job::create_execution]
    /// to hold a `StartExecutionToken`.
    ///
    /// Note that all the setters affecting `create_execution` are
    /// mutually exclusive.
    pub fn set_start_execution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_execution = std::option::Option::Some(
            crate::model::job::CreateExecution::StartExecutionToken(v.into()),
        );
        self
    }

    /// Sets the value of [create_execution][crate::model::Job::create_execution]
    /// to hold a `RunExecutionToken`.
    ///
    /// Note that all the setters affecting `create_execution` are
    /// mutually exclusive.
    pub fn set_run_execution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_execution = std::option::Option::Some(
            crate::model::job::CreateExecution::RunExecutionToken(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Job"
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum CreateExecution {
        /// A unique string used as a suffix creating a new execution. The Job will
        /// become ready when the execution is successfully started.
        /// The sum of job name and token length must be fewer than 63 characters.
        StartExecutionToken(std::string::String),
        /// A unique string used as a suffix for creating a new execution. The Job
        /// will become ready when the execution is successfully completed.
        /// The sum of job name and token length must be fewer than 63 characters.
        RunExecutionToken(std::string::String),
    }
}

/// Reference to an Execution. Use /Executions.GetExecution with the given name
/// to get full execution including the latest status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutionReference {
    /// Name of the execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Creation timestamp of the execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Creation timestamp of the execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// The deletion time of the execution. It is only
    /// populated as a response to a Delete request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Status for the execution completion.
    pub completion_status: crate::model::execution_reference::CompletionStatus,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExecutionReference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ExecutionReference::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [completion_time][crate::model::ExecutionReference::completion_time].
    pub fn set_completion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::ExecutionReference::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [completion_status][crate::model::ExecutionReference::completion_status].
    pub fn set_completion_status<
        T: std::convert::Into<crate::model::execution_reference::CompletionStatus>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completion_status = v.into();
        self
    }
}

impl wkt::message::Message for ExecutionReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ExecutionReference"
    }
}

/// Defines additional types related to [ExecutionReference].
pub mod execution_reference {
    #[allow(unused_imports)]
    use super::*;

    /// Possible execution completion status.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompletionStatus {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// Job execution has succeeded.
        ExecutionSucceeded,
        /// Job execution has failed.
        ExecutionFailed,
        /// Job execution is running normally.
        ExecutionRunning,
        /// Waiting for backing resources to be provisioned.
        ExecutionPending,
        /// Job execution has been cancelled by the user.
        ExecutionCancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompletionStatus::value] or
        /// [CompletionStatus::name].
        UnknownValue(completion_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod completion_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompletionStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ExecutionSucceeded => std::option::Option::Some(1),
                Self::ExecutionFailed => std::option::Option::Some(2),
                Self::ExecutionRunning => std::option::Option::Some(3),
                Self::ExecutionPending => std::option::Option::Some(4),
                Self::ExecutionCancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPLETION_STATUS_UNSPECIFIED"),
                Self::ExecutionSucceeded => std::option::Option::Some("EXECUTION_SUCCEEDED"),
                Self::ExecutionFailed => std::option::Option::Some("EXECUTION_FAILED"),
                Self::ExecutionRunning => std::option::Option::Some("EXECUTION_RUNNING"),
                Self::ExecutionPending => std::option::Option::Some("EXECUTION_PENDING"),
                Self::ExecutionCancelled => std::option::Option::Some("EXECUTION_CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompletionStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompletionStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompletionStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ExecutionSucceeded,
                2 => Self::ExecutionFailed,
                3 => Self::ExecutionRunning,
                4 => Self::ExecutionPending,
                5 => Self::ExecutionCancelled,
                _ => Self::UnknownValue(completion_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompletionStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPLETION_STATUS_UNSPECIFIED" => Self::Unspecified,
                "EXECUTION_SUCCEEDED" => Self::ExecutionSucceeded,
                "EXECUTION_FAILED" => Self::ExecutionFailed,
                "EXECUTION_RUNNING" => Self::ExecutionRunning,
                "EXECUTION_PENDING" => Self::ExecutionPending,
                "EXECUTION_CANCELLED" => Self::ExecutionCancelled,
                _ => Self::UnknownValue(completion_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompletionStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ExecutionSucceeded => serializer.serialize_i32(1),
                Self::ExecutionFailed => serializer.serialize_i32(2),
                Self::ExecutionRunning => serializer.serialize_i32(3),
                Self::ExecutionPending => serializer.serialize_i32(4),
                Self::ExecutionCancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompletionStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompletionStatus>::new(
                ".google.cloud.run.v2.ExecutionReference.CompletionStatus",
            ))
        }
    }
}

/// A single application container.
/// This specifies both the container to run, the command to run in the container
/// and the arguments to supply to it.
/// Note that additional arguments can be supplied by the system to the container
/// at runtime.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Container {
    /// Name of the container specified as a DNS_LABEL (RFC 1123).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Name of the container image in Dockerhub, Google Artifact
    /// Registry, or Google Container Registry. If the host is not provided,
    /// Dockerhub is assumed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image: std::string::String,

    /// Entrypoint array. Not executed within a shell.
    /// The docker image's ENTRYPOINT is used if this is not provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub command: std::vec::Vec<std::string::String>,

    /// Arguments to the entrypoint.
    /// The docker image's CMD is used if this is not provided.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// List of environment variables to set in the container.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub env: std::vec::Vec<crate::model::EnvVar>,

    /// Compute Resource requirements by this container.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resources: std::option::Option<crate::model::ResourceRequirements>,

    /// List of ports to expose from the container. Only a single port can be
    /// specified. The specified ports must be listening on all interfaces
    /// (0.0.0.0) within the container to be accessible.
    ///
    /// If omitted, a port number will be chosen and passed to the container
    /// through the PORT environment variable for the container to listen on.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ports: std::vec::Vec<crate::model::ContainerPort>,

    /// Volume to mount into the container's filesystem.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volume_mounts: std::vec::Vec<crate::model::VolumeMount>,

    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub working_dir: std::string::String,

    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub liveness_probe: std::option::Option<crate::model::Probe>,

    /// Startup probe of application within the container.
    /// All other probes are disabled if a startup probe is provided, until it
    /// succeeds. Container will not be added to service endpoints if the probe
    /// fails.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub startup_probe: std::option::Option<crate::model::Probe>,

    /// Names of the containers that must start before this container.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub depends_on: std::vec::Vec<std::string::String>,

    /// Base image for this container. Only supported for services. If set, it
    /// indicates that the service is enrolled into automatic base image update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_image_uri: std::string::String,

    /// Output only. The build info of the container image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_info: std::option::Option<crate::model::BuildInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Container {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Container::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [image][crate::model::Container::image].
    pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = v.into();
        self
    }

    /// Sets the value of [resources][crate::model::Container::resources].
    pub fn set_resources<
        T: std::convert::Into<std::option::Option<crate::model::ResourceRequirements>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resources = v.into();
        self
    }

    /// Sets the value of [working_dir][crate::model::Container::working_dir].
    pub fn set_working_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.working_dir = v.into();
        self
    }

    /// Sets the value of [liveness_probe][crate::model::Container::liveness_probe].
    pub fn set_liveness_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.liveness_probe = v.into();
        self
    }

    /// Sets the value of [startup_probe][crate::model::Container::startup_probe].
    pub fn set_startup_probe<T: std::convert::Into<std::option::Option<crate::model::Probe>>>(
        mut self,
        v: T,
    ) -> Self {
        self.startup_probe = v.into();
        self
    }

    /// Sets the value of [base_image_uri][crate::model::Container::base_image_uri].
    pub fn set_base_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_image_uri = v.into();
        self
    }

    /// Sets the value of [build_info][crate::model::Container::build_info].
    pub fn set_build_info<T: std::convert::Into<std::option::Option<crate::model::BuildInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.build_info = v.into();
        self
    }

    /// Sets the value of [command][crate::model::Container::command].
    pub fn set_command<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.command = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [args][crate::model::Container::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [env][crate::model::Container::env].
    pub fn set_env<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EnvVar>,
    {
        use std::iter::Iterator;
        self.env = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ports][crate::model::Container::ports].
    pub fn set_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContainerPort>,
    {
        use std::iter::Iterator;
        self.ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volume_mounts][crate::model::Container::volume_mounts].
    pub fn set_volume_mounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeMount>,
    {
        use std::iter::Iterator;
        self.volume_mounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [depends_on][crate::model::Container::depends_on].
    pub fn set_depends_on<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.depends_on = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Container {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Container"
    }
}

/// ResourceRequirements describes the compute resource requirements.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceRequirements {
    /// Only `memory` and `cpu` keys in the map are supported.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub limits: std::collections::HashMap<std::string::String, std::string::String>,

    /// Determines whether CPU is only allocated during requests (true by default).
    /// However, if ResourceRequirements is set, the caller must explicitly
    /// set this field to true to preserve the default behavior.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub cpu_idle: bool,

    /// Determines whether CPU should be boosted on startup of a new container
    /// instance above the requested CPU threshold, this can help reduce cold-start
    /// latency.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub startup_cpu_boost: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceRequirements {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_idle][crate::model::ResourceRequirements::cpu_idle].
    pub fn set_cpu_idle<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cpu_idle = v.into();
        self
    }

    /// Sets the value of [startup_cpu_boost][crate::model::ResourceRequirements::startup_cpu_boost].
    pub fn set_startup_cpu_boost<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.startup_cpu_boost = v.into();
        self
    }

    /// Sets the value of [limits][crate::model::ResourceRequirements::limits].
    pub fn set_limits<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.limits = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceRequirements {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ResourceRequirements"
    }
}

/// EnvVar represents an environment variable present in a Container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnvVar {
    /// Required. Name of the environment variable. Must not exceed 32768
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub values: std::option::Option<crate::model::env_var::Values>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvVar {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnvVar::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [values][crate::model::EnvVar::values].
    ///
    /// Note that all the setters affecting `values` are mutually
    /// exclusive.
    pub fn set_values<T: std::convert::Into<std::option::Option<crate::model::env_var::Values>>>(
        mut self,
        v: T,
    ) -> Self {
        self.values = v.into();
        self
    }

    /// The value of [values][crate::model::EnvVar::values]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.values.as_ref().and_then(|v| match v {
            crate::model::env_var::Values::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [values][crate::model::EnvVar::values]
    /// if it holds a `ValueSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EnvVarSource>> {
        #[allow(unreachable_patterns)]
        self.values.as_ref().and_then(|v| match v {
            crate::model::env_var::Values::ValueSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [values][crate::model::EnvVar::values]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `values` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.values = std::option::Option::Some(crate::model::env_var::Values::Value(v.into()));
        self
    }

    /// Sets the value of [values][crate::model::EnvVar::values]
    /// to hold a `ValueSource`.
    ///
    /// Note that all the setters affecting `values` are
    /// mutually exclusive.
    pub fn set_value_source<T: std::convert::Into<std::boxed::Box<crate::model::EnvVarSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.values =
            std::option::Option::Some(crate::model::env_var::Values::ValueSource(v.into()));
        self
    }
}

impl wkt::message::Message for EnvVar {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.EnvVar"
    }
}

/// Defines additional types related to [EnvVar].
pub mod env_var {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Values {
        /// Literal value of the environment variable.
        /// Defaults to "", and the maximum length is 32768 bytes.
        /// Variable references are not supported in Cloud Run.
        Value(std::string::String),
        /// Source for the environment variable's value.
        ValueSource(std::boxed::Box<crate::model::EnvVarSource>),
    }
}

/// EnvVarSource represents a source for the value of an EnvVar.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnvVarSource {
    /// Selects a secret and a specific version from Cloud Secret Manager.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secret_key_ref: std::option::Option<crate::model::SecretKeySelector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvVarSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret_key_ref][crate::model::EnvVarSource::secret_key_ref].
    pub fn set_secret_key_ref<
        T: std::convert::Into<std::option::Option<crate::model::SecretKeySelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secret_key_ref = v.into();
        self
    }
}

impl wkt::message::Message for EnvVarSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.EnvVarSource"
    }
}

/// SecretEnvVarSource represents a source for the value of an EnvVar.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretKeySelector {
    /// Required. The name of the secret in Cloud Secret Manager.
    /// Format: {secret_name} if the secret is in the same project.
    /// projects/{project}/secrets/{secret_name} if the secret is
    /// in a different project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret: std::string::String,

    /// The Cloud Secret Manager secret version.
    /// Can be 'latest' for the latest version, an integer for a specific version,
    /// or a version alias.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretKeySelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret][crate::model::SecretKeySelector::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::SecretKeySelector::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for SecretKeySelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SecretKeySelector"
    }
}

/// ContainerPort represents a network port in a single container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerPort {
    /// If specified, used to specify which protocol to use.
    /// Allowed values are "http1" and "h2c".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Port number the container listens on.
    /// This must be a valid TCP port number, 0 < container_port < 65536.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub container_port: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerPort {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ContainerPort::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [container_port][crate::model::ContainerPort::container_port].
    pub fn set_container_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.container_port = v.into();
        self
    }
}

impl wkt::message::Message for ContainerPort {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ContainerPort"
    }
}

/// VolumeMount describes a mounting of a Volume within a container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VolumeMount {
    /// Required. This must match the Name of a Volume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Path within the container at which the volume should be mounted.
    /// Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must
    /// otherwise be `/cloudsql`. All instances defined in the Volume will be
    /// available as `/cloudsql/[instance]`. For more information on Cloud SQL
    /// volumes, visit <https://cloud.google.com/sql/docs/mysql/connect-run>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mount_path: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeMount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeMount::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mount_path][crate::model::VolumeMount::mount_path].
    pub fn set_mount_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mount_path = v.into();
        self
    }
}

impl wkt::message::Message for VolumeMount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.VolumeMount"
    }
}

/// Volume represents a named volume in a container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Volume {
    /// Required. Volume's name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub volume_type: std::option::Option<crate::model::volume::VolumeType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Volume {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Volume::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type].
    ///
    /// Note that all the setters affecting `volume_type` are mutually
    /// exclusive.
    pub fn set_volume_type<
        T: std::convert::Into<std::option::Option<crate::model::volume::VolumeType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type = v.into();
        self
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `Secret`, `None` if the field is not set or
    /// holds a different branch.
    pub fn secret(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecretVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::Secret(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `CloudSqlInstance`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_instance(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlInstance>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::CloudSqlInstance(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `EmptyDir`, `None` if the field is not set or
    /// holds a different branch.
    pub fn empty_dir(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EmptyDirVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::EmptyDir(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `Nfs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn nfs(&self) -> std::option::Option<&std::boxed::Box<crate::model::NFSVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::Nfs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [volume_type][crate::model::Volume::volume_type]
    /// if it holds a `Gcs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs(&self) -> std::option::Option<&std::boxed::Box<crate::model::GCSVolumeSource>> {
        #[allow(unreachable_patterns)]
        self.volume_type.as_ref().and_then(|v| match v {
            crate::model::volume::VolumeType::Gcs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `Secret`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_secret<T: std::convert::Into<std::boxed::Box<crate::model::SecretVolumeSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::Secret(v.into()));
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `CloudSqlInstance`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_cloud_sql_instance<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlInstance>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::CloudSqlInstance(v.into()));
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `EmptyDir`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_empty_dir<
        T: std::convert::Into<std::boxed::Box<crate::model::EmptyDirVolumeSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::EmptyDir(v.into()));
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `Nfs`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_nfs<T: std::convert::Into<std::boxed::Box<crate::model::NFSVolumeSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::Nfs(v.into()));
        self
    }

    /// Sets the value of [volume_type][crate::model::Volume::volume_type]
    /// to hold a `Gcs`.
    ///
    /// Note that all the setters affecting `volume_type` are
    /// mutually exclusive.
    pub fn set_gcs<T: std::convert::Into<std::boxed::Box<crate::model::GCSVolumeSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type =
            std::option::Option::Some(crate::model::volume::VolumeType::Gcs(v.into()));
        self
    }
}

impl wkt::message::Message for Volume {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Volume"
    }
}

/// Defines additional types related to [Volume].
pub mod volume {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VolumeType {
        /// Secret represents a secret that should populate this volume.
        Secret(std::boxed::Box<crate::model::SecretVolumeSource>),
        /// For Cloud SQL volumes, contains the specific instances that should be
        /// mounted. Visit <https://cloud.google.com/sql/docs/mysql/connect-run> for
        /// more information on how to connect Cloud SQL and Cloud Run.
        CloudSqlInstance(std::boxed::Box<crate::model::CloudSqlInstance>),
        /// Ephemeral storage used as a shared volume.
        EmptyDir(std::boxed::Box<crate::model::EmptyDirVolumeSource>),
        /// For NFS Voumes, contains the path to the nfs Volume
        Nfs(std::boxed::Box<crate::model::NFSVolumeSource>),
        /// Persistent storage backed by a Google Cloud Storage bucket.
        Gcs(std::boxed::Box<crate::model::GCSVolumeSource>),
    }
}

/// The secret's value will be presented as the content of a file whose
/// name is defined in the item path. If no items are defined, the name of
/// the file is the secret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretVolumeSource {
    /// Required. The name of the secret in Cloud Secret Manager.
    /// Format: {secret} if the secret is in the same project.
    /// projects/{project}/secrets/{secret} if the secret is
    /// in a different project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret: std::string::String,

    /// If unspecified, the volume will expose a file whose name is the
    /// secret, relative to VolumeMount.mount_path.
    /// If specified, the key will be used as the version to fetch from Cloud
    /// Secret Manager and the path will be the name of the file exposed in the
    /// volume. When items are defined, they must specify a path and a version.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::VersionToPath>,

    /// Integer representation of mode bits to use on created files by default.
    /// Must be a value between 0000 and 0777 (octal), defaulting to 0444.
    /// Directories within the path are not affected by  this setting.
    ///
    /// Notes
    ///
    /// * Internally, a umask of 0222 will be applied to any non-zero value.
    /// * This is an integer representation of the mode bits. So, the octal
    ///   integer value should look exactly as the chmod numeric notation with a
    ///   leading zero. Some examples: for chmod 640 (u=rw,g=r), set to 0640 (octal)
    ///   or 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or
    ///   493 (base-10).
    /// * This might be in conflict with other options that affect the
    ///   file mode, like fsGroup, and the result can be other mode bits set.
    ///
    /// This might be in conflict with other options that affect the
    /// file mode, like fsGroup, and as a result, other mode bits could be set.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub default_mode: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secret][crate::model::SecretVolumeSource::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [default_mode][crate::model::SecretVolumeSource::default_mode].
    pub fn set_default_mode<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.default_mode = v.into();
        self
    }

    /// Sets the value of [items][crate::model::SecretVolumeSource::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VersionToPath>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SecretVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.SecretVolumeSource"
    }
}

/// VersionToPath maps a specific version of a secret to a relative file to mount
/// to, relative to VolumeMount's mount_path.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VersionToPath {
    /// Required. The relative path of the secret in the container.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// The Cloud Secret Manager secret version.
    /// Can be 'latest' for the latest value, or an integer or a secret alias for a
    /// specific version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Integer octal mode bits to use on this file, must be a value between
    /// 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be
    /// used.
    ///
    /// Notes
    ///
    /// * Internally, a umask of 0222 will be applied to any non-zero value.
    /// * This is an integer representation of the mode bits. So, the octal
    ///   integer value should look exactly as the chmod numeric notation with a
    ///   leading zero. Some examples: for chmod 640 (u=rw,g=r), set to 0640 (octal)
    ///   or 416 (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or
    ///   493 (base-10).
    /// * This might be in conflict with other options that affect the
    ///   file mode, like fsGroup, and the result can be other mode bits set.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub mode: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VersionToPath {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::VersionToPath::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [version][crate::model::VersionToPath::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::VersionToPath::mode].
    pub fn set_mode<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for VersionToPath {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.VersionToPath"
    }
}

/// Represents a set of Cloud SQL instances. Each one will be available under
/// /cloudsql/[instance]. Visit
/// <https://cloud.google.com/sql/docs/mysql/connect-run> for more information on
/// how to connect Cloud SQL and Cloud Run.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlInstance {
    /// The Cloud SQL instance connection names, as can be found in
    /// <https://console.cloud.google.com/sql/instances>. Visit
    /// <https://cloud.google.com/sql/docs/mysql/connect-run> for more information on
    /// how to connect Cloud SQL and Cloud Run. Format:
    /// {project}:{location}:{instance}
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::CloudSqlInstance::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CloudSqlInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CloudSqlInstance"
    }
}

/// In memory (tmpfs) ephemeral storage.
/// It is ephemeral in the sense that when the sandbox is taken down, the data is
/// destroyed with it (it does not persist across sandbox runs).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EmptyDirVolumeSource {
    /// The medium on which the data is stored. Acceptable values today is only
    /// MEMORY or none. When none, the default will currently be backed by memory
    /// but could change over time. +optional
    pub medium: crate::model::empty_dir_volume_source::Medium,

    /// Limit on the storage usable by this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value
    /// between the SizeLimit specified here and the sum of memory limits of all
    /// containers. The default is nil which means that the limit is undefined.
    /// More info:
    /// <https://cloud.google.com/run/docs/configuring/in-memory-volumes#configure-volume>.
    /// Info in Kubernetes:
    /// <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub size_limit: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EmptyDirVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [medium][crate::model::EmptyDirVolumeSource::medium].
    pub fn set_medium<T: std::convert::Into<crate::model::empty_dir_volume_source::Medium>>(
        mut self,
        v: T,
    ) -> Self {
        self.medium = v.into();
        self
    }

    /// Sets the value of [size_limit][crate::model::EmptyDirVolumeSource::size_limit].
    pub fn set_size_limit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.size_limit = v.into();
        self
    }
}

impl wkt::message::Message for EmptyDirVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.EmptyDirVolumeSource"
    }
}

/// Defines additional types related to [EmptyDirVolumeSource].
pub mod empty_dir_volume_source {
    #[allow(unused_imports)]
    use super::*;

    /// The different types of medium supported for EmptyDir.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Medium {
        /// When not specified, falls back to the default implementation which
        /// is currently in memory (this may change over time).
        Unspecified,
        /// Explicitly set the EmptyDir to be in memory. Uses tmpfs.
        Memory,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Medium::value] or
        /// [Medium::name].
        UnknownValue(medium::UnknownValue),
    }

    #[doc(hidden)]
    pub mod medium {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Medium {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Memory => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MEDIUM_UNSPECIFIED"),
                Self::Memory => std::option::Option::Some("MEMORY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Medium {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Medium {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Medium {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Memory,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Medium {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MEDIUM_UNSPECIFIED" => Self::Unspecified,
                "MEMORY" => Self::Memory,
                _ => Self::UnknownValue(medium::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Medium {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Memory => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Medium {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Medium>::new(
                ".google.cloud.run.v2.EmptyDirVolumeSource.Medium",
            ))
        }
    }
}

/// Represents an NFS mount.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NFSVolumeSource {
    /// Hostname or IP address of the NFS server
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server: std::string::String,

    /// Path that is exported by the NFS server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// If true, the volume will be mounted as read only for all mounts.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub read_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NFSVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [server][crate::model::NFSVolumeSource::server].
    pub fn set_server<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server = v.into();
        self
    }

    /// Sets the value of [path][crate::model::NFSVolumeSource::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [read_only][crate::model::NFSVolumeSource::read_only].
    pub fn set_read_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.read_only = v.into();
        self
    }
}

impl wkt::message::Message for NFSVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.NFSVolumeSource"
    }
}

/// Represents a volume backed by a Cloud Storage bucket using Cloud Storage
/// FUSE.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GCSVolumeSource {
    /// Cloud Storage Bucket name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// If true, the volume will be mounted as read only for all mounts.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub read_only: bool,

    /// A list of additional flags to pass to the gcsfuse CLI.
    /// Options should be specified without the leading "--".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mount_options: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GCSVolumeSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::GCSVolumeSource::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [read_only][crate::model::GCSVolumeSource::read_only].
    pub fn set_read_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.read_only = v.into();
        self
    }

    /// Sets the value of [mount_options][crate::model::GCSVolumeSource::mount_options].
    pub fn set_mount_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.mount_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GCSVolumeSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GCSVolumeSource"
    }
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Probe {
    /// Optional. Number of seconds after the container has started before the
    /// probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum
    /// value for liveness probe is 3600. Maximum value for startup probe is 240.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub initial_delay_seconds: i32,

    /// Optional. Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1. Maximum value is 3600.
    /// Must be smaller than period_seconds.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub timeout_seconds: i32,

    /// Optional. How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe
    /// is 3600. Maximum value for startup probe is 240.
    /// Must be greater or equal than timeout_seconds.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub period_seconds: i32,

    /// Optional. Minimum consecutive failures for the probe to be considered
    /// failed after having succeeded. Defaults to 3. Minimum value is 1.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub failure_threshold: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub probe_type: std::option::Option<crate::model::probe::ProbeType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Probe {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_delay_seconds][crate::model::Probe::initial_delay_seconds].
    pub fn set_initial_delay_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_delay_seconds = v.into();
        self
    }

    /// Sets the value of [timeout_seconds][crate::model::Probe::timeout_seconds].
    pub fn set_timeout_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.timeout_seconds = v.into();
        self
    }

    /// Sets the value of [period_seconds][crate::model::Probe::period_seconds].
    pub fn set_period_seconds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.period_seconds = v.into();
        self
    }

    /// Sets the value of [failure_threshold][crate::model::Probe::failure_threshold].
    pub fn set_failure_threshold<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failure_threshold = v.into();
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type].
    ///
    /// Note that all the setters affecting `probe_type` are mutually
    /// exclusive.
    pub fn set_probe_type<
        T: std::convert::Into<std::option::Option<crate::model::probe::ProbeType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = v.into();
        self
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `HttpGet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn http_get(&self) -> std::option::Option<&std::boxed::Box<crate::model::HTTPGetAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::HttpGet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `TcpSocket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn tcp_socket(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TCPSocketAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::TcpSocket(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [probe_type][crate::model::Probe::probe_type]
    /// if it holds a `Grpc`, `None` if the field is not set or
    /// holds a different branch.
    pub fn grpc(&self) -> std::option::Option<&std::boxed::Box<crate::model::GRPCAction>> {
        #[allow(unreachable_patterns)]
        self.probe_type.as_ref().and_then(|v| match v {
            crate::model::probe::ProbeType::Grpc(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `HttpGet`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_http_get<T: std::convert::Into<std::boxed::Box<crate::model::HTTPGetAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::HttpGet(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `TcpSocket`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_tcp_socket<T: std::convert::Into<std::boxed::Box<crate::model::TCPSocketAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type =
            std::option::Option::Some(crate::model::probe::ProbeType::TcpSocket(v.into()));
        self
    }

    /// Sets the value of [probe_type][crate::model::Probe::probe_type]
    /// to hold a `Grpc`.
    ///
    /// Note that all the setters affecting `probe_type` are
    /// mutually exclusive.
    pub fn set_grpc<T: std::convert::Into<std::boxed::Box<crate::model::GRPCAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.probe_type = std::option::Option::Some(crate::model::probe::ProbeType::Grpc(v.into()));
        self
    }
}

impl wkt::message::Message for Probe {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Probe"
    }
}

/// Defines additional types related to [Probe].
pub mod probe {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ProbeType {
        /// Optional. HTTPGet specifies the http request to perform.
        /// Exactly one of httpGet, tcpSocket, or grpc must be specified.
        HttpGet(std::boxed::Box<crate::model::HTTPGetAction>),
        /// Optional. TCPSocket specifies an action involving a TCP port.
        /// Exactly one of httpGet, tcpSocket, or grpc must be specified.
        TcpSocket(std::boxed::Box<crate::model::TCPSocketAction>),
        /// Optional. GRPC specifies an action involving a gRPC port.
        /// Exactly one of httpGet, tcpSocket, or grpc must be specified.
        Grpc(std::boxed::Box<crate::model::GRPCAction>),
    }
}

/// HTTPGetAction describes an action based on HTTP Get requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HTTPGetAction {
    /// Optional. Path to access on the HTTP server. Defaults to '/'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Optional. Custom headers to set in the request. HTTP allows repeated
    /// headers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub http_headers: std::vec::Vec<crate::model::HTTPHeader>,

    /// Optional. Port number to access on the container. Must be in the range 1 to
    /// 65535. If not specified, defaults to the exposed port of the container,
    /// which is the value of container.ports[0].containerPort.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HTTPGetAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::HTTPGetAction::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [port][crate::model::HTTPGetAction::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [http_headers][crate::model::HTTPGetAction::http_headers].
    pub fn set_http_headers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HTTPHeader>,
    {
        use std::iter::Iterator;
        self.http_headers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for HTTPGetAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.HTTPGetAction"
    }
}

/// HTTPHeader describes a custom header to be used in HTTP probes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HTTPHeader {
    /// Required. The header field name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The header field value
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HTTPHeader {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HTTPHeader::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::HTTPHeader::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for HTTPHeader {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.HTTPHeader"
    }
}

/// TCPSocketAction describes an action based on opening a socket
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TCPSocketAction {
    /// Optional. Port number to access on the container. Must be in the range 1 to
    /// 65535. If not specified, defaults to the exposed port of the container,
    /// which is the value of container.ports[0].containerPort.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TCPSocketAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [port][crate::model::TCPSocketAction::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }
}

impl wkt::message::Message for TCPSocketAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TCPSocketAction"
    }
}

/// GRPCAction describes an action involving a GRPC port.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GRPCAction {
    /// Optional. Port number of the gRPC service. Number must be in the range 1 to
    /// 65535. If not specified, defaults to the exposed port of the container,
    /// which is the value of container.ports[0].containerPort.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    /// Optional. Service is the name of the service to place in the gRPC
    /// HealthCheckRequest (see
    /// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md> ). If this
    /// is not specified, the default behavior is defined by gRPC.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GRPCAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [port][crate::model::GRPCAction::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [service][crate::model::GRPCAction::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for GRPCAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GRPCAction"
    }
}

/// Build information of the image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildInfo {
    /// Output only. Entry point of the function when the image is a Cloud Run
    /// function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub function_target: std::string::String,

    /// Output only. Source code location of the image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [function_target][crate::model::BuildInfo::function_target].
    pub fn set_function_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function_target = v.into();
        self
    }

    /// Sets the value of [source_location][crate::model::BuildInfo::source_location].
    pub fn set_source_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_location = v.into();
        self
    }
}

impl wkt::message::Message for BuildInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.BuildInfo"
    }
}

/// Request message for obtaining a Revision by its full name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRevisionRequest {
    /// Required. The full name of the Revision.
    /// Format:
    /// projects/{project}/locations/{location}/services/{service}/revisions/{revision}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetRevisionRequest"
    }
}

/// Request message for retrieving a list of Revisions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRevisionsRequest {
    /// Required. The Service from which the Revisions should be listed.
    /// To list all Revisions across Services, use "-" instead of Service name.
    /// Format:
    /// projects/{project}/locations/{location}/services/{service}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of revisions to return in this call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token received from a previous call to ListRevisions.
    /// All other parameters must match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRevisionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRevisionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRevisionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListRevisionsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListRevisionsRequest"
    }
}

/// Response message containing a list of Revisions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRevisionsResponse {
    /// The resulting list of Revisions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub revisions: std::vec::Vec<crate::model::Revision>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListRevisions request to continue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRevisionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [revisions][crate::model::ListRevisionsResponse::revisions].
    pub fn set_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Revision>,
    {
        use std::iter::Iterator;
        self.revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListRevisionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRevisionsResponse {
    type PageItem = crate::model::Revision;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.revisions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for deleting a retired Revision.
/// Revision lifecycle is usually managed by making changes to the parent
/// Service. Only retired revisions can be deleted with this API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRevisionRequest {
    /// Required. The name of the Revision to delete.
    /// Format:
    /// projects/{project}/locations/{location}/services/{service}/revisions/{revision}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. This may be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRevisionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRevisionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteRevisionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRevisionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRevisionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteRevisionRequest"
    }
}

/// A Revision is an immutable snapshot of code and configuration.  A Revision
/// references a container image. Revisions are only created by updates to its
/// parent Service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Revision {
    /// Output only. The unique name of this Revision.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Revision. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Output only. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the deletion time. It is only
    /// populated as a response to a Delete request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted. It is only populated as a response to a Delete
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// The least stable launch stage needed to create this resource, as defined by
    /// [Google Cloud Platform Launch
    /// Stages](https://cloud.google.com/terms/launch-stages). Cloud Run supports
    /// `ALPHA`, `BETA`, and `GA`.
    ///
    /// Note that this value might not be what was used
    /// as input. For example, if ALPHA was provided as input in the parent
    /// resource, but only BETA and GA-level features are were, this field will be
    /// BETA.
    pub launch_stage: api::model::LaunchStage,

    /// Output only. The name of the parent service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    /// Scaling settings for this revision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scaling: std::option::Option<crate::model::RevisionScaling>,

    /// VPC Access configuration for this Revision. For more information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    /// Sets the maximum number of requests that each serving instance can receive.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_instance_request_concurrency: i32,

    /// Max allowed time for an instance to respond to a request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Email address of the IAM service account associated with the revision of
    /// the service. The service account represents the identity of the running
    /// revision, and determines what permissions the revision has.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Holds the single container that defines the unit of execution for this
    /// Revision.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub containers: std::vec::Vec<crate::model::Container>,

    /// A list of Volumes to make available to containers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// The execution environment being used to host this Revision.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// A reference to a customer managed encryption key (CMEK) to use to encrypt
    /// this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encryption_key: std::string::String,

    /// Enables service mesh connectivity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_mesh: std::option::Option<crate::model::ServiceMesh>,

    /// The action to take if the encryption key is revoked.
    pub encryption_key_revocation_action: crate::model::EncryptionKeyRevocationAction,

    /// If encryption_key_revocation_action is SHUTDOWN, the duration before
    /// shutting down all instances. The minimum increment is 1 hour.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_key_shutdown_duration: std::option::Option<wkt::Duration>,

    /// Output only. Indicates whether the resource's reconciliation is still in
    /// progress. See comments in `Service.reconciling` for additional information
    /// on reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Output only. The Condition of this Revision, containing its readiness
    /// status, and detailed error information in case it did not reach a serving
    /// state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. The generation of this Revision currently serving traffic. See
    /// comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub observed_generation: i64,

    /// Output only. The Google Console URI to obtain logs for the Revision.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_uri: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Enable session affinity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub session_affinity: bool,

    /// Output only. The current effective scaling settings for the revision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scaling_status: std::option::Option<crate::model::RevisionScalingStatus>,

    /// The node selector for the revision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_selector: std::option::Option<crate::model::NodeSelector>,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Revision {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Revision::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Revision::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Revision::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Revision::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Revision::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Revision::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Revision::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Revision::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Revision::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [scaling][crate::model::Revision::scaling].
    pub fn set_scaling<
        T: std::convert::Into<std::option::Option<crate::model::RevisionScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling = v.into();
        self
    }

    /// Sets the value of [vpc_access][crate::model::Revision::vpc_access].
    pub fn set_vpc_access<T: std::convert::Into<std::option::Option<crate::model::VpcAccess>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_access = v.into();
        self
    }

    /// Sets the value of [max_instance_request_concurrency][crate::model::Revision::max_instance_request_concurrency].
    pub fn set_max_instance_request_concurrency<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_instance_request_concurrency = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::Revision::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Revision::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::Revision::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::Revision::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [service_mesh][crate::model::Revision::service_mesh].
    pub fn set_service_mesh<
        T: std::convert::Into<std::option::Option<crate::model::ServiceMesh>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_mesh = v.into();
        self
    }

    /// Sets the value of [encryption_key_revocation_action][crate::model::Revision::encryption_key_revocation_action].
    pub fn set_encryption_key_revocation_action<
        T: std::convert::Into<crate::model::EncryptionKeyRevocationAction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_revocation_action = v.into();
        self
    }

    /// Sets the value of [encryption_key_shutdown_duration][crate::model::Revision::encryption_key_shutdown_duration].
    pub fn set_encryption_key_shutdown_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_shutdown_duration = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Revision::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Revision::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [log_uri][crate::model::Revision::log_uri].
    pub fn set_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Revision::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [session_affinity][crate::model::Revision::session_affinity].
    pub fn set_session_affinity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.session_affinity = v.into();
        self
    }

    /// Sets the value of [scaling_status][crate::model::Revision::scaling_status].
    pub fn set_scaling_status<
        T: std::convert::Into<std::option::Option<crate::model::RevisionScalingStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling_status = v.into();
        self
    }

    /// Sets the value of [node_selector][crate::model::Revision::node_selector].
    pub fn set_node_selector<
        T: std::convert::Into<std::option::Option<crate::model::NodeSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_selector = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Revision::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::Revision::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::Revision::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::Revision::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Revision::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Revision::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Revision {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Revision"
    }
}

/// RevisionTemplate describes the data a revision should have when created from
/// a template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevisionTemplate {
    /// Optional. The unique name for the revision. If this field is omitted, it
    /// will be automatically generated based on the Service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,

    /// Optional. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Unstructured key value map that may be set by external tools to
    /// store and arbitrary metadata. They are not queryable and should be
    /// preserved when modifying objects.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Scaling settings for this Revision.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scaling: std::option::Option<crate::model::RevisionScaling>,

    /// Optional. VPC Access configuration to use for this Revision. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    /// Optional. Max allowed time for an instance to respond to a request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Optional. Email address of the IAM service account associated with the
    /// revision of the service. The service account represents the identity of the
    /// running revision, and determines what permissions the revision has. If not
    /// provided, the revision will use the project's default service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Holds the single container that defines the unit of execution for this
    /// Revision.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub containers: std::vec::Vec<crate::model::Container>,

    /// Optional. A list of Volumes to make available to containers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Optional. The sandbox environment to host this Revision.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// A reference to a customer managed encryption key (CMEK) to use to encrypt
    /// this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encryption_key: std::string::String,

    /// Optional. Sets the maximum number of requests that each serving instance
    /// can receive. If not specified or 0, concurrency defaults to 80 when
    /// requested `CPU >= 1` and defaults to 1 when requested `CPU < 1`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_instance_request_concurrency: i32,

    /// Optional. Enables service mesh connectivity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_mesh: std::option::Option<crate::model::ServiceMesh>,

    /// Optional. The action to take if the encryption key is revoked.
    pub encryption_key_revocation_action: crate::model::EncryptionKeyRevocationAction,

    /// Optional. If encryption_key_revocation_action is SHUTDOWN, the duration
    /// before shutting down all instances. The minimum increment is 1 hour.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_key_shutdown_duration: std::option::Option<wkt::Duration>,

    /// Optional. Enable session affinity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub session_affinity: bool,

    /// Optional. Disables health checking containers during deployment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub health_check_disabled: bool,

    /// Optional. The node selector for the revision template.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_selector: std::option::Option<crate::model::NodeSelector>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevisionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [revision][crate::model::RevisionTemplate::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [scaling][crate::model::RevisionTemplate::scaling].
    pub fn set_scaling<
        T: std::convert::Into<std::option::Option<crate::model::RevisionScaling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scaling = v.into();
        self
    }

    /// Sets the value of [vpc_access][crate::model::RevisionTemplate::vpc_access].
    pub fn set_vpc_access<T: std::convert::Into<std::option::Option<crate::model::VpcAccess>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_access = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::RevisionTemplate::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::RevisionTemplate::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::RevisionTemplate::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::RevisionTemplate::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [max_instance_request_concurrency][crate::model::RevisionTemplate::max_instance_request_concurrency].
    pub fn set_max_instance_request_concurrency<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_instance_request_concurrency = v.into();
        self
    }

    /// Sets the value of [service_mesh][crate::model::RevisionTemplate::service_mesh].
    pub fn set_service_mesh<
        T: std::convert::Into<std::option::Option<crate::model::ServiceMesh>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.service_mesh = v.into();
        self
    }

    /// Sets the value of [encryption_key_revocation_action][crate::model::RevisionTemplate::encryption_key_revocation_action].
    pub fn set_encryption_key_revocation_action<
        T: std::convert::Into<crate::model::EncryptionKeyRevocationAction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_revocation_action = v.into();
        self
    }

    /// Sets the value of [encryption_key_shutdown_duration][crate::model::RevisionTemplate::encryption_key_shutdown_duration].
    pub fn set_encryption_key_shutdown_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key_shutdown_duration = v.into();
        self
    }

    /// Sets the value of [session_affinity][crate::model::RevisionTemplate::session_affinity].
    pub fn set_session_affinity<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.session_affinity = v.into();
        self
    }

    /// Sets the value of [health_check_disabled][crate::model::RevisionTemplate::health_check_disabled].
    pub fn set_health_check_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.health_check_disabled = v.into();
        self
    }

    /// Sets the value of [node_selector][crate::model::RevisionTemplate::node_selector].
    pub fn set_node_selector<
        T: std::convert::Into<std::option::Option<crate::model::NodeSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_selector = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::RevisionTemplate::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::RevisionTemplate::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::RevisionTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::RevisionTemplate::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RevisionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RevisionTemplate"
    }
}

/// Request message for creating a Service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateServiceRequest {
    /// Required. The location and project in which this service should be created.
    /// Format: projects/{project}/locations/{location}, where {project} can be
    /// project id or number. Only lowercase characters, digits, and hyphens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Service instance to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    /// Required. The unique identifier for the Service. It must begin with letter,
    /// and cannot end with hyphen; must contain fewer than 50 characters.
    /// The name of the service becomes {parent}/services/{service_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_id: std::string::String,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or creating any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateServiceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<crate::model::Service>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [service_id][crate::model::CreateServiceRequest::service_id].
    pub fn set_service_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateServiceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.CreateServiceRequest"
    }
}

/// Request message for updating a service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServiceRequest {
    /// Optional. The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The Service to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::Service>,

    /// Indicates that the request should be validated and default values
    /// populated, without persisting the request or updating any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. If set to true, and if the Service does not exist, it will create
    /// a new one. The caller must have 'run.services.create' permissions if this
    /// is set to true and the Service does not exist.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateServiceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [service][crate::model::UpdateServiceRequest::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<crate::model::Service>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateServiceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateServiceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.UpdateServiceRequest"
    }
}

/// Request message for retrieving a list of Services.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Required. The location and project to list resources on.
    /// Location must be a valid Google Cloud region, and cannot be the "-"
    /// wildcard. Format: projects/{project}/locations/{location}, where {project}
    /// can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of Services to return in this call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token received from a previous call to ListServices.
    /// All other parameters must match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListServicesRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListServicesRequest"
    }
}

/// Response message containing a list of Services.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The resulting list of Services.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services: std::vec::Vec<crate::model::Service>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListServices request to continue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for obtaining a Service by its full name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Required. The full name of the Service.
    /// Format: projects/{project}/locations/{location}/services/{service}, where
    /// {project} can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetServiceRequest"
    }
}

/// Request message to delete a Service by its full name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Required. The full name of the Service.
    /// Format: projects/{project}/locations/{location}/services/{service}, where
    /// {project} can be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Indicates that the request should be validated without actually
    /// deleting any resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteServiceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteServiceRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.DeleteServiceRequest"
    }
}

/// Service acts as a top-level container that manages a set of
/// configurations and revision templates which implement a network service.
/// Service exists to provide a singular abstraction which can be access
/// controlled, reasoned about, and which encapsulates software lifecycle
/// decisions such as rollout policy and team resource ownership.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Service {
    /// The fully qualified name of this Service. In CreateServiceRequest, this
    /// field is ignored, and instead composed from CreateServiceRequest.parent and
    /// CreateServiceRequest.service_id.
    ///
    /// Format:
    /// projects/{project}/locations/{location}/services/{service_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User-provided description of the Service. This field currently has a
    /// 512-character limit.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Server assigned unique identifier for the trigger. The value
    /// is a UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    /// Please note that unlike v1, this is an int64 value. As with most Google
    /// APIs, its JSON representation will be a `string` instead of an `integer`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Optional. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Unstructured key value map that may be set by external tools to
    /// store and arbitrary metadata. They are not queryable and should be
    /// preserved when modifying objects.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The deletion time. It is only populated as a response to a
    /// Delete request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permanently deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Email address of the authenticated creator.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// Output only. Email address of the last authenticated modifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub last_modifier: std::string::String,

    /// Arbitrary identifier for the API client.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client: std::string::String,

    /// Arbitrary version identifier for the API client.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_version: std::string::String,

    /// Optional. Provides the ingress settings for this Service. On output,
    /// returns the currently observed ingress settings, or
    /// INGRESS_TRAFFIC_UNSPECIFIED if no revision is active.
    pub ingress: crate::model::IngressTraffic,

    /// Optional. The launch stage as defined by [Google Cloud Platform
    /// Launch Stages](https://cloud.google.com/terms/launch-stages).
    /// Cloud Run supports `ALPHA`, `BETA`, and `GA`. If no value is specified, GA
    /// is assumed.
    /// Set the launch stage to a preview stage on input to allow use of preview
    /// features in that stage. On read (or output), describes whether the resource
    /// uses preview features.
    ///
    /// For example, if ALPHA is provided as input, but only BETA and GA-level
    /// features are used, this field will be BETA on output.
    pub launch_stage: api::model::LaunchStage,

    /// Optional. Settings for the Binary Authorization feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Required. The template used to create revisions for this Service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::RevisionTemplate>,

    /// Optional. Specifies how to distribute traffic over a collection of
    /// Revisions belonging to the Service. If traffic is empty or not provided,
    /// defaults to 100% traffic to the latest `Ready` Revision.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub traffic: std::vec::Vec<crate::model::TrafficTarget>,

    /// Optional. Specifies service-level scaling settings
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scaling: std::option::Option<crate::model::ServiceScaling>,

    /// Optional. Disables IAM permission check for run.routes.invoke for callers
    /// of this service. This feature is available by invitation only. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/securing/managing-access#invoker_check>.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub invoker_iam_disabled: bool,

    /// Optional. Disables public resolution of the default URI of this service.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub default_uri_disabled: bool,

    /// Output only. All URLs serving traffic for this Service.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub urls: std::vec::Vec<std::string::String>,

    /// One or more custom audiences that you want this service to support. Specify
    /// each custom audience as the full URL in a string. The custom audiences are
    /// encoded in the token and used to authenticate requests. For more
    /// information, see
    /// <https://cloud.google.com/run/docs/configuring/custom-audiences>.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_audiences: std::vec::Vec<std::string::String>,

    /// Output only. The generation of this Service currently serving traffic. See
    /// comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run. Please note that unlike v1, this is an int64 value.
    /// As with most Google APIs, its JSON representation will be a `string`
    /// instead of an `integer`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub observed_generation: i64,

    /// Output only. The Condition of this Service, containing its readiness
    /// status, and detailed error information in case it did not reach a serving
    /// state. See comments in `reconciling` for additional information on
    /// reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub terminal_condition: std::option::Option<crate::model::Condition>,

    /// Output only. The Conditions of all other associated sub-resources. They
    /// contain additional diagnostics information in case the Service does not
    /// reach its Serving state. See comments in `reconciling` for additional
    /// information on reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. Name of the latest revision that is serving traffic. See
    /// comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latest_ready_revision: std::string::String,

    /// Output only. Name of the last created revision. See comments in
    /// `reconciling` for additional information on reconciliation process in Cloud
    /// Run.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latest_created_revision: std::string::String,

    /// Output only. Detailed status information for corresponding traffic targets.
    /// See comments in `reconciling` for additional information on reconciliation
    /// process in Cloud Run.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub traffic_statuses: std::vec::Vec<crate::model::TrafficTargetStatus>,

    /// Output only. The main URI in which this Service is serving traffic.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Optional. Configuration for building a Cloud Run function.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub build_config: std::option::Option<crate::model::BuildConfig>,

    /// Output only. Returns true if the Service is currently being acted upon by
    /// the system to bring it into the desired state.
    ///
    /// When a new Service is created, or an existing one is updated, Cloud Run
    /// will asynchronously perform all necessary steps to bring the Service to the
    /// desired serving state. This process is called reconciliation.
    /// While reconciliation is in process, `observed_generation`,
    /// `latest_ready_revision`, `traffic_statuses`, and `uri` will have transient
    /// values that might mismatch the intended state: Once reconciliation is over
    /// (and this field is false), there are two possible outcomes: reconciliation
    /// succeeded and the serving state matches the Service, or there was an error,
    /// and reconciliation failed. This state can be found in
    /// `terminal_condition.state`.
    ///
    /// If reconciliation succeeded, the following fields will match: `traffic` and
    /// `traffic_statuses`, `observed_generation` and `generation`,
    /// `latest_ready_revision` and `latest_created_revision`.
    ///
    /// If reconciliation failed, `traffic_statuses`, `observed_generation`, and
    /// `latest_ready_revision` will have the state of the last serving revision,
    /// or empty for newly created Services. Additional information on the failure
    /// can be found in `terminal_condition` and `conditions`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Service::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Service::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Service::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Service::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Service::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Service::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Service::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::Service::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [last_modifier][crate::model::Service::last_modifier].
    pub fn set_last_modifier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_modifier = v.into();
        self
    }

    /// Sets the value of [client][crate::model::Service::client].
    pub fn set_client<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client = v.into();
        self
    }

    /// Sets the value of [client_version][crate::model::Service::client_version].
    pub fn set_client_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_version = v.into();
        self
    }

    /// Sets the value of [ingress][crate::model::Service::ingress].
    pub fn set_ingress<T: std::convert::Into<crate::model::IngressTraffic>>(
        mut self,
        v: T,
    ) -> Self {
        self.ingress = v.into();
        self
    }

    /// Sets the value of [launch_stage][crate::model::Service::launch_stage].
    pub fn set_launch_stage<T: std::convert::Into<api::model::LaunchStage>>(
        mut self,
        v: T,
    ) -> Self {
        self.launch_stage = v.into();
        self
    }

    /// Sets the value of [binary_authorization][crate::model::Service::binary_authorization].
    pub fn set_binary_authorization<
        T: std::convert::Into<std::option::Option<crate::model::BinaryAuthorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.binary_authorization = v.into();
        self
    }

    /// Sets the value of [template][crate::model::Service::template].
    pub fn set_template<
        T: std::convert::Into<std::option::Option<crate::model::RevisionTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [scaling][crate::model::Service::scaling].
    pub fn set_scaling<T: std::convert::Into<std::option::Option<crate::model::ServiceScaling>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scaling = v.into();
        self
    }

    /// Sets the value of [invoker_iam_disabled][crate::model::Service::invoker_iam_disabled].
    pub fn set_invoker_iam_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.invoker_iam_disabled = v.into();
        self
    }

    /// Sets the value of [default_uri_disabled][crate::model::Service::default_uri_disabled].
    pub fn set_default_uri_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.default_uri_disabled = v.into();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Service::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [terminal_condition][crate::model::Service::terminal_condition].
    pub fn set_terminal_condition<
        T: std::convert::Into<std::option::Option<crate::model::Condition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.terminal_condition = v.into();
        self
    }

    /// Sets the value of [latest_ready_revision][crate::model::Service::latest_ready_revision].
    pub fn set_latest_ready_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_ready_revision = v.into();
        self
    }

    /// Sets the value of [latest_created_revision][crate::model::Service::latest_created_revision].
    pub fn set_latest_created_revision<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_created_revision = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::Service::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Service::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [build_config][crate::model::Service::build_config].
    pub fn set_build_config<
        T: std::convert::Into<std::option::Option<crate::model::BuildConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.build_config = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Service::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Service::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [traffic][crate::model::Service::traffic].
    pub fn set_traffic<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrafficTarget>,
    {
        use std::iter::Iterator;
        self.traffic = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [urls][crate::model::Service::urls].
    pub fn set_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_audiences][crate::model::Service::custom_audiences].
    pub fn set_custom_audiences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.custom_audiences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::Service::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [traffic_statuses][crate::model::Service::traffic_statuses].
    pub fn set_traffic_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TrafficTargetStatus>,
    {
        use std::iter::Iterator;
        self.traffic_statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Service::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Service::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Service"
    }
}

/// Effective settings for the current revision
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevisionScalingStatus {
    /// The current number of min instances provisioned for this revision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub desired_min_instance_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevisionScalingStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [desired_min_instance_count][crate::model::RevisionScalingStatus::desired_min_instance_count].
    pub fn set_desired_min_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.desired_min_instance_count = v.into();
        self
    }
}

impl wkt::message::Message for RevisionScalingStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RevisionScalingStatus"
    }
}

/// Request message for obtaining a Task by its full name.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTaskRequest {
    /// Required. The full name of the Task.
    /// Format:
    /// projects/{project}/locations/{location}/jobs/{job}/executions/{execution}/tasks/{task}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.GetTaskRequest"
    }
}

/// Request message for retrieving a list of Tasks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTasksRequest {
    /// Required. The Execution from which the Tasks should be listed.
    /// To list all Tasks across Executions of a Job, use "-" instead of Execution
    /// name. To list all Tasks across Jobs, use "-" instead of Job name. Format:
    /// projects/{project}/locations/{location}/jobs/{job}/executions/{execution}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of Tasks to return in this call.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token received from a previous call to ListTasks.
    /// All other parameters must match.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// If true, returns deleted (but unexpired) resources along with active ones.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListTasksRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListTasksRequest"
    }
}

/// Response message containing a list of Tasks.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTasksResponse {
    /// The resulting list of Tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tasks: std::vec::Vec<crate::model::Task>,

    /// A token indicating there are more items than page_size. Use it in the next
    /// ListTasks request to continue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tasks][crate::model::ListTasksResponse::tasks].
    pub fn set_tasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Task>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ListTasksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTasksResponse {
    type PageItem = crate::model::Task;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tasks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Task represents a single run of a container to completion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Task {
    /// Output only. The unique name of this Task.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Server assigned unique identifier for the Task. The value is a
    /// UUID4 string and guaranteed to remain unchanged until the resource is
    /// deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. A number that monotonically increases every time the user
    /// modifies the desired state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub generation: i64,

    /// Output only. Unstructured key value map that can be used to organize and
    /// categorize objects. User-provided labels are shared with Google's billing
    /// system, so they can be used to filter, or break down billing charges by
    /// team, component, environment, state, etc. For more information, visit
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels> or
    /// <https://cloud.google.com/run/docs/configuring/labels>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Unstructured key value map that may
    /// be set by external tools to store and arbitrary metadata.
    /// They are not queryable and should be preserved
    /// when modifying objects.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Represents time when the task was created by the system.
    /// It is not guaranteed to be set in happens-before order across separate
    /// operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the task was scheduled to run by the
    /// system. It is not guaranteed to be set in happens-before order across
    /// separate operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduled_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the task started to run.
    /// It is not guaranteed to be set in happens-before order across separate
    /// operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Represents time when the Task was completed. It is not
    /// guaranteed to be set in happens-before order across separate operations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last-modified time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the deletion time. It is only
    /// populated as a response to a Delete request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. For a deleted resource, the time after which it will be
    /// permamently deleted. It is only populated as a response to a Delete
    /// request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the parent Job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job: std::string::String,

    /// Output only. The name of the parent Execution.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub execution: std::string::String,

    /// Holds the single container that defines the unit of execution for this
    /// task.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub containers: std::vec::Vec<crate::model::Container>,

    /// A list of Volumes to make available to containers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Number of retries allowed per Task, before marking this Task failed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_retries: i32,

    /// Max allowed time duration the Task may be active before the system will
    /// actively try to mark it failed and kill associated containers. This applies
    /// per attempt of a task, meaning each retry can run for the full timeout.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Email address of the IAM service account associated with the Task of a
    /// Job. The service account represents the identity of the
    /// running task, and determines what permissions the task has. If
    /// not provided, the task will use the project's default service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The execution environment being used to host this Task.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// Output only. Indicates whether the resource's reconciliation is still in
    /// progress. See comments in `Job.reconciling` for additional information on
    /// reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Output only. The Condition of this Task, containing its readiness status,
    /// and detailed error information in case it did not reach the desired state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Output only. The generation of this Task. See comments in `Job.reconciling`
    /// for additional information on reconciliation process in Cloud Run.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub observed_generation: i64,

    /// Output only. Index of the Task, unique per execution, and beginning at 0.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub index: i32,

    /// Output only. The number of times this Task was retried.
    /// Tasks are retried when they fail up to the maxRetries limit.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub retried: i32,

    /// Output only. Result of the last attempt of this Task.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_attempt_result: std::option::Option<crate::model::TaskAttemptResult>,

    /// Output only. A reference to a customer managed encryption key (CMEK) to use
    /// to encrypt this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encryption_key: std::string::String,

    /// Output only. VPC Access configuration to use for this Task. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    /// Output only. URI where logs for this execution can be found in Cloud
    /// Console.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub log_uri: std::string::String,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub satisfies_pzs: bool,

    /// Output only. A system-generated fingerprint for this version of the
    /// resource. May be used to detect modification conflict during updates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Task {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Task::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Task::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [generation][crate::model::Task::generation].
    pub fn set_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.generation = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Task::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [scheduled_time][crate::model::Task::scheduled_time].
    pub fn set_scheduled_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.scheduled_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Task::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [completion_time][crate::model::Task::completion_time].
    pub fn set_completion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Task::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Task::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Task::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [job][crate::model::Task::job].
    pub fn set_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [execution][crate::model::Task::execution].
    pub fn set_execution<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.execution = v.into();
        self
    }

    /// Sets the value of [max_retries][crate::model::Task::max_retries].
    pub fn set_max_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_retries = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::Task::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Task::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::Task::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Task::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [observed_generation][crate::model::Task::observed_generation].
    pub fn set_observed_generation<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.observed_generation = v.into();
        self
    }

    /// Sets the value of [index][crate::model::Task::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [retried][crate::model::Task::retried].
    pub fn set_retried<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retried = v.into();
        self
    }

    /// Sets the value of [last_attempt_result][crate::model::Task::last_attempt_result].
    pub fn set_last_attempt_result<
        T: std::convert::Into<std::option::Option<crate::model::TaskAttemptResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_attempt_result = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::Task::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [vpc_access][crate::model::Task::vpc_access].
    pub fn set_vpc_access<T: std::convert::Into<std::option::Option<crate::model::VpcAccess>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_access = v.into();
        self
    }

    /// Sets the value of [log_uri][crate::model::Task::log_uri].
    pub fn set_log_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.log_uri = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Task::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Task::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::Task::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::Task::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::Task::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Task::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Task::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Task {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.Task"
    }
}

/// Result of a task attempt.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TaskAttemptResult {
    /// Output only. The status of this attempt.
    /// If the status code is OK, then the attempt succeeded.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,

    /// Output only. The exit code of this attempt.
    /// This may be unset if the container was unable to exit cleanly with a code
    /// due to some other failure.
    /// See status field for possible failure details.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub exit_code: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaskAttemptResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::TaskAttemptResult::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [exit_code][crate::model::TaskAttemptResult::exit_code].
    pub fn set_exit_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.exit_code = v.into();
        self
    }
}

impl wkt::message::Message for TaskAttemptResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TaskAttemptResult"
    }
}

/// TaskTemplate describes the data a task should have when created
/// from a template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TaskTemplate {
    /// Holds the single container that defines the unit of execution for this
    /// task.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub containers: std::vec::Vec<crate::model::Container>,

    /// Optional. A list of Volumes to make available to containers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub volumes: std::vec::Vec<crate::model::Volume>,

    /// Optional. Max allowed time duration the Task may be active before the
    /// system will actively try to mark it failed and kill associated containers.
    /// This applies per attempt of a task, meaning each retry can run for the full
    /// timeout. Defaults to 600 seconds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeout: std::option::Option<wkt::Duration>,

    /// Optional. Email address of the IAM service account associated with the Task
    /// of a Job. The service account represents the identity of the running task,
    /// and determines what permissions the task has. If not provided, the task
    /// will use the project's default service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. The execution environment being used to host this Task.
    pub execution_environment: crate::model::ExecutionEnvironment,

    /// A reference to a customer managed encryption key (CMEK) to use to encrypt
    /// this container image. For more information, go to
    /// <https://cloud.google.com/run/docs/securing/using-cmek>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encryption_key: std::string::String,

    /// Optional. VPC Access configuration to use for this Task. For more
    /// information, visit
    /// <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_access: std::option::Option<crate::model::VpcAccess>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub retries: std::option::Option<crate::model::task_template::Retries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TaskTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [timeout][crate::model::TaskTemplate::timeout].
    pub fn set_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timeout = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::TaskTemplate::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [execution_environment][crate::model::TaskTemplate::execution_environment].
    pub fn set_execution_environment<T: std::convert::Into<crate::model::ExecutionEnvironment>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_environment = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::TaskTemplate::encryption_key].
    pub fn set_encryption_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [vpc_access][crate::model::TaskTemplate::vpc_access].
    pub fn set_vpc_access<T: std::convert::Into<std::option::Option<crate::model::VpcAccess>>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_access = v.into();
        self
    }

    /// Sets the value of [containers][crate::model::TaskTemplate::containers].
    pub fn set_containers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Container>,
    {
        use std::iter::Iterator;
        self.containers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volumes][crate::model::TaskTemplate::volumes].
    pub fn set_volumes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Volume>,
    {
        use std::iter::Iterator;
        self.volumes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [retries][crate::model::TaskTemplate::retries].
    ///
    /// Note that all the setters affecting `retries` are mutually
    /// exclusive.
    pub fn set_retries<
        T: std::convert::Into<std::option::Option<crate::model::task_template::Retries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retries = v.into();
        self
    }

    /// The value of [retries][crate::model::TaskTemplate::retries]
    /// if it holds a `MaxRetries`, `None` if the field is not set or
    /// holds a different branch.
    pub fn max_retries(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.retries.as_ref().and_then(|v| match v {
            crate::model::task_template::Retries::MaxRetries(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [retries][crate::model::TaskTemplate::retries]
    /// to hold a `MaxRetries`.
    ///
    /// Note that all the setters affecting `retries` are
    /// mutually exclusive.
    pub fn set_max_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retries =
            std::option::Option::Some(crate::model::task_template::Retries::MaxRetries(v.into()));
        self
    }
}

impl wkt::message::Message for TaskTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TaskTemplate"
    }
}

/// Defines additional types related to [TaskTemplate].
pub mod task_template {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Retries {
        /// Number of retries allowed per Task, before marking this Task failed.
        /// Defaults to 3.
        MaxRetries(i32),
    }
}

/// Holds a single traffic routing entry for the Service. Allocations can be done
/// to a specific Revision name, or pointing to the latest Ready Revision.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrafficTarget {
    /// The allocation type for this traffic target.
    #[serde(rename = "type")]
    pub r#type: crate::model::TrafficTargetAllocationType,

    /// Revision to which to send this portion of traffic, if traffic allocation is
    /// by revision.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,

    /// Specifies percent of the traffic to this Revision.
    /// This defaults to zero if unspecified.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub percent: i32,

    /// Indicates a string to be part of the URI to exclusively reference this
    /// target.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrafficTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TrafficTarget::type].
    pub fn set_type<T: std::convert::Into<crate::model::TrafficTargetAllocationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::TrafficTarget::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [percent][crate::model::TrafficTarget::percent].
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.percent = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::TrafficTarget::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for TrafficTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TrafficTarget"
    }
}

/// Represents the observed state of a single `TrafficTarget` entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrafficTargetStatus {
    /// The allocation type for this traffic target.
    #[serde(rename = "type")]
    pub r#type: crate::model::TrafficTargetAllocationType,

    /// Revision to which this traffic is sent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision: std::string::String,

    /// Specifies percent of the traffic to this Revision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub percent: i32,

    /// Indicates the string used in the URI to exclusively reference this target.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag: std::string::String,

    /// Displays the target URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrafficTargetStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TrafficTargetStatus::type].
    pub fn set_type<T: std::convert::Into<crate::model::TrafficTargetAllocationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::TrafficTargetStatus::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }

    /// Sets the value of [percent][crate::model::TrafficTargetStatus::percent].
    pub fn set_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.percent = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::TrafficTargetStatus::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::TrafficTargetStatus::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for TrafficTargetStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.TrafficTargetStatus"
    }
}

/// VPC Access settings. For more information on sending traffic to a VPC
/// network, visit <https://cloud.google.com/run/docs/configuring/connecting-vpc>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcAccess {
    /// VPC Access connector name.
    /// Format: `projects/{project}/locations/{location}/connectors/{connector}`,
    /// where `{project}` can be project id or number.
    /// For more information on sending traffic to a VPC network via a connector,
    /// visit <https://cloud.google.com/run/docs/configuring/vpc-connectors>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connector: std::string::String,

    /// Optional. Traffic VPC egress settings. If not provided, it defaults to
    /// PRIVATE_RANGES_ONLY.
    pub egress: crate::model::vpc_access::VpcEgress,

    /// Optional. Direct VPC egress settings. Currently only single network
    /// interface is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_interfaces: std::vec::Vec<crate::model::vpc_access::NetworkInterface>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcAccess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connector][crate::model::VpcAccess::connector].
    pub fn set_connector<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connector = v.into();
        self
    }

    /// Sets the value of [egress][crate::model::VpcAccess::egress].
    pub fn set_egress<T: std::convert::Into<crate::model::vpc_access::VpcEgress>>(
        mut self,
        v: T,
    ) -> Self {
        self.egress = v.into();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::VpcAccess::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vpc_access::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VpcAccess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.VpcAccess"
    }
}

/// Defines additional types related to [VpcAccess].
pub mod vpc_access {
    #[allow(unused_imports)]
    use super::*;

    /// Direct VPC egress settings.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NetworkInterface {
        /// Optional. The VPC network that the Cloud Run resource will be able to
        /// send traffic to. At least one of network or subnetwork must be specified.
        /// If both network and subnetwork are specified, the given VPC subnetwork
        /// must belong to the given VPC network. If network is not specified, it
        /// will be looked up from the subnetwork.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network: std::string::String,

        /// Optional. The VPC subnetwork that the Cloud Run resource will get IPs
        /// from. At least one of network or subnetwork must be specified. If both
        /// network and subnetwork are specified, the given VPC subnetwork must
        /// belong to the given VPC network. If subnetwork is not specified, the
        /// subnetwork with the same name with the network will be used.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub subnetwork: std::string::String,

        /// Optional. Network tags applied to this Cloud Run resource.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub tags: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkInterface {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::vpc_access::NetworkInterface::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [subnetwork][crate::model::vpc_access::NetworkInterface::subnetwork].
        pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.subnetwork = v.into();
            self
        }

        /// Sets the value of [tags][crate::model::vpc_access::NetworkInterface::tags].
        pub fn set_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NetworkInterface {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.run.v2.VpcAccess.NetworkInterface"
        }
    }

    /// Egress options for VPC access.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VpcEgress {
        /// Unspecified
        Unspecified,
        /// All outbound traffic is routed through the VPC connector.
        AllTraffic,
        /// Only private IP ranges are routed through the VPC connector.
        PrivateRangesOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VpcEgress::value] or
        /// [VpcEgress::name].
        UnknownValue(vpc_egress::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vpc_egress {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VpcEgress {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AllTraffic => std::option::Option::Some(1),
                Self::PrivateRangesOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VPC_EGRESS_UNSPECIFIED"),
                Self::AllTraffic => std::option::Option::Some("ALL_TRAFFIC"),
                Self::PrivateRangesOnly => std::option::Option::Some("PRIVATE_RANGES_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VpcEgress {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VpcEgress {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VpcEgress {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AllTraffic,
                2 => Self::PrivateRangesOnly,
                _ => Self::UnknownValue(vpc_egress::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VpcEgress {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VPC_EGRESS_UNSPECIFIED" => Self::Unspecified,
                "ALL_TRAFFIC" => Self::AllTraffic,
                "PRIVATE_RANGES_ONLY" => Self::PrivateRangesOnly,
                _ => Self::UnknownValue(vpc_egress::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VpcEgress {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AllTraffic => serializer.serialize_i32(1),
                Self::PrivateRangesOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VpcEgress {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VpcEgress>::new(
                ".google.cloud.run.v2.VpcAccess.VpcEgress",
            ))
        }
    }
}

/// Settings for Binary Authorization feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BinaryAuthorization {
    /// Optional. If present, indicates to use Breakglass using this justification.
    /// If use_default is False, then it must be empty.
    /// For more information on breakglass, see
    /// <https://cloud.google.com/binary-authorization/docs/using-breakglass>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub breakglass_justification: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub binauthz_method: std::option::Option<crate::model::binary_authorization::BinauthzMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BinaryAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [breakglass_justification][crate::model::BinaryAuthorization::breakglass_justification].
    pub fn set_breakglass_justification<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.breakglass_justification = v.into();
        self
    }

    /// Sets the value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method].
    ///
    /// Note that all the setters affecting `binauthz_method` are mutually
    /// exclusive.
    pub fn set_binauthz_method<
        T: std::convert::Into<std::option::Option<crate::model::binary_authorization::BinauthzMethod>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.binauthz_method = v.into();
        self
    }

    /// The value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// if it holds a `UseDefault`, `None` if the field is not set or
    /// holds a different branch.
    pub fn use_default(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.binauthz_method.as_ref().and_then(|v| match v {
            crate::model::binary_authorization::BinauthzMethod::UseDefault(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// if it holds a `Policy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn policy(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.binauthz_method.as_ref().and_then(|v| match v {
            crate::model::binary_authorization::BinauthzMethod::Policy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// to hold a `UseDefault`.
    ///
    /// Note that all the setters affecting `binauthz_method` are
    /// mutually exclusive.
    pub fn set_use_default<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.binauthz_method = std::option::Option::Some(
            crate::model::binary_authorization::BinauthzMethod::UseDefault(v.into()),
        );
        self
    }

    /// Sets the value of [binauthz_method][crate::model::BinaryAuthorization::binauthz_method]
    /// to hold a `Policy`.
    ///
    /// Note that all the setters affecting `binauthz_method` are
    /// mutually exclusive.
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.binauthz_method = std::option::Option::Some(
            crate::model::binary_authorization::BinauthzMethod::Policy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BinaryAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.BinaryAuthorization"
    }
}

/// Defines additional types related to [BinaryAuthorization].
pub mod binary_authorization {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BinauthzMethod {
        /// Optional. If True, indicates to use the default project's binary
        /// authorization policy. If False, binary authorization will be disabled.
        UseDefault(bool),
        /// Optional. The path to a binary authorization policy.
        /// Format: `projects/{project}/platforms/cloudRun/{policy-name}`
        Policy(std::string::String),
    }
}

/// Settings for revision-level scaling settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevisionScaling {
    /// Optional. Minimum number of serving instances that this resource should
    /// have.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_instance_count: i32,

    /// Optional. Maximum number of serving instances that this resource should
    /// have. When unspecified, the field is set to the server default value of
    /// 100. For more information see
    /// <https://cloud.google.com/run/docs/configuring/max-instances>
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_instance_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevisionScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_instance_count][crate::model::RevisionScaling::min_instance_count].
    pub fn set_min_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instance_count = v.into();
        self
    }

    /// Sets the value of [max_instance_count][crate::model::RevisionScaling::max_instance_count].
    pub fn set_max_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instance_count = v.into();
        self
    }
}

impl wkt::message::Message for RevisionScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.RevisionScaling"
    }
}

/// Settings for Cloud Service Mesh. For more information see
/// <https://cloud.google.com/service-mesh/docs/overview>.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceMesh {
    /// The Mesh resource name. Format:
    /// `projects/{project}/locations/global/meshes/{mesh}`, where `{project}` can
    /// be project id or number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mesh: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceMesh {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mesh][crate::model::ServiceMesh::mesh].
    pub fn set_mesh<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mesh = v.into();
        self
    }
}

impl wkt::message::Message for ServiceMesh {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ServiceMesh"
    }
}

/// Scaling settings applied at the service level rather than
/// at the revision level.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceScaling {
    /// Optional. total min instances for the service. This number of instances is
    /// divided among all revisions with specified traffic based on the percent
    /// of traffic they are receiving.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_instance_count: i32,

    /// Optional. The scaling mode for the service.
    pub scaling_mode: crate::model::service_scaling::ScalingMode,

    /// Optional. total instance count for the service in manual scaling mode. This
    /// number of instances is divided among all revisions with specified traffic
    /// based on the percent of traffic they are receiving.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub manual_instance_count: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceScaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_instance_count][crate::model::ServiceScaling::min_instance_count].
    pub fn set_min_instance_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instance_count = v.into();
        self
    }

    /// Sets the value of [scaling_mode][crate::model::ServiceScaling::scaling_mode].
    pub fn set_scaling_mode<T: std::convert::Into<crate::model::service_scaling::ScalingMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.scaling_mode = v.into();
        self
    }

    /// Sets the value of [manual_instance_count][crate::model::ServiceScaling::manual_instance_count].
    pub fn set_manual_instance_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.manual_instance_count = v.into();
        self
    }
}

impl wkt::message::Message for ServiceScaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.ServiceScaling"
    }
}

/// Defines additional types related to [ServiceScaling].
pub mod service_scaling {
    #[allow(unused_imports)]
    use super::*;

    /// The scaling mode for the service. If not provided, it defaults to
    /// AUTOMATIC.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScalingMode {
        /// Unspecified.
        Unspecified,
        /// Scale based on traffic between min and max instances.
        Automatic,
        /// Scale to exactly min instances and ignore max instances.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ScalingMode::value] or
        /// [ScalingMode::name].
        UnknownValue(scaling_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scaling_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ScalingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCALING_MODE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ScalingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ScalingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ScalingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(scaling_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ScalingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCALING_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(scaling_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ScalingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ScalingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScalingMode>::new(
                ".google.cloud.run.v2.ServiceScaling.ScalingMode",
            ))
        }
    }
}

/// Hardware constraints configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeSelector {
    /// Required. GPU accelerator type to attach to an instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub accelerator: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator][crate::model::NodeSelector::accelerator].
    pub fn set_accelerator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.accelerator = v.into();
        self
    }
}

impl wkt::message::Message for NodeSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.NodeSelector"
    }
}

/// Describes the Build step of the function that builds a container from the
/// given source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BuildConfig {
    /// Output only. The Cloud Build name of the latest successful deployment of
    /// the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The Cloud Storage bucket URI where the function source code is located.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_location: std::string::String,

    /// Optional. The name of the function (as defined in source code) that will be
    /// executed. Defaults to the resource name suffix, if not specified. For
    /// backward compatibility, if function with given name is not found, then the
    /// system will try to use function named "function".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub function_target: std::string::String,

    /// Optional. Artifact Registry URI to store the built image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Optional. The base image used to build the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub base_image: std::string::String,

    /// Optional. Sets whether the function will receive automatic base image
    /// updates.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_automatic_updates: bool,

    /// Optional. Name of the Cloud Build Custom Worker Pool that should be used to
    /// build the Cloud Run function. The format of this field is
    /// `projects/{project}/locations/{region}/workerPools/{workerPool}` where
    /// `{project}` and `{region}` are the project id and region respectively where
    /// the worker pool is defined and `{workerPool}` is the short name of the
    /// worker pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub worker_pool: std::string::String,

    /// Optional. User-provided build-time environment variables for the function
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub environment_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Service account to be used for building the container. The format
    /// of this field is
    /// `projects/{projectId}/serviceAccounts/{serviceAccountEmail}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BuildConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BuildConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_location][crate::model::BuildConfig::source_location].
    pub fn set_source_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_location = v.into();
        self
    }

    /// Sets the value of [function_target][crate::model::BuildConfig::function_target].
    pub fn set_function_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function_target = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::BuildConfig::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [base_image][crate::model::BuildConfig::base_image].
    pub fn set_base_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_image = v.into();
        self
    }

    /// Sets the value of [enable_automatic_updates][crate::model::BuildConfig::enable_automatic_updates].
    pub fn set_enable_automatic_updates<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_automatic_updates = v.into();
        self
    }

    /// Sets the value of [worker_pool][crate::model::BuildConfig::worker_pool].
    pub fn set_worker_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.worker_pool = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::BuildConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [environment_variables][crate::model::BuildConfig::environment_variables].
    pub fn set_environment_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.environment_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BuildConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.run.v2.BuildConfig"
    }
}

/// The type of instance allocation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TrafficTargetAllocationType {
    /// Unspecified instance allocation type.
    Unspecified,
    /// Allocates instances to the Service's latest ready Revision.
    Latest,
    /// Allocates instances to a Revision by name.
    Revision,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TrafficTargetAllocationType::value] or
    /// [TrafficTargetAllocationType::name].
    UnknownValue(traffic_target_allocation_type::UnknownValue),
}

#[doc(hidden)]
pub mod traffic_target_allocation_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TrafficTargetAllocationType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Latest => std::option::Option::Some(1),
            Self::Revision => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("TRAFFIC_TARGET_ALLOCATION_TYPE_UNSPECIFIED")
            }
            Self::Latest => std::option::Option::Some("TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST"),
            Self::Revision => std::option::Option::Some("TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TrafficTargetAllocationType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TrafficTargetAllocationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TrafficTargetAllocationType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Latest,
            2 => Self::Revision,
            _ => Self::UnknownValue(traffic_target_allocation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TrafficTargetAllocationType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRAFFIC_TARGET_ALLOCATION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST" => Self::Latest,
            "TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION" => Self::Revision,
            _ => Self::UnknownValue(traffic_target_allocation_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TrafficTargetAllocationType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Latest => serializer.serialize_i32(1),
            Self::Revision => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TrafficTargetAllocationType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<TrafficTargetAllocationType>::new(
                ".google.cloud.run.v2.TrafficTargetAllocationType",
            ),
        )
    }
}

/// Allowed ingress traffic for the Container.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IngressTraffic {
    /// Unspecified
    Unspecified,
    /// All inbound traffic is allowed.
    All,
    /// Only internal traffic is allowed.
    InternalOnly,
    /// Both internal and Google Cloud Load Balancer traffic is allowed.
    InternalLoadBalancer,
    /// No ingress traffic is allowed.
    None,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IngressTraffic::value] or
    /// [IngressTraffic::name].
    UnknownValue(ingress_traffic::UnknownValue),
}

#[doc(hidden)]
pub mod ingress_traffic {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IngressTraffic {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::All => std::option::Option::Some(1),
            Self::InternalOnly => std::option::Option::Some(2),
            Self::InternalLoadBalancer => std::option::Option::Some(3),
            Self::None => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INGRESS_TRAFFIC_UNSPECIFIED"),
            Self::All => std::option::Option::Some("INGRESS_TRAFFIC_ALL"),
            Self::InternalOnly => std::option::Option::Some("INGRESS_TRAFFIC_INTERNAL_ONLY"),
            Self::InternalLoadBalancer => {
                std::option::Option::Some("INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER")
            }
            Self::None => std::option::Option::Some("INGRESS_TRAFFIC_NONE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IngressTraffic {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IngressTraffic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IngressTraffic {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::All,
            2 => Self::InternalOnly,
            3 => Self::InternalLoadBalancer,
            4 => Self::None,
            _ => Self::UnknownValue(ingress_traffic::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IngressTraffic {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INGRESS_TRAFFIC_UNSPECIFIED" => Self::Unspecified,
            "INGRESS_TRAFFIC_ALL" => Self::All,
            "INGRESS_TRAFFIC_INTERNAL_ONLY" => Self::InternalOnly,
            "INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER" => Self::InternalLoadBalancer,
            "INGRESS_TRAFFIC_NONE" => Self::None,
            _ => Self::UnknownValue(ingress_traffic::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IngressTraffic {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::All => serializer.serialize_i32(1),
            Self::InternalOnly => serializer.serialize_i32(2),
            Self::InternalLoadBalancer => serializer.serialize_i32(3),
            Self::None => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IngressTraffic {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IngressTraffic>::new(
            ".google.cloud.run.v2.IngressTraffic",
        ))
    }
}

/// Alternatives for execution environments.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ExecutionEnvironment {
    /// Unspecified
    Unspecified,
    /// Uses the First Generation environment.
    Gen1,
    /// Uses Second Generation environment.
    Gen2,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ExecutionEnvironment::value] or
    /// [ExecutionEnvironment::name].
    UnknownValue(execution_environment::UnknownValue),
}

#[doc(hidden)]
pub mod execution_environment {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ExecutionEnvironment {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Gen1 => std::option::Option::Some(1),
            Self::Gen2 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("EXECUTION_ENVIRONMENT_UNSPECIFIED"),
            Self::Gen1 => std::option::Option::Some("EXECUTION_ENVIRONMENT_GEN1"),
            Self::Gen2 => std::option::Option::Some("EXECUTION_ENVIRONMENT_GEN2"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ExecutionEnvironment {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ExecutionEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ExecutionEnvironment {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Gen1,
            2 => Self::Gen2,
            _ => Self::UnknownValue(execution_environment::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ExecutionEnvironment {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "EXECUTION_ENVIRONMENT_UNSPECIFIED" => Self::Unspecified,
            "EXECUTION_ENVIRONMENT_GEN1" => Self::Gen1,
            "EXECUTION_ENVIRONMENT_GEN2" => Self::Gen2,
            _ => Self::UnknownValue(execution_environment::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ExecutionEnvironment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Gen1 => serializer.serialize_i32(1),
            Self::Gen2 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ExecutionEnvironment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionEnvironment>::new(
            ".google.cloud.run.v2.ExecutionEnvironment",
        ))
    }
}

/// Specifies behavior if an encryption key used by a resource is revoked.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EncryptionKeyRevocationAction {
    /// Unspecified
    Unspecified,
    /// Prevents the creation of new instances.
    PreventNew,
    /// Shuts down existing instances, and prevents creation of new ones.
    Shutdown,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EncryptionKeyRevocationAction::value] or
    /// [EncryptionKeyRevocationAction::name].
    UnknownValue(encryption_key_revocation_action::UnknownValue),
}

#[doc(hidden)]
pub mod encryption_key_revocation_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EncryptionKeyRevocationAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PreventNew => std::option::Option::Some(1),
            Self::Shutdown => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED")
            }
            Self::PreventNew => std::option::Option::Some("PREVENT_NEW"),
            Self::Shutdown => std::option::Option::Some("SHUTDOWN"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EncryptionKeyRevocationAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EncryptionKeyRevocationAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EncryptionKeyRevocationAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PreventNew,
            2 => Self::Shutdown,
            _ => Self::UnknownValue(encryption_key_revocation_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EncryptionKeyRevocationAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED" => Self::Unspecified,
            "PREVENT_NEW" => Self::PreventNew,
            "SHUTDOWN" => Self::Shutdown,
            _ => Self::UnknownValue(encryption_key_revocation_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EncryptionKeyRevocationAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PreventNew => serializer.serialize_i32(1),
            Self::Shutdown => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EncryptionKeyRevocationAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<EncryptionKeyRevocationAction>::new(
                ".google.cloud.run.v2.EncryptionKeyRevocationAction",
            ),
        )
    }
}
