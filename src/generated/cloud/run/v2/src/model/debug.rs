// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::SubmitBuildRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SubmitBuildRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("image_uri", &self.image_uri);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("source", &self.source);
        debug_struct.field("build_type", &self.build_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::submit_build_request::DockerBuild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DockerBuild");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::submit_build_request::BuildpacksBuild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildpacksBuild");
        debug_struct.field("runtime", &self.runtime);
        debug_struct.field("function_target", &self.function_target);
        debug_struct.field("cache_image_uri", &self.cache_image_uri);
        debug_struct.field("base_image", &self.base_image);
        debug_struct.field("environment_variables", &self.environment_variables);
        debug_struct.field("enable_automatic_updates", &self.enable_automatic_updates);
        debug_struct.field("project_descriptor", &self.project_descriptor);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SubmitBuildResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SubmitBuildResponse");
        debug_struct.field("build_operation", &self.build_operation);
        debug_struct.field("base_image_uri", &self.base_image_uri);
        debug_struct.field("base_image_warning", &self.base_image_warning);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StorageSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StorageSource");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("object", &self.object);
        debug_struct.field("generation", &self.generation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Condition");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("state", &self.state);
        debug_struct.field("message", &self.message);
        debug_struct.field("last_transition_time", &self.last_transition_time);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("reasons", &self.reasons);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetExecutionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetExecutionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListExecutionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListExecutionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListExecutionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListExecutionsResponse");
        debug_struct.field("executions", &self.executions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteExecutionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteExecutionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CancelExecutionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelExecutionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Execution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Execution");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("completion_time", &self.completion_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("job", &self.job);
        debug_struct.field("parallelism", &self.parallelism);
        debug_struct.field("task_count", &self.task_count);
        debug_struct.field("template", &self.template);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("observed_generation", &self.observed_generation);
        debug_struct.field("running_count", &self.running_count);
        debug_struct.field("succeeded_count", &self.succeeded_count);
        debug_struct.field("failed_count", &self.failed_count);
        debug_struct.field("cancelled_count", &self.cancelled_count);
        debug_struct.field("retried_count", &self.retried_count);
        debug_struct.field("log_uri", &self.log_uri);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExecutionTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutionTemplate");
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("parallelism", &self.parallelism);
        debug_struct.field("task_count", &self.task_count);
        debug_struct.field("template", &self.template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceSplit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceSplit");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("percent", &self.percent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceSplitStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceSplitStatus");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("percent", &self.percent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("job", &self.job);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateJobRequest");
        debug_struct.field("job", &self.job);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsResponse");
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RunJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("overrides", &self.overrides);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::run_job_request::Overrides {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Overrides");
        debug_struct.field("container_overrides", &self.container_overrides);
        debug_struct.field("task_count", &self.task_count);
        debug_struct.field("timeout", &self.timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::run_job_request::overrides::ContainerOverride {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContainerOverride");
        debug_struct.field("name", &self.name);
        debug_struct.field("args", &self.args);
        debug_struct.field("env", &self.env);
        debug_struct.field("clear_args", &self.clear_args);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Job");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("last_modifier", &self.last_modifier);
        debug_struct.field("client", &self.client);
        debug_struct.field("client_version", &self.client_version);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("binary_authorization", &self.binary_authorization);
        debug_struct.field("template", &self.template);
        debug_struct.field("observed_generation", &self.observed_generation);
        debug_struct.field("terminal_condition", &self.terminal_condition);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("execution_count", &self.execution_count);
        debug_struct.field("latest_created_execution", &self.latest_created_execution);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("create_execution", &self.create_execution);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExecutionReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutionReference");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("completion_time", &self.completion_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("completion_status", &self.completion_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Container {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Container");
        debug_struct.field("name", &self.name);
        debug_struct.field("image", &self.image);
        debug_struct.field("command", &self.command);
        debug_struct.field("args", &self.args);
        debug_struct.field("env", &self.env);
        debug_struct.field("resources", &self.resources);
        debug_struct.field("ports", &self.ports);
        debug_struct.field("volume_mounts", &self.volume_mounts);
        debug_struct.field("working_dir", &self.working_dir);
        debug_struct.field("liveness_probe", &self.liveness_probe);
        debug_struct.field("startup_probe", &self.startup_probe);
        debug_struct.field("depends_on", &self.depends_on);
        debug_struct.field("base_image_uri", &self.base_image_uri);
        debug_struct.field("build_info", &self.build_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResourceRequirements {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceRequirements");
        debug_struct.field("limits", &self.limits);
        debug_struct.field("cpu_idle", &self.cpu_idle);
        debug_struct.field("startup_cpu_boost", &self.startup_cpu_boost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnvVar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnvVar");
        debug_struct.field("name", &self.name);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnvVarSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnvVarSource");
        debug_struct.field("secret_key_ref", &self.secret_key_ref);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretKeySelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretKeySelector");
        debug_struct.field("secret", &self.secret);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ContainerPort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContainerPort");
        debug_struct.field("name", &self.name);
        debug_struct.field("container_port", &self.container_port);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VolumeMount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VolumeMount");
        debug_struct.field("name", &self.name);
        debug_struct.field("mount_path", &self.mount_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Volume");
        debug_struct.field("name", &self.name);
        debug_struct.field("volume_type", &self.volume_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretVolumeSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretVolumeSource");
        debug_struct.field("secret", &self.secret);
        debug_struct.field("items", &self.items);
        debug_struct.field("default_mode", &self.default_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VersionToPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VersionToPath");
        debug_struct.field("path", &self.path);
        debug_struct.field("version", &self.version);
        debug_struct.field("mode", &self.mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlInstance");
        debug_struct.field("instances", &self.instances);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EmptyDirVolumeSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EmptyDirVolumeSource");
        debug_struct.field("medium", &self.medium);
        debug_struct.field("size_limit", &self.size_limit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NFSVolumeSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NFSVolumeSource");
        debug_struct.field("server", &self.server);
        debug_struct.field("path", &self.path);
        debug_struct.field("read_only", &self.read_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GCSVolumeSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GCSVolumeSource");
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("read_only", &self.read_only);
        debug_struct.field("mount_options", &self.mount_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Probe {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Probe");
        debug_struct.field("initial_delay_seconds", &self.initial_delay_seconds);
        debug_struct.field("timeout_seconds", &self.timeout_seconds);
        debug_struct.field("period_seconds", &self.period_seconds);
        debug_struct.field("failure_threshold", &self.failure_threshold);
        debug_struct.field("probe_type", &self.probe_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HTTPGetAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HTTPGetAction");
        debug_struct.field("path", &self.path);
        debug_struct.field("http_headers", &self.http_headers);
        debug_struct.field("port", &self.port);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HTTPHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HTTPHeader");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TCPSocketAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TCPSocketAction");
        debug_struct.field("port", &self.port);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GRPCAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GRPCAction");
        debug_struct.field("port", &self.port);
        debug_struct.field("service", &self.service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildInfo");
        debug_struct.field("function_target", &self.function_target);
        debug_struct.field("source_location", &self.source_location);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRevisionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRevisionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRevisionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListRevisionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRevisionsResponse");
        debug_struct.field("revisions", &self.revisions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteRevisionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteRevisionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Revision {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Revision");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("service", &self.service);
        debug_struct.field("scaling", &self.scaling);
        debug_struct.field("vpc_access", &self.vpc_access);
        debug_struct.field(
            "max_instance_request_concurrency",
            &self.max_instance_request_concurrency,
        );
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("containers", &self.containers);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("execution_environment", &self.execution_environment);
        debug_struct.field("encryption_key", &self.encryption_key);
        debug_struct.field("service_mesh", &self.service_mesh);
        debug_struct.field(
            "encryption_key_revocation_action",
            &self.encryption_key_revocation_action,
        );
        debug_struct.field(
            "encryption_key_shutdown_duration",
            &self.encryption_key_shutdown_duration,
        );
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("observed_generation", &self.observed_generation);
        debug_struct.field("log_uri", &self.log_uri);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("session_affinity", &self.session_affinity);
        debug_struct.field("scaling_status", &self.scaling_status);
        debug_struct.field("node_selector", &self.node_selector);
        debug_struct.field(
            "gpu_zonal_redundancy_disabled",
            &self.gpu_zonal_redundancy_disabled,
        );
        debug_struct.field("creator", &self.creator);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RevisionTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RevisionTemplate");
        debug_struct.field("revision", &self.revision);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("scaling", &self.scaling);
        debug_struct.field("vpc_access", &self.vpc_access);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("containers", &self.containers);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("execution_environment", &self.execution_environment);
        debug_struct.field("encryption_key", &self.encryption_key);
        debug_struct.field(
            "max_instance_request_concurrency",
            &self.max_instance_request_concurrency,
        );
        debug_struct.field("service_mesh", &self.service_mesh);
        debug_struct.field(
            "encryption_key_revocation_action",
            &self.encryption_key_revocation_action,
        );
        debug_struct.field(
            "encryption_key_shutdown_duration",
            &self.encryption_key_shutdown_duration,
        );
        debug_struct.field("session_affinity", &self.session_affinity);
        debug_struct.field("health_check_disabled", &self.health_check_disabled);
        debug_struct.field("node_selector", &self.node_selector);
        debug_struct.field(
            "gpu_zonal_redundancy_disabled",
            &self.gpu_zonal_redundancy_disabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateServiceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("service", &self.service);
        debug_struct.field("service_id", &self.service_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateServiceRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("service", &self.service);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListServicesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServicesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListServicesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServicesResponse");
        debug_struct.field("services", &self.services);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServiceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteServiceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Service {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Service");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("last_modifier", &self.last_modifier);
        debug_struct.field("client", &self.client);
        debug_struct.field("client_version", &self.client_version);
        debug_struct.field("ingress", &self.ingress);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("binary_authorization", &self.binary_authorization);
        debug_struct.field("template", &self.template);
        debug_struct.field("traffic", &self.traffic);
        debug_struct.field("scaling", &self.scaling);
        debug_struct.field("invoker_iam_disabled", &self.invoker_iam_disabled);
        debug_struct.field("default_uri_disabled", &self.default_uri_disabled);
        debug_struct.field("urls", &self.urls);
        debug_struct.field("custom_audiences", &self.custom_audiences);
        debug_struct.field("observed_generation", &self.observed_generation);
        debug_struct.field("terminal_condition", &self.terminal_condition);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("latest_ready_revision", &self.latest_ready_revision);
        debug_struct.field("latest_created_revision", &self.latest_created_revision);
        debug_struct.field("traffic_statuses", &self.traffic_statuses);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("build_config", &self.build_config);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RevisionScalingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RevisionScalingStatus");
        debug_struct.field(
            "desired_min_instance_count",
            &self.desired_min_instance_count,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetTaskRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTaskRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListTasksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTasksRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListTasksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTasksResponse");
        debug_struct.field("tasks", &self.tasks);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Task {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Task");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("scheduled_time", &self.scheduled_time);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("completion_time", &self.completion_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("job", &self.job);
        debug_struct.field("execution", &self.execution);
        debug_struct.field("containers", &self.containers);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("max_retries", &self.max_retries);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("execution_environment", &self.execution_environment);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("observed_generation", &self.observed_generation);
        debug_struct.field("index", &self.index);
        debug_struct.field("retried", &self.retried);
        debug_struct.field("last_attempt_result", &self.last_attempt_result);
        debug_struct.field("encryption_key", &self.encryption_key);
        debug_struct.field("vpc_access", &self.vpc_access);
        debug_struct.field("log_uri", &self.log_uri);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("node_selector", &self.node_selector);
        debug_struct.field(
            "gpu_zonal_redundancy_disabled",
            &self.gpu_zonal_redundancy_disabled,
        );
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TaskAttemptResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TaskAttemptResult");
        debug_struct.field("status", &self.status);
        debug_struct.field("exit_code", &self.exit_code);
        debug_struct.field("term_signal", &self.term_signal);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TaskTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TaskTemplate");
        debug_struct.field("containers", &self.containers);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("timeout", &self.timeout);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("execution_environment", &self.execution_environment);
        debug_struct.field("encryption_key", &self.encryption_key);
        debug_struct.field("vpc_access", &self.vpc_access);
        debug_struct.field("node_selector", &self.node_selector);
        debug_struct.field(
            "gpu_zonal_redundancy_disabled",
            &self.gpu_zonal_redundancy_disabled,
        );
        debug_struct.field("retries", &self.retries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TrafficTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrafficTarget");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("percent", &self.percent);
        debug_struct.field("tag", &self.tag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TrafficTargetStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrafficTargetStatus");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("revision", &self.revision);
        debug_struct.field("percent", &self.percent);
        debug_struct.field("tag", &self.tag);
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VpcAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcAccess");
        debug_struct.field("connector", &self.connector);
        debug_struct.field("egress", &self.egress);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::vpc_access::NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkInterface");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("tags", &self.tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BinaryAuthorization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BinaryAuthorization");
        debug_struct.field("breakglass_justification", &self.breakglass_justification);
        debug_struct.field("binauthz_method", &self.binauthz_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RevisionScaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RevisionScaling");
        debug_struct.field("min_instance_count", &self.min_instance_count);
        debug_struct.field("max_instance_count", &self.max_instance_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServiceMesh {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceMesh");
        debug_struct.field("mesh", &self.mesh);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServiceScaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceScaling");
        debug_struct.field("min_instance_count", &self.min_instance_count);
        debug_struct.field("scaling_mode", &self.scaling_mode);
        debug_struct.field("manual_instance_count", &self.manual_instance_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkerPoolScaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkerPoolScaling");
        debug_struct.field("manual_instance_count", &self.manual_instance_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeSelector");
        debug_struct.field("accelerator", &self.accelerator);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BuildConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BuildConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("source_location", &self.source_location);
        debug_struct.field("function_target", &self.function_target);
        debug_struct.field("image_uri", &self.image_uri);
        debug_struct.field("base_image", &self.base_image);
        debug_struct.field("enable_automatic_updates", &self.enable_automatic_updates);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("environment_variables", &self.environment_variables);
        debug_struct.field("service_account", &self.service_account);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateWorkerPoolRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("worker_pool_id", &self.worker_pool_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateWorkerPoolRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("worker_pool", &self.worker_pool);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("force_new_revision", &self.force_new_revision);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkerPoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkerPoolsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkerPoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkerPoolsResponse");
        debug_struct.field("worker_pools", &self.worker_pools);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetWorkerPoolRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteWorkerPoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteWorkerPoolRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkerPool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkerPool");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("generation", &self.generation);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("last_modifier", &self.last_modifier);
        debug_struct.field("client", &self.client);
        debug_struct.field("client_version", &self.client_version);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("binary_authorization", &self.binary_authorization);
        debug_struct.field("template", &self.template);
        debug_struct.field("instance_splits", &self.instance_splits);
        debug_struct.field("scaling", &self.scaling);
        debug_struct.field("observed_generation", &self.observed_generation);
        debug_struct.field("terminal_condition", &self.terminal_condition);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("latest_ready_revision", &self.latest_ready_revision);
        debug_struct.field("latest_created_revision", &self.latest_created_revision);
        debug_struct.field("instance_split_statuses", &self.instance_split_statuses);
        debug_struct.field("custom_audiences", &self.custom_audiences);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkerPoolRevisionTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkerPoolRevisionTemplate");
        debug_struct.field("revision", &self.revision);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("vpc_access", &self.vpc_access);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("containers", &self.containers);
        debug_struct.field("volumes", &self.volumes);
        debug_struct.field("encryption_key", &self.encryption_key);
        debug_struct.field("service_mesh", &self.service_mesh);
        debug_struct.field(
            "encryption_key_revocation_action",
            &self.encryption_key_revocation_action,
        );
        debug_struct.field(
            "encryption_key_shutdown_duration",
            &self.encryption_key_shutdown_duration,
        );
        debug_struct.field("node_selector", &self.node_selector);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
