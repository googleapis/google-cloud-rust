// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Details about the Access request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessApprovalRequest {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/accessApprovalRequests/{access_approval_request}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time at which approval was requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The justification for which approval is being requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_reason: std::option::Option<crate::model::AccessReason>,

    /// The requested expiration for the approval. If the request is approved,
    /// access will be granted from the time of approval until the expiration time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_expiration_time: std::option::Option<wkt::Timestamp>,
}

impl AccessApprovalRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessApprovalRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::AccessApprovalRequest::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [requested_reason][crate::model::AccessApprovalRequest::requested_reason].
    pub fn set_requested_reason<
        T: std::convert::Into<std::option::Option<crate::model::AccessReason>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_reason = v.into();
        self
    }

    /// Sets the value of [requested_expiration_time][crate::model::AccessApprovalRequest::requested_expiration_time].
    pub fn set_requested_expiration_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for AccessApprovalRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessApprovalRequest"
    }
}

/// Request for getting the access requests associated with a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of access requests to return. The service may
    /// return fewer than this value. If unspecified, at most 500 access requests
    /// will be returned.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListAccessApprovalRequests` call. Provide this to retrieve the subsequent
    /// page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListAccessApprovalRequestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAccessApprovalRequestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAccessApprovalRequestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAccessApprovalRequestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAccessApprovalRequestsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAccessApprovalRequestsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsRequest"
    }
}

/// Response message for list access requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsResponse {
    /// List of access approval requests
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub access_approval_requests: std::vec::Vec<crate::model::AccessApprovalRequest>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListAccessApprovalRequestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAccessApprovalRequestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [access_approval_requests][crate::model::ListAccessApprovalRequestsResponse::access_approval_requests].
    pub fn set_access_approval_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessApprovalRequest>,
    {
        use std::iter::Iterator;
        self.access_approval_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAccessApprovalRequestsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsResponse"
    }
}

impl gax::paginator::PageableResponse for ListAccessApprovalRequestsResponse {
    type PageItem = crate::model::AccessApprovalRequest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.access_approval_requests
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Reason for the access.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessReason {
    /// Type of access justification.
    #[serde(rename = "type")]
    pub r#type: crate::model::access_reason::Type,

    /// More detail about certain reason types. See comments for each type above.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detail: std::string::String,
}

impl AccessReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AccessReason::type].
    pub fn set_type<T: std::convert::Into<crate::model::access_reason::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::AccessReason::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for AccessReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessReason"
    }
}

/// Defines additional types related to [AccessReason].
pub mod access_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Type of access justification.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Default value for proto, shouldn't be used.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// Customer made a request or raised an issue that required the principal to
        /// access customer data. `detail` is of the form ("#####" is the issue ID):
        ///
        /// - "Feedback Report: #####"
        /// - "Case Number: #####"
        /// - "Case ID: #####"
        /// - "E-PIN Reference: #####"
        /// - "Google-#####"
        /// - "T-#####"
        pub const CUSTOMER_INITIATED_SUPPORT: Type = Type::new(1);

        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services. Often this access is used to confirm that
        /// customers are not affected by a suspected service issue or to remediate a
        /// reversible system issue.
        pub const GOOGLE_INITIATED_SERVICE: Type = Type::new(2);

        /// Google initiated service for security, fraud, abuse, or compliance
        /// purposes.
        pub const GOOGLE_INITIATED_REVIEW: Type = Type::new(3);

        /// The principal was compelled to access customer data in order to respond
        /// to a legal third party data request or process, including legal processes
        /// from customers themselves.
        pub const THIRD_PARTY_DATA_REQUEST: Type = Type::new(4);

        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services or a known outage.
        pub const GOOGLE_RESPONSE_TO_PRODUCTION_ALERT: Type = Type::new(5);

        /// Similar to 'GOOGLE_INITIATED_SERVICE' or 'GOOGLE_INITIATED_REVIEW', but
        /// with universe agnostic naming. The principal accessed customer data in
        /// order to diagnose or resolve a suspected issue in services or a known
        /// outage, or for security, fraud, abuse, or compliance review purposes.
        pub const CLOUD_INITIATED_ACCESS: Type = Type::new(6);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CUSTOMER_INITIATED_SUPPORT"),
                2 => std::borrow::Cow::Borrowed("GOOGLE_INITIATED_SERVICE"),
                3 => std::borrow::Cow::Borrowed("GOOGLE_INITIATED_REVIEW"),
                4 => std::borrow::Cow::Borrowed("THIRD_PARTY_DATA_REQUEST"),
                5 => std::borrow::Cow::Borrowed("GOOGLE_RESPONSE_TO_PRODUCTION_ALERT"),
                6 => std::borrow::Cow::Borrowed("CLOUD_INITIATED_ACCESS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "CUSTOMER_INITIATED_SUPPORT" => {
                    std::option::Option::Some(Self::CUSTOMER_INITIATED_SUPPORT)
                }
                "GOOGLE_INITIATED_SERVICE" => {
                    std::option::Option::Some(Self::GOOGLE_INITIATED_SERVICE)
                }
                "GOOGLE_INITIATED_REVIEW" => {
                    std::option::Option::Some(Self::GOOGLE_INITIATED_REVIEW)
                }
                "THIRD_PARTY_DATA_REQUEST" => {
                    std::option::Option::Some(Self::THIRD_PARTY_DATA_REQUEST)
                }
                "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT" => {
                    std::option::Option::Some(Self::GOOGLE_RESPONSE_TO_PRODUCTION_ALERT)
                }
                "CLOUD_INITIATED_ACCESS" => std::option::Option::Some(Self::CLOUD_INITIATED_ACCESS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.OperationMetadata"
    }
}

/// Contains metadata around the [Workload
/// resource](https://cloud.google.com/assured-workloads/docs/reference/rest/Shared.Types/Workload)
/// in the Assured Workloads API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Workload {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Folder id this workload is associated with
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub folder_id: i64,

    /// Output only. Time the resource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of container folder of the assured workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub folder: std::string::String,

    /// Container for workload onboarding steps.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_onboarding_state: std::option::Option<crate::model::WorkloadOnboardingState>,

    /// Indicates whether a workload is fully onboarded.
    pub is_onboarded: bool,

    /// The project id of the key management project for the workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_management_project_id: std::string::String,

    /// The Google Cloud location of the workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Partner associated with this workload.
    pub partner: crate::model::workload::Partner,
}

impl Workload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Workload::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Workload::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Workload::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [folder][crate::model::Workload::folder].
    pub fn set_folder<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.folder = v.into();
        self
    }

    /// Sets the value of [workload_onboarding_state][crate::model::Workload::workload_onboarding_state].
    pub fn set_workload_onboarding_state<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadOnboardingState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_onboarding_state = v.into();
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Workload::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }

    /// Sets the value of [key_management_project_id][crate::model::Workload::key_management_project_id].
    pub fn set_key_management_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_management_project_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Workload::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [partner][crate::model::Workload::partner].
    pub fn set_partner<T: std::convert::Into<crate::model::workload::Partner>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner = v.into();
        self
    }
}

impl wkt::message::Message for Workload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Workload"
    }
}

/// Defines additional types related to [Workload].
pub mod workload {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Assured Workloads Partners.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Partner(i32);

    impl Partner {
        /// Unknown Partner.
        pub const PARTNER_UNSPECIFIED: Partner = Partner::new(0);

        /// Enum representing S3NS (Thales) partner.
        pub const PARTNER_LOCAL_CONTROLS_BY_S3NS: Partner = Partner::new(1);

        /// Enum representing T_SYSTEM (TSI) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS: Partner = Partner::new(2);

        /// Enum representing SIA_MINSAIT (Indra) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT: Partner = Partner::new(3);

        /// Enum representing PSN (TIM) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_PSN: Partner = Partner::new(4);

        /// Enum representing CNTXT (Kingdom of Saudi Arabia) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT: Partner = Partner::new(6);

        /// Enum representing CNXT (Kingdom of Saudi Arabia) partner offering without
        /// EKM provisioning.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM: Partner = Partner::new(7);

        /// Creates a new Partner instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PARTNER_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PARTNER_LOCAL_CONTROLS_BY_S3NS"),
                2 => std::borrow::Cow::Borrowed("PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS"),
                3 => std::borrow::Cow::Borrowed("PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT"),
                4 => std::borrow::Cow::Borrowed("PARTNER_SOVEREIGN_CONTROLS_BY_PSN"),
                6 => std::borrow::Cow::Borrowed("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT"),
                7 => std::borrow::Cow::Borrowed("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PARTNER_UNSPECIFIED" => std::option::Option::Some(Self::PARTNER_UNSPECIFIED),
                "PARTNER_LOCAL_CONTROLS_BY_S3NS" => {
                    std::option::Option::Some(Self::PARTNER_LOCAL_CONTROLS_BY_S3NS)
                }
                "PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS" => {
                    std::option::Option::Some(Self::PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS)
                }
                "PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT" => {
                    std::option::Option::Some(Self::PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT)
                }
                "PARTNER_SOVEREIGN_CONTROLS_BY_PSN" => {
                    std::option::Option::Some(Self::PARTNER_SOVEREIGN_CONTROLS_BY_PSN)
                }
                "PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT" => {
                    std::option::Option::Some(Self::PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT)
                }
                "PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM" => {
                    std::option::Option::Some(Self::PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Partner {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Partner {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request to list customer workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of workloads to return. The service may return fewer
    /// than this value. If unspecified, at most 500 workloads will be returned.
    pub page_size: i32,

    /// A page token, received from a previous `ListWorkloads` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListWorkloadsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkloadsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkloadsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkloadsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkloadsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListWorkloadsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkloadsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsRequest"
    }
}

/// Response message for list customer workloads requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsResponse {
    /// List of customer workloads
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workloads: std::vec::Vec<crate::model::Workload>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListWorkloadsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkloadsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workloads][crate::model::ListWorkloadsResponse::workloads].
    pub fn set_workloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workload>,
    {
        use std::iter::Iterator;
        self.workloads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkloadsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkloadsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsResponse"
    }
}

impl gax::paginator::PageableResponse for ListWorkloadsResponse {
    type PageItem = crate::model::Workload;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workloads
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a customer workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkloadRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetWorkloadRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkloadRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkloadRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetWorkloadRequest"
    }
}

/// Container for workload onboarding steps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadOnboardingState {
    /// List of workload onboarding steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub onboarding_steps: std::vec::Vec<crate::model::WorkloadOnboardingStep>,
}

impl WorkloadOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::WorkloadOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkloadOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingState"
    }
}

/// Container for workload onboarding information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadOnboardingStep {
    /// The onboarding step.
    pub step: crate::model::workload_onboarding_step::Step,

    /// The starting time of the onboarding step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The completion state of the onboarding step.
    pub completion_state: crate::model::CompletionState,
}

impl WorkloadOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::WorkloadOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::workload_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::WorkloadOnboardingStep::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [completion_time][crate::model::WorkloadOnboardingStep::completion_time].
    pub fn set_completion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_time = v.into();
        self
    }

    /// Sets the value of [completion_state][crate::model::WorkloadOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingStep"
    }
}

/// Defines additional types related to [WorkloadOnboardingStep].
pub mod workload_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Step(i32);

    impl Step {
        /// Unspecified step.
        pub const STEP_UNSPECIFIED: Step = Step::new(0);

        /// EKM Provisioned step.
        pub const EKM_PROVISIONED: Step = Step::new(1);

        /// Signed Access Approval step.
        pub const SIGNED_ACCESS_APPROVAL_CONFIGURED: Step = Step::new(2);

        /// Creates a new Step instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STEP_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("EKM_PROVISIONED"),
                2 => std::borrow::Cow::Borrowed("SIGNED_ACCESS_APPROVAL_CONFIGURED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STEP_UNSPECIFIED" => std::option::Option::Some(Self::STEP_UNSPECIFIED),
                "EKM_PROVISIONED" => std::option::Option::Some(Self::EKM_PROVISIONED),
                "SIGNED_ACCESS_APPROVAL_CONFIGURED" => {
                    std::option::Option::Some(Self::SIGNED_ACCESS_APPROVAL_CONFIGURED)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Step {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Contains metadata around a Cloud Controls Partner Customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Customer {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Display name for the customer
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Container for customer onboarding steps
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_onboarding_state: std::option::Option<crate::model::CustomerOnboardingState>,

    /// Output only. Indicates whether a customer is fully onboarded
    pub is_onboarded: bool,
}

impl Customer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Customer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Customer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [customer_onboarding_state][crate::model::Customer::customer_onboarding_state].
    pub fn set_customer_onboarding_state<
        T: std::convert::Into<std::option::Option<crate::model::CustomerOnboardingState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_onboarding_state = v.into();
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Customer::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }
}

impl wkt::message::Message for Customer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Customer"
    }
}

/// Request to list customers
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomersRequest {
    /// Required. Parent resource
    /// Format: `organizations/{organization}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Customers to return. The service may return fewer
    /// than this value. If unspecified, at most 500 Customers will be returned.
    pub page_size: i32,

    /// A page token, received from a previous `ListCustomers` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListCustomersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCustomersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersRequest"
    }
}

/// Response message for list customer Customers requests
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomersResponse {
    /// List of customers
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub customers: std::vec::Vec<crate::model::Customer>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListCustomersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [customers][crate::model::ListCustomersResponse::customers].
    pub fn set_customers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Customer>,
    {
        use std::iter::Iterator;
        self.customers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCustomersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersResponse"
    }
}

impl gax::paginator::PageableResponse for ListCustomersResponse {
    type PageItem = crate::model::Customer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.customers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetCustomerRequest"
    }
}

/// Container for customer onboarding steps
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerOnboardingState {
    /// List of customer onboarding steps
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub onboarding_steps: std::vec::Vec<crate::model::CustomerOnboardingStep>,
}

impl CustomerOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::CustomerOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingState"
    }
}

/// Container for customer onboarding information
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerOnboardingStep {
    /// The onboarding step
    pub step: crate::model::customer_onboarding_step::Step,

    /// The starting time of the onboarding step
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Current state of the step
    pub completion_state: crate::model::CompletionState,
}

impl CustomerOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::CustomerOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::customer_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CustomerOnboardingStep::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [completion_time][crate::model::CustomerOnboardingStep::completion_time].
    pub fn set_completion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_time = v.into();
        self
    }

    /// Sets the value of [completion_state][crate::model::CustomerOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingStep"
    }
}

/// Defines additional types related to [CustomerOnboardingStep].
pub mod customer_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Step(i32);

    impl Step {
        /// Unspecified step
        pub const STEP_UNSPECIFIED: Step = Step::new(0);

        /// KAJ Enrollment
        pub const KAJ_ENROLLMENT: Step = Step::new(1);

        /// Customer Environment
        pub const CUSTOMER_ENVIRONMENT: Step = Step::new(2);

        /// Creates a new Step instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STEP_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("KAJ_ENROLLMENT"),
                2 => std::borrow::Cow::Borrowed("CUSTOMER_ENVIRONMENT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STEP_UNSPECIFIED" => std::option::Option::Some(Self::STEP_UNSPECIFIED),
                "KAJ_ENROLLMENT" => std::option::Option::Some(Self::KAJ_ENROLLMENT),
                "CUSTOMER_ENVIRONMENT" => std::option::Option::Some(Self::CUSTOMER_ENVIRONMENT),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Step {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The EKM connections associated with a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConnections {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The EKM connections associated with the workload
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ekm_connections: std::vec::Vec<crate::model::EkmConnection>,
}

impl EkmConnections {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConnections::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ekm_connections][crate::model::EkmConnections::ekm_connections].
    pub fn set_ekm_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmConnection>,
    {
        use std::iter::Iterator;
        self.ekm_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EkmConnections {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnections"
    }
}

/// Request for getting the EKM connections associated with a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEkmConnectionsRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEkmConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConnectionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetEkmConnectionsRequest"
    }
}

/// Details about the EKM connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConnection {
    /// Resource name of the EKM connection in the format:
    /// projects/{project}/locations/{location}/ekmConnections/{ekm_connection}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_name: std::string::String,

    /// Output only. The connection state
    pub connection_state: crate::model::ekm_connection::ConnectionState,

    /// The connection error that occurred if any
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_error: std::option::Option<crate::model::ekm_connection::ConnectionError>,
}

impl EkmConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_name][crate::model::EkmConnection::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [connection_state][crate::model::EkmConnection::connection_state].
    pub fn set_connection_state<
        T: std::convert::Into<crate::model::ekm_connection::ConnectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_state = v.into();
        self
    }

    /// Sets the value of [connection_error][crate::model::EkmConnection::connection_error].
    pub fn set_connection_error<
        T: std::convert::Into<std::option::Option<crate::model::ekm_connection::ConnectionError>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_error = v.into();
        self
    }
}

impl wkt::message::Message for EkmConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection"
    }
}

/// Defines additional types related to [EkmConnection].
pub mod ekm_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Information around the error that occurred if the connection state is
    /// anything other than available or unspecified
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConnectionError {
        /// The error domain for the error
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_domain: std::string::String,

        /// The error message for the error
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,
    }

    impl ConnectionError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_domain][crate::model::ekm_connection::ConnectionError::error_domain].
        pub fn set_error_domain<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_domain = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::ekm_connection::ConnectionError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectionError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection.ConnectionError"
        }
    }

    /// The EKM connection state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConnectionState(i32);

    impl ConnectionState {
        /// Unspecified EKM connection state
        pub const CONNECTION_STATE_UNSPECIFIED: ConnectionState = ConnectionState::new(0);

        /// Available EKM connection state
        pub const AVAILABLE: ConnectionState = ConnectionState::new(1);

        /// Not available EKM connection state
        pub const NOT_AVAILABLE: ConnectionState = ConnectionState::new(2);

        /// Error EKM connection state
        pub const ERROR: ConnectionState = ConnectionState::new(3);

        /// Permission denied EKM connection state
        pub const PERMISSION_DENIED: ConnectionState = ConnectionState::new(4);

        /// Creates a new ConnectionState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONNECTION_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("AVAILABLE"),
                2 => std::borrow::Cow::Borrowed("NOT_AVAILABLE"),
                3 => std::borrow::Cow::Borrowed("ERROR"),
                4 => std::borrow::Cow::Borrowed("PERMISSION_DENIED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONNECTION_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONNECTION_STATE_UNSPECIFIED)
                }
                "AVAILABLE" => std::option::Option::Some(Self::AVAILABLE),
                "NOT_AVAILABLE" => std::option::Option::Some(Self::NOT_AVAILABLE),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "PERMISSION_DENIED" => std::option::Option::Some(Self::PERMISSION_DENIED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConnectionState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConnectionState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The permissions granted to the partner for a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartnerPermissions {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The partner permissions granted for the workload
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partner_permissions: std::vec::Vec<crate::model::partner_permissions::Permission>,
}

impl PartnerPermissions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PartnerPermissions::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [partner_permissions][crate::model::PartnerPermissions::partner_permissions].
    pub fn set_partner_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::partner_permissions::Permission>,
    {
        use std::iter::Iterator;
        self.partner_permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PartnerPermissions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.PartnerPermissions"
    }
}

/// Defines additional types related to [PartnerPermissions].
pub mod partner_permissions {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Permission(i32);

    impl Permission {
        /// Unspecified partner permission
        pub const PERMISSION_UNSPECIFIED: Permission = Permission::new(0);

        /// Permission for Access Transparency and emergency logs
        pub const ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS: Permission = Permission::new(1);

        /// Permission for Assured Workloads monitoring violations
        pub const ASSURED_WORKLOADS_MONITORING: Permission = Permission::new(2);

        /// Permission for Access Approval requests
        pub const ACCESS_APPROVAL_REQUESTS: Permission = Permission::new(3);

        /// Permission for External Key Manager connection status
        pub const ASSURED_WORKLOADS_EKM_CONNECTION_STATUS: Permission = Permission::new(4);

        /// Permission for support case details for Access Transparency log entries
        pub const ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER: Permission = Permission::new(5);

        /// Creates a new Permission instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PERMISSION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS"),
                2 => std::borrow::Cow::Borrowed("ASSURED_WORKLOADS_MONITORING"),
                3 => std::borrow::Cow::Borrowed("ACCESS_APPROVAL_REQUESTS"),
                4 => std::borrow::Cow::Borrowed("ASSURED_WORKLOADS_EKM_CONNECTION_STATUS"),
                5 => std::borrow::Cow::Borrowed("ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PERMISSION_UNSPECIFIED" => std::option::Option::Some(Self::PERMISSION_UNSPECIFIED),
                "ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS" => {
                    std::option::Option::Some(Self::ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS)
                }
                "ASSURED_WORKLOADS_MONITORING" => {
                    std::option::Option::Some(Self::ASSURED_WORKLOADS_MONITORING)
                }
                "ACCESS_APPROVAL_REQUESTS" => {
                    std::option::Option::Some(Self::ACCESS_APPROVAL_REQUESTS)
                }
                "ASSURED_WORKLOADS_EKM_CONNECTION_STATUS" => {
                    std::option::Option::Some(Self::ASSURED_WORKLOADS_EKM_CONNECTION_STATUS)
                }
                "ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER" => {
                    std::option::Option::Some(Self::ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Permission {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Permission {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for getting the partner permissions granted for a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPartnerPermissionsRequest {
    /// Required. Name of the resource to get in the format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPartnerPermissionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerPermissionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerPermissionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerPermissionsRequest"
    }
}

/// Message describing Partner resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Partner {
    /// Identifier. The resource name of the partner.
    /// Format: `organizations/{organization}/locations/{location}/partner`
    /// Example: "organizations/123456/locations/us-central1/partner"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// List of SKUs the partner is offering
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub skus: std::vec::Vec<crate::model::Sku>,

    /// List of Google Cloud supported EKM partners supported by the partner
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ekm_solutions: std::vec::Vec<crate::model::EkmMetadata>,

    /// List of Google Cloud regions that the partner sells services to customers.
    /// Valid Google Cloud regions found here:
    /// <https://cloud.google.com/compute/docs/regions-zones>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub operated_cloud_regions: std::vec::Vec<std::string::String>,

    /// Google Cloud project ID in the partner's Google Cloud organization for
    /// receiving enhanced Logs for Partners.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub partner_project_id: std::string::String,

    /// Output only. Time the resource was created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the resource was updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl Partner {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Partner::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [partner_project_id][crate::model::Partner::partner_project_id].
    pub fn set_partner_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner_project_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Partner::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Partner::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [skus][crate::model::Partner::skus].
    pub fn set_skus<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sku>,
    {
        use std::iter::Iterator;
        self.skus = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ekm_solutions][crate::model::Partner::ekm_solutions].
    pub fn set_ekm_solutions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmMetadata>,
    {
        use std::iter::Iterator;
        self.ekm_solutions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operated_cloud_regions][crate::model::Partner::operated_cloud_regions].
    pub fn set_operated_cloud_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.operated_cloud_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Partner {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Partner"
    }
}

/// Message for getting a Partner
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPartnerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/partner`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPartnerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerRequest"
    }
}

/// Represents the SKU a partner owns inside Google Cloud to sell to customers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sku {
    /// Argentum product SKU, that is associated with the partner offerings to
    /// customers used by Syntro for billing purposes. SKUs can represent resold
    /// Google products or support services.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Display name of the product identified by the SKU. A partner may want to
    /// show partner branded names for their offerings such as local sovereign
    /// cloud solutions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,
}

impl Sku {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Sku::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Sku::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Sku {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Sku"
    }
}

/// Holds information needed by Mudbray to use partner EKMs for workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmMetadata {
    /// The Cloud EKM partner.
    pub ekm_solution: crate::model::ekm_metadata::EkmSolution,

    /// Endpoint for sending requests to the EKM for key provisioning during
    /// Assured Workload creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ekm_endpoint_uri: std::string::String,
}

impl EkmMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_solution][crate::model::EkmMetadata::ekm_solution].
    pub fn set_ekm_solution<T: std::convert::Into<crate::model::ekm_metadata::EkmSolution>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_solution = v.into();
        self
    }

    /// Sets the value of [ekm_endpoint_uri][crate::model::EkmMetadata::ekm_endpoint_uri].
    pub fn set_ekm_endpoint_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_endpoint_uri = v.into();
        self
    }
}

impl wkt::message::Message for EkmMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmMetadata"
    }
}

/// Defines additional types related to [EkmMetadata].
pub mod ekm_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents Google Cloud supported external key management partners
    /// [Google Cloud EKM partners
    /// docs](https://cloud.google.com/kms/docs/ekm#supported_partners).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EkmSolution(i32);

    impl EkmSolution {
        /// Unspecified EKM solution
        pub const EKM_SOLUTION_UNSPECIFIED: EkmSolution = EkmSolution::new(0);

        /// EKM Partner Fortanix
        pub const FORTANIX: EkmSolution = EkmSolution::new(1);

        /// EKM Partner FutureX
        pub const FUTUREX: EkmSolution = EkmSolution::new(2);

        /// EKM Partner Thales
        pub const THALES: EkmSolution = EkmSolution::new(3);

        /// EKM Partner Virtu
        pub const VIRTRU: EkmSolution = EkmSolution::new(4);

        /// Creates a new EkmSolution instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EKM_SOLUTION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FORTANIX"),
                2 => std::borrow::Cow::Borrowed("FUTUREX"),
                3 => std::borrow::Cow::Borrowed("THALES"),
                4 => std::borrow::Cow::Borrowed("VIRTRU"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EKM_SOLUTION_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EKM_SOLUTION_UNSPECIFIED)
                }
                "FORTANIX" => std::option::Option::Some(Self::FORTANIX),
                "FUTUREX" => std::option::Option::Some(Self::FUTUREX),
                "THALES" => std::option::Option::Some(Self::THALES),
                "VIRTRU" => std::option::Option::Some(Self::VIRTRU),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for EkmSolution {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for EkmSolution {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Details of resource Violation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Violation {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Description for the Violation.
    /// e.g. OrgPolicy gcp.resourceLocations has non compliant value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Time of the event which triggered the Violation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time when the Violation record was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time of the event which fixed the Violation.
    /// If the violation is ACTIVE this will be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolve_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Category under which this violation is mapped.
    /// e.g. Location, Service Usage, Access, Encryption, etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub category: std::string::String,

    /// Output only. State of the violation
    pub state: crate::model::violation::State,

    /// Output only. Immutable. Name of the OrgPolicy which was modified with
    /// non-compliant change and resulted this violation. Format:
    /// `projects/{project_number}/policies/{constraint_name}`
    /// `folders/{folder_id}/policies/{constraint_name}`
    /// `organizations/{organization_id}/policies/{constraint_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub non_compliant_org_policy: std::string::String,

    /// The folder_id of the violation
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub folder_id: i64,

    /// Output only. Compliance violation remediation
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub remediation: std::option::Option<crate::model::violation::Remediation>,
}

impl Violation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Violation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Violation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [begin_time][crate::model::Violation::begin_time].
    pub fn set_begin_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.begin_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Violation::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [resolve_time][crate::model::Violation::resolve_time].
    pub fn set_resolve_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resolve_time = v.into();
        self
    }

    /// Sets the value of [category][crate::model::Violation::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Violation::state].
    pub fn set_state<T: std::convert::Into<crate::model::violation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [non_compliant_org_policy][crate::model::Violation::non_compliant_org_policy].
    pub fn set_non_compliant_org_policy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.non_compliant_org_policy = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Violation::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::Violation::remediation].
    pub fn set_remediation<
        T: std::convert::Into<std::option::Option<crate::model::violation::Remediation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remediation = v.into();
        self
    }
}

impl wkt::message::Message for Violation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation"
    }
}

/// Defines additional types related to [Violation].
pub mod violation {
    #[allow(unused_imports)]
    use super::*;

    /// Represents remediation guidance to resolve compliance violation for
    /// AssuredWorkload
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Remediation {
        /// Required. Remediation instructions to resolve violations
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub instructions: std::option::Option<crate::model::violation::remediation::Instructions>,

        /// Values that can resolve the violation
        /// For example: for list org policy violations, this will either be the list
        /// of allowed or denied values
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub compliant_values: std::vec::Vec<std::string::String>,

        /// Output only. Remediation type based on the type of org policy values
        /// violated
        pub remediation_type: crate::model::violation::remediation::RemediationType,
    }

    impl Remediation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instructions][crate::model::violation::Remediation::instructions].
        pub fn set_instructions<
            T: std::convert::Into<
                    std::option::Option<crate::model::violation::remediation::Instructions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.instructions = v.into();
            self
        }

        /// Sets the value of [remediation_type][crate::model::violation::Remediation::remediation_type].
        pub fn set_remediation_type<
            T: std::convert::Into<crate::model::violation::remediation::RemediationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.remediation_type = v.into();
            self
        }

        /// Sets the value of [compliant_values][crate::model::violation::Remediation::compliant_values].
        pub fn set_compliant_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.compliant_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Remediation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation"
        }
    }

    /// Defines additional types related to [Remediation].
    pub mod remediation {
        #[allow(unused_imports)]
        use super::*;

        /// Instructions to remediate violation
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Instructions {
            /// Remediation instructions to resolve violation via gcloud cli
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub gcloud_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Gcloud>,

            /// Remediation instructions to resolve violation via cloud console
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub console_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Console>,
        }

        impl Instructions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gcloud_instructions][crate::model::violation::remediation::Instructions::gcloud_instructions].
            pub fn set_gcloud_instructions<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::violation::remediation::instructions::Gcloud,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.gcloud_instructions = v.into();
                self
            }

            /// Sets the value of [console_instructions][crate::model::violation::remediation::Instructions::console_instructions].
            pub fn set_console_instructions<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::violation::remediation::instructions::Console,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.console_instructions = v.into();
                self
            }
        }

        impl wkt::message::Message for Instructions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions"
            }
        }

        /// Defines additional types related to [Instructions].
        pub mod instructions {
            #[allow(unused_imports)]
            use super::*;

            /// Remediation instructions to resolve violation via gcloud cli
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Gcloud {
                /// Gcloud command to resolve violation
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub gcloud_commands: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via gcloud cli
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub additional_links: std::vec::Vec<std::string::String>,
            }

            impl Gcloud {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [gcloud_commands][crate::model::violation::remediation::instructions::Gcloud::gcloud_commands].
                pub fn set_gcloud_commands<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gcloud_commands = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Gcloud::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Gcloud::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Gcloud {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Gcloud"
                }
            }

            /// Remediation instructions to resolve violation via cloud console
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Console {
                /// Link to console page where violations can be resolved
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub console_uris: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via cloud console
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub additional_links: std::vec::Vec<std::string::String>,
            }

            impl Console {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [console_uris][crate::model::violation::remediation::instructions::Console::console_uris].
                pub fn set_console_uris<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.console_uris = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Console::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Console::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Console {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Console"
                }
            }
        }

        /// Classifying remediation into various types based on the kind of
        /// violation. For example, violations caused due to changes in boolean org
        /// policy requires different remediation instructions compared to violation
        /// caused due to changes in allowed values of list org policy.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct RemediationType(i32);

        impl RemediationType {
            /// Unspecified remediation type
            pub const REMEDIATION_TYPE_UNSPECIFIED: RemediationType = RemediationType::new(0);

            /// Remediation type for boolean org policy
            pub const REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION: RemediationType =
                RemediationType::new(1);

            /// Remediation type for list org policy which have allowed values in the
            /// monitoring rule
            pub const REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION: RemediationType =
                RemediationType::new(2);

            /// Remediation type for list org policy which have denied values in the
            /// monitoring rule
            pub const REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION: RemediationType =
                RemediationType::new(3);

            /// Remediation type for gcp.restrictCmekCryptoKeyProjects
            pub const REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION:
                RemediationType = RemediationType::new(4);

            /// Remediation type for resource violation.
            pub const REMEDIATION_RESOURCE_VIOLATION: RemediationType = RemediationType::new(5);

            /// Creates a new RemediationType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("REMEDIATION_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION"),
                    2 => std::borrow::Cow::Borrowed(
                        "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION",
                    ),
                    3 => std::borrow::Cow::Borrowed(
                        "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION",
                    ),
                    4 => std::borrow::Cow::Borrowed(
                        "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION",
                    ),
                    5 => std::borrow::Cow::Borrowed("REMEDIATION_RESOURCE_VIOLATION"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "REMEDIATION_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::REMEDIATION_TYPE_UNSPECIFIED),
                    "REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION" => std::option::Option::Some(Self::REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION),
                    "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION" => std::option::Option::Some(Self::REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION),
                    "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION" => std::option::Option::Some(Self::REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION),
                    "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION" => std::option::Option::Some(Self::REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION),
                    "REMEDIATION_RESOURCE_VIOLATION" => std::option::Option::Some(Self::REMEDIATION_RESOURCE_VIOLATION),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for RemediationType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for RemediationType {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Violation State Values
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Violation is resolved.
        pub const RESOLVED: State = State::new(1);

        /// Violation is Unresolved
        pub const UNRESOLVED: State = State::new(2);

        /// Violation is Exception
        pub const EXCEPTION: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RESOLVED"),
                2 => std::borrow::Cow::Borrowed("UNRESOLVED"),
                3 => std::borrow::Cow::Borrowed("EXCEPTION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RESOLVED" => std::option::Option::Some(Self::RESOLVED),
                "UNRESOLVED" => std::option::Option::Some(Self::UNRESOLVED),
                "EXCEPTION" => std::option::Option::Some(Self::EXCEPTION),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for requesting list of Violations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViolationsRequest {
    /// Required. Parent resource
    /// Format
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of customers row to return. The service may
    /// return fewer than this value. If unspecified, at most 10 customers will be
    /// returned.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListViolations` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. Specifies the interval for retrieving violations.
    /// if unspecified, all violations will be returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<gtype::model::Interval>,
}

impl ListViolationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViolationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViolationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViolationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListViolationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListViolationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListViolationsRequest::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<gtype::model::Interval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }
}

impl wkt::message::Message for ListViolationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsRequest"
    }
}

/// Response message for list customer violation requests
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViolationsResponse {
    /// List of violation
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub violations: std::vec::Vec<crate::model::Violation>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Workloads that could not be reached due to permission errors or any other
    /// error. Ref: <https://google.aip.dev/217>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListViolationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListViolationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [violations][crate::model::ListViolationsResponse::violations].
    pub fn set_violations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Violation>,
    {
        use std::iter::Iterator;
        self.violations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListViolationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListViolationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsResponse"
    }
}

impl gax::paginator::PageableResponse for ListViolationsResponse {
    type PageItem = crate::model::Violation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.violations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Violation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetViolationRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetViolationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViolationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViolationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetViolationRequest"
    }
}

/// Enum for possible completion states.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct CompletionState(i32);

impl CompletionState {
    /// Unspecified completion state.
    pub const COMPLETION_STATE_UNSPECIFIED: CompletionState = CompletionState::new(0);

    /// Task started (has start date) but not yet completed.
    pub const PENDING: CompletionState = CompletionState::new(1);

    /// Succeeded state.
    pub const SUCCEEDED: CompletionState = CompletionState::new(2);

    /// Failed state.
    pub const FAILED: CompletionState = CompletionState::new(3);

    /// Not applicable state.
    pub const NOT_APPLICABLE: CompletionState = CompletionState::new(4);

    /// Creates a new CompletionState instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("COMPLETION_STATE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("PENDING"),
            2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
            3 => std::borrow::Cow::Borrowed("FAILED"),
            4 => std::borrow::Cow::Borrowed("NOT_APPLICABLE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "COMPLETION_STATE_UNSPECIFIED" => {
                std::option::Option::Some(Self::COMPLETION_STATE_UNSPECIFIED)
            }
            "PENDING" => std::option::Option::Some(Self::PENDING),
            "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
            "FAILED" => std::option::Option::Some(Self::FAILED),
            "NOT_APPLICABLE" => std::option::Option::Some(Self::NOT_APPLICABLE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for CompletionState {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for CompletionState {
    fn default() -> Self {
        Self::new(0)
    }
}
