// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Details about the Access request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessApprovalRequest {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/accessApprovalRequests/{access_approval_request}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time at which approval was requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The justification for which approval is being requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_reason: std::option::Option<crate::model::AccessReason>,

    /// The requested expiration for the approval. If the request is approved,
    /// access will be granted from the time of approval until the expiration time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_expiration_time: std::option::Option<wkt::Timestamp>,
}

impl AccessApprovalRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessApprovalRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::AccessApprovalRequest::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [requested_reason][crate::model::AccessApprovalRequest::requested_reason].
    pub fn set_requested_reason<
        T: std::convert::Into<std::option::Option<crate::model::AccessReason>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_reason = v.into();
        self
    }

    /// Sets the value of [requested_expiration_time][crate::model::AccessApprovalRequest::requested_expiration_time].
    pub fn set_requested_expiration_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requested_expiration_time = v.into();
        self
    }
}

impl wkt::message::Message for AccessApprovalRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessApprovalRequest"
    }
}

/// Request for getting the access requests associated with a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of access requests to return. The service may
    /// return fewer than this value. If unspecified, at most 500 access requests
    /// will be returned.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListAccessApprovalRequests` call. Provide this to retrieve the subsequent
    /// page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListAccessApprovalRequestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAccessApprovalRequestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAccessApprovalRequestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAccessApprovalRequestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAccessApprovalRequestsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAccessApprovalRequestsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsRequest"
    }
}

/// Response message for list access requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsResponse {
    /// List of access approval requests
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub access_approval_requests: std::vec::Vec<crate::model::AccessApprovalRequest>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListAccessApprovalRequestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAccessApprovalRequestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [access_approval_requests][crate::model::ListAccessApprovalRequestsResponse::access_approval_requests].
    pub fn set_access_approval_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessApprovalRequest>,
    {
        use std::iter::Iterator;
        self.access_approval_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAccessApprovalRequestsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAccessApprovalRequestsResponse {
    type PageItem = crate::model::AccessApprovalRequest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.access_approval_requests
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Reason for the access.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessReason {
    /// Type of access justification.
    #[serde(rename = "type")]
    pub r#type: crate::model::access_reason::Type,

    /// More detail about certain reason types. See comments for each type above.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detail: std::string::String,
}

impl AccessReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AccessReason::type].
    pub fn set_type<T: std::convert::Into<crate::model::access_reason::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::AccessReason::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for AccessReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessReason"
    }
}

/// Defines additional types related to AccessReason
pub mod access_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Type of access justification.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::borrow::Cow<'static, str>);

    impl Type {
        /// Creates a new Type instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// Default value for proto, shouldn't be used.
        pub const TYPE_UNSPECIFIED: Type = Type::new("TYPE_UNSPECIFIED");

        /// Customer made a request or raised an issue that required the principal to
        /// access customer data. `detail` is of the form ("#####" is the issue ID):
        ///
        /// - "Feedback Report: #####"
        /// - "Case Number: #####"
        /// - "Case ID: #####"
        /// - "E-PIN Reference: #####"
        /// - "Google-#####"
        /// - "T-#####"
        pub const CUSTOMER_INITIATED_SUPPORT: Type = Type::new("CUSTOMER_INITIATED_SUPPORT");

        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services. Often this access is used to confirm that
        /// customers are not affected by a suspected service issue or to remediate a
        /// reversible system issue.
        pub const GOOGLE_INITIATED_SERVICE: Type = Type::new("GOOGLE_INITIATED_SERVICE");

        /// Google initiated service for security, fraud, abuse, or compliance
        /// purposes.
        pub const GOOGLE_INITIATED_REVIEW: Type = Type::new("GOOGLE_INITIATED_REVIEW");

        /// The principal was compelled to access customer data in order to respond
        /// to a legal third party data request or process, including legal processes
        /// from customers themselves.
        pub const THIRD_PARTY_DATA_REQUEST: Type = Type::new("THIRD_PARTY_DATA_REQUEST");

        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services or a known outage.
        pub const GOOGLE_RESPONSE_TO_PRODUCTION_ALERT: Type =
            Type::new("GOOGLE_RESPONSE_TO_PRODUCTION_ALERT");

        /// Similar to 'GOOGLE_INITIATED_SERVICE' or 'GOOGLE_INITIATED_REVIEW', but
        /// with universe agnostic naming. The principal accessed customer data in
        /// order to diagnose or resolve a suspected issue in services or a known
        /// outage, or for security, fraud, abuse, or compliance review purposes.
        pub const CLOUD_INITIATED_ACCESS: Type = Type::new("CLOUD_INITIATED_ACCESS");
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            r#type::TYPE_UNSPECIFIED
        }
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.OperationMetadata"
    }
}

/// Contains metadata around the [Workload
/// resource](https://cloud.google.com/assured-workloads/docs/reference/rest/Shared.Types/Workload)
/// in the Assured Workloads API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Workload {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Folder id this workload is associated with
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub folder_id: i64,

    /// Output only. Time the resource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of container folder of the assured workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub folder: std::string::String,

    /// Container for workload onboarding steps.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_onboarding_state: std::option::Option<crate::model::WorkloadOnboardingState>,

    /// Indicates whether a workload is fully onboarded.
    pub is_onboarded: bool,

    /// The project id of the key management project for the workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_management_project_id: std::string::String,

    /// The Google Cloud location of the workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Partner associated with this workload.
    pub partner: crate::model::workload::Partner,
}

impl Workload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Workload::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Workload::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Workload::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [folder][crate::model::Workload::folder].
    pub fn set_folder<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.folder = v.into();
        self
    }

    /// Sets the value of [workload_onboarding_state][crate::model::Workload::workload_onboarding_state].
    pub fn set_workload_onboarding_state<
        T: std::convert::Into<std::option::Option<crate::model::WorkloadOnboardingState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workload_onboarding_state = v.into();
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Workload::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }

    /// Sets the value of [key_management_project_id][crate::model::Workload::key_management_project_id].
    pub fn set_key_management_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_management_project_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Workload::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [partner][crate::model::Workload::partner].
    pub fn set_partner<T: std::convert::Into<crate::model::workload::Partner>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner = v.into();
        self
    }
}

impl wkt::message::Message for Workload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Workload"
    }
}

/// Defines additional types related to Workload
pub mod workload {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Assured Workloads Partners.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Partner(std::borrow::Cow<'static, str>);

    impl Partner {
        /// Creates a new Partner instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Partner](Partner)
    pub mod partner {
        use super::Partner;

        /// Unknown Partner.
        pub const PARTNER_UNSPECIFIED: Partner = Partner::new("PARTNER_UNSPECIFIED");

        /// Enum representing S3NS (Thales) partner.
        pub const PARTNER_LOCAL_CONTROLS_BY_S3NS: Partner =
            Partner::new("PARTNER_LOCAL_CONTROLS_BY_S3NS");

        /// Enum representing T_SYSTEM (TSI) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS: Partner =
            Partner::new("PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS");

        /// Enum representing SIA_MINSAIT (Indra) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT: Partner =
            Partner::new("PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT");

        /// Enum representing PSN (TIM) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_PSN: Partner =
            Partner::new("PARTNER_SOVEREIGN_CONTROLS_BY_PSN");

        /// Enum representing CNTXT (Kingdom of Saudi Arabia) partner.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT: Partner =
            Partner::new("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT");

        /// Enum representing CNXT (Kingdom of Saudi Arabia) partner offering without
        /// EKM provisioning.
        pub const PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM: Partner =
            Partner::new("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM");
    }

    impl std::convert::From<std::string::String> for Partner {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Partner {
        fn default() -> Self {
            partner::PARTNER_UNSPECIFIED
        }
    }
}

/// Request to list customer workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of workloads to return. The service may return fewer
    /// than this value. If unspecified, at most 500 workloads will be returned.
    pub page_size: i32,

    /// A page token, received from a previous `ListWorkloads` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListWorkloadsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkloadsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkloadsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkloadsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkloadsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListWorkloadsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkloadsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsRequest"
    }
}

/// Response message for list customer workloads requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsResponse {
    /// List of customer workloads
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workloads: std::vec::Vec<crate::model::Workload>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListWorkloadsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkloadsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workloads][crate::model::ListWorkloadsResponse::workloads].
    pub fn set_workloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workload>,
    {
        use std::iter::Iterator;
        self.workloads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkloadsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkloadsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListWorkloadsResponse {
    type PageItem = crate::model::Workload;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workloads
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for getting a customer workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkloadRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetWorkloadRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkloadRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkloadRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetWorkloadRequest"
    }
}

/// Container for workload onboarding steps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadOnboardingState {
    /// List of workload onboarding steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub onboarding_steps: std::vec::Vec<crate::model::WorkloadOnboardingStep>,
}

impl WorkloadOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::WorkloadOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkloadOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingState"
    }
}

/// Container for workload onboarding information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadOnboardingStep {
    /// The onboarding step.
    pub step: crate::model::workload_onboarding_step::Step,

    /// The starting time of the onboarding step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The completion state of the onboarding step.
    pub completion_state: crate::model::CompletionState,
}

impl WorkloadOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::WorkloadOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::workload_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::WorkloadOnboardingStep::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [completion_time][crate::model::WorkloadOnboardingStep::completion_time].
    pub fn set_completion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_time = v.into();
        self
    }

    /// Sets the value of [completion_state][crate::model::WorkloadOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingStep"
    }
}

/// Defines additional types related to WorkloadOnboardingStep
pub mod workload_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Step(std::borrow::Cow<'static, str>);

    impl Step {
        /// Creates a new Step instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Step](Step)
    pub mod step {
        use super::Step;

        /// Unspecified step.
        pub const STEP_UNSPECIFIED: Step = Step::new("STEP_UNSPECIFIED");

        /// EKM Provisioned step.
        pub const EKM_PROVISIONED: Step = Step::new("EKM_PROVISIONED");

        /// Signed Access Approval step.
        pub const SIGNED_ACCESS_APPROVAL_CONFIGURED: Step =
            Step::new("SIGNED_ACCESS_APPROVAL_CONFIGURED");
    }

    impl std::convert::From<std::string::String> for Step {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            step::STEP_UNSPECIFIED
        }
    }
}

/// Contains metadata around a Cloud Controls Partner Customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Customer {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Display name for the customer
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Container for customer onboarding steps
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_onboarding_state: std::option::Option<crate::model::CustomerOnboardingState>,

    /// Output only. Indicates whether a customer is fully onboarded
    pub is_onboarded: bool,
}

impl Customer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Customer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Customer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [customer_onboarding_state][crate::model::Customer::customer_onboarding_state].
    pub fn set_customer_onboarding_state<
        T: std::convert::Into<std::option::Option<crate::model::CustomerOnboardingState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_onboarding_state = v.into();
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Customer::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }
}

impl wkt::message::Message for Customer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Customer"
    }
}

/// Request to list customers
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomersRequest {
    /// Required. Parent resource
    /// Format: `organizations/{organization}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Customers to return. The service may return fewer
    /// than this value. If unspecified, at most 500 Customers will be returned.
    pub page_size: i32,

    /// A page token, received from a previous `ListCustomers` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListCustomersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCustomersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersRequest"
    }
}

/// Response message for list customer Customers requests
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomersResponse {
    /// List of customers
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub customers: std::vec::Vec<crate::model::Customer>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListCustomersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [customers][crate::model::ListCustomersResponse::customers].
    pub fn set_customers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Customer>,
    {
        use std::iter::Iterator;
        self.customers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCustomersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListCustomersResponse {
    type PageItem = crate::model::Customer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.customers
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for getting a customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetCustomerRequest"
    }
}

/// Container for customer onboarding steps
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerOnboardingState {
    /// List of customer onboarding steps
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub onboarding_steps: std::vec::Vec<crate::model::CustomerOnboardingStep>,
}

impl CustomerOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::CustomerOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingState"
    }
}

/// Container for customer onboarding information
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerOnboardingStep {
    /// The onboarding step
    pub step: crate::model::customer_onboarding_step::Step,

    /// The starting time of the onboarding step
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Current state of the step
    pub completion_state: crate::model::CompletionState,
}

impl CustomerOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::CustomerOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::customer_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CustomerOnboardingStep::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [completion_time][crate::model::CustomerOnboardingStep::completion_time].
    pub fn set_completion_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_time = v.into();
        self
    }

    /// Sets the value of [completion_state][crate::model::CustomerOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingStep"
    }
}

/// Defines additional types related to CustomerOnboardingStep
pub mod customer_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Step(std::borrow::Cow<'static, str>);

    impl Step {
        /// Creates a new Step instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Step](Step)
    pub mod step {
        use super::Step;

        /// Unspecified step
        pub const STEP_UNSPECIFIED: Step = Step::new("STEP_UNSPECIFIED");

        /// KAJ Enrollment
        pub const KAJ_ENROLLMENT: Step = Step::new("KAJ_ENROLLMENT");

        /// Customer Environment
        pub const CUSTOMER_ENVIRONMENT: Step = Step::new("CUSTOMER_ENVIRONMENT");
    }

    impl std::convert::From<std::string::String> for Step {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            step::STEP_UNSPECIFIED
        }
    }
}

/// The EKM connections associated with a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConnections {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The EKM connections associated with the workload
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ekm_connections: std::vec::Vec<crate::model::EkmConnection>,
}

impl EkmConnections {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConnections::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ekm_connections][crate::model::EkmConnections::ekm_connections].
    pub fn set_ekm_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmConnection>,
    {
        use std::iter::Iterator;
        self.ekm_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EkmConnections {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnections"
    }
}

/// Request for getting the EKM connections associated with a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEkmConnectionsRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEkmConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConnectionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetEkmConnectionsRequest"
    }
}

/// Details about the EKM connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConnection {
    /// Resource name of the EKM connection in the format:
    /// projects/{project}/locations/{location}/ekmConnections/{ekm_connection}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_name: std::string::String,

    /// Output only. The connection state
    pub connection_state: crate::model::ekm_connection::ConnectionState,

    /// The connection error that occurred if any
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_error: std::option::Option<crate::model::ekm_connection::ConnectionError>,
}

impl EkmConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_name][crate::model::EkmConnection::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [connection_state][crate::model::EkmConnection::connection_state].
    pub fn set_connection_state<
        T: std::convert::Into<crate::model::ekm_connection::ConnectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_state = v.into();
        self
    }

    /// Sets the value of [connection_error][crate::model::EkmConnection::connection_error].
    pub fn set_connection_error<
        T: std::convert::Into<std::option::Option<crate::model::ekm_connection::ConnectionError>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_error = v.into();
        self
    }
}

impl wkt::message::Message for EkmConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection"
    }
}

/// Defines additional types related to EkmConnection
pub mod ekm_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Information around the error that occurred if the connection state is
    /// anything other than available or unspecified
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConnectionError {
        /// The error domain for the error
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_domain: std::string::String,

        /// The error message for the error
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,
    }

    impl ConnectionError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_domain][crate::model::ekm_connection::ConnectionError::error_domain].
        pub fn set_error_domain<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_domain = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::ekm_connection::ConnectionError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectionError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection.ConnectionError"
        }
    }

    /// The EKM connection state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConnectionState(std::borrow::Cow<'static, str>);

    impl ConnectionState {
        /// Creates a new ConnectionState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ConnectionState](ConnectionState)
    pub mod connection_state {
        use super::ConnectionState;

        /// Unspecified EKM connection state
        pub const CONNECTION_STATE_UNSPECIFIED: ConnectionState =
            ConnectionState::new("CONNECTION_STATE_UNSPECIFIED");

        /// Available EKM connection state
        pub const AVAILABLE: ConnectionState = ConnectionState::new("AVAILABLE");

        /// Not available EKM connection state
        pub const NOT_AVAILABLE: ConnectionState = ConnectionState::new("NOT_AVAILABLE");

        /// Error EKM connection state
        pub const ERROR: ConnectionState = ConnectionState::new("ERROR");

        /// Permission denied EKM connection state
        pub const PERMISSION_DENIED: ConnectionState = ConnectionState::new("PERMISSION_DENIED");
    }

    impl std::convert::From<std::string::String> for ConnectionState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for ConnectionState {
        fn default() -> Self {
            connection_state::CONNECTION_STATE_UNSPECIFIED
        }
    }
}

/// The permissions granted to the partner for a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartnerPermissions {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The partner permissions granted for the workload
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partner_permissions: std::vec::Vec<crate::model::partner_permissions::Permission>,
}

impl PartnerPermissions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PartnerPermissions::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [partner_permissions][crate::model::PartnerPermissions::partner_permissions].
    pub fn set_partner_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::partner_permissions::Permission>,
    {
        use std::iter::Iterator;
        self.partner_permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PartnerPermissions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.PartnerPermissions"
    }
}

/// Defines additional types related to PartnerPermissions
pub mod partner_permissions {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Permission(std::borrow::Cow<'static, str>);

    impl Permission {
        /// Creates a new Permission instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Permission](Permission)
    pub mod permission {
        use super::Permission;

        /// Unspecified partner permission
        pub const PERMISSION_UNSPECIFIED: Permission = Permission::new("PERMISSION_UNSPECIFIED");

        /// Permission for Access Transparency and emergency logs
        pub const ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS: Permission =
            Permission::new("ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS");

        /// Permission for Assured Workloads monitoring violations
        pub const ASSURED_WORKLOADS_MONITORING: Permission =
            Permission::new("ASSURED_WORKLOADS_MONITORING");

        /// Permission for Access Approval requests
        pub const ACCESS_APPROVAL_REQUESTS: Permission =
            Permission::new("ACCESS_APPROVAL_REQUESTS");

        /// Permission for External Key Manager connection status
        pub const ASSURED_WORKLOADS_EKM_CONNECTION_STATUS: Permission =
            Permission::new("ASSURED_WORKLOADS_EKM_CONNECTION_STATUS");

        /// Permission for support case details for Access Transparency log entries
        pub const ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER: Permission =
            Permission::new("ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER");
    }

    impl std::convert::From<std::string::String> for Permission {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Permission {
        fn default() -> Self {
            permission::PERMISSION_UNSPECIFIED
        }
    }
}

/// Request for getting the partner permissions granted for a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPartnerPermissionsRequest {
    /// Required. Name of the resource to get in the format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPartnerPermissionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerPermissionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerPermissionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerPermissionsRequest"
    }
}

/// Message describing Partner resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Partner {
    /// Identifier. The resource name of the partner.
    /// Format: `organizations/{organization}/locations/{location}/partner`
    /// Example: "organizations/123456/locations/us-central1/partner"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// List of SKUs the partner is offering
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub skus: std::vec::Vec<crate::model::Sku>,

    /// List of Google Cloud supported EKM partners supported by the partner
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ekm_solutions: std::vec::Vec<crate::model::EkmMetadata>,

    /// List of Google Cloud regions that the partner sells services to customers.
    /// Valid Google Cloud regions found here:
    /// <https://cloud.google.com/compute/docs/regions-zones>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub operated_cloud_regions: std::vec::Vec<std::string::String>,

    /// Google Cloud project ID in the partner's Google Cloud organization for
    /// receiving enhanced Logs for Partners.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub partner_project_id: std::string::String,

    /// Output only. Time the resource was created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the resource was updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl Partner {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Partner::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [partner_project_id][crate::model::Partner::partner_project_id].
    pub fn set_partner_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner_project_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Partner::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Partner::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [skus][crate::model::Partner::skus].
    pub fn set_skus<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sku>,
    {
        use std::iter::Iterator;
        self.skus = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ekm_solutions][crate::model::Partner::ekm_solutions].
    pub fn set_ekm_solutions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmMetadata>,
    {
        use std::iter::Iterator;
        self.ekm_solutions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operated_cloud_regions][crate::model::Partner::operated_cloud_regions].
    pub fn set_operated_cloud_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.operated_cloud_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Partner {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Partner"
    }
}

/// Message for getting a Partner
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPartnerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/partner`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPartnerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerRequest"
    }
}

/// Represents the SKU a partner owns inside Google Cloud to sell to customers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sku {
    /// Argentum product SKU, that is associated with the partner offerings to
    /// customers used by Syntro for billing purposes. SKUs can represent resold
    /// Google products or support services.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Display name of the product identified by the SKU. A partner may want to
    /// show partner branded names for their offerings such as local sovereign
    /// cloud solutions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,
}

impl Sku {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Sku::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Sku::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Sku {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Sku"
    }
}

/// Holds information needed by Mudbray to use partner EKMs for workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmMetadata {
    /// The Cloud EKM partner.
    pub ekm_solution: crate::model::ekm_metadata::EkmSolution,

    /// Endpoint for sending requests to the EKM for key provisioning during
    /// Assured Workload creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ekm_endpoint_uri: std::string::String,
}

impl EkmMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_solution][crate::model::EkmMetadata::ekm_solution].
    pub fn set_ekm_solution<T: std::convert::Into<crate::model::ekm_metadata::EkmSolution>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_solution = v.into();
        self
    }

    /// Sets the value of [ekm_endpoint_uri][crate::model::EkmMetadata::ekm_endpoint_uri].
    pub fn set_ekm_endpoint_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_endpoint_uri = v.into();
        self
    }
}

impl wkt::message::Message for EkmMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmMetadata"
    }
}

/// Defines additional types related to EkmMetadata
pub mod ekm_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents Google Cloud supported external key management partners
    /// [Google Cloud EKM partners
    /// docs](https://cloud.google.com/kms/docs/ekm#supported_partners).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EkmSolution(std::borrow::Cow<'static, str>);

    impl EkmSolution {
        /// Creates a new EkmSolution instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [EkmSolution](EkmSolution)
    pub mod ekm_solution {
        use super::EkmSolution;

        /// Unspecified EKM solution
        pub const EKM_SOLUTION_UNSPECIFIED: EkmSolution =
            EkmSolution::new("EKM_SOLUTION_UNSPECIFIED");

        /// EKM Partner Fortanix
        pub const FORTANIX: EkmSolution = EkmSolution::new("FORTANIX");

        /// EKM Partner FutureX
        pub const FUTUREX: EkmSolution = EkmSolution::new("FUTUREX");

        /// EKM Partner Thales
        pub const THALES: EkmSolution = EkmSolution::new("THALES");

        /// EKM Partner Virtu
        pub const VIRTRU: EkmSolution = EkmSolution::new("VIRTRU");
    }

    impl std::convert::From<std::string::String> for EkmSolution {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for EkmSolution {
        fn default() -> Self {
            ekm_solution::EKM_SOLUTION_UNSPECIFIED
        }
    }
}

/// Details of resource Violation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Violation {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Description for the Violation.
    /// e.g. OrgPolicy gcp.resourceLocations has non compliant value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Time of the event which triggered the Violation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time when the Violation record was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time of the event which fixed the Violation.
    /// If the violation is ACTIVE this will be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolve_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Category under which this violation is mapped.
    /// e.g. Location, Service Usage, Access, Encryption, etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub category: std::string::String,

    /// Output only. State of the violation
    pub state: crate::model::violation::State,

    /// Output only. Immutable. Name of the OrgPolicy which was modified with
    /// non-compliant change and resulted this violation. Format:
    /// `projects/{project_number}/policies/{constraint_name}`
    /// `folders/{folder_id}/policies/{constraint_name}`
    /// `organizations/{organization_id}/policies/{constraint_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub non_compliant_org_policy: std::string::String,

    /// The folder_id of the violation
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub folder_id: i64,

    /// Output only. Compliance violation remediation
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub remediation: std::option::Option<crate::model::violation::Remediation>,
}

impl Violation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Violation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Violation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [begin_time][crate::model::Violation::begin_time].
    pub fn set_begin_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.begin_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Violation::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [resolve_time][crate::model::Violation::resolve_time].
    pub fn set_resolve_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.resolve_time = v.into();
        self
    }

    /// Sets the value of [category][crate::model::Violation::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Violation::state].
    pub fn set_state<T: std::convert::Into<crate::model::violation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [non_compliant_org_policy][crate::model::Violation::non_compliant_org_policy].
    pub fn set_non_compliant_org_policy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.non_compliant_org_policy = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Violation::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::Violation::remediation].
    pub fn set_remediation<
        T: std::convert::Into<std::option::Option<crate::model::violation::Remediation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.remediation = v.into();
        self
    }
}

impl wkt::message::Message for Violation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation"
    }
}

/// Defines additional types related to Violation
pub mod violation {
    #[allow(unused_imports)]
    use super::*;

    /// Represents remediation guidance to resolve compliance violation for
    /// AssuredWorkload
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Remediation {
        /// Required. Remediation instructions to resolve violations
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub instructions: std::option::Option<crate::model::violation::remediation::Instructions>,

        /// Values that can resolve the violation
        /// For example: for list org policy violations, this will either be the list
        /// of allowed or denied values
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub compliant_values: std::vec::Vec<std::string::String>,

        /// Output only. Remediation type based on the type of org policy values
        /// violated
        pub remediation_type: crate::model::violation::remediation::RemediationType,
    }

    impl Remediation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instructions][crate::model::violation::Remediation::instructions].
        pub fn set_instructions<
            T: std::convert::Into<
                std::option::Option<crate::model::violation::remediation::Instructions>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.instructions = v.into();
            self
        }

        /// Sets the value of [remediation_type][crate::model::violation::Remediation::remediation_type].
        pub fn set_remediation_type<
            T: std::convert::Into<crate::model::violation::remediation::RemediationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.remediation_type = v.into();
            self
        }

        /// Sets the value of [compliant_values][crate::model::violation::Remediation::compliant_values].
        pub fn set_compliant_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.compliant_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Remediation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation"
        }
    }

    /// Defines additional types related to Remediation
    pub mod remediation {
        #[allow(unused_imports)]
        use super::*;

        /// Instructions to remediate violation
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Instructions {
            /// Remediation instructions to resolve violation via gcloud cli
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub gcloud_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Gcloud>,

            /// Remediation instructions to resolve violation via cloud console
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub console_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Console>,
        }

        impl Instructions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gcloud_instructions][crate::model::violation::remediation::Instructions::gcloud_instructions].
            pub fn set_gcloud_instructions<
                T: std::convert::Into<
                    std::option::Option<crate::model::violation::remediation::instructions::Gcloud>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.gcloud_instructions = v.into();
                self
            }

            /// Sets the value of [console_instructions][crate::model::violation::remediation::Instructions::console_instructions].
            pub fn set_console_instructions<
                T: std::convert::Into<
                    std::option::Option<
                        crate::model::violation::remediation::instructions::Console,
                    >,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.console_instructions = v.into();
                self
            }
        }

        impl wkt::message::Message for Instructions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions"
            }
        }

        /// Defines additional types related to Instructions
        pub mod instructions {
            #[allow(unused_imports)]
            use super::*;

            /// Remediation instructions to resolve violation via gcloud cli
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Gcloud {
                /// Gcloud command to resolve violation
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub gcloud_commands: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via gcloud cli
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub additional_links: std::vec::Vec<std::string::String>,
            }

            impl Gcloud {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [gcloud_commands][crate::model::violation::remediation::instructions::Gcloud::gcloud_commands].
                pub fn set_gcloud_commands<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gcloud_commands = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Gcloud::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Gcloud::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Gcloud {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Gcloud"
                }
            }

            /// Remediation instructions to resolve violation via cloud console
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Console {
                /// Link to console page where violations can be resolved
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub console_uris: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via cloud console
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub additional_links: std::vec::Vec<std::string::String>,
            }

            impl Console {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [console_uris][crate::model::violation::remediation::instructions::Console::console_uris].
                pub fn set_console_uris<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.console_uris = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Console::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Console::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Console {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Console"
                }
            }
        }

        /// Classifying remediation into various types based on the kind of
        /// violation. For example, violations caused due to changes in boolean org
        /// policy requires different remediation instructions compared to violation
        /// caused due to changes in allowed values of list org policy.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct RemediationType(std::borrow::Cow<'static, str>);

        impl RemediationType {
            /// Creates a new RemediationType instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [RemediationType](RemediationType)
        pub mod remediation_type {
            use super::RemediationType;

            /// Unspecified remediation type
            pub const REMEDIATION_TYPE_UNSPECIFIED: RemediationType =
                RemediationType::new("REMEDIATION_TYPE_UNSPECIFIED");

            /// Remediation type for boolean org policy
            pub const REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION: RemediationType =
                RemediationType::new("REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION");

            /// Remediation type for list org policy which have allowed values in the
            /// monitoring rule
            pub const REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION: RemediationType =
                RemediationType::new("REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION");

            /// Remediation type for list org policy which have denied values in the
            /// monitoring rule
            pub const REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION: RemediationType =
                RemediationType::new("REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION");

            /// Remediation type for gcp.restrictCmekCryptoKeyProjects
            pub const REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION:
                RemediationType = RemediationType::new(
                "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION",
            );

            /// Remediation type for resource violation.
            pub const REMEDIATION_RESOURCE_VIOLATION: RemediationType =
                RemediationType::new("REMEDIATION_RESOURCE_VIOLATION");
        }

        impl std::convert::From<std::string::String> for RemediationType {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        impl std::default::Default for RemediationType {
            fn default() -> Self {
                remediation_type::REMEDIATION_TYPE_UNSPECIFIED
            }
        }
    }

    /// Violation State Values
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// Violation is resolved.
        pub const RESOLVED: State = State::new("RESOLVED");

        /// Violation is Unresolved
        pub const UNRESOLVED: State = State::new("UNRESOLVED");

        /// Violation is Exception
        pub const EXCEPTION: State = State::new("EXCEPTION");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }
}

/// Message for requesting list of Violations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViolationsRequest {
    /// Required. Parent resource
    /// Format
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of customers row to return. The service may
    /// return fewer than this value. If unspecified, at most 10 customers will be
    /// returned.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListViolations` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. Specifies the interval for retrieving violations.
    /// if unspecified, all violations will be returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<gtype::model::Interval>,
}

impl ListViolationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViolationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViolationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViolationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListViolationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListViolationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListViolationsRequest::interval].
    pub fn set_interval<T: std::convert::Into<std::option::Option<gtype::model::Interval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.interval = v.into();
        self
    }
}

impl wkt::message::Message for ListViolationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsRequest"
    }
}

/// Response message for list customer violation requests
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViolationsResponse {
    /// List of violation
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub violations: std::vec::Vec<crate::model::Violation>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Workloads that could not be reached due to permission errors or any other
    /// error. Ref: <https://google.aip.dev/217>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListViolationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListViolationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [violations][crate::model::ListViolationsResponse::violations].
    pub fn set_violations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Violation>,
    {
        use std::iter::Iterator;
        self.violations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListViolationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListViolationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListViolationsResponse {
    type PageItem = crate::model::Violation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.violations
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for getting a Violation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetViolationRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetViolationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViolationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViolationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetViolationRequest"
    }
}

/// Enum for possible completion states.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct CompletionState(std::borrow::Cow<'static, str>);

impl CompletionState {
    /// Creates a new CompletionState instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [CompletionState](CompletionState)
pub mod completion_state {
    use super::CompletionState;

    /// Unspecified completion state.
    pub const COMPLETION_STATE_UNSPECIFIED: CompletionState =
        CompletionState::new("COMPLETION_STATE_UNSPECIFIED");

    /// Task started (has start date) but not yet completed.
    pub const PENDING: CompletionState = CompletionState::new("PENDING");

    /// Succeeded state.
    pub const SUCCEEDED: CompletionState = CompletionState::new("SUCCEEDED");

    /// Failed state.
    pub const FAILED: CompletionState = CompletionState::new("FAILED");

    /// Not applicable state.
    pub const NOT_APPLICABLE: CompletionState = CompletionState::new("NOT_APPLICABLE");
}

impl std::convert::From<std::string::String> for CompletionState {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for CompletionState {
    fn default() -> Self {
        completion_state::COMPLETION_STATE_UNSPECIFIED
    }
}
