// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Details about the Access request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessApprovalRequest {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/accessApprovalRequests/{access_approval_request}`
    pub name: std::string::String,

    /// The time at which approval was requested.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The justification for which approval is being requested.
    pub requested_reason: std::option::Option<crate::model::AccessReason>,

    /// The requested expiration for the approval. If the request is approved,
    /// access will be granted from the time of approval until the expiration time.
    pub requested_expiration_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessApprovalRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessApprovalRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::AccessApprovalRequest::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::AccessApprovalRequest::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_reason][crate::model::AccessApprovalRequest::requested_reason].
    pub fn set_requested_reason<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessReason>,
    {
        self.requested_reason = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_reason][crate::model::AccessApprovalRequest::requested_reason].
    pub fn set_or_clear_requested_reason<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessReason>,
    {
        self.requested_reason = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_expiration_time][crate::model::AccessApprovalRequest::requested_expiration_time].
    pub fn set_requested_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.requested_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_expiration_time][crate::model::AccessApprovalRequest::requested_expiration_time].
    pub fn set_or_clear_requested_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.requested_expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AccessApprovalRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessApprovalRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessApprovalRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_time,
            __requested_reason,
            __requested_expiration_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessApprovalRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "requestedReason" => Ok(__FieldTag::__requested_reason),
                            "requested_reason" => Ok(__FieldTag::__requested_reason),
                            "requestedExpirationTime" => {
                                Ok(__FieldTag::__requested_expiration_time)
                            }
                            "requested_expiration_time" => {
                                Ok(__FieldTag::__requested_expiration_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessApprovalRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessApprovalRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__requested_reason => {
                            if !fields.insert(__FieldTag::__requested_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_reason",
                                ));
                            }
                            result.requested_reason = map
                                .next_value::<std::option::Option<crate::model::AccessReason>>()?;
                        }
                        __FieldTag::__requested_expiration_time => {
                            if !fields.insert(__FieldTag::__requested_expiration_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_expiration_time",
                                ));
                            }
                            result.requested_expiration_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessApprovalRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.requested_reason.is_some() {
            state.serialize_entry("requestedReason", &self.requested_reason)?;
        }
        if self.requested_expiration_time.is_some() {
            state.serialize_entry("requestedExpirationTime", &self.requested_expiration_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for getting the access requests associated with a workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    pub parent: std::string::String,

    /// Optional. The maximum number of access requests to return. The service may
    /// return fewer than this value. If unspecified, at most 500 access requests
    /// will be returned.
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListAccessApprovalRequests` call. Provide this to retrieve the subsequent
    /// page.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAccessApprovalRequestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAccessApprovalRequestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAccessApprovalRequestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAccessApprovalRequestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAccessApprovalRequestsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAccessApprovalRequestsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAccessApprovalRequestsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAccessApprovalRequestsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAccessApprovalRequestsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAccessApprovalRequestsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAccessApprovalRequestsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for list access requests.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsResponse {
    /// List of access approval requests
    pub access_approval_requests: std::vec::Vec<crate::model::AccessApprovalRequest>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAccessApprovalRequestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_approval_requests][crate::model::ListAccessApprovalRequestsResponse::access_approval_requests].
    pub fn set_access_approval_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessApprovalRequest>,
    {
        use std::iter::Iterator;
        self.access_approval_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAccessApprovalRequestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAccessApprovalRequestsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAccessApprovalRequestsResponse {
    type PageItem = crate::model::AccessApprovalRequest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.access_approval_requests
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAccessApprovalRequestsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_approval_requests,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAccessApprovalRequestsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessApprovalRequests" => Ok(__FieldTag::__access_approval_requests),
                            "access_approval_requests" => {
                                Ok(__FieldTag::__access_approval_requests)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAccessApprovalRequestsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAccessApprovalRequestsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_approval_requests => {
                            if !fields.insert(__FieldTag::__access_approval_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_approval_requests",
                                ));
                            }
                            result.access_approval_requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AccessApprovalRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAccessApprovalRequestsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_approval_requests.is_empty() {
            state.serialize_entry("accessApprovalRequests", &self.access_approval_requests)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Reason for the access.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessReason {
    /// Type of access justification.
    pub r#type: crate::model::access_reason::Type,

    /// More detail about certain reason types. See comments for each type above.
    pub detail: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AccessReason::type].
    pub fn set_type<T: std::convert::Into<crate::model::access_reason::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::AccessReason::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for AccessReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessReason"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __detail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessReason")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "detail" => Ok(__FieldTag::__detail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessReason;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessReason")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::access_reason::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccessReason].
pub mod access_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Type of access justification.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value for proto, shouldn't be used.
        Unspecified,
        /// Customer made a request or raised an issue that required the principal to
        /// access customer data. `detail` is of the form ("#####" is the issue ID):
        ///
        /// - "Feedback Report: #####"
        /// - "Case Number: #####"
        /// - "Case ID: #####"
        /// - "E-PIN Reference: #####"
        /// - "Google-#####"
        /// - "T-#####"
        CustomerInitiatedSupport,
        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services. Often this access is used to confirm that
        /// customers are not affected by a suspected service issue or to remediate a
        /// reversible system issue.
        GoogleInitiatedService,
        /// Google initiated service for security, fraud, abuse, or compliance
        /// purposes.
        GoogleInitiatedReview,
        /// The principal was compelled to access customer data in order to respond
        /// to a legal third party data request or process, including legal processes
        /// from customers themselves.
        ThirdPartyDataRequest,
        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services or a known outage.
        GoogleResponseToProductionAlert,
        /// Similar to 'GOOGLE_INITIATED_SERVICE' or 'GOOGLE_INITIATED_REVIEW', but
        /// with universe agnostic naming. The principal accessed customer data in
        /// order to diagnose or resolve a suspected issue in services or a known
        /// outage, or for security, fraud, abuse, or compliance review purposes.
        CloudInitiatedAccess,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CustomerInitiatedSupport => std::option::Option::Some(1),
                Self::GoogleInitiatedService => std::option::Option::Some(2),
                Self::GoogleInitiatedReview => std::option::Option::Some(3),
                Self::ThirdPartyDataRequest => std::option::Option::Some(4),
                Self::GoogleResponseToProductionAlert => std::option::Option::Some(5),
                Self::CloudInitiatedAccess => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::CustomerInitiatedSupport => {
                    std::option::Option::Some("CUSTOMER_INITIATED_SUPPORT")
                }
                Self::GoogleInitiatedService => {
                    std::option::Option::Some("GOOGLE_INITIATED_SERVICE")
                }
                Self::GoogleInitiatedReview => std::option::Option::Some("GOOGLE_INITIATED_REVIEW"),
                Self::ThirdPartyDataRequest => {
                    std::option::Option::Some("THIRD_PARTY_DATA_REQUEST")
                }
                Self::GoogleResponseToProductionAlert => {
                    std::option::Option::Some("GOOGLE_RESPONSE_TO_PRODUCTION_ALERT")
                }
                Self::CloudInitiatedAccess => std::option::Option::Some("CLOUD_INITIATED_ACCESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CustomerInitiatedSupport,
                2 => Self::GoogleInitiatedService,
                3 => Self::GoogleInitiatedReview,
                4 => Self::ThirdPartyDataRequest,
                5 => Self::GoogleResponseToProductionAlert,
                6 => Self::CloudInitiatedAccess,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOMER_INITIATED_SUPPORT" => Self::CustomerInitiatedSupport,
                "GOOGLE_INITIATED_SERVICE" => Self::GoogleInitiatedService,
                "GOOGLE_INITIATED_REVIEW" => Self::GoogleInitiatedReview,
                "THIRD_PARTY_DATA_REQUEST" => Self::ThirdPartyDataRequest,
                "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT" => Self::GoogleResponseToProductionAlert,
                "CLOUD_INITIATED_ACCESS" => Self::CloudInitiatedAccess,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CustomerInitiatedSupport => serializer.serialize_i32(1),
                Self::GoogleInitiatedService => serializer.serialize_i32(2),
                Self::GoogleInitiatedReview => serializer.serialize_i32(3),
                Self::ThirdPartyDataRequest => serializer.serialize_i32(4),
                Self::GoogleResponseToProductionAlert => serializer.serialize_i32(5),
                Self::CloudInitiatedAccess => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.cloudcontrolspartner.v1.AccessReason.Type",
            ))
        }
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][google.longrunning.Operation.error] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains metadata around the [Workload
/// resource](https://cloud.google.com/assured-workloads/docs/reference/rest/Shared.Types/Workload)
/// in the Assured Workloads API.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Workload {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    pub name: std::string::String,

    /// Output only. Folder id this workload is associated with
    pub folder_id: i64,

    /// Output only. Time the resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of container folder of the assured workload
    pub folder: std::string::String,

    /// Container for workload onboarding steps.
    pub workload_onboarding_state: std::option::Option<crate::model::WorkloadOnboardingState>,

    /// Indicates whether a workload is fully onboarded.
    pub is_onboarded: bool,

    /// The project id of the key management project for the workload
    pub key_management_project_id: std::string::String,

    /// The Google Cloud location of the workload
    pub location: std::string::String,

    /// Partner associated with this workload.
    pub partner: crate::model::workload::Partner,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Workload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Workload::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Workload::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Workload::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Workload::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [folder][crate::model::Workload::folder].
    pub fn set_folder<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.folder = v.into();
        self
    }

    /// Sets the value of [workload_onboarding_state][crate::model::Workload::workload_onboarding_state].
    pub fn set_workload_onboarding_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadOnboardingState>,
    {
        self.workload_onboarding_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_onboarding_state][crate::model::Workload::workload_onboarding_state].
    pub fn set_or_clear_workload_onboarding_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadOnboardingState>,
    {
        self.workload_onboarding_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Workload::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }

    /// Sets the value of [key_management_project_id][crate::model::Workload::key_management_project_id].
    pub fn set_key_management_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_management_project_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Workload::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [partner][crate::model::Workload::partner].
    pub fn set_partner<T: std::convert::Into<crate::model::workload::Partner>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner = v.into();
        self
    }
}

impl wkt::message::Message for Workload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Workload"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Workload {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __folder_id,
            __create_time,
            __folder,
            __workload_onboarding_state,
            __is_onboarded,
            __key_management_project_id,
            __location,
            __partner,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Workload")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "folderId" => Ok(__FieldTag::__folder_id),
                            "folder_id" => Ok(__FieldTag::__folder_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "folder" => Ok(__FieldTag::__folder),
                            "workloadOnboardingState" => {
                                Ok(__FieldTag::__workload_onboarding_state)
                            }
                            "workload_onboarding_state" => {
                                Ok(__FieldTag::__workload_onboarding_state)
                            }
                            "isOnboarded" => Ok(__FieldTag::__is_onboarded),
                            "is_onboarded" => Ok(__FieldTag::__is_onboarded),
                            "keyManagementProjectId" => Ok(__FieldTag::__key_management_project_id),
                            "key_management_project_id" => {
                                Ok(__FieldTag::__key_management_project_id)
                            }
                            "location" => Ok(__FieldTag::__location),
                            "partner" => Ok(__FieldTag::__partner),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Workload;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Workload")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__folder_id => {
                            if !fields.insert(__FieldTag::__folder_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folder_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.folder_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__folder => {
                            if !fields.insert(__FieldTag::__folder) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folder",
                                ));
                            }
                            result.folder = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_onboarding_state => {
                            if !fields.insert(__FieldTag::__workload_onboarding_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_onboarding_state",
                                ));
                            }
                            result.workload_onboarding_state = map.next_value::<std::option::Option<crate::model::WorkloadOnboardingState>>()?
                                ;
                        }
                        __FieldTag::__is_onboarded => {
                            if !fields.insert(__FieldTag::__is_onboarded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_onboarded",
                                ));
                            }
                            result.is_onboarded = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_management_project_id => {
                            if !fields.insert(__FieldTag::__key_management_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_management_project_id",
                                ));
                            }
                            result.key_management_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partner => {
                            if !fields.insert(__FieldTag::__partner) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partner",
                                ));
                            }
                            result.partner = map
                                .next_value::<std::option::Option<crate::model::workload::Partner>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Workload {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.folder_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("folderId", &__With(&self.folder_id))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.folder.is_empty() {
            state.serialize_entry("folder", &self.folder)?;
        }
        if self.workload_onboarding_state.is_some() {
            state.serialize_entry("workloadOnboardingState", &self.workload_onboarding_state)?;
        }
        if !wkt::internal::is_default(&self.is_onboarded) {
            state.serialize_entry("isOnboarded", &self.is_onboarded)?;
        }
        if !self.key_management_project_id.is_empty() {
            state.serialize_entry("keyManagementProjectId", &self.key_management_project_id)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.partner) {
            state.serialize_entry("partner", &self.partner)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Workload].
pub mod workload {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Assured Workloads Partners.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Partner {
        /// Unknown Partner.
        Unspecified,
        /// Enum representing S3NS (Thales) partner.
        LocalControlsByS3Ns,
        /// Enum representing T_SYSTEM (TSI) partner.
        SovereignControlsByTSystems,
        /// Enum representing SIA_MINSAIT (Indra) partner.
        SovereignControlsBySiaMinsait,
        /// Enum representing PSN (TIM) partner.
        SovereignControlsByPsn,
        /// Enum representing CNTXT (Kingdom of Saudi Arabia) partner.
        SovereignControlsByCntxt,
        /// Enum representing CNXT (Kingdom of Saudi Arabia) partner offering without
        /// EKM provisioning.
        SovereignControlsByCntxtNoEkm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Partner::value] or
        /// [Partner::name].
        UnknownValue(partner::UnknownValue),
    }

    #[doc(hidden)]
    pub mod partner {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Partner {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LocalControlsByS3Ns => std::option::Option::Some(1),
                Self::SovereignControlsByTSystems => std::option::Option::Some(2),
                Self::SovereignControlsBySiaMinsait => std::option::Option::Some(3),
                Self::SovereignControlsByPsn => std::option::Option::Some(4),
                Self::SovereignControlsByCntxt => std::option::Option::Some(6),
                Self::SovereignControlsByCntxtNoEkm => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PARTNER_UNSPECIFIED"),
                Self::LocalControlsByS3Ns => {
                    std::option::Option::Some("PARTNER_LOCAL_CONTROLS_BY_S3NS")
                }
                Self::SovereignControlsByTSystems => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS")
                }
                Self::SovereignControlsBySiaMinsait => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT")
                }
                Self::SovereignControlsByPsn => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_PSN")
                }
                Self::SovereignControlsByCntxt => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT")
                }
                Self::SovereignControlsByCntxtNoEkm => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Partner {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Partner {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Partner {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LocalControlsByS3Ns,
                2 => Self::SovereignControlsByTSystems,
                3 => Self::SovereignControlsBySiaMinsait,
                4 => Self::SovereignControlsByPsn,
                6 => Self::SovereignControlsByCntxt,
                7 => Self::SovereignControlsByCntxtNoEkm,
                _ => Self::UnknownValue(partner::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Partner {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PARTNER_UNSPECIFIED" => Self::Unspecified,
                "PARTNER_LOCAL_CONTROLS_BY_S3NS" => Self::LocalControlsByS3Ns,
                "PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS" => Self::SovereignControlsByTSystems,
                "PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT" => Self::SovereignControlsBySiaMinsait,
                "PARTNER_SOVEREIGN_CONTROLS_BY_PSN" => Self::SovereignControlsByPsn,
                "PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT" => Self::SovereignControlsByCntxt,
                "PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM" => Self::SovereignControlsByCntxtNoEkm,
                _ => Self::UnknownValue(partner::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Partner {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LocalControlsByS3Ns => serializer.serialize_i32(1),
                Self::SovereignControlsByTSystems => serializer.serialize_i32(2),
                Self::SovereignControlsBySiaMinsait => serializer.serialize_i32(3),
                Self::SovereignControlsByPsn => serializer.serialize_i32(4),
                Self::SovereignControlsByCntxt => serializer.serialize_i32(6),
                Self::SovereignControlsByCntxtNoEkm => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Partner {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Partner>::new(
                ".google.cloud.cloudcontrolspartner.v1.Workload.Partner",
            ))
        }
    }
}

/// Request to list customer workloads.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkloadsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    pub parent: std::string::String,

    /// The maximum number of workloads to return. The service may return fewer
    /// than this value. If unspecified, at most 500 workloads will be returned.
    pub page_size: i32,

    /// A page token, received from a previous `ListWorkloads` call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkloadsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkloadsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkloadsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkloadsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkloadsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListWorkloadsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkloadsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkloadsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkloadsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkloadsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkloadsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkloadsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for list customer workloads requests.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkloadsResponse {
    /// List of customer workloads
    pub workloads: std::vec::Vec<crate::model::Workload>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkloadsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workloads][crate::model::ListWorkloadsResponse::workloads].
    pub fn set_workloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workload>,
    {
        use std::iter::Iterator;
        self.workloads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkloadsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkloadsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkloadsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkloadsResponse {
    type PageItem = crate::model::Workload;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workloads
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkloadsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workloads,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkloadsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workloads" => Ok(__FieldTag::__workloads),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkloadsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkloadsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workloads => {
                            if !fields.insert(__FieldTag::__workloads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workloads",
                                ));
                            }
                            result.workloads = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Workload>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkloadsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workloads.is_empty() {
            state.serialize_entry("workloads", &self.workloads)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a customer workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkloadRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkloadRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkloadRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkloadRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetWorkloadRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkloadRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkloadRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkloadRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkloadRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkloadRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Container for workload onboarding steps.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkloadOnboardingState {
    /// List of workload onboarding steps.
    pub onboarding_steps: std::vec::Vec<crate::model::WorkloadOnboardingStep>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::WorkloadOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkloadOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingState"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkloadOnboardingState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __onboarding_steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadOnboardingState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "onboardingSteps" => Ok(__FieldTag::__onboarding_steps),
                            "onboarding_steps" => Ok(__FieldTag::__onboarding_steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkloadOnboardingState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadOnboardingState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__onboarding_steps => {
                            if !fields.insert(__FieldTag::__onboarding_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for onboarding_steps",
                                ));
                            }
                            result.onboarding_steps = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkloadOnboardingStep>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkloadOnboardingState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.onboarding_steps.is_empty() {
            state.serialize_entry("onboardingSteps", &self.onboarding_steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Container for workload onboarding information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkloadOnboardingStep {
    /// The onboarding step.
    pub step: crate::model::workload_onboarding_step::Step,

    /// The starting time of the onboarding step.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step.
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The completion state of the onboarding step.
    pub completion_state: crate::model::CompletionState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::WorkloadOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::workload_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::WorkloadOnboardingStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::WorkloadOnboardingStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_time][crate::model::WorkloadOnboardingStep::completion_time].
    pub fn set_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_time][crate::model::WorkloadOnboardingStep::completion_time].
    pub fn set_or_clear_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_state][crate::model::WorkloadOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkloadOnboardingStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __step,
            __start_time,
            __completion_time,
            __completion_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadOnboardingStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "step" => Ok(__FieldTag::__step),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "completionTime" => Ok(__FieldTag::__completion_time),
                            "completion_time" => Ok(__FieldTag::__completion_time),
                            "completionState" => Ok(__FieldTag::__completion_state),
                            "completion_state" => Ok(__FieldTag::__completion_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkloadOnboardingStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadOnboardingStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__step => {
                            if !fields.insert(__FieldTag::__step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step",
                                ));
                            }
                            result.step =
                                map.next_value::<std::option::Option<
                                    crate::model::workload_onboarding_step::Step,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_time => {
                            if !fields.insert(__FieldTag::__completion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_time",
                                ));
                            }
                            result.completion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_state => {
                            if !fields.insert(__FieldTag::__completion_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_state",
                                ));
                            }
                            result.completion_state = map
                                .next_value::<std::option::Option<crate::model::CompletionState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkloadOnboardingStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.step) {
            state.serialize_entry("step", &self.step)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.completion_time.is_some() {
            state.serialize_entry("completionTime", &self.completion_time)?;
        }
        if !wkt::internal::is_default(&self.completion_state) {
            state.serialize_entry("completionState", &self.completion_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkloadOnboardingStep].
pub mod workload_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Unspecified step.
        Unspecified,
        /// EKM Provisioned step.
        EkmProvisioned,
        /// Signed Access Approval step.
        SignedAccessApprovalConfigured,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Step::value] or
        /// [Step::name].
        UnknownValue(step::UnknownValue),
    }

    #[doc(hidden)]
    pub mod step {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Step {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EkmProvisioned => std::option::Option::Some(1),
                Self::SignedAccessApprovalConfigured => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STEP_UNSPECIFIED"),
                Self::EkmProvisioned => std::option::Option::Some("EKM_PROVISIONED"),
                Self::SignedAccessApprovalConfigured => {
                    std::option::Option::Some("SIGNED_ACCESS_APPROVAL_CONFIGURED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Step {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Step {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EkmProvisioned,
                2 => Self::SignedAccessApprovalConfigured,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Step {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STEP_UNSPECIFIED" => Self::Unspecified,
                "EKM_PROVISIONED" => Self::EkmProvisioned,
                "SIGNED_ACCESS_APPROVAL_CONFIGURED" => Self::SignedAccessApprovalConfigured,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Step {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EkmProvisioned => serializer.serialize_i32(1),
                Self::SignedAccessApprovalConfigured => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Step {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Step>::new(
                ".google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingStep.Step",
            ))
        }
    }
}

/// Contains metadata around a Cloud Controls Partner Customer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Customer {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    pub name: std::string::String,

    /// Required. Display name for the customer
    pub display_name: std::string::String,

    /// Output only. Container for customer onboarding steps
    pub customer_onboarding_state: std::option::Option<crate::model::CustomerOnboardingState>,

    /// Output only. Indicates whether a customer is fully onboarded
    pub is_onboarded: bool,

    /// Output only. The customer organization domain, extracted from
    /// CRM Organizations display_name field. e.g. "google.com"
    pub organization_domain: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Customer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Customer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Customer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [customer_onboarding_state][crate::model::Customer::customer_onboarding_state].
    pub fn set_customer_onboarding_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerOnboardingState>,
    {
        self.customer_onboarding_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer_onboarding_state][crate::model::Customer::customer_onboarding_state].
    pub fn set_or_clear_customer_onboarding_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerOnboardingState>,
    {
        self.customer_onboarding_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Customer::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }

    /// Sets the value of [organization_domain][crate::model::Customer::organization_domain].
    pub fn set_organization_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.organization_domain = v.into();
        self
    }
}

impl wkt::message::Message for Customer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Customer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Customer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __customer_onboarding_state,
            __is_onboarded,
            __organization_domain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Customer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "customerOnboardingState" => {
                                Ok(__FieldTag::__customer_onboarding_state)
                            }
                            "customer_onboarding_state" => {
                                Ok(__FieldTag::__customer_onboarding_state)
                            }
                            "isOnboarded" => Ok(__FieldTag::__is_onboarded),
                            "is_onboarded" => Ok(__FieldTag::__is_onboarded),
                            "organizationDomain" => Ok(__FieldTag::__organization_domain),
                            "organization_domain" => Ok(__FieldTag::__organization_domain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Customer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Customer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customer_onboarding_state => {
                            if !fields.insert(__FieldTag::__customer_onboarding_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_onboarding_state",
                                ));
                            }
                            result.customer_onboarding_state = map.next_value::<std::option::Option<crate::model::CustomerOnboardingState>>()?
                                ;
                        }
                        __FieldTag::__is_onboarded => {
                            if !fields.insert(__FieldTag::__is_onboarded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_onboarded",
                                ));
                            }
                            result.is_onboarded = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__organization_domain => {
                            if !fields.insert(__FieldTag::__organization_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization_domain",
                                ));
                            }
                            result.organization_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Customer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.customer_onboarding_state.is_some() {
            state.serialize_entry("customerOnboardingState", &self.customer_onboarding_state)?;
        }
        if !wkt::internal::is_default(&self.is_onboarded) {
            state.serialize_entry("isOnboarded", &self.is_onboarded)?;
        }
        if !self.organization_domain.is_empty() {
            state.serialize_entry("organizationDomain", &self.organization_domain)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to list customers
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomersRequest {
    /// Required. Parent resource
    /// Format: `organizations/{organization}/locations/{location}`
    pub parent: std::string::String,

    /// The maximum number of Customers to return. The service may return fewer
    /// than this value. If unspecified, at most 500 Customers will be returned.
    pub page_size: i32,

    /// A page token, received from a previous `ListCustomers` call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCustomersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for list customer Customers requests
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomersResponse {
    /// List of customers
    pub customers: std::vec::Vec<crate::model::Customer>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [customers][crate::model::ListCustomersResponse::customers].
    pub fn set_customers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Customer>,
    {
        use std::iter::Iterator;
        self.customers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCustomersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomersResponse {
    type PageItem = crate::model::Customer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.customers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __customers,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customers" => Ok(__FieldTag::__customers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__customers => {
                            if !fields.insert(__FieldTag::__customers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customers",
                                ));
                            }
                            result.customers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Customer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.customers.is_empty() {
            state.serialize_entry("customers", &self.customers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to create a customer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCustomerRequest {
    /// Required. Parent resource
    /// Format: `organizations/{organization}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The customer to create.
    pub customer: std::option::Option<crate::model::Customer>,

    /// Required. The customer id to use for the customer, which will become the
    /// final component of the customer's resource name. The specified value must
    /// be a valid Google cloud organization id.
    pub customer_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [customer][crate::model::CreateCustomerRequest::customer].
    pub fn set_customer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer][crate::model::CreateCustomerRequest::customer].
    pub fn set_or_clear_customer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_id][crate::model::CreateCustomerRequest::customer_id].
    pub fn set_customer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.customer_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CreateCustomerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCustomerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __customer,
            __customer_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCustomerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "customer" => Ok(__FieldTag::__customer),
                            "customerId" => Ok(__FieldTag::__customer_id),
                            "customer_id" => Ok(__FieldTag::__customer_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCustomerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCustomerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customer => {
                            if !fields.insert(__FieldTag::__customer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer",
                                ));
                            }
                            result.customer =
                                map.next_value::<std::option::Option<crate::model::Customer>>()?;
                        }
                        __FieldTag::__customer_id => {
                            if !fields.insert(__FieldTag::__customer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer_id",
                                ));
                            }
                            result.customer_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCustomerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.customer.is_some() {
            state.serialize_entry("customer", &self.customer)?;
        }
        if !self.customer_id.is_empty() {
            state.serialize_entry("customerId", &self.customer_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a customer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCustomerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetCustomerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCustomerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCustomerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCustomerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCustomerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCustomerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Container for customer onboarding steps
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerOnboardingState {
    /// List of customer onboarding steps
    pub onboarding_steps: std::vec::Vec<crate::model::CustomerOnboardingStep>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::CustomerOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingState"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomerOnboardingState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __onboarding_steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerOnboardingState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "onboardingSteps" => Ok(__FieldTag::__onboarding_steps),
                            "onboarding_steps" => Ok(__FieldTag::__onboarding_steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomerOnboardingState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerOnboardingState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__onboarding_steps => {
                            if !fields.insert(__FieldTag::__onboarding_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for onboarding_steps",
                                ));
                            }
                            result.onboarding_steps = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomerOnboardingStep>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomerOnboardingState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.onboarding_steps.is_empty() {
            state.serialize_entry("onboardingSteps", &self.onboarding_steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Container for customer onboarding information
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerOnboardingStep {
    /// The onboarding step
    pub step: crate::model::customer_onboarding_step::Step,

    /// The starting time of the onboarding step
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Current state of the step
    pub completion_state: crate::model::CompletionState,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::CustomerOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::customer_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CustomerOnboardingStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CustomerOnboardingStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_time][crate::model::CustomerOnboardingStep::completion_time].
    pub fn set_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_time][crate::model::CustomerOnboardingStep::completion_time].
    pub fn set_or_clear_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_state][crate::model::CustomerOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomerOnboardingStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __step,
            __start_time,
            __completion_time,
            __completion_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomerOnboardingStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "step" => Ok(__FieldTag::__step),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "completionTime" => Ok(__FieldTag::__completion_time),
                            "completion_time" => Ok(__FieldTag::__completion_time),
                            "completionState" => Ok(__FieldTag::__completion_state),
                            "completion_state" => Ok(__FieldTag::__completion_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomerOnboardingStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomerOnboardingStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__step => {
                            if !fields.insert(__FieldTag::__step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step",
                                ));
                            }
                            result.step =
                                map.next_value::<std::option::Option<
                                    crate::model::customer_onboarding_step::Step,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_time => {
                            if !fields.insert(__FieldTag::__completion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_time",
                                ));
                            }
                            result.completion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_state => {
                            if !fields.insert(__FieldTag::__completion_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_state",
                                ));
                            }
                            result.completion_state = map
                                .next_value::<std::option::Option<crate::model::CompletionState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomerOnboardingStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.step) {
            state.serialize_entry("step", &self.step)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.completion_time.is_some() {
            state.serialize_entry("completionTime", &self.completion_time)?;
        }
        if !wkt::internal::is_default(&self.completion_state) {
            state.serialize_entry("completionState", &self.completion_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CustomerOnboardingStep].
pub mod customer_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Unspecified step
        Unspecified,
        /// KAJ Enrollment
        KajEnrollment,
        /// Customer Environment
        CustomerEnvironment,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Step::value] or
        /// [Step::name].
        UnknownValue(step::UnknownValue),
    }

    #[doc(hidden)]
    pub mod step {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Step {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::KajEnrollment => std::option::Option::Some(1),
                Self::CustomerEnvironment => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STEP_UNSPECIFIED"),
                Self::KajEnrollment => std::option::Option::Some("KAJ_ENROLLMENT"),
                Self::CustomerEnvironment => std::option::Option::Some("CUSTOMER_ENVIRONMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Step {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Step {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::KajEnrollment,
                2 => Self::CustomerEnvironment,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Step {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STEP_UNSPECIFIED" => Self::Unspecified,
                "KAJ_ENROLLMENT" => Self::KajEnrollment,
                "CUSTOMER_ENVIRONMENT" => Self::CustomerEnvironment,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Step {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::KajEnrollment => serializer.serialize_i32(1),
                Self::CustomerEnvironment => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Step {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Step>::new(
                ".google.cloud.cloudcontrolspartner.v1.CustomerOnboardingStep.Step",
            ))
        }
    }
}

/// Request to update a customer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCustomerRequest {
    /// Required. The customer to update
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    pub customer: std::option::Option<crate::model::Customer>,

    /// Optional. The list of fields to update
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [customer][crate::model::UpdateCustomerRequest::customer].
    pub fn set_customer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer][crate::model::UpdateCustomerRequest::customer].
    pub fn set_or_clear_customer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCustomerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCustomerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.UpdateCustomerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCustomerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __customer,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCustomerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customer" => Ok(__FieldTag::__customer),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCustomerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCustomerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__customer => {
                            if !fields.insert(__FieldTag::__customer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customer",
                                ));
                            }
                            result.customer =
                                map.next_value::<std::option::Option<crate::model::Customer>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCustomerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.customer.is_some() {
            state.serialize_entry("customer", &self.customer)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting customer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCustomerRequest {
    /// Required. name of the resource to be deleted
    /// format: name=organizations/*/locations/*/customers/*
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.DeleteCustomerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCustomerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCustomerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCustomerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCustomerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCustomerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The EKM connections associated with a workload
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EkmConnections {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    pub name: std::string::String,

    /// The EKM connections associated with the workload
    pub ekm_connections: std::vec::Vec<crate::model::EkmConnection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmConnections {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConnections::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ekm_connections][crate::model::EkmConnections::ekm_connections].
    pub fn set_ekm_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmConnection>,
    {
        use std::iter::Iterator;
        self.ekm_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EkmConnections {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnections"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EkmConnections {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ekm_connections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EkmConnections")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ekmConnections" => Ok(__FieldTag::__ekm_connections),
                            "ekm_connections" => Ok(__FieldTag::__ekm_connections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EkmConnections;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EkmConnections")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ekm_connections => {
                            if !fields.insert(__FieldTag::__ekm_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_connections",
                                ));
                            }
                            result.ekm_connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EkmConnection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EkmConnections {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ekm_connections.is_empty() {
            state.serialize_entry("ekmConnections", &self.ekm_connections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for getting the EKM connections associated with a workload
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEkmConnectionsRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEkmConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConnectionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetEkmConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEkmConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEkmConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEkmConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEkmConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEkmConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Details about the EKM connection
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EkmConnection {
    /// Resource name of the EKM connection in the format:
    /// projects/{project}/locations/{location}/ekmConnections/{ekm_connection}
    pub connection_name: std::string::String,

    /// Output only. The connection state
    pub connection_state: crate::model::ekm_connection::ConnectionState,

    /// The connection error that occurred if any
    pub connection_error: std::option::Option<crate::model::ekm_connection::ConnectionError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_name][crate::model::EkmConnection::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [connection_state][crate::model::EkmConnection::connection_state].
    pub fn set_connection_state<
        T: std::convert::Into<crate::model::ekm_connection::ConnectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_state = v.into();
        self
    }

    /// Sets the value of [connection_error][crate::model::EkmConnection::connection_error].
    pub fn set_connection_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ekm_connection::ConnectionError>,
    {
        self.connection_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_error][crate::model::EkmConnection::connection_error].
    pub fn set_or_clear_connection_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ekm_connection::ConnectionError>,
    {
        self.connection_error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EkmConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EkmConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_name,
            __connection_state,
            __connection_error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EkmConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionName" => Ok(__FieldTag::__connection_name),
                            "connection_name" => Ok(__FieldTag::__connection_name),
                            "connectionState" => Ok(__FieldTag::__connection_state),
                            "connection_state" => Ok(__FieldTag::__connection_state),
                            "connectionError" => Ok(__FieldTag::__connection_error),
                            "connection_error" => Ok(__FieldTag::__connection_error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EkmConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EkmConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_name => {
                            if !fields.insert(__FieldTag::__connection_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_name",
                                ));
                            }
                            result.connection_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_state => {
                            if !fields.insert(__FieldTag::__connection_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_state",
                                ));
                            }
                            result.connection_state =
                                map.next_value::<std::option::Option<
                                    crate::model::ekm_connection::ConnectionState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_error => {
                            if !fields.insert(__FieldTag::__connection_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_error",
                                ));
                            }
                            result.connection_error = map.next_value::<std::option::Option<
                                crate::model::ekm_connection::ConnectionError,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EkmConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection_name.is_empty() {
            state.serialize_entry("connectionName", &self.connection_name)?;
        }
        if !wkt::internal::is_default(&self.connection_state) {
            state.serialize_entry("connectionState", &self.connection_state)?;
        }
        if self.connection_error.is_some() {
            state.serialize_entry("connectionError", &self.connection_error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EkmConnection].
pub mod ekm_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Information around the error that occurred if the connection state is
    /// anything other than available or unspecified
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConnectionError {
        /// The error domain for the error
        pub error_domain: std::string::String,

        /// The error message for the error
        pub error_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectionError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_domain][crate::model::ekm_connection::ConnectionError::error_domain].
        pub fn set_error_domain<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_domain = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::ekm_connection::ConnectionError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectionError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection.ConnectionError"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConnectionError {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __error_domain,
                __error_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConnectionError")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "errorDomain" => Ok(__FieldTag::__error_domain),
                                "error_domain" => Ok(__FieldTag::__error_domain),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConnectionError;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConnectionError")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__error_domain => {
                                if !fields.insert(__FieldTag::__error_domain) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_domain",
                                    ));
                                }
                                result.error_domain = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConnectionError {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.error_domain.is_empty() {
                state.serialize_entry("errorDomain", &self.error_domain)?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The EKM connection state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionState {
        /// Unspecified EKM connection state
        Unspecified,
        /// Available EKM connection state
        Available,
        /// Not available EKM connection state
        NotAvailable,
        /// Error EKM connection state
        Error,
        /// Permission denied EKM connection state
        PermissionDenied,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectionState::value] or
        /// [ConnectionState::name].
        UnknownValue(connection_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connection_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Available => std::option::Option::Some(1),
                Self::NotAvailable => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::PermissionDenied => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTION_STATE_UNSPECIFIED"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::NotAvailable => std::option::Option::Some("NOT_AVAILABLE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Available,
                2 => Self::NotAvailable,
                3 => Self::Error,
                4 => Self::PermissionDenied,
                _ => Self::UnknownValue(connection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConnectionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "AVAILABLE" => Self::Available,
                "NOT_AVAILABLE" => Self::NotAvailable,
                "ERROR" => Self::Error,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                _ => Self::UnknownValue(connection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConnectionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Available => serializer.serialize_i32(1),
                Self::NotAvailable => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::PermissionDenied => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionState>::new(
                ".google.cloud.cloudcontrolspartner.v1.EkmConnection.ConnectionState",
            ))
        }
    }
}

/// The permissions granted to the partner for a workload
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PartnerPermissions {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    pub name: std::string::String,

    /// The partner permissions granted for the workload
    pub partner_permissions: std::vec::Vec<crate::model::partner_permissions::Permission>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartnerPermissions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PartnerPermissions::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [partner_permissions][crate::model::PartnerPermissions::partner_permissions].
    pub fn set_partner_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::partner_permissions::Permission>,
    {
        use std::iter::Iterator;
        self.partner_permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PartnerPermissions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.PartnerPermissions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartnerPermissions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __partner_permissions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartnerPermissions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "partnerPermissions" => Ok(__FieldTag::__partner_permissions),
                            "partner_permissions" => Ok(__FieldTag::__partner_permissions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartnerPermissions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartnerPermissions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partner_permissions => {
                            if !fields.insert(__FieldTag::__partner_permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partner_permissions",
                                ));
                            }
                            result.partner_permissions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::partner_permissions::Permission>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartnerPermissions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.partner_permissions.is_empty() {
            state.serialize_entry("partnerPermissions", &self.partner_permissions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PartnerPermissions].
pub mod partner_permissions {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Permission {
        /// Unspecified partner permission
        Unspecified,
        /// Permission for Access Transparency and emergency logs
        AccessTransparencyAndEmergencyAccessLogs,
        /// Permission for Assured Workloads monitoring violations
        AssuredWorkloadsMonitoring,
        /// Permission for Access Approval requests
        AccessApprovalRequests,
        /// Permission for External Key Manager connection status
        AssuredWorkloadsEkmConnectionStatus,
        /// Permission for support case details for Access Transparency log entries
        AccessTransparencyLogsSupportCaseViewer,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Permission::value] or
        /// [Permission::name].
        UnknownValue(permission::UnknownValue),
    }

    #[doc(hidden)]
    pub mod permission {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Permission {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AccessTransparencyAndEmergencyAccessLogs => std::option::Option::Some(1),
                Self::AssuredWorkloadsMonitoring => std::option::Option::Some(2),
                Self::AccessApprovalRequests => std::option::Option::Some(3),
                Self::AssuredWorkloadsEkmConnectionStatus => std::option::Option::Some(4),
                Self::AccessTransparencyLogsSupportCaseViewer => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERMISSION_UNSPECIFIED"),
                Self::AccessTransparencyAndEmergencyAccessLogs => {
                    std::option::Option::Some("ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS")
                }
                Self::AssuredWorkloadsMonitoring => {
                    std::option::Option::Some("ASSURED_WORKLOADS_MONITORING")
                }
                Self::AccessApprovalRequests => {
                    std::option::Option::Some("ACCESS_APPROVAL_REQUESTS")
                }
                Self::AssuredWorkloadsEkmConnectionStatus => {
                    std::option::Option::Some("ASSURED_WORKLOADS_EKM_CONNECTION_STATUS")
                }
                Self::AccessTransparencyLogsSupportCaseViewer => {
                    std::option::Option::Some("ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Permission {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Permission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Permission {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AccessTransparencyAndEmergencyAccessLogs,
                2 => Self::AssuredWorkloadsMonitoring,
                3 => Self::AccessApprovalRequests,
                4 => Self::AssuredWorkloadsEkmConnectionStatus,
                5 => Self::AccessTransparencyLogsSupportCaseViewer,
                _ => Self::UnknownValue(permission::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Permission {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERMISSION_UNSPECIFIED" => Self::Unspecified,
                "ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS" => {
                    Self::AccessTransparencyAndEmergencyAccessLogs
                }
                "ASSURED_WORKLOADS_MONITORING" => Self::AssuredWorkloadsMonitoring,
                "ACCESS_APPROVAL_REQUESTS" => Self::AccessApprovalRequests,
                "ASSURED_WORKLOADS_EKM_CONNECTION_STATUS" => {
                    Self::AssuredWorkloadsEkmConnectionStatus
                }
                "ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER" => {
                    Self::AccessTransparencyLogsSupportCaseViewer
                }
                _ => Self::UnknownValue(permission::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Permission {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AccessTransparencyAndEmergencyAccessLogs => serializer.serialize_i32(1),
                Self::AssuredWorkloadsMonitoring => serializer.serialize_i32(2),
                Self::AccessApprovalRequests => serializer.serialize_i32(3),
                Self::AssuredWorkloadsEkmConnectionStatus => serializer.serialize_i32(4),
                Self::AccessTransparencyLogsSupportCaseViewer => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Permission {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Permission>::new(
                ".google.cloud.cloudcontrolspartner.v1.PartnerPermissions.Permission",
            ))
        }
    }
}

/// Request for getting the partner permissions granted for a workload
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPartnerPermissionsRequest {
    /// Required. Name of the resource to get in the format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPartnerPermissionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerPermissionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerPermissionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerPermissionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPartnerPermissionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPartnerPermissionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPartnerPermissionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPartnerPermissionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPartnerPermissionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing Partner resource
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Partner {
    /// Identifier. The resource name of the partner.
    /// Format: `organizations/{organization}/locations/{location}/partner`
    /// Example: "organizations/123456/locations/us-central1/partner"
    pub name: std::string::String,

    /// List of SKUs the partner is offering
    pub skus: std::vec::Vec<crate::model::Sku>,

    /// List of Google Cloud supported EKM partners supported by the partner
    pub ekm_solutions: std::vec::Vec<crate::model::EkmMetadata>,

    /// List of Google Cloud regions that the partner sells services to customers.
    /// Valid Google Cloud regions found here:
    /// <https://cloud.google.com/compute/docs/regions-zones>
    pub operated_cloud_regions: std::vec::Vec<std::string::String>,

    /// Google Cloud project ID in the partner's Google Cloud organization for
    /// receiving enhanced Logs for Partners.
    pub partner_project_id: std::string::String,

    /// Output only. Time the resource was created
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the resource was updated
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Partner {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Partner::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skus][crate::model::Partner::skus].
    pub fn set_skus<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sku>,
    {
        use std::iter::Iterator;
        self.skus = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ekm_solutions][crate::model::Partner::ekm_solutions].
    pub fn set_ekm_solutions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmMetadata>,
    {
        use std::iter::Iterator;
        self.ekm_solutions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operated_cloud_regions][crate::model::Partner::operated_cloud_regions].
    pub fn set_operated_cloud_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.operated_cloud_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partner_project_id][crate::model::Partner::partner_project_id].
    pub fn set_partner_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner_project_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Partner::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Partner::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Partner::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Partner::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Partner {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Partner"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Partner {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __skus,
            __ekm_solutions,
            __operated_cloud_regions,
            __partner_project_id,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Partner")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "skus" => Ok(__FieldTag::__skus),
                            "ekmSolutions" => Ok(__FieldTag::__ekm_solutions),
                            "ekm_solutions" => Ok(__FieldTag::__ekm_solutions),
                            "operatedCloudRegions" => Ok(__FieldTag::__operated_cloud_regions),
                            "operated_cloud_regions" => Ok(__FieldTag::__operated_cloud_regions),
                            "partnerProjectId" => Ok(__FieldTag::__partner_project_id),
                            "partner_project_id" => Ok(__FieldTag::__partner_project_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Partner;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Partner")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skus => {
                            if !fields.insert(__FieldTag::__skus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skus",
                                ));
                            }
                            result.skus = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Sku>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ekm_solutions => {
                            if !fields.insert(__FieldTag::__ekm_solutions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_solutions",
                                ));
                            }
                            result.ekm_solutions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EkmMetadata>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__operated_cloud_regions => {
                            if !fields.insert(__FieldTag::__operated_cloud_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operated_cloud_regions",
                                ));
                            }
                            result.operated_cloud_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__partner_project_id => {
                            if !fields.insert(__FieldTag::__partner_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partner_project_id",
                                ));
                            }
                            result.partner_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Partner {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.skus.is_empty() {
            state.serialize_entry("skus", &self.skus)?;
        }
        if !self.ekm_solutions.is_empty() {
            state.serialize_entry("ekmSolutions", &self.ekm_solutions)?;
        }
        if !self.operated_cloud_regions.is_empty() {
            state.serialize_entry("operatedCloudRegions", &self.operated_cloud_regions)?;
        }
        if !self.partner_project_id.is_empty() {
            state.serialize_entry("partnerProjectId", &self.partner_project_id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a Partner
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPartnerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/partner`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPartnerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPartnerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPartnerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPartnerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPartnerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPartnerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the SKU a partner owns inside Google Cloud to sell to customers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Sku {
    /// Argentum product SKU, that is associated with the partner offerings to
    /// customers used by Syntro for billing purposes. SKUs can represent resold
    /// Google products or support services.
    pub id: std::string::String,

    /// Display name of the product identified by the SKU. A partner may want to
    /// show partner branded names for their offerings such as local sovereign
    /// cloud solutions.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sku {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Sku::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Sku::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Sku {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Sku"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Sku {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sku")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Sku;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sku")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Sku {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Holds information needed by Mudbray to use partner EKMs for workloads.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EkmMetadata {
    /// The Cloud EKM partner.
    pub ekm_solution: crate::model::ekm_metadata::EkmSolution,

    /// Endpoint for sending requests to the EKM for key provisioning during
    /// Assured Workload creation.
    pub ekm_endpoint_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_solution][crate::model::EkmMetadata::ekm_solution].
    pub fn set_ekm_solution<T: std::convert::Into<crate::model::ekm_metadata::EkmSolution>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_solution = v.into();
        self
    }

    /// Sets the value of [ekm_endpoint_uri][crate::model::EkmMetadata::ekm_endpoint_uri].
    pub fn set_ekm_endpoint_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_endpoint_uri = v.into();
        self
    }
}

impl wkt::message::Message for EkmMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EkmMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ekm_solution,
            __ekm_endpoint_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EkmMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ekmSolution" => Ok(__FieldTag::__ekm_solution),
                            "ekm_solution" => Ok(__FieldTag::__ekm_solution),
                            "ekmEndpointUri" => Ok(__FieldTag::__ekm_endpoint_uri),
                            "ekm_endpoint_uri" => Ok(__FieldTag::__ekm_endpoint_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EkmMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EkmMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ekm_solution => {
                            if !fields.insert(__FieldTag::__ekm_solution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_solution",
                                ));
                            }
                            result.ekm_solution = map.next_value::<std::option::Option<crate::model::ekm_metadata::EkmSolution>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ekm_endpoint_uri => {
                            if !fields.insert(__FieldTag::__ekm_endpoint_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ekm_endpoint_uri",
                                ));
                            }
                            result.ekm_endpoint_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EkmMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ekm_solution) {
            state.serialize_entry("ekmSolution", &self.ekm_solution)?;
        }
        if !self.ekm_endpoint_uri.is_empty() {
            state.serialize_entry("ekmEndpointUri", &self.ekm_endpoint_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EkmMetadata].
pub mod ekm_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents Google Cloud supported external key management partners
    /// [Google Cloud EKM partners
    /// docs](https://cloud.google.com/kms/docs/ekm#supported_partners).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EkmSolution {
        /// Unspecified EKM solution
        Unspecified,
        /// EKM Partner Fortanix
        Fortanix,
        /// EKM Partner FutureX
        Futurex,
        /// EKM Partner Thales
        Thales,
        /// This enum value is never used.
        #[deprecated]
        Virtru,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EkmSolution::value] or
        /// [EkmSolution::name].
        UnknownValue(ekm_solution::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ekm_solution {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EkmSolution {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fortanix => std::option::Option::Some(1),
                Self::Futurex => std::option::Option::Some(2),
                Self::Thales => std::option::Option::Some(3),
                Self::Virtru => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EKM_SOLUTION_UNSPECIFIED"),
                Self::Fortanix => std::option::Option::Some("FORTANIX"),
                Self::Futurex => std::option::Option::Some("FUTUREX"),
                Self::Thales => std::option::Option::Some("THALES"),
                Self::Virtru => std::option::Option::Some("VIRTRU"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EkmSolution {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EkmSolution {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EkmSolution {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fortanix,
                2 => Self::Futurex,
                3 => Self::Thales,
                4 => Self::Virtru,
                _ => Self::UnknownValue(ekm_solution::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EkmSolution {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EKM_SOLUTION_UNSPECIFIED" => Self::Unspecified,
                "FORTANIX" => Self::Fortanix,
                "FUTUREX" => Self::Futurex,
                "THALES" => Self::Thales,
                "VIRTRU" => Self::Virtru,
                _ => Self::UnknownValue(ekm_solution::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EkmSolution {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fortanix => serializer.serialize_i32(1),
                Self::Futurex => serializer.serialize_i32(2),
                Self::Thales => serializer.serialize_i32(3),
                Self::Virtru => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EkmSolution {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EkmSolution>::new(
                ".google.cloud.cloudcontrolspartner.v1.EkmMetadata.EkmSolution",
            ))
        }
    }
}

/// Details of resource Violation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Violation {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    pub name: std::string::String,

    /// Output only. Description for the Violation.
    /// e.g. OrgPolicy gcp.resourceLocations has non compliant value.
    pub description: std::string::String,

    /// Output only. Time of the event which triggered the Violation.
    pub begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time when the Violation record was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time of the event which fixed the Violation.
    /// If the violation is ACTIVE this will be empty.
    pub resolve_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Category under which this violation is mapped.
    /// e.g. Location, Service Usage, Access, Encryption, etc.
    pub category: std::string::String,

    /// Output only. State of the violation
    pub state: crate::model::violation::State,

    /// Output only. Immutable. Name of the OrgPolicy which was modified with
    /// non-compliant change and resulted this violation. Format:
    /// `projects/{project_number}/policies/{constraint_name}`
    /// `folders/{folder_id}/policies/{constraint_name}`
    /// `organizations/{organization_id}/policies/{constraint_name}`
    pub non_compliant_org_policy: std::string::String,

    /// The folder_id of the violation
    pub folder_id: i64,

    /// Output only. Compliance violation remediation
    pub remediation: std::option::Option<crate::model::violation::Remediation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Violation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Violation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Violation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [begin_time][crate::model::Violation::begin_time].
    pub fn set_begin_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.begin_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [begin_time][crate::model::Violation::begin_time].
    pub fn set_or_clear_begin_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.begin_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Violation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Violation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolve_time][crate::model::Violation::resolve_time].
    pub fn set_resolve_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.resolve_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolve_time][crate::model::Violation::resolve_time].
    pub fn set_or_clear_resolve_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.resolve_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [category][crate::model::Violation::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Violation::state].
    pub fn set_state<T: std::convert::Into<crate::model::violation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [non_compliant_org_policy][crate::model::Violation::non_compliant_org_policy].
    pub fn set_non_compliant_org_policy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.non_compliant_org_policy = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Violation::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::Violation::remediation].
    pub fn set_remediation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::violation::Remediation>,
    {
        self.remediation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [remediation][crate::model::Violation::remediation].
    pub fn set_or_clear_remediation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::violation::Remediation>,
    {
        self.remediation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Violation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Violation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __begin_time,
            __update_time,
            __resolve_time,
            __category,
            __state,
            __non_compliant_org_policy,
            __folder_id,
            __remediation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Violation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "beginTime" => Ok(__FieldTag::__begin_time),
                            "begin_time" => Ok(__FieldTag::__begin_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "resolveTime" => Ok(__FieldTag::__resolve_time),
                            "resolve_time" => Ok(__FieldTag::__resolve_time),
                            "category" => Ok(__FieldTag::__category),
                            "state" => Ok(__FieldTag::__state),
                            "nonCompliantOrgPolicy" => Ok(__FieldTag::__non_compliant_org_policy),
                            "non_compliant_org_policy" => {
                                Ok(__FieldTag::__non_compliant_org_policy)
                            }
                            "folderId" => Ok(__FieldTag::__folder_id),
                            "folder_id" => Ok(__FieldTag::__folder_id),
                            "remediation" => Ok(__FieldTag::__remediation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Violation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Violation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__begin_time => {
                            if !fields.insert(__FieldTag::__begin_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for begin_time",
                                ));
                            }
                            result.begin_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resolve_time => {
                            if !fields.insert(__FieldTag::__resolve_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolve_time",
                                ));
                            }
                            result.resolve_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::violation::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__non_compliant_org_policy => {
                            if !fields.insert(__FieldTag::__non_compliant_org_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for non_compliant_org_policy",
                                ));
                            }
                            result.non_compliant_org_policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__folder_id => {
                            if !fields.insert(__FieldTag::__folder_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for folder_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.folder_id = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__remediation => {
                            if !fields.insert(__FieldTag::__remediation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remediation",
                                ));
                            }
                            result.remediation = map.next_value::<std::option::Option<crate::model::violation::Remediation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Violation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.begin_time.is_some() {
            state.serialize_entry("beginTime", &self.begin_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.resolve_time.is_some() {
            state.serialize_entry("resolveTime", &self.resolve_time)?;
        }
        if !self.category.is_empty() {
            state.serialize_entry("category", &self.category)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.non_compliant_org_policy.is_empty() {
            state.serialize_entry("nonCompliantOrgPolicy", &self.non_compliant_org_policy)?;
        }
        if !wkt::internal::is_default(&self.folder_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("folderId", &__With(&self.folder_id))?;
        }
        if self.remediation.is_some() {
            state.serialize_entry("remediation", &self.remediation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Violation].
pub mod violation {
    #[allow(unused_imports)]
    use super::*;

    /// Represents remediation guidance to resolve compliance violation for
    /// AssuredWorkload
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Remediation {
        /// Required. Remediation instructions to resolve violations
        pub instructions: std::option::Option<crate::model::violation::remediation::Instructions>,

        /// Values that can resolve the violation
        /// For example: for list org policy violations, this will either be the list
        /// of allowed or denied values
        pub compliant_values: std::vec::Vec<std::string::String>,

        /// Output only. Remediation type based on the type of org policy values
        /// violated
        pub remediation_type: crate::model::violation::remediation::RemediationType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Remediation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instructions][crate::model::violation::Remediation::instructions].
        pub fn set_instructions<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::violation::remediation::Instructions>,
        {
            self.instructions = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [instructions][crate::model::violation::Remediation::instructions].
        pub fn set_or_clear_instructions<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::violation::remediation::Instructions>,
        {
            self.instructions = v.map(|x| x.into());
            self
        }

        /// Sets the value of [compliant_values][crate::model::violation::Remediation::compliant_values].
        pub fn set_compliant_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.compliant_values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [remediation_type][crate::model::violation::Remediation::remediation_type].
        pub fn set_remediation_type<
            T: std::convert::Into<crate::model::violation::remediation::RemediationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.remediation_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Remediation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Remediation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __instructions,
                __compliant_values,
                __remediation_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Remediation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "instructions" => Ok(__FieldTag::__instructions),
                                "compliantValues" => Ok(__FieldTag::__compliant_values),
                                "compliant_values" => Ok(__FieldTag::__compliant_values),
                                "remediationType" => Ok(__FieldTag::__remediation_type),
                                "remediation_type" => Ok(__FieldTag::__remediation_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Remediation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Remediation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__instructions => {
                                if !fields.insert(__FieldTag::__instructions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for instructions",
                                    ));
                                }
                                result.instructions = map.next_value::<std::option::Option<
                                    crate::model::violation::remediation::Instructions,
                                >>()?;
                            }
                            __FieldTag::__compliant_values => {
                                if !fields.insert(__FieldTag::__compliant_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compliant_values",
                                    ));
                                }
                                result.compliant_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__remediation_type => {
                                if !fields.insert(__FieldTag::__remediation_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for remediation_type",
                                    ));
                                }
                                result.remediation_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::violation::remediation::RemediationType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Remediation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.instructions.is_some() {
                state.serialize_entry("instructions", &self.instructions)?;
            }
            if !self.compliant_values.is_empty() {
                state.serialize_entry("compliantValues", &self.compliant_values)?;
            }
            if !wkt::internal::is_default(&self.remediation_type) {
                state.serialize_entry("remediationType", &self.remediation_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Remediation].
    pub mod remediation {
        #[allow(unused_imports)]
        use super::*;

        /// Instructions to remediate violation
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Instructions {
            /// Remediation instructions to resolve violation via gcloud cli
            pub gcloud_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Gcloud>,

            /// Remediation instructions to resolve violation via cloud console
            pub console_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Console>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Instructions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gcloud_instructions][crate::model::violation::remediation::Instructions::gcloud_instructions].
            pub fn set_gcloud_instructions<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Gcloud>,
            {
                self.gcloud_instructions = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [gcloud_instructions][crate::model::violation::remediation::Instructions::gcloud_instructions].
            pub fn set_or_clear_gcloud_instructions<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Gcloud>,
            {
                self.gcloud_instructions = v.map(|x| x.into());
                self
            }

            /// Sets the value of [console_instructions][crate::model::violation::remediation::Instructions::console_instructions].
            pub fn set_console_instructions<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Console>,
            {
                self.console_instructions = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [console_instructions][crate::model::violation::remediation::Instructions::console_instructions].
            pub fn set_or_clear_console_instructions<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Console>,
            {
                self.console_instructions = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Instructions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Instructions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __gcloud_instructions,
                    __console_instructions,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Instructions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "gcloudInstructions" => Ok(__FieldTag::__gcloud_instructions),
                                    "gcloud_instructions" => Ok(__FieldTag::__gcloud_instructions),
                                    "consoleInstructions" => Ok(__FieldTag::__console_instructions),
                                    "console_instructions" => {
                                        Ok(__FieldTag::__console_instructions)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Instructions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Instructions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__gcloud_instructions => {
                                    if !fields.insert(__FieldTag::__gcloud_instructions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for gcloud_instructions",
                                            ),
                                        );
                                    }
                                    result.gcloud_instructions = map
                                        .next_value::<std::option::Option<
                                        crate::model::violation::remediation::instructions::Gcloud,
                                    >>(
                                    )?;
                                }
                                __FieldTag::__console_instructions => {
                                    if !fields.insert(__FieldTag::__console_instructions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for console_instructions",
                                            ),
                                        );
                                    }
                                    result.console_instructions = map
                                        .next_value::<std::option::Option<
                                        crate::model::violation::remediation::instructions::Console,
                                    >>(
                                    )?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Instructions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.gcloud_instructions.is_some() {
                    state.serialize_entry("gcloudInstructions", &self.gcloud_instructions)?;
                }
                if self.console_instructions.is_some() {
                    state.serialize_entry("consoleInstructions", &self.console_instructions)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Instructions].
        pub mod instructions {
            #[allow(unused_imports)]
            use super::*;

            /// Remediation instructions to resolve violation via gcloud cli
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Gcloud {
                /// Gcloud command to resolve violation
                pub gcloud_commands: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via gcloud cli
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                pub additional_links: std::vec::Vec<std::string::String>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Gcloud {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [gcloud_commands][crate::model::violation::remediation::instructions::Gcloud::gcloud_commands].
                pub fn set_gcloud_commands<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gcloud_commands = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Gcloud::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Gcloud::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Gcloud {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Gcloud"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Gcloud {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __gcloud_commands,
                        __steps,
                        __additional_links,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Gcloud")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "gcloudCommands" => Ok(__FieldTag::__gcloud_commands),
                                        "gcloud_commands" => Ok(__FieldTag::__gcloud_commands),
                                        "steps" => Ok(__FieldTag::__steps),
                                        "additionalLinks" => Ok(__FieldTag::__additional_links),
                                        "additional_links" => Ok(__FieldTag::__additional_links),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Gcloud;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Gcloud")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__gcloud_commands => {
                                        if !fields.insert(__FieldTag::__gcloud_commands) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for gcloud_commands",
                                                ),
                                            );
                                        }
                                        result.gcloud_commands =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__steps => {
                                        if !fields.insert(__FieldTag::__steps) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for steps",
                                                ),
                                            );
                                        }
                                        result.steps =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__additional_links => {
                                        if !fields.insert(__FieldTag::__additional_links) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for additional_links",
                                                ),
                                            );
                                        }
                                        result.additional_links =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Gcloud {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.gcloud_commands.is_empty() {
                        state.serialize_entry("gcloudCommands", &self.gcloud_commands)?;
                    }
                    if !self.steps.is_empty() {
                        state.serialize_entry("steps", &self.steps)?;
                    }
                    if !self.additional_links.is_empty() {
                        state.serialize_entry("additionalLinks", &self.additional_links)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Remediation instructions to resolve violation via cloud console
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Console {
                /// Link to console page where violations can be resolved
                pub console_uris: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via cloud console
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                pub additional_links: std::vec::Vec<std::string::String>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Console {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [console_uris][crate::model::violation::remediation::instructions::Console::console_uris].
                pub fn set_console_uris<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.console_uris = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Console::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Console::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Console {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Console"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Console {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __console_uris,
                        __steps,
                        __additional_links,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Console")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "consoleUris" => Ok(__FieldTag::__console_uris),
                                        "console_uris" => Ok(__FieldTag::__console_uris),
                                        "steps" => Ok(__FieldTag::__steps),
                                        "additionalLinks" => Ok(__FieldTag::__additional_links),
                                        "additional_links" => Ok(__FieldTag::__additional_links),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Console;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Console")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__console_uris => {
                                        if !fields.insert(__FieldTag::__console_uris) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for console_uris",
                                                ),
                                            );
                                        }
                                        result.console_uris =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__steps => {
                                        if !fields.insert(__FieldTag::__steps) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for steps",
                                                ),
                                            );
                                        }
                                        result.steps =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__additional_links => {
                                        if !fields.insert(__FieldTag::__additional_links) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for additional_links",
                                                ),
                                            );
                                        }
                                        result.additional_links =
                                            map.next_value::<std::option::Option<
                                                std::vec::Vec<std::string::String>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Console {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.console_uris.is_empty() {
                        state.serialize_entry("consoleUris", &self.console_uris)?;
                    }
                    if !self.steps.is_empty() {
                        state.serialize_entry("steps", &self.steps)?;
                    }
                    if !self.additional_links.is_empty() {
                        state.serialize_entry("additionalLinks", &self.additional_links)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// Classifying remediation into various types based on the kind of
        /// violation. For example, violations caused due to changes in boolean org
        /// policy requires different remediation instructions compared to violation
        /// caused due to changes in allowed values of list org policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum RemediationType {
            /// Unspecified remediation type
            Unspecified,
            /// Remediation type for boolean org policy
            RemediationBooleanOrgPolicyViolation,
            /// Remediation type for list org policy which have allowed values in the
            /// monitoring rule
            RemediationListAllowedValuesOrgPolicyViolation,
            /// Remediation type for list org policy which have denied values in the
            /// monitoring rule
            RemediationListDeniedValuesOrgPolicyViolation,
            /// Remediation type for gcp.restrictCmekCryptoKeyProjects
            RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation,
            /// Remediation type for resource violation.
            RemediationResourceViolation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [RemediationType::value] or
            /// [RemediationType::name].
            UnknownValue(remediation_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod remediation_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl RemediationType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::RemediationBooleanOrgPolicyViolation => std::option::Option::Some(1),
                    Self::RemediationListAllowedValuesOrgPolicyViolation => {
                        std::option::Option::Some(2)
                    }
                    Self::RemediationListDeniedValuesOrgPolicyViolation => {
                        std::option::Option::Some(3)
                    }
                    Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation => {
                        std::option::Option::Some(4)
                    }
                    Self::RemediationResourceViolation => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("REMEDIATION_TYPE_UNSPECIFIED"),
                    Self::RemediationBooleanOrgPolicyViolation => {
                        std::option::Option::Some("REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION")
                    }
                    Self::RemediationListAllowedValuesOrgPolicyViolation => {
                        std::option::Option::Some(
                            "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION",
                        )
                    }
                    Self::RemediationListDeniedValuesOrgPolicyViolation => {
                        std::option::Option::Some(
                            "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION",
                        )
                    }
                    Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation => {
                        std::option::Option::Some(
                            "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION",
                        )
                    }
                    Self::RemediationResourceViolation => {
                        std::option::Option::Some("REMEDIATION_RESOURCE_VIOLATION")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for RemediationType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for RemediationType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for RemediationType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::RemediationBooleanOrgPolicyViolation,
                    2 => Self::RemediationListAllowedValuesOrgPolicyViolation,
                    3 => Self::RemediationListDeniedValuesOrgPolicyViolation,
                    4 => Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation,
                    5 => Self::RemediationResourceViolation,
                    _ => Self::UnknownValue(remediation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for RemediationType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "REMEDIATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION" => {
                        Self::RemediationBooleanOrgPolicyViolation
                    }
                    "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION" => {
                        Self::RemediationListAllowedValuesOrgPolicyViolation
                    }
                    "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION" => {
                        Self::RemediationListDeniedValuesOrgPolicyViolation
                    }
                    "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION" => {
                        Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation
                    }
                    "REMEDIATION_RESOURCE_VIOLATION" => Self::RemediationResourceViolation,
                    _ => Self::UnknownValue(remediation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for RemediationType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::RemediationBooleanOrgPolicyViolation => serializer.serialize_i32(1),
                    Self::RemediationListAllowedValuesOrgPolicyViolation => {
                        serializer.serialize_i32(2)
                    }
                    Self::RemediationListDeniedValuesOrgPolicyViolation => {
                        serializer.serialize_i32(3)
                    }
                    Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation => {
                        serializer.serialize_i32(4)
                    }
                    Self::RemediationResourceViolation => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for RemediationType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<RemediationType>::new(
                    ".google.cloud.cloudcontrolspartner.v1.Violation.Remediation.RemediationType",
                ))
            }
        }
    }

    /// Violation State Values
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Violation is resolved.
        Resolved,
        /// Violation is Unresolved
        Unresolved,
        /// Violation is Exception
        Exception,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Resolved => std::option::Option::Some(1),
                Self::Unresolved => std::option::Option::Some(2),
                Self::Exception => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Resolved => std::option::Option::Some("RESOLVED"),
                Self::Unresolved => std::option::Option::Some("UNRESOLVED"),
                Self::Exception => std::option::Option::Some("EXCEPTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Resolved,
                2 => Self::Unresolved,
                3 => Self::Exception,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RESOLVED" => Self::Resolved,
                "UNRESOLVED" => Self::Unresolved,
                "EXCEPTION" => Self::Exception,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Resolved => serializer.serialize_i32(1),
                Self::Unresolved => serializer.serialize_i32(2),
                Self::Exception => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.cloudcontrolspartner.v1.Violation.State",
            ))
        }
    }
}

/// Message for requesting list of Violations
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListViolationsRequest {
    /// Required. Parent resource
    /// Format
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    pub parent: std::string::String,

    /// Optional. The maximum number of customers row to return. The service may
    /// return fewer than this value. If unspecified, at most 10 customers will be
    /// returned.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListViolations` call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    /// Optional. Specifies the interval for retrieving violations.
    /// if unspecified, all violations will be returned.
    pub interval: std::option::Option<gtype::model::Interval>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViolationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViolationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViolationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViolationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListViolationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListViolationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListViolationsRequest::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::ListViolationsRequest::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListViolationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListViolationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListViolationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "interval" => Ok(__FieldTag::__interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListViolationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListViolationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval =
                                map.next_value::<std::option::Option<gtype::model::Interval>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListViolationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for list customer violation requests
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListViolationsResponse {
    /// List of violation
    pub violations: std::vec::Vec<crate::model::Violation>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Workloads that could not be reached due to permission errors or any other
    /// error. Ref: <https://google.aip.dev/217>
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViolationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [violations][crate::model::ListViolationsResponse::violations].
    pub fn set_violations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Violation>,
    {
        use std::iter::Iterator;
        self.violations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListViolationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListViolationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListViolationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListViolationsResponse {
    type PageItem = crate::model::Violation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.violations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListViolationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __violations,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListViolationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "violations" => Ok(__FieldTag::__violations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListViolationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListViolationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__violations => {
                            if !fields.insert(__FieldTag::__violations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for violations",
                                ));
                            }
                            result.violations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Violation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListViolationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.violations.is_empty() {
            state.serialize_entry("violations", &self.violations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a Violation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetViolationRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetViolationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViolationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViolationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetViolationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetViolationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetViolationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetViolationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetViolationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetViolationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Enum for possible completion states.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CompletionState {
    /// Unspecified completion state.
    Unspecified,
    /// Task started (has start date) but not yet completed.
    Pending,
    /// Succeeded state.
    Succeeded,
    /// Failed state.
    Failed,
    /// Not applicable state.
    NotApplicable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CompletionState::value] or
    /// [CompletionState::name].
    UnknownValue(completion_state::UnknownValue),
}

#[doc(hidden)]
pub mod completion_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CompletionState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pending => std::option::Option::Some(1),
            Self::Succeeded => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::NotApplicable => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPLETION_STATE_UNSPECIFIED"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::NotApplicable => std::option::Option::Some("NOT_APPLICABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CompletionState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CompletionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CompletionState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Pending,
            2 => Self::Succeeded,
            3 => Self::Failed,
            4 => Self::NotApplicable,
            _ => Self::UnknownValue(completion_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CompletionState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPLETION_STATE_UNSPECIFIED" => Self::Unspecified,
            "PENDING" => Self::Pending,
            "SUCCEEDED" => Self::Succeeded,
            "FAILED" => Self::Failed,
            "NOT_APPLICABLE" => Self::NotApplicable,
            _ => Self::UnknownValue(completion_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CompletionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pending => serializer.serialize_i32(1),
            Self::Succeeded => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::NotApplicable => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CompletionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompletionState>::new(
            ".google.cloud.cloudcontrolspartner.v1.CompletionState",
        ))
    }
}
