// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Details about the Access request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessApprovalRequest {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/accessApprovalRequests/{access_approval_request}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The time at which approval was requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The justification for which approval is being requested.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_reason: std::option::Option<crate::model::AccessReason>,

    /// The requested expiration for the approval. If the request is approved,
    /// access will be granted from the time of approval until the expiration time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_expiration_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessApprovalRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessApprovalRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::AccessApprovalRequest::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::AccessApprovalRequest::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_reason][crate::model::AccessApprovalRequest::requested_reason].
    pub fn set_requested_reason<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessReason>,
    {
        self.requested_reason = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_reason][crate::model::AccessApprovalRequest::requested_reason].
    pub fn set_or_clear_requested_reason<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessReason>,
    {
        self.requested_reason = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_expiration_time][crate::model::AccessApprovalRequest::requested_expiration_time].
    pub fn set_requested_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.requested_expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_expiration_time][crate::model::AccessApprovalRequest::requested_expiration_time].
    pub fn set_or_clear_requested_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.requested_expiration_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AccessApprovalRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessApprovalRequest"
    }
}

/// Request for getting the access requests associated with a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of access requests to return. The service may
    /// return fewer than this value. If unspecified, at most 500 access requests
    /// will be returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous
    /// `ListAccessApprovalRequests` call. Provide this to retrieve the subsequent
    /// page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAccessApprovalRequestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAccessApprovalRequestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAccessApprovalRequestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAccessApprovalRequestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAccessApprovalRequestsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAccessApprovalRequestsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsRequest"
    }
}

/// Response message for list access requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAccessApprovalRequestsResponse {
    /// List of access approval requests
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub access_approval_requests: std::vec::Vec<crate::model::AccessApprovalRequest>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAccessApprovalRequestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_approval_requests][crate::model::ListAccessApprovalRequestsResponse::access_approval_requests].
    pub fn set_access_approval_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessApprovalRequest>,
    {
        use std::iter::Iterator;
        self.access_approval_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAccessApprovalRequestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListAccessApprovalRequestsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAccessApprovalRequestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListAccessApprovalRequestsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAccessApprovalRequestsResponse {
    type PageItem = crate::model::AccessApprovalRequest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.access_approval_requests
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Reason for the access.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessReason {
    /// Type of access justification.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub r#type: crate::model::access_reason::Type,

    /// More detail about certain reason types. See comments for each type above.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub detail: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AccessReason::type].
    pub fn set_type<T: std::convert::Into<crate::model::access_reason::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::AccessReason::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

impl wkt::message::Message for AccessReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.AccessReason"
    }
}

/// Defines additional types related to [AccessReason].
pub mod access_reason {
    #[allow(unused_imports)]
    use super::*;

    /// Type of access justification.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value for proto, shouldn't be used.
        Unspecified,
        /// Customer made a request or raised an issue that required the principal to
        /// access customer data. `detail` is of the form ("#####" is the issue ID):
        ///
        /// - "Feedback Report: #####"
        /// - "Case Number: #####"
        /// - "Case ID: #####"
        /// - "E-PIN Reference: #####"
        /// - "Google-#####"
        /// - "T-#####"
        CustomerInitiatedSupport,
        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services. Often this access is used to confirm that
        /// customers are not affected by a suspected service issue or to remediate a
        /// reversible system issue.
        GoogleInitiatedService,
        /// Google initiated service for security, fraud, abuse, or compliance
        /// purposes.
        GoogleInitiatedReview,
        /// The principal was compelled to access customer data in order to respond
        /// to a legal third party data request or process, including legal processes
        /// from customers themselves.
        ThirdPartyDataRequest,
        /// The principal accessed customer data in order to diagnose or resolve a
        /// suspected issue in services or a known outage.
        GoogleResponseToProductionAlert,
        /// Similar to 'GOOGLE_INITIATED_SERVICE' or 'GOOGLE_INITIATED_REVIEW', but
        /// with universe agnostic naming. The principal accessed customer data in
        /// order to diagnose or resolve a suspected issue in services or a known
        /// outage, or for security, fraud, abuse, or compliance review purposes.
        CloudInitiatedAccess,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CustomerInitiatedSupport => std::option::Option::Some(1),
                Self::GoogleInitiatedService => std::option::Option::Some(2),
                Self::GoogleInitiatedReview => std::option::Option::Some(3),
                Self::ThirdPartyDataRequest => std::option::Option::Some(4),
                Self::GoogleResponseToProductionAlert => std::option::Option::Some(5),
                Self::CloudInitiatedAccess => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::CustomerInitiatedSupport => {
                    std::option::Option::Some("CUSTOMER_INITIATED_SUPPORT")
                }
                Self::GoogleInitiatedService => {
                    std::option::Option::Some("GOOGLE_INITIATED_SERVICE")
                }
                Self::GoogleInitiatedReview => std::option::Option::Some("GOOGLE_INITIATED_REVIEW"),
                Self::ThirdPartyDataRequest => {
                    std::option::Option::Some("THIRD_PARTY_DATA_REQUEST")
                }
                Self::GoogleResponseToProductionAlert => {
                    std::option::Option::Some("GOOGLE_RESPONSE_TO_PRODUCTION_ALERT")
                }
                Self::CloudInitiatedAccess => std::option::Option::Some("CLOUD_INITIATED_ACCESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CustomerInitiatedSupport,
                2 => Self::GoogleInitiatedService,
                3 => Self::GoogleInitiatedReview,
                4 => Self::ThirdPartyDataRequest,
                5 => Self::GoogleResponseToProductionAlert,
                6 => Self::CloudInitiatedAccess,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CUSTOMER_INITIATED_SUPPORT" => Self::CustomerInitiatedSupport,
                "GOOGLE_INITIATED_SERVICE" => Self::GoogleInitiatedService,
                "GOOGLE_INITIATED_REVIEW" => Self::GoogleInitiatedReview,
                "THIRD_PARTY_DATA_REQUEST" => Self::ThirdPartyDataRequest,
                "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT" => Self::GoogleResponseToProductionAlert,
                "CLOUD_INITIATED_ACCESS" => Self::CloudInitiatedAccess,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CustomerInitiatedSupport => serializer.serialize_i32(1),
                Self::GoogleInitiatedService => serializer.serialize_i32(2),
                Self::GoogleInitiatedReview => serializer.serialize_i32(3),
                Self::ThirdPartyDataRequest => serializer.serialize_i32(4),
                Self::GoogleResponseToProductionAlert => serializer.serialize_i32(5),
                Self::CloudInitiatedAccess => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.cloudcontrolspartner.v1.AccessReason.Type",
            ))
        }
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][google.longrunning.Operation.error] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.OperationMetadata"
    }
}

/// Contains metadata around the [Workload
/// resource](https://cloud.google.com/assured-workloads/docs/reference/rest/Shared.Types/Workload)
/// in the Assured Workloads API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Workload {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Folder id this workload is associated with
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub folder_id: i64,

    /// Output only. Time the resource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of container folder of the assured workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub folder: std::string::String,

    /// Container for workload onboarding steps.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workload_onboarding_state: std::option::Option<crate::model::WorkloadOnboardingState>,

    /// Indicates whether a workload is fully onboarded.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_onboarded: bool,

    /// The project id of the key management project for the workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub key_management_project_id: std::string::String,

    /// The Google Cloud location of the workload
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub location: std::string::String,

    /// Partner associated with this workload.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub partner: crate::model::workload::Partner,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Workload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Workload::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Workload::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Workload::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Workload::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [folder][crate::model::Workload::folder].
    pub fn set_folder<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.folder = v.into();
        self
    }

    /// Sets the value of [workload_onboarding_state][crate::model::Workload::workload_onboarding_state].
    pub fn set_workload_onboarding_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadOnboardingState>,
    {
        self.workload_onboarding_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_onboarding_state][crate::model::Workload::workload_onboarding_state].
    pub fn set_or_clear_workload_onboarding_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadOnboardingState>,
    {
        self.workload_onboarding_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Workload::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }

    /// Sets the value of [key_management_project_id][crate::model::Workload::key_management_project_id].
    pub fn set_key_management_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_management_project_id = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Workload::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [partner][crate::model::Workload::partner].
    pub fn set_partner<T: std::convert::Into<crate::model::workload::Partner>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner = v.into();
        self
    }
}

impl wkt::message::Message for Workload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Workload"
    }
}

/// Defines additional types related to [Workload].
pub mod workload {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Assured Workloads Partners.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Partner {
        /// Unknown Partner.
        Unspecified,
        /// Enum representing S3NS (Thales) partner.
        LocalControlsByS3Ns,
        /// Enum representing T_SYSTEM (TSI) partner.
        SovereignControlsByTSystems,
        /// Enum representing SIA_MINSAIT (Indra) partner.
        SovereignControlsBySiaMinsait,
        /// Enum representing PSN (TIM) partner.
        SovereignControlsByPsn,
        /// Enum representing CNTXT (Kingdom of Saudi Arabia) partner.
        SovereignControlsByCntxt,
        /// Enum representing CNXT (Kingdom of Saudi Arabia) partner offering without
        /// EKM provisioning.
        SovereignControlsByCntxtNoEkm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Partner::value] or
        /// [Partner::name].
        UnknownValue(partner::UnknownValue),
    }

    #[doc(hidden)]
    pub mod partner {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Partner {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::LocalControlsByS3Ns => std::option::Option::Some(1),
                Self::SovereignControlsByTSystems => std::option::Option::Some(2),
                Self::SovereignControlsBySiaMinsait => std::option::Option::Some(3),
                Self::SovereignControlsByPsn => std::option::Option::Some(4),
                Self::SovereignControlsByCntxt => std::option::Option::Some(6),
                Self::SovereignControlsByCntxtNoEkm => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PARTNER_UNSPECIFIED"),
                Self::LocalControlsByS3Ns => {
                    std::option::Option::Some("PARTNER_LOCAL_CONTROLS_BY_S3NS")
                }
                Self::SovereignControlsByTSystems => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS")
                }
                Self::SovereignControlsBySiaMinsait => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT")
                }
                Self::SovereignControlsByPsn => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_PSN")
                }
                Self::SovereignControlsByCntxt => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT")
                }
                Self::SovereignControlsByCntxtNoEkm => {
                    std::option::Option::Some("PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Partner {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Partner {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Partner {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::LocalControlsByS3Ns,
                2 => Self::SovereignControlsByTSystems,
                3 => Self::SovereignControlsBySiaMinsait,
                4 => Self::SovereignControlsByPsn,
                6 => Self::SovereignControlsByCntxt,
                7 => Self::SovereignControlsByCntxtNoEkm,
                _ => Self::UnknownValue(partner::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Partner {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PARTNER_UNSPECIFIED" => Self::Unspecified,
                "PARTNER_LOCAL_CONTROLS_BY_S3NS" => Self::LocalControlsByS3Ns,
                "PARTNER_SOVEREIGN_CONTROLS_BY_T_SYSTEMS" => Self::SovereignControlsByTSystems,
                "PARTNER_SOVEREIGN_CONTROLS_BY_SIA_MINSAIT" => Self::SovereignControlsBySiaMinsait,
                "PARTNER_SOVEREIGN_CONTROLS_BY_PSN" => Self::SovereignControlsByPsn,
                "PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT" => Self::SovereignControlsByCntxt,
                "PARTNER_SOVEREIGN_CONTROLS_BY_CNTXT_NO_EKM" => Self::SovereignControlsByCntxtNoEkm,
                _ => Self::UnknownValue(partner::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Partner {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::LocalControlsByS3Ns => serializer.serialize_i32(1),
                Self::SovereignControlsByTSystems => serializer.serialize_i32(2),
                Self::SovereignControlsBySiaMinsait => serializer.serialize_i32(3),
                Self::SovereignControlsByPsn => serializer.serialize_i32(4),
                Self::SovereignControlsByCntxt => serializer.serialize_i32(6),
                Self::SovereignControlsByCntxtNoEkm => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Partner {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Partner>::new(
                ".google.cloud.cloudcontrolspartner.v1.Workload.Partner",
            ))
        }
    }
}

/// Request to list customer workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsRequest {
    /// Required. Parent resource
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of workloads to return. The service may return fewer
    /// than this value. If unspecified, at most 500 workloads will be returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A page token, received from a previous `ListWorkloads` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkloadsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkloadsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkloadsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkloadsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkloadsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListWorkloadsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkloadsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsRequest"
    }
}

/// Response message for list customer workloads requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkloadsResponse {
    /// List of customer workloads
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub workloads: std::vec::Vec<crate::model::Workload>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkloadsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workloads][crate::model::ListWorkloadsResponse::workloads].
    pub fn set_workloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workload>,
    {
        use std::iter::Iterator;
        self.workloads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkloadsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkloadsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkloadsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListWorkloadsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkloadsResponse {
    type PageItem = crate::model::Workload;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workloads
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a customer workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkloadRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkloadRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkloadRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkloadRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetWorkloadRequest"
    }
}

/// Container for workload onboarding steps.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadOnboardingState {
    /// List of workload onboarding steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub onboarding_steps: std::vec::Vec<crate::model::WorkloadOnboardingStep>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::WorkloadOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkloadOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingState"
    }
}

/// Container for workload onboarding information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkloadOnboardingStep {
    /// The onboarding step.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub step: crate::model::workload_onboarding_step::Step,

    /// The starting time of the onboarding step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The completion state of the onboarding step.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub completion_state: crate::model::CompletionState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::WorkloadOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::workload_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::WorkloadOnboardingStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::WorkloadOnboardingStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_time][crate::model::WorkloadOnboardingStep::completion_time].
    pub fn set_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_time][crate::model::WorkloadOnboardingStep::completion_time].
    pub fn set_or_clear_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_state][crate::model::WorkloadOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingStep"
    }
}

/// Defines additional types related to [WorkloadOnboardingStep].
pub mod workload_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Unspecified step.
        Unspecified,
        /// EKM Provisioned step.
        EkmProvisioned,
        /// Signed Access Approval step.
        SignedAccessApprovalConfigured,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Step::value] or
        /// [Step::name].
        UnknownValue(step::UnknownValue),
    }

    #[doc(hidden)]
    pub mod step {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Step {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EkmProvisioned => std::option::Option::Some(1),
                Self::SignedAccessApprovalConfigured => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STEP_UNSPECIFIED"),
                Self::EkmProvisioned => std::option::Option::Some("EKM_PROVISIONED"),
                Self::SignedAccessApprovalConfigured => {
                    std::option::Option::Some("SIGNED_ACCESS_APPROVAL_CONFIGURED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Step {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Step {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EkmProvisioned,
                2 => Self::SignedAccessApprovalConfigured,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Step {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STEP_UNSPECIFIED" => Self::Unspecified,
                "EKM_PROVISIONED" => Self::EkmProvisioned,
                "SIGNED_ACCESS_APPROVAL_CONFIGURED" => Self::SignedAccessApprovalConfigured,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Step {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EkmProvisioned => serializer.serialize_i32(1),
                Self::SignedAccessApprovalConfigured => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Step {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Step>::new(
                ".google.cloud.cloudcontrolspartner.v1.WorkloadOnboardingStep.Step",
            ))
        }
    }
}

/// Contains metadata around a Cloud Controls Partner Customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Customer {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Required. Display name for the customer
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// Output only. Container for customer onboarding steps
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_onboarding_state: std::option::Option<crate::model::CustomerOnboardingState>,

    /// Output only. Indicates whether a customer is fully onboarded
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_onboarded: bool,

    /// Output only. The customer organization domain, extracted from
    /// CRM Organizations display_name field. e.g. "google.com"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub organization_domain: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Customer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Customer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Customer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [customer_onboarding_state][crate::model::Customer::customer_onboarding_state].
    pub fn set_customer_onboarding_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerOnboardingState>,
    {
        self.customer_onboarding_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer_onboarding_state][crate::model::Customer::customer_onboarding_state].
    pub fn set_or_clear_customer_onboarding_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerOnboardingState>,
    {
        self.customer_onboarding_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_onboarded][crate::model::Customer::is_onboarded].
    pub fn set_is_onboarded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_onboarded = v.into();
        self
    }

    /// Sets the value of [organization_domain][crate::model::Customer::organization_domain].
    pub fn set_organization_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.organization_domain = v.into();
        self
    }
}

impl wkt::message::Message for Customer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Customer"
    }
}

/// Request to list customers
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomersRequest {
    /// Required. Parent resource
    /// Format: `organizations/{organization}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of Customers to return. The service may return fewer
    /// than this value. If unspecified, at most 500 Customers will be returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A page token, received from a previous `ListCustomers` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCustomersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCustomersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersRequest"
    }
}

/// Response message for list customer Customers requests
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomersResponse {
    /// List of customers
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub customers: std::vec::Vec<crate::model::Customer>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [customers][crate::model::ListCustomersResponse::customers].
    pub fn set_customers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Customer>,
    {
        use std::iter::Iterator;
        self.customers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCustomersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListCustomersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomersResponse {
    type PageItem = crate::model::Customer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.customers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to create a customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCustomerRequest {
    /// Required. Parent resource
    /// Format: `organizations/{organization}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The customer to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer: std::option::Option<crate::model::Customer>,

    /// Required. The customer id to use for the customer, which will become the
    /// final component of the customer's resource name. The specified value must
    /// be a valid Google cloud organization id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub customer_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCustomerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [customer][crate::model::CreateCustomerRequest::customer].
    pub fn set_customer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer][crate::model::CreateCustomerRequest::customer].
    pub fn set_or_clear_customer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [customer_id][crate::model::CreateCustomerRequest::customer_id].
    pub fn set_customer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.customer_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CreateCustomerRequest"
    }
}

/// Message for getting a customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetCustomerRequest"
    }
}

/// Container for customer onboarding steps
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerOnboardingState {
    /// List of customer onboarding steps
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub onboarding_steps: std::vec::Vec<crate::model::CustomerOnboardingStep>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerOnboardingState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [onboarding_steps][crate::model::CustomerOnboardingState::onboarding_steps].
    pub fn set_onboarding_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerOnboardingStep>,
    {
        use std::iter::Iterator;
        self.onboarding_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingState"
    }
}

/// Container for customer onboarding information
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerOnboardingStep {
    /// The onboarding step
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub step: crate::model::customer_onboarding_step::Step,

    /// The starting time of the onboarding step
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The completion time of the onboarding step
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Current state of the step
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub completion_state: crate::model::CompletionState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerOnboardingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::CustomerOnboardingStep::step].
    pub fn set_step<T: std::convert::Into<crate::model::customer_onboarding_step::Step>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CustomerOnboardingStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CustomerOnboardingStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_time][crate::model::CustomerOnboardingStep::completion_time].
    pub fn set_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_time][crate::model::CustomerOnboardingStep::completion_time].
    pub fn set_or_clear_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_state][crate::model::CustomerOnboardingStep::completion_state].
    pub fn set_completion_state<T: std::convert::Into<crate::model::CompletionState>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }
}

impl wkt::message::Message for CustomerOnboardingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.CustomerOnboardingStep"
    }
}

/// Defines additional types related to [CustomerOnboardingStep].
pub mod customer_onboarding_step {
    #[allow(unused_imports)]
    use super::*;

    /// Enum for possible onboarding steps
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Unspecified step
        Unspecified,
        /// KAJ Enrollment
        KajEnrollment,
        /// Customer Environment
        CustomerEnvironment,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Step::value] or
        /// [Step::name].
        UnknownValue(step::UnknownValue),
    }

    #[doc(hidden)]
    pub mod step {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Step {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::KajEnrollment => std::option::Option::Some(1),
                Self::CustomerEnvironment => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STEP_UNSPECIFIED"),
                Self::KajEnrollment => std::option::Option::Some("KAJ_ENROLLMENT"),
                Self::CustomerEnvironment => std::option::Option::Some("CUSTOMER_ENVIRONMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Step {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Step {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Step {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::KajEnrollment,
                2 => Self::CustomerEnvironment,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Step {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STEP_UNSPECIFIED" => Self::Unspecified,
                "KAJ_ENROLLMENT" => Self::KajEnrollment,
                "CUSTOMER_ENVIRONMENT" => Self::CustomerEnvironment,
                _ => Self::UnknownValue(step::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Step {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::KajEnrollment => serializer.serialize_i32(1),
                Self::CustomerEnvironment => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Step {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Step>::new(
                ".google.cloud.cloudcontrolspartner.v1.CustomerOnboardingStep.Step",
            ))
        }
    }
}

/// Request to update a customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCustomerRequest {
    /// Required. The customer to update
    /// Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer: std::option::Option<crate::model::Customer>,

    /// Optional. The list of fields to update
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [customer][crate::model::UpdateCustomerRequest::customer].
    pub fn set_customer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [customer][crate::model::UpdateCustomerRequest::customer].
    pub fn set_or_clear_customer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Customer>,
    {
        self.customer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCustomerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCustomerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.UpdateCustomerRequest"
    }
}

/// Message for deleting customer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCustomerRequest {
    /// Required. name of the resource to be deleted
    /// format: name=organizations/*/locations/*/customers/*
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.DeleteCustomerRequest"
    }
}

/// The EKM connections associated with a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConnections {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The EKM connections associated with the workload
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub ekm_connections: std::vec::Vec<crate::model::EkmConnection>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmConnections {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EkmConnections::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ekm_connections][crate::model::EkmConnections::ekm_connections].
    pub fn set_ekm_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmConnection>,
    {
        use std::iter::Iterator;
        self.ekm_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EkmConnections {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnections"
    }
}

/// Request for getting the EKM connections associated with a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEkmConnectionsRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/ekmConnections`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEkmConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEkmConnectionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEkmConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetEkmConnectionsRequest"
    }
}

/// Details about the EKM connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmConnection {
    /// Resource name of the EKM connection in the format:
    /// projects/{project}/locations/{location}/ekmConnections/{ekm_connection}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connection_name: std::string::String,

    /// Output only. The connection state
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub connection_state: crate::model::ekm_connection::ConnectionState,

    /// The connection error that occurred if any
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_error: std::option::Option<crate::model::ekm_connection::ConnectionError>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_name][crate::model::EkmConnection::connection_name].
    pub fn set_connection_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_name = v.into();
        self
    }

    /// Sets the value of [connection_state][crate::model::EkmConnection::connection_state].
    pub fn set_connection_state<
        T: std::convert::Into<crate::model::ekm_connection::ConnectionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_state = v.into();
        self
    }

    /// Sets the value of [connection_error][crate::model::EkmConnection::connection_error].
    pub fn set_connection_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ekm_connection::ConnectionError>,
    {
        self.connection_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_error][crate::model::EkmConnection::connection_error].
    pub fn set_or_clear_connection_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ekm_connection::ConnectionError>,
    {
        self.connection_error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EkmConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection"
    }
}

/// Defines additional types related to [EkmConnection].
pub mod ekm_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Information around the error that occurred if the connection state is
    /// anything other than available or unspecified
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConnectionError {
        /// The error domain for the error
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub error_domain: std::string::String,

        /// The error message for the error
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub error_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectionError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_domain][crate::model::ekm_connection::ConnectionError::error_domain].
        pub fn set_error_domain<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_domain = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::ekm_connection::ConnectionError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectionError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmConnection.ConnectionError"
        }
    }

    /// The EKM connection state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionState {
        /// Unspecified EKM connection state
        Unspecified,
        /// Available EKM connection state
        Available,
        /// Not available EKM connection state
        NotAvailable,
        /// Error EKM connection state
        Error,
        /// Permission denied EKM connection state
        PermissionDenied,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConnectionState::value] or
        /// [ConnectionState::name].
        UnknownValue(connection_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod connection_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConnectionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Available => std::option::Option::Some(1),
                Self::NotAvailable => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::PermissionDenied => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONNECTION_STATE_UNSPECIFIED"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::NotAvailable => std::option::Option::Some("NOT_AVAILABLE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConnectionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConnectionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConnectionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Available,
                2 => Self::NotAvailable,
                3 => Self::Error,
                4 => Self::PermissionDenied,
                _ => Self::UnknownValue(connection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConnectionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONNECTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "AVAILABLE" => Self::Available,
                "NOT_AVAILABLE" => Self::NotAvailable,
                "ERROR" => Self::Error,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                _ => Self::UnknownValue(connection_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConnectionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Available => serializer.serialize_i32(1),
                Self::NotAvailable => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::PermissionDenied => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConnectionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionState>::new(
                ".google.cloud.cloudcontrolspartner.v1.EkmConnection.ConnectionState",
            ))
        }
    }
}

/// The permissions granted to the partner for a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartnerPermissions {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The partner permissions granted for the workload
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub partner_permissions: std::vec::Vec<crate::model::partner_permissions::Permission>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartnerPermissions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PartnerPermissions::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [partner_permissions][crate::model::PartnerPermissions::partner_permissions].
    pub fn set_partner_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::partner_permissions::Permission>,
    {
        use std::iter::Iterator;
        self.partner_permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PartnerPermissions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.PartnerPermissions"
    }
}

/// Defines additional types related to [PartnerPermissions].
pub mod partner_permissions {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Permission {
        /// Unspecified partner permission
        Unspecified,
        /// Permission for Access Transparency and emergency logs
        AccessTransparencyAndEmergencyAccessLogs,
        /// Permission for Assured Workloads monitoring violations
        AssuredWorkloadsMonitoring,
        /// Permission for Access Approval requests
        AccessApprovalRequests,
        /// Permission for External Key Manager connection status
        AssuredWorkloadsEkmConnectionStatus,
        /// Permission for support case details for Access Transparency log entries
        AccessTransparencyLogsSupportCaseViewer,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Permission::value] or
        /// [Permission::name].
        UnknownValue(permission::UnknownValue),
    }

    #[doc(hidden)]
    pub mod permission {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Permission {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AccessTransparencyAndEmergencyAccessLogs => std::option::Option::Some(1),
                Self::AssuredWorkloadsMonitoring => std::option::Option::Some(2),
                Self::AccessApprovalRequests => std::option::Option::Some(3),
                Self::AssuredWorkloadsEkmConnectionStatus => std::option::Option::Some(4),
                Self::AccessTransparencyLogsSupportCaseViewer => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERMISSION_UNSPECIFIED"),
                Self::AccessTransparencyAndEmergencyAccessLogs => {
                    std::option::Option::Some("ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS")
                }
                Self::AssuredWorkloadsMonitoring => {
                    std::option::Option::Some("ASSURED_WORKLOADS_MONITORING")
                }
                Self::AccessApprovalRequests => {
                    std::option::Option::Some("ACCESS_APPROVAL_REQUESTS")
                }
                Self::AssuredWorkloadsEkmConnectionStatus => {
                    std::option::Option::Some("ASSURED_WORKLOADS_EKM_CONNECTION_STATUS")
                }
                Self::AccessTransparencyLogsSupportCaseViewer => {
                    std::option::Option::Some("ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Permission {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Permission {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Permission {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AccessTransparencyAndEmergencyAccessLogs,
                2 => Self::AssuredWorkloadsMonitoring,
                3 => Self::AccessApprovalRequests,
                4 => Self::AssuredWorkloadsEkmConnectionStatus,
                5 => Self::AccessTransparencyLogsSupportCaseViewer,
                _ => Self::UnknownValue(permission::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Permission {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERMISSION_UNSPECIFIED" => Self::Unspecified,
                "ACCESS_TRANSPARENCY_AND_EMERGENCY_ACCESS_LOGS" => {
                    Self::AccessTransparencyAndEmergencyAccessLogs
                }
                "ASSURED_WORKLOADS_MONITORING" => Self::AssuredWorkloadsMonitoring,
                "ACCESS_APPROVAL_REQUESTS" => Self::AccessApprovalRequests,
                "ASSURED_WORKLOADS_EKM_CONNECTION_STATUS" => {
                    Self::AssuredWorkloadsEkmConnectionStatus
                }
                "ACCESS_TRANSPARENCY_LOGS_SUPPORT_CASE_VIEWER" => {
                    Self::AccessTransparencyLogsSupportCaseViewer
                }
                _ => Self::UnknownValue(permission::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Permission {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AccessTransparencyAndEmergencyAccessLogs => serializer.serialize_i32(1),
                Self::AssuredWorkloadsMonitoring => serializer.serialize_i32(2),
                Self::AccessApprovalRequests => serializer.serialize_i32(3),
                Self::AssuredWorkloadsEkmConnectionStatus => serializer.serialize_i32(4),
                Self::AccessTransparencyLogsSupportCaseViewer => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Permission {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Permission>::new(
                ".google.cloud.cloudcontrolspartner.v1.PartnerPermissions.Permission",
            ))
        }
    }
}

/// Request for getting the partner permissions granted for a workload
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPartnerPermissionsRequest {
    /// Required. Name of the resource to get in the format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPartnerPermissionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerPermissionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerPermissionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerPermissionsRequest"
    }
}

/// Message describing Partner resource
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Partner {
    /// Identifier. The resource name of the partner.
    /// Format: `organizations/{organization}/locations/{location}/partner`
    /// Example: "organizations/123456/locations/us-central1/partner"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// List of SKUs the partner is offering
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub skus: std::vec::Vec<crate::model::Sku>,

    /// List of Google Cloud supported EKM partners supported by the partner
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub ekm_solutions: std::vec::Vec<crate::model::EkmMetadata>,

    /// List of Google Cloud regions that the partner sells services to customers.
    /// Valid Google Cloud regions found here:
    /// <https://cloud.google.com/compute/docs/regions-zones>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub operated_cloud_regions: std::vec::Vec<std::string::String>,

    /// Google Cloud project ID in the partner's Google Cloud organization for
    /// receiving enhanced Logs for Partners.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub partner_project_id: std::string::String,

    /// Output only. Time the resource was created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the resource was updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Partner {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Partner::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skus][crate::model::Partner::skus].
    pub fn set_skus<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sku>,
    {
        use std::iter::Iterator;
        self.skus = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ekm_solutions][crate::model::Partner::ekm_solutions].
    pub fn set_ekm_solutions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EkmMetadata>,
    {
        use std::iter::Iterator;
        self.ekm_solutions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operated_cloud_regions][crate::model::Partner::operated_cloud_regions].
    pub fn set_operated_cloud_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.operated_cloud_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partner_project_id][crate::model::Partner::partner_project_id].
    pub fn set_partner_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.partner_project_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Partner::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Partner::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Partner::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Partner::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Partner {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Partner"
    }
}

/// Message for getting a Partner
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPartnerRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/partner`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPartnerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartnerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartnerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetPartnerRequest"
    }
}

/// Represents the SKU a partner owns inside Google Cloud to sell to customers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sku {
    /// Argentum product SKU, that is associated with the partner offerings to
    /// customers used by Syntro for billing purposes. SKUs can represent resold
    /// Google products or support services.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// Display name of the product identified by the SKU. A partner may want to
    /// show partner branded names for their offerings such as local sovereign
    /// cloud solutions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sku {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::Sku::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Sku::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Sku {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Sku"
    }
}

/// Holds information needed by Mudbray to use partner EKMs for workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EkmMetadata {
    /// The Cloud EKM partner.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ekm_solution: crate::model::ekm_metadata::EkmSolution,

    /// Endpoint for sending requests to the EKM for key provisioning during
    /// Assured Workload creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ekm_endpoint_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EkmMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ekm_solution][crate::model::EkmMetadata::ekm_solution].
    pub fn set_ekm_solution<T: std::convert::Into<crate::model::ekm_metadata::EkmSolution>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_solution = v.into();
        self
    }

    /// Sets the value of [ekm_endpoint_uri][crate::model::EkmMetadata::ekm_endpoint_uri].
    pub fn set_ekm_endpoint_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ekm_endpoint_uri = v.into();
        self
    }
}

impl wkt::message::Message for EkmMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.EkmMetadata"
    }
}

/// Defines additional types related to [EkmMetadata].
pub mod ekm_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents Google Cloud supported external key management partners
    /// [Google Cloud EKM partners
    /// docs](https://cloud.google.com/kms/docs/ekm#supported_partners).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EkmSolution {
        /// Unspecified EKM solution
        Unspecified,
        /// EKM Partner Fortanix
        Fortanix,
        /// EKM Partner FutureX
        Futurex,
        /// EKM Partner Thales
        Thales,
        /// This enum value is never used.
        #[deprecated]
        Virtru,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EkmSolution::value] or
        /// [EkmSolution::name].
        UnknownValue(ekm_solution::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ekm_solution {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EkmSolution {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Fortanix => std::option::Option::Some(1),
                Self::Futurex => std::option::Option::Some(2),
                Self::Thales => std::option::Option::Some(3),
                Self::Virtru => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EKM_SOLUTION_UNSPECIFIED"),
                Self::Fortanix => std::option::Option::Some("FORTANIX"),
                Self::Futurex => std::option::Option::Some("FUTUREX"),
                Self::Thales => std::option::Option::Some("THALES"),
                Self::Virtru => std::option::Option::Some("VIRTRU"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EkmSolution {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EkmSolution {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EkmSolution {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Fortanix,
                2 => Self::Futurex,
                3 => Self::Thales,
                4 => Self::Virtru,
                _ => Self::UnknownValue(ekm_solution::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EkmSolution {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EKM_SOLUTION_UNSPECIFIED" => Self::Unspecified,
                "FORTANIX" => Self::Fortanix,
                "FUTUREX" => Self::Futurex,
                "THALES" => Self::Thales,
                "VIRTRU" => Self::Virtru,
                _ => Self::UnknownValue(ekm_solution::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EkmSolution {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Fortanix => serializer.serialize_i32(1),
                Self::Futurex => serializer.serialize_i32(2),
                Self::Thales => serializer.serialize_i32(3),
                Self::Virtru => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EkmSolution {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EkmSolution>::new(
                ".google.cloud.cloudcontrolspartner.v1.EkmMetadata.EkmSolution",
            ))
        }
    }
}

/// Details of resource Violation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Violation {
    /// Identifier. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. Description for the Violation.
    /// e.g. OrgPolicy gcp.resourceLocations has non compliant value.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Output only. Time of the event which triggered the Violation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub begin_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time when the Violation record was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time of the event which fixed the Violation.
    /// If the violation is ACTIVE this will be empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resolve_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Category under which this violation is mapped.
    /// e.g. Location, Service Usage, Access, Encryption, etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub category: std::string::String,

    /// Output only. State of the violation
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::violation::State,

    /// Output only. Immutable. Name of the OrgPolicy which was modified with
    /// non-compliant change and resulted this violation. Format:
    /// `projects/{project_number}/policies/{constraint_name}`
    /// `folders/{folder_id}/policies/{constraint_name}`
    /// `organizations/{organization_id}/policies/{constraint_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub non_compliant_org_policy: std::string::String,

    /// The folder_id of the violation
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub folder_id: i64,

    /// Output only. Compliance violation remediation
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub remediation: std::option::Option<crate::model::violation::Remediation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Violation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Violation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Violation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [begin_time][crate::model::Violation::begin_time].
    pub fn set_begin_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.begin_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [begin_time][crate::model::Violation::begin_time].
    pub fn set_or_clear_begin_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.begin_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Violation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Violation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolve_time][crate::model::Violation::resolve_time].
    pub fn set_resolve_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.resolve_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resolve_time][crate::model::Violation::resolve_time].
    pub fn set_or_clear_resolve_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.resolve_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [category][crate::model::Violation::category].
    pub fn set_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Violation::state].
    pub fn set_state<T: std::convert::Into<crate::model::violation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [non_compliant_org_policy][crate::model::Violation::non_compliant_org_policy].
    pub fn set_non_compliant_org_policy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.non_compliant_org_policy = v.into();
        self
    }

    /// Sets the value of [folder_id][crate::model::Violation::folder_id].
    pub fn set_folder_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.folder_id = v.into();
        self
    }

    /// Sets the value of [remediation][crate::model::Violation::remediation].
    pub fn set_remediation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::violation::Remediation>,
    {
        self.remediation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [remediation][crate::model::Violation::remediation].
    pub fn set_or_clear_remediation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::violation::Remediation>,
    {
        self.remediation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Violation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation"
    }
}

/// Defines additional types related to [Violation].
pub mod violation {
    #[allow(unused_imports)]
    use super::*;

    /// Represents remediation guidance to resolve compliance violation for
    /// AssuredWorkload
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Remediation {
        /// Required. Remediation instructions to resolve violations
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub instructions: std::option::Option<crate::model::violation::remediation::Instructions>,

        /// Values that can resolve the violation
        /// For example: for list org policy violations, this will either be the list
        /// of allowed or denied values
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
        pub compliant_values: std::vec::Vec<std::string::String>,

        /// Output only. Remediation type based on the type of org policy values
        /// violated
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub remediation_type: crate::model::violation::remediation::RemediationType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Remediation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instructions][crate::model::violation::Remediation::instructions].
        pub fn set_instructions<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::violation::remediation::Instructions>,
        {
            self.instructions = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [instructions][crate::model::violation::Remediation::instructions].
        pub fn set_or_clear_instructions<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::violation::remediation::Instructions>,
        {
            self.instructions = v.map(|x| x.into());
            self
        }

        /// Sets the value of [compliant_values][crate::model::violation::Remediation::compliant_values].
        pub fn set_compliant_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.compliant_values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [remediation_type][crate::model::violation::Remediation::remediation_type].
        pub fn set_remediation_type<
            T: std::convert::Into<crate::model::violation::remediation::RemediationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.remediation_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Remediation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation"
        }
    }

    /// Defines additional types related to [Remediation].
    pub mod remediation {
        #[allow(unused_imports)]
        use super::*;

        /// Instructions to remediate violation
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Instructions {
            /// Remediation instructions to resolve violation via gcloud cli
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub gcloud_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Gcloud>,

            /// Remediation instructions to resolve violation via cloud console
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub console_instructions:
                std::option::Option<crate::model::violation::remediation::instructions::Console>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Instructions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gcloud_instructions][crate::model::violation::remediation::Instructions::gcloud_instructions].
            pub fn set_gcloud_instructions<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Gcloud>,
            {
                self.gcloud_instructions = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [gcloud_instructions][crate::model::violation::remediation::Instructions::gcloud_instructions].
            pub fn set_or_clear_gcloud_instructions<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Gcloud>,
            {
                self.gcloud_instructions = v.map(|x| x.into());
                self
            }

            /// Sets the value of [console_instructions][crate::model::violation::remediation::Instructions::console_instructions].
            pub fn set_console_instructions<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Console>,
            {
                self.console_instructions = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [console_instructions][crate::model::violation::remediation::Instructions::console_instructions].
            pub fn set_or_clear_console_instructions<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::violation::remediation::instructions::Console>,
            {
                self.console_instructions = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for Instructions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions"
            }
        }

        /// Defines additional types related to [Instructions].
        pub mod instructions {
            #[allow(unused_imports)]
            use super::*;

            /// Remediation instructions to resolve violation via gcloud cli
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Gcloud {
                /// Gcloud command to resolve violation
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
                pub gcloud_commands: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via gcloud cli
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
                pub additional_links: std::vec::Vec<std::string::String>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Gcloud {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [gcloud_commands][crate::model::violation::remediation::instructions::Gcloud::gcloud_commands].
                pub fn set_gcloud_commands<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.gcloud_commands = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Gcloud::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Gcloud::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Gcloud {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Gcloud"
                }
            }

            /// Remediation instructions to resolve violation via cloud console
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Console {
                /// Link to console page where violations can be resolved
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
                pub console_uris: std::vec::Vec<std::string::String>,

                /// Steps to resolve violation via cloud console
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
                pub steps: std::vec::Vec<std::string::String>,

                /// Additional urls for more information about steps
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
                pub additional_links: std::vec::Vec<std::string::String>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Console {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [console_uris][crate::model::violation::remediation::instructions::Console::console_uris].
                pub fn set_console_uris<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.console_uris = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [steps][crate::model::violation::remediation::instructions::Console::steps].
                pub fn set_steps<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.steps = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [additional_links][crate::model::violation::remediation::instructions::Console::additional_links].
                pub fn set_additional_links<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<std::string::String>,
                {
                    use std::iter::Iterator;
                    self.additional_links = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Console {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.Violation.Remediation.Instructions.Console"
                }
            }
        }

        /// Classifying remediation into various types based on the kind of
        /// violation. For example, violations caused due to changes in boolean org
        /// policy requires different remediation instructions compared to violation
        /// caused due to changes in allowed values of list org policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum RemediationType {
            /// Unspecified remediation type
            Unspecified,
            /// Remediation type for boolean org policy
            RemediationBooleanOrgPolicyViolation,
            /// Remediation type for list org policy which have allowed values in the
            /// monitoring rule
            RemediationListAllowedValuesOrgPolicyViolation,
            /// Remediation type for list org policy which have denied values in the
            /// monitoring rule
            RemediationListDeniedValuesOrgPolicyViolation,
            /// Remediation type for gcp.restrictCmekCryptoKeyProjects
            RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation,
            /// Remediation type for resource violation.
            RemediationResourceViolation,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [RemediationType::value] or
            /// [RemediationType::name].
            UnknownValue(remediation_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod remediation_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl RemediationType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::RemediationBooleanOrgPolicyViolation => std::option::Option::Some(1),
                    Self::RemediationListAllowedValuesOrgPolicyViolation => {
                        std::option::Option::Some(2)
                    }
                    Self::RemediationListDeniedValuesOrgPolicyViolation => {
                        std::option::Option::Some(3)
                    }
                    Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation => {
                        std::option::Option::Some(4)
                    }
                    Self::RemediationResourceViolation => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("REMEDIATION_TYPE_UNSPECIFIED"),
                    Self::RemediationBooleanOrgPolicyViolation => {
                        std::option::Option::Some("REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION")
                    }
                    Self::RemediationListAllowedValuesOrgPolicyViolation => {
                        std::option::Option::Some(
                            "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION",
                        )
                    }
                    Self::RemediationListDeniedValuesOrgPolicyViolation => {
                        std::option::Option::Some(
                            "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION",
                        )
                    }
                    Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation => {
                        std::option::Option::Some(
                            "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION",
                        )
                    }
                    Self::RemediationResourceViolation => {
                        std::option::Option::Some("REMEDIATION_RESOURCE_VIOLATION")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for RemediationType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for RemediationType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for RemediationType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::RemediationBooleanOrgPolicyViolation,
                    2 => Self::RemediationListAllowedValuesOrgPolicyViolation,
                    3 => Self::RemediationListDeniedValuesOrgPolicyViolation,
                    4 => Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation,
                    5 => Self::RemediationResourceViolation,
                    _ => Self::UnknownValue(remediation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for RemediationType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "REMEDIATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION" => {
                        Self::RemediationBooleanOrgPolicyViolation
                    }
                    "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION" => {
                        Self::RemediationListAllowedValuesOrgPolicyViolation
                    }
                    "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION" => {
                        Self::RemediationListDeniedValuesOrgPolicyViolation
                    }
                    "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION" => {
                        Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation
                    }
                    "REMEDIATION_RESOURCE_VIOLATION" => Self::RemediationResourceViolation,
                    _ => Self::UnknownValue(remediation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for RemediationType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::RemediationBooleanOrgPolicyViolation => serializer.serialize_i32(1),
                    Self::RemediationListAllowedValuesOrgPolicyViolation => {
                        serializer.serialize_i32(2)
                    }
                    Self::RemediationListDeniedValuesOrgPolicyViolation => {
                        serializer.serialize_i32(3)
                    }
                    Self::RemediationRestrictCmekCryptoKeyProjectsOrgPolicyViolation => {
                        serializer.serialize_i32(4)
                    }
                    Self::RemediationResourceViolation => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for RemediationType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<RemediationType>::new(
                    ".google.cloud.cloudcontrolspartner.v1.Violation.Remediation.RemediationType",
                ))
            }
        }
    }

    /// Violation State Values
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Violation is resolved.
        Resolved,
        /// Violation is Unresolved
        Unresolved,
        /// Violation is Exception
        Exception,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Resolved => std::option::Option::Some(1),
                Self::Unresolved => std::option::Option::Some(2),
                Self::Exception => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Resolved => std::option::Option::Some("RESOLVED"),
                Self::Unresolved => std::option::Option::Some("UNRESOLVED"),
                Self::Exception => std::option::Option::Some("EXCEPTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Resolved,
                2 => Self::Unresolved,
                3 => Self::Exception,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RESOLVED" => Self::Resolved,
                "UNRESOLVED" => Self::Unresolved,
                "EXCEPTION" => Self::Exception,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Resolved => serializer.serialize_i32(1),
                Self::Unresolved => serializer.serialize_i32(2),
                Self::Exception => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.cloudcontrolspartner.v1.Violation.State",
            ))
        }
    }
}

/// Message for requesting list of Violations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViolationsRequest {
    /// Required. Parent resource
    /// Format
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of customers row to return. The service may
    /// return fewer than this value. If unspecified, at most 10 customers will be
    /// returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListViolations` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    /// Optional. Specifies the interval for retrieving violations.
    /// if unspecified, all violations will be returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub interval: std::option::Option<gtype::model::Interval>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViolationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListViolationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListViolationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListViolationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListViolationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListViolationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ListViolationsRequest::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::ListViolationsRequest::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListViolationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsRequest"
    }
}

/// Response message for list customer violation requests
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListViolationsResponse {
    /// List of violation
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub violations: std::vec::Vec<crate::model::Violation>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Workloads that could not be reached due to permission errors or any other
    /// error. Ref: <https://google.aip.dev/217>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListViolationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [violations][crate::model::ListViolationsResponse::violations].
    pub fn set_violations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Violation>,
    {
        use std::iter::Iterator;
        self.violations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListViolationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListViolationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListViolationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.ListViolationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListViolationsResponse {
    type PageItem = crate::model::Violation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.violations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Violation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetViolationRequest {
    /// Required. Format:
    /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/violations/{violation}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetViolationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetViolationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetViolationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.cloudcontrolspartner.v1.GetViolationRequest"
    }
}

/// Enum for possible completion states.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CompletionState {
    /// Unspecified completion state.
    Unspecified,
    /// Task started (has start date) but not yet completed.
    Pending,
    /// Succeeded state.
    Succeeded,
    /// Failed state.
    Failed,
    /// Not applicable state.
    NotApplicable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CompletionState::value] or
    /// [CompletionState::name].
    UnknownValue(completion_state::UnknownValue),
}

#[doc(hidden)]
pub mod completion_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CompletionState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Pending => std::option::Option::Some(1),
            Self::Succeeded => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::NotApplicable => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPLETION_STATE_UNSPECIFIED"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::NotApplicable => std::option::Option::Some("NOT_APPLICABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CompletionState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CompletionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CompletionState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Pending,
            2 => Self::Succeeded,
            3 => Self::Failed,
            4 => Self::NotApplicable,
            _ => Self::UnknownValue(completion_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CompletionState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPLETION_STATE_UNSPECIFIED" => Self::Unspecified,
            "PENDING" => Self::Pending,
            "SUCCEEDED" => Self::Succeeded,
            "FAILED" => Self::Failed,
            "NOT_APPLICABLE" => Self::NotApplicable,
            _ => Self::UnknownValue(completion_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CompletionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Pending => serializer.serialize_i32(1),
            Self::Succeeded => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::NotApplicable => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CompletionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompletionState>::new(
            ".google.cloud.cloudcontrolspartner.v1.CompletionState",
        ))
    }
}
