// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate bytes;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate wkt;

/// **Anthos Config Management**: State for a single cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MembershipState {
    /// This field is set to the `cluster_name` field of the Membership Spec if it
    /// is not empty. Otherwise, it is set to the cluster's fleet membership name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Membership configuration in the cluster. This represents the actual state
    /// in the cluster, while the MembershipSpec in the FeatureSpec represents
    /// the intended state
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub membership_spec: std::option::Option<crate::model::MembershipSpec>,

    /// Current install status of ACM's Operator
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub operator_state: std::option::Option<crate::model::OperatorState>,

    /// Current sync status
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_sync_state: std::option::Option<crate::model::ConfigSyncState>,

    /// PolicyController status
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy_controller_state: std::option::Option<crate::model::PolicyControllerState>,

    /// Hierarchy Controller status
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hierarchy_controller_state: std::option::Option<crate::model::HierarchyControllerState>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MembershipState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::MembershipState::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [membership_spec][crate::model::MembershipState::membership_spec].
    pub fn set_membership_spec<
        T: std::convert::Into<std::option::Option<crate::model::MembershipSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.membership_spec = v.into();
        self
    }

    /// Sets the value of [operator_state][crate::model::MembershipState::operator_state].
    pub fn set_operator_state<
        T: std::convert::Into<std::option::Option<crate::model::OperatorState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operator_state = v.into();
        self
    }

    /// Sets the value of [config_sync_state][crate::model::MembershipState::config_sync_state].
    pub fn set_config_sync_state<
        T: std::convert::Into<std::option::Option<crate::model::ConfigSyncState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_sync_state = v.into();
        self
    }

    /// Sets the value of [policy_controller_state][crate::model::MembershipState::policy_controller_state].
    pub fn set_policy_controller_state<
        T: std::convert::Into<std::option::Option<crate::model::PolicyControllerState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy_controller_state = v.into();
        self
    }

    /// Sets the value of [hierarchy_controller_state][crate::model::MembershipState::hierarchy_controller_state].
    pub fn set_hierarchy_controller_state<
        T: std::convert::Into<std::option::Option<crate::model::HierarchyControllerState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hierarchy_controller_state = v.into();
        self
    }
}

impl wkt::message::Message for MembershipState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.MembershipState"
    }
}

/// **Anthos Config Management**: Configuration for a single cluster.
/// Intended to parallel the ConfigManagement CR.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MembershipSpec {
    /// Config Sync configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_sync: std::option::Option<crate::model::ConfigSync>,

    /// Policy Controller configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy_controller: std::option::Option<crate::model::PolicyController>,

    /// Hierarchy Controller configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hierarchy_controller: std::option::Option<crate::model::HierarchyControllerConfig>,

    /// Version of ACM installed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// The user-specified cluster name used by Config Sync cluster-name-selector
    /// annotation or ClusterSelector, for applying configs to only a subset
    /// of clusters.
    /// Omit this field if the cluster's fleet membership name is used by Config
    /// Sync cluster-name-selector annotation or ClusterSelector.
    /// Set this field if a name different from the cluster's fleet membership name
    /// is used by Config Sync cluster-name-selector annotation or ClusterSelector.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,

    /// Enables automatic Feature management.
    pub management: crate::model::membership_spec::Management,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MembershipSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config_sync][crate::model::MembershipSpec::config_sync].
    pub fn set_config_sync<T: std::convert::Into<std::option::Option<crate::model::ConfigSync>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_sync = v.into();
        self
    }

    /// Sets the value of [policy_controller][crate::model::MembershipSpec::policy_controller].
    pub fn set_policy_controller<
        T: std::convert::Into<std::option::Option<crate::model::PolicyController>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy_controller = v.into();
        self
    }

    /// Sets the value of [hierarchy_controller][crate::model::MembershipSpec::hierarchy_controller].
    pub fn set_hierarchy_controller<
        T: std::convert::Into<std::option::Option<crate::model::HierarchyControllerConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hierarchy_controller = v.into();
        self
    }

    /// Sets the value of [version][crate::model::MembershipSpec::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::MembershipSpec::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [management][crate::model::MembershipSpec::management].
    pub fn set_management<T: std::convert::Into<crate::model::membership_spec::Management>>(
        mut self,
        v: T,
    ) -> Self {
        self.management = v.into();
        self
    }
}

impl wkt::message::Message for MembershipSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.MembershipSpec"
    }
}

/// Defines additional types related to [MembershipSpec].
pub mod membership_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Whether to automatically manage the Feature.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Management {
        /// Unspecified
        Unspecified,
        /// Google will manage the Feature for the cluster.
        Automatic,
        /// User will manually manage the Feature for the cluster.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Management::value] or
        /// [Management::name].
        UnknownValue(management::UnknownValue),
    }

    #[doc(hidden)]
    pub mod management {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Management {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MANAGEMENT_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("MANAGEMENT_AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANAGEMENT_MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Management {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Management {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Management {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(management::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Management {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MANAGEMENT_UNSPECIFIED" => Self::Unspecified,
                "MANAGEMENT_AUTOMATIC" => Self::Automatic,
                "MANAGEMENT_MANUAL" => Self::Manual,
                _ => Self::UnknownValue(management::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Management {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Management {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Management>::new(
                ".google.cloud.gkehub.configmanagement.v1.MembershipSpec.Management",
            ))
        }
    }
}

/// Configuration for Config Sync
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigSync {
    /// Git repo configuration for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub git: std::option::Option<crate::model::GitConfig>,

    /// Specifies whether the Config Sync Repo is
    /// in "hierarchical" or "unstructured" mode.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_format: std::string::String,

    /// Enables the installation of ConfigSync.
    /// If set to true, ConfigSync resources will be created and the other
    /// ConfigSync fields will be applied if exist.
    /// If set to false, all other ConfigSync fields will be ignored, ConfigSync
    /// resources will be deleted.
    /// If omitted, ConfigSync resources will be managed depends on the presence
    /// of the git or oci field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<bool>,

    /// Set to true to enable the Config Sync admission webhook to prevent drifts.
    /// If set to `false`, disables the Config Sync admission webhook and does not
    /// prevent drifts.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub prevent_drift: bool,

    /// OCI repo configuration for the cluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub oci: std::option::Option<crate::model::OciConfig>,

    /// The Email of the Google Cloud Service Account (GSA) used for exporting
    /// Config Sync metrics to Cloud Monitoring when Workload Identity is enabled.
    /// The GSA should have the Monitoring Metric Writer
    /// (roles/monitoring.metricWriter) IAM role.
    /// The Kubernetes ServiceAccount `default` in the namespace
    /// `config-management-monitoring` should be bound to the GSA.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metrics_gcp_service_account_email: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigSync {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git][crate::model::ConfigSync::git].
    pub fn set_git<T: std::convert::Into<std::option::Option<crate::model::GitConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.git = v.into();
        self
    }

    /// Sets the value of [source_format][crate::model::ConfigSync::source_format].
    pub fn set_source_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_format = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::ConfigSync::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [prevent_drift][crate::model::ConfigSync::prevent_drift].
    pub fn set_prevent_drift<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.prevent_drift = v.into();
        self
    }

    /// Sets the value of [oci][crate::model::ConfigSync::oci].
    pub fn set_oci<T: std::convert::Into<std::option::Option<crate::model::OciConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.oci = v.into();
        self
    }

    /// Sets the value of [metrics_gcp_service_account_email][crate::model::ConfigSync::metrics_gcp_service_account_email].
    pub fn set_metrics_gcp_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics_gcp_service_account_email = v.into();
        self
    }
}

impl wkt::message::Message for ConfigSync {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.ConfigSync"
    }
}

/// Git repo configuration for a single cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitConfig {
    /// The URL of the Git repository to use as the source of truth.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sync_repo: std::string::String,

    /// The branch of the repository to sync from. Default: master.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sync_branch: std::string::String,

    /// The path within the Git repository that represents the top level of the
    /// repo to sync. Default: the root directory of the repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_dir: std::string::String,

    /// Period in seconds between consecutive syncs. Default: 15.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub sync_wait_secs: i64,

    /// Git revision (tag or hash) to check out. Default HEAD.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sync_rev: std::string::String,

    /// Type of secret configured for access to the Git repo. Must be one of ssh,
    /// cookiefile, gcenode, token, gcpserviceaccount or none. The
    /// validation of this is case-sensitive. Required.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_type: std::string::String,

    /// URL for the HTTPS proxy to be used when communicating with the Git repo.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub https_proxy: std::string::String,

    /// The Google Cloud Service Account Email used for auth when secret_type is
    /// gcpServiceAccount.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_service_account_email: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sync_repo][crate::model::GitConfig::sync_repo].
    pub fn set_sync_repo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sync_repo = v.into();
        self
    }

    /// Sets the value of [sync_branch][crate::model::GitConfig::sync_branch].
    pub fn set_sync_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sync_branch = v.into();
        self
    }

    /// Sets the value of [policy_dir][crate::model::GitConfig::policy_dir].
    pub fn set_policy_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_dir = v.into();
        self
    }

    /// Sets the value of [sync_wait_secs][crate::model::GitConfig::sync_wait_secs].
    pub fn set_sync_wait_secs<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sync_wait_secs = v.into();
        self
    }

    /// Sets the value of [sync_rev][crate::model::GitConfig::sync_rev].
    pub fn set_sync_rev<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sync_rev = v.into();
        self
    }

    /// Sets the value of [secret_type][crate::model::GitConfig::secret_type].
    pub fn set_secret_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_type = v.into();
        self
    }

    /// Sets the value of [https_proxy][crate::model::GitConfig::https_proxy].
    pub fn set_https_proxy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.https_proxy = v.into();
        self
    }

    /// Sets the value of [gcp_service_account_email][crate::model::GitConfig::gcp_service_account_email].
    pub fn set_gcp_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_service_account_email = v.into();
        self
    }
}

impl wkt::message::Message for GitConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.GitConfig"
    }
}

/// OCI repo configuration for a single cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OciConfig {
    /// The OCI image repository URL for the package to sync from.
    /// e.g. `LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sync_repo: std::string::String,

    /// The absolute path of the directory that contains
    /// the local resources.  Default: the root directory of the image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_dir: std::string::String,

    /// Period in seconds between consecutive syncs. Default: 15.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub sync_wait_secs: i64,

    /// Type of secret configured for access to the Git repo.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secret_type: std::string::String,

    /// The Google Cloud Service Account Email used for auth when secret_type is
    /// gcpServiceAccount.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcp_service_account_email: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OciConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sync_repo][crate::model::OciConfig::sync_repo].
    pub fn set_sync_repo<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sync_repo = v.into();
        self
    }

    /// Sets the value of [policy_dir][crate::model::OciConfig::policy_dir].
    pub fn set_policy_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_dir = v.into();
        self
    }

    /// Sets the value of [sync_wait_secs][crate::model::OciConfig::sync_wait_secs].
    pub fn set_sync_wait_secs<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sync_wait_secs = v.into();
        self
    }

    /// Sets the value of [secret_type][crate::model::OciConfig::secret_type].
    pub fn set_secret_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_type = v.into();
        self
    }

    /// Sets the value of [gcp_service_account_email][crate::model::OciConfig::gcp_service_account_email].
    pub fn set_gcp_service_account_email<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_service_account_email = v.into();
        self
    }
}

impl wkt::message::Message for OciConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.OciConfig"
    }
}

/// Configuration for Policy Controller
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicyController {
    /// Enables the installation of Policy Controller.
    /// If false, the rest of PolicyController fields take no
    /// effect.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// Installs the default template library along with Policy Controller.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template_library_installed: std::option::Option<bool>,

    /// Sets the interval for Policy Controller Audit Scans (in seconds).
    /// When set to 0, this disables audit functionality altogether.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub audit_interval_seconds: std::option::Option<i64>,

    /// The set of namespaces that are excluded from Policy Controller checks.
    /// Namespaces do not need to currently exist on the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exemptable_namespaces: std::vec::Vec<std::string::String>,

    /// Enables the ability to use Constraint Templates that reference to objects
    /// other than the object currently being evaluated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub referential_rules_enabled: bool,

    /// Logs all denies and dry run failures.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub log_denies_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyController {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::PolicyController::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [template_library_installed][crate::model::PolicyController::template_library_installed].
    pub fn set_template_library_installed<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.template_library_installed = v.into();
        self
    }

    /// Sets the value of [audit_interval_seconds][crate::model::PolicyController::audit_interval_seconds].
    pub fn set_audit_interval_seconds<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.audit_interval_seconds = v.into();
        self
    }

    /// Sets the value of [referential_rules_enabled][crate::model::PolicyController::referential_rules_enabled].
    pub fn set_referential_rules_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.referential_rules_enabled = v.into();
        self
    }

    /// Sets the value of [log_denies_enabled][crate::model::PolicyController::log_denies_enabled].
    pub fn set_log_denies_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.log_denies_enabled = v.into();
        self
    }

    /// Sets the value of [exemptable_namespaces][crate::model::PolicyController::exemptable_namespaces].
    pub fn set_exemptable_namespaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exemptable_namespaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PolicyController {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.PolicyController"
    }
}

/// Configuration for Hierarchy Controller
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HierarchyControllerConfig {
    /// Whether Hierarchy Controller is enabled in this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    /// Whether pod tree labels are enabled in this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_pod_tree_labels: bool,

    /// Whether hierarchical resource quota is enabled in this cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_hierarchical_resource_quota: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HierarchyControllerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::HierarchyControllerConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [enable_pod_tree_labels][crate::model::HierarchyControllerConfig::enable_pod_tree_labels].
    pub fn set_enable_pod_tree_labels<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_pod_tree_labels = v.into();
        self
    }

    /// Sets the value of [enable_hierarchical_resource_quota][crate::model::HierarchyControllerConfig::enable_hierarchical_resource_quota].
    pub fn set_enable_hierarchical_resource_quota<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_hierarchical_resource_quota = v.into();
        self
    }
}

impl wkt::message::Message for HierarchyControllerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.HierarchyControllerConfig"
    }
}

/// Deployment state for Hierarchy Controller
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HierarchyControllerDeploymentState {
    /// The deployment state for open source HNC (e.g. v0.7.0-hc.0)
    pub hnc: crate::model::DeploymentState,

    /// The deployment state for Hierarchy Controller extension (e.g. v0.7.0-hc.1)
    pub extension: crate::model::DeploymentState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HierarchyControllerDeploymentState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hnc][crate::model::HierarchyControllerDeploymentState::hnc].
    pub fn set_hnc<T: std::convert::Into<crate::model::DeploymentState>>(mut self, v: T) -> Self {
        self.hnc = v.into();
        self
    }

    /// Sets the value of [extension][crate::model::HierarchyControllerDeploymentState::extension].
    pub fn set_extension<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.extension = v.into();
        self
    }
}

impl wkt::message::Message for HierarchyControllerDeploymentState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.HierarchyControllerDeploymentState"
    }
}

/// Version for Hierarchy Controller
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HierarchyControllerVersion {
    /// Version for open source HNC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hnc: std::string::String,

    /// Version for Hierarchy Controller extension
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub extension: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HierarchyControllerVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hnc][crate::model::HierarchyControllerVersion::hnc].
    pub fn set_hnc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hnc = v.into();
        self
    }

    /// Sets the value of [extension][crate::model::HierarchyControllerVersion::extension].
    pub fn set_extension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.extension = v.into();
        self
    }
}

impl wkt::message::Message for HierarchyControllerVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.HierarchyControllerVersion"
    }
}

/// State for Hierarchy Controller
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HierarchyControllerState {
    /// The version for Hierarchy Controller
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::HierarchyControllerVersion>,

    /// The deployment state for Hierarchy Controller
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state: std::option::Option<crate::model::HierarchyControllerDeploymentState>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HierarchyControllerState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::HierarchyControllerState::version].
    pub fn set_version<
        T: std::convert::Into<std::option::Option<crate::model::HierarchyControllerVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::HierarchyControllerState::state].
    pub fn set_state<
        T: std::convert::Into<std::option::Option<crate::model::HierarchyControllerDeploymentState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for HierarchyControllerState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.HierarchyControllerState"
    }
}

/// State information for an ACM's Operator
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperatorState {
    /// The semenatic version number of the operator
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// The state of the Operator's deployment
    pub deployment_state: crate::model::DeploymentState,

    /// Install errors.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::InstallError>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperatorState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::OperatorState::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [deployment_state][crate::model::OperatorState::deployment_state].
    pub fn set_deployment_state<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::OperatorState::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstallError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperatorState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.OperatorState"
    }
}

/// Errors pertaining to the installation of ACM
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstallError {
    /// A string representing the user facing error message
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstallError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_message][crate::model::InstallError::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }
}

impl wkt::message::Message for InstallError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.InstallError"
    }
}

/// State information for ConfigSync
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigSyncState {
    /// The version of ConfigSync deployed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::ConfigSyncVersion>,

    /// Information about the deployment of ConfigSync, including the version
    /// of the various Pods deployed
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_state: std::option::Option<crate::model::ConfigSyncDeploymentState>,

    /// The state of ConfigSync's process to sync configs to a cluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sync_state: std::option::Option<crate::model::SyncState>,

    /// Errors pertaining to the installation of Config Sync.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::ConfigSyncError>,

    /// The state of the RootSync CRD
    pub rootsync_crd: crate::model::config_sync_state::CRDState,

    /// The state of the Reposync CRD
    pub reposync_crd: crate::model::config_sync_state::CRDState,

    /// The state of CS
    /// This field summarizes the other fields in this message.
    pub state: crate::model::config_sync_state::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigSyncState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::ConfigSyncState::version].
    pub fn set_version<
        T: std::convert::Into<std::option::Option<crate::model::ConfigSyncVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [deployment_state][crate::model::ConfigSyncState::deployment_state].
    pub fn set_deployment_state<
        T: std::convert::Into<std::option::Option<crate::model::ConfigSyncDeploymentState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_state = v.into();
        self
    }

    /// Sets the value of [sync_state][crate::model::ConfigSyncState::sync_state].
    pub fn set_sync_state<T: std::convert::Into<std::option::Option<crate::model::SyncState>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sync_state = v.into();
        self
    }

    /// Sets the value of [rootsync_crd][crate::model::ConfigSyncState::rootsync_crd].
    pub fn set_rootsync_crd<T: std::convert::Into<crate::model::config_sync_state::CRDState>>(
        mut self,
        v: T,
    ) -> Self {
        self.rootsync_crd = v.into();
        self
    }

    /// Sets the value of [reposync_crd][crate::model::ConfigSyncState::reposync_crd].
    pub fn set_reposync_crd<T: std::convert::Into<crate::model::config_sync_state::CRDState>>(
        mut self,
        v: T,
    ) -> Self {
        self.reposync_crd = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ConfigSyncState::state].
    pub fn set_state<T: std::convert::Into<crate::model::config_sync_state::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::ConfigSyncState::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigSyncError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfigSyncState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.ConfigSyncState"
    }
}

/// Defines additional types related to [ConfigSyncState].
pub mod config_sync_state {
    #[allow(unused_imports)]
    use super::*;

    /// CRDState representing the state of a CRD
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CRDState {
        /// CRD's state cannot be determined
        Unspecified,
        /// CRD is not installed
        NotInstalled,
        /// CRD is installed
        Installed,
        /// CRD is terminating (i.e., it has been deleted and is cleaning up)
        Terminating,
        /// CRD is installing
        Installing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CRDState::value] or
        /// [CRDState::name].
        UnknownValue(crd_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod crd_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CRDState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotInstalled => std::option::Option::Some(1),
                Self::Installed => std::option::Option::Some(2),
                Self::Terminating => std::option::Option::Some(3),
                Self::Installing => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CRD_STATE_UNSPECIFIED"),
                Self::NotInstalled => std::option::Option::Some("NOT_INSTALLED"),
                Self::Installed => std::option::Option::Some("INSTALLED"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Installing => std::option::Option::Some("INSTALLING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CRDState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CRDState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CRDState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotInstalled,
                2 => Self::Installed,
                3 => Self::Terminating,
                4 => Self::Installing,
                _ => Self::UnknownValue(crd_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CRDState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CRD_STATE_UNSPECIFIED" => Self::Unspecified,
                "NOT_INSTALLED" => Self::NotInstalled,
                "INSTALLED" => Self::Installed,
                "TERMINATING" => Self::Terminating,
                "INSTALLING" => Self::Installing,
                _ => Self::UnknownValue(crd_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CRDState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotInstalled => serializer.serialize_i32(1),
                Self::Installed => serializer.serialize_i32(2),
                Self::Terminating => serializer.serialize_i32(3),
                Self::Installing => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CRDState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CRDState>::new(
                ".google.cloud.gkehub.configmanagement.v1.ConfigSyncState.CRDState",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// CS's state cannot be determined.
        Unspecified,
        /// CS is not installed.
        ConfigSyncNotInstalled,
        /// The expected CS version is installed successfully.
        ConfigSyncInstalled,
        /// CS encounters errors.
        ConfigSyncError,
        /// CS is installing or terminating.
        ConfigSyncPending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConfigSyncNotInstalled => std::option::Option::Some(1),
                Self::ConfigSyncInstalled => std::option::Option::Some(2),
                Self::ConfigSyncError => std::option::Option::Some(3),
                Self::ConfigSyncPending => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::ConfigSyncNotInstalled => {
                    std::option::Option::Some("CONFIG_SYNC_NOT_INSTALLED")
                }
                Self::ConfigSyncInstalled => std::option::Option::Some("CONFIG_SYNC_INSTALLED"),
                Self::ConfigSyncError => std::option::Option::Some("CONFIG_SYNC_ERROR"),
                Self::ConfigSyncPending => std::option::Option::Some("CONFIG_SYNC_PENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConfigSyncNotInstalled,
                2 => Self::ConfigSyncInstalled,
                3 => Self::ConfigSyncError,
                4 => Self::ConfigSyncPending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CONFIG_SYNC_NOT_INSTALLED" => Self::ConfigSyncNotInstalled,
                "CONFIG_SYNC_INSTALLED" => Self::ConfigSyncInstalled,
                "CONFIG_SYNC_ERROR" => Self::ConfigSyncError,
                "CONFIG_SYNC_PENDING" => Self::ConfigSyncPending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConfigSyncNotInstalled => serializer.serialize_i32(1),
                Self::ConfigSyncInstalled => serializer.serialize_i32(2),
                Self::ConfigSyncError => serializer.serialize_i32(3),
                Self::ConfigSyncPending => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkehub.configmanagement.v1.ConfigSyncState.State",
            ))
        }
    }
}

/// Errors pertaining to the installation of Config Sync
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigSyncError {
    /// A string representing the user facing error message
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigSyncError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_message][crate::model::ConfigSyncError::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }
}

impl wkt::message::Message for ConfigSyncError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.ConfigSyncError"
    }
}

/// Specific versioning information pertaining to ConfigSync's Pods
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigSyncVersion {
    /// Version of the deployed importer pod
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub importer: std::string::String,

    /// Version of the deployed syncer pod
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub syncer: std::string::String,

    /// Version of the deployed git-sync pod
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_sync: std::string::String,

    /// Version of the deployed monitor pod
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub monitor: std::string::String,

    /// Version of the deployed reconciler-manager pod
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reconciler_manager: std::string::String,

    /// Version of the deployed reconciler container in root-reconciler pod
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_reconciler: std::string::String,

    /// Version of the deployed admission_webhook pod
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub admission_webhook: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigSyncVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [importer][crate::model::ConfigSyncVersion::importer].
    pub fn set_importer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.importer = v.into();
        self
    }

    /// Sets the value of [syncer][crate::model::ConfigSyncVersion::syncer].
    pub fn set_syncer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.syncer = v.into();
        self
    }

    /// Sets the value of [git_sync][crate::model::ConfigSyncVersion::git_sync].
    pub fn set_git_sync<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_sync = v.into();
        self
    }

    /// Sets the value of [monitor][crate::model::ConfigSyncVersion::monitor].
    pub fn set_monitor<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.monitor = v.into();
        self
    }

    /// Sets the value of [reconciler_manager][crate::model::ConfigSyncVersion::reconciler_manager].
    pub fn set_reconciler_manager<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reconciler_manager = v.into();
        self
    }

    /// Sets the value of [root_reconciler][crate::model::ConfigSyncVersion::root_reconciler].
    pub fn set_root_reconciler<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_reconciler = v.into();
        self
    }

    /// Sets the value of [admission_webhook][crate::model::ConfigSyncVersion::admission_webhook].
    pub fn set_admission_webhook<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.admission_webhook = v.into();
        self
    }
}

impl wkt::message::Message for ConfigSyncVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.ConfigSyncVersion"
    }
}

/// The state of ConfigSync's deployment on a cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigSyncDeploymentState {
    /// Deployment state of the importer pod
    pub importer: crate::model::DeploymentState,

    /// Deployment state of the syncer pod
    pub syncer: crate::model::DeploymentState,

    /// Deployment state of the git-sync pod
    pub git_sync: crate::model::DeploymentState,

    /// Deployment state of the monitor pod
    pub monitor: crate::model::DeploymentState,

    /// Deployment state of reconciler-manager pod
    pub reconciler_manager: crate::model::DeploymentState,

    /// Deployment state of root-reconciler
    pub root_reconciler: crate::model::DeploymentState,

    /// Deployment state of admission-webhook
    pub admission_webhook: crate::model::DeploymentState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigSyncDeploymentState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [importer][crate::model::ConfigSyncDeploymentState::importer].
    pub fn set_importer<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.importer = v.into();
        self
    }

    /// Sets the value of [syncer][crate::model::ConfigSyncDeploymentState::syncer].
    pub fn set_syncer<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.syncer = v.into();
        self
    }

    /// Sets the value of [git_sync][crate::model::ConfigSyncDeploymentState::git_sync].
    pub fn set_git_sync<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_sync = v.into();
        self
    }

    /// Sets the value of [monitor][crate::model::ConfigSyncDeploymentState::monitor].
    pub fn set_monitor<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitor = v.into();
        self
    }

    /// Sets the value of [reconciler_manager][crate::model::ConfigSyncDeploymentState::reconciler_manager].
    pub fn set_reconciler_manager<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.reconciler_manager = v.into();
        self
    }

    /// Sets the value of [root_reconciler][crate::model::ConfigSyncDeploymentState::root_reconciler].
    pub fn set_root_reconciler<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.root_reconciler = v.into();
        self
    }

    /// Sets the value of [admission_webhook][crate::model::ConfigSyncDeploymentState::admission_webhook].
    pub fn set_admission_webhook<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.admission_webhook = v.into();
        self
    }
}

impl wkt::message::Message for ConfigSyncDeploymentState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.ConfigSyncDeploymentState"
    }
}

/// State indicating an ACM's progress syncing configurations to a cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncState {
    /// Token indicating the state of the repo.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_token: std::string::String,

    /// Token indicating the state of the importer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub import_token: std::string::String,

    /// Token indicating the state of the syncer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sync_token: std::string::String,

    /// Deprecated: use last_sync_time instead.
    /// Timestamp of when ACM last successfully synced the repo
    /// The time format is specified in <https://golang.org/pkg/time/#Time.String>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub last_sync: std::string::String,

    /// Timestamp type of when ACM last successfully synced the repo
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_sync_time: std::option::Option<wkt::Timestamp>,

    /// Sync status code
    pub code: crate::model::sync_state::SyncCode,

    /// A list of errors resulting from problematic configs.
    /// This list will be truncated after 100 errors, although it is
    /// unlikely for that many errors to simultaneously exist.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub errors: std::vec::Vec<crate::model::SyncError>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SyncState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_token][crate::model::SyncState::source_token].
    pub fn set_source_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_token = v.into();
        self
    }

    /// Sets the value of [import_token][crate::model::SyncState::import_token].
    pub fn set_import_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.import_token = v.into();
        self
    }

    /// Sets the value of [sync_token][crate::model::SyncState::sync_token].
    pub fn set_sync_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sync_token = v.into();
        self
    }

    /// Sets the value of [last_sync][crate::model::SyncState::last_sync].
    #[deprecated]
    pub fn set_last_sync<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.last_sync = v.into();
        self
    }

    /// Sets the value of [last_sync_time][crate::model::SyncState::last_sync_time].
    pub fn set_last_sync_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_sync_time = v.into();
        self
    }

    /// Sets the value of [code][crate::model::SyncState::code].
    pub fn set_code<T: std::convert::Into<crate::model::sync_state::SyncCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::SyncState::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SyncError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SyncState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.SyncState"
    }
}

/// Defines additional types related to [SyncState].
pub mod sync_state {
    #[allow(unused_imports)]
    use super::*;

    /// An enum representing Config Sync's status of syncing configs to a cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SyncCode {
        /// Config Sync cannot determine a sync code
        Unspecified,
        /// Config Sync successfully synced the git Repo with the cluster
        Synced,
        /// Config Sync is in the progress of syncing a new change
        Pending,
        /// Indicates an error configuring Config Sync, and user action is required
        Error,
        /// Config Sync has been installed but not configured
        NotConfigured,
        /// Config Sync has not been installed
        NotInstalled,
        /// Error authorizing with the cluster
        Unauthorized,
        /// Cluster could not be reached
        Unreachable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SyncCode::value] or
        /// [SyncCode::name].
        UnknownValue(sync_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sync_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SyncCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Synced => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::NotConfigured => std::option::Option::Some(4),
                Self::NotInstalled => std::option::Option::Some(5),
                Self::Unauthorized => std::option::Option::Some(6),
                Self::Unreachable => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SYNC_CODE_UNSPECIFIED"),
                Self::Synced => std::option::Option::Some("SYNCED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::NotConfigured => std::option::Option::Some("NOT_CONFIGURED"),
                Self::NotInstalled => std::option::Option::Some("NOT_INSTALLED"),
                Self::Unauthorized => std::option::Option::Some("UNAUTHORIZED"),
                Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SyncCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SyncCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SyncCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Synced,
                2 => Self::Pending,
                3 => Self::Error,
                4 => Self::NotConfigured,
                5 => Self::NotInstalled,
                6 => Self::Unauthorized,
                7 => Self::Unreachable,
                _ => Self::UnknownValue(sync_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SyncCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SYNC_CODE_UNSPECIFIED" => Self::Unspecified,
                "SYNCED" => Self::Synced,
                "PENDING" => Self::Pending,
                "ERROR" => Self::Error,
                "NOT_CONFIGURED" => Self::NotConfigured,
                "NOT_INSTALLED" => Self::NotInstalled,
                "UNAUTHORIZED" => Self::Unauthorized,
                "UNREACHABLE" => Self::Unreachable,
                _ => Self::UnknownValue(sync_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SyncCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Synced => serializer.serialize_i32(1),
                Self::Pending => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::NotConfigured => serializer.serialize_i32(4),
                Self::NotInstalled => serializer.serialize_i32(5),
                Self::Unauthorized => serializer.serialize_i32(6),
                Self::Unreachable => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SyncCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SyncCode>::new(
                ".google.cloud.gkehub.configmanagement.v1.SyncState.SyncCode",
            ))
        }
    }
}

/// An ACM created error representing a problem syncing configurations
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SyncError {
    /// An ACM defined error code
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    /// A description of the error
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    /// A list of config(s) associated with the error, if any
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_resources: std::vec::Vec<crate::model::ErrorResource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SyncError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::SyncError::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::SyncError::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [error_resources][crate::model::SyncError::error_resources].
    pub fn set_error_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ErrorResource>,
    {
        use std::iter::Iterator;
        self.error_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SyncError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.SyncError"
    }
}

/// Model for a config file in the git repo with an associated Sync error
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorResource {
    /// Path in the git repo of the erroneous config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_path: std::string::String,

    /// Metadata name of the resource that is causing an error
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_name: std::string::String,

    /// Namespace of the resource that is causing an error
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource_namespace: std::string::String,

    /// Group/version/kind of the resource that is causing an error
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_gvk: std::option::Option<crate::model::GroupVersionKind>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_path][crate::model::ErrorResource::source_path].
    pub fn set_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_path = v.into();
        self
    }

    /// Sets the value of [resource_name][crate::model::ErrorResource::resource_name].
    pub fn set_resource_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_name = v.into();
        self
    }

    /// Sets the value of [resource_namespace][crate::model::ErrorResource::resource_namespace].
    pub fn set_resource_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_namespace = v.into();
        self
    }

    /// Sets the value of [resource_gvk][crate::model::ErrorResource::resource_gvk].
    pub fn set_resource_gvk<
        T: std::convert::Into<std::option::Option<crate::model::GroupVersionKind>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_gvk = v.into();
        self
    }
}

impl wkt::message::Message for ErrorResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.ErrorResource"
    }
}

/// A Kubernetes object's GVK
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroupVersionKind {
    /// Kubernetes Group
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// Kubernetes Version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Kubernetes Kind
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kind: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GroupVersionKind {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::GroupVersionKind::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GroupVersionKind::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::GroupVersionKind::kind].
    pub fn set_kind<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for GroupVersionKind {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.GroupVersionKind"
    }
}

/// State for PolicyControllerState.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicyControllerState {
    /// The version of Gatekeeper Policy Controller deployed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<crate::model::PolicyControllerVersion>,

    /// The state about the policy controller installation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deployment_state: std::option::Option<crate::model::GatekeeperDeploymentState>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyControllerState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::PolicyControllerState::version].
    pub fn set_version<
        T: std::convert::Into<std::option::Option<crate::model::PolicyControllerVersion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [deployment_state][crate::model::PolicyControllerState::deployment_state].
    pub fn set_deployment_state<
        T: std::convert::Into<std::option::Option<crate::model::GatekeeperDeploymentState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.deployment_state = v.into();
        self
    }
}

impl wkt::message::Message for PolicyControllerState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.PolicyControllerState"
    }
}

/// The build version of Gatekeeper Policy Controller is using.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PolicyControllerVersion {
    /// The gatekeeper image tag that is composed of ACM version, git tag, build
    /// number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PolicyControllerVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::PolicyControllerVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for PolicyControllerVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.PolicyControllerVersion"
    }
}

/// State of Policy Controller installation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GatekeeperDeploymentState {
    /// Status of gatekeeper-controller-manager pod.
    pub gatekeeper_controller_manager_state: crate::model::DeploymentState,

    /// Status of gatekeeper-audit deployment.
    pub gatekeeper_audit: crate::model::DeploymentState,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GatekeeperDeploymentState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gatekeeper_controller_manager_state][crate::model::GatekeeperDeploymentState::gatekeeper_controller_manager_state].
    pub fn set_gatekeeper_controller_manager_state<
        T: std::convert::Into<crate::model::DeploymentState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gatekeeper_controller_manager_state = v.into();
        self
    }

    /// Sets the value of [gatekeeper_audit][crate::model::GatekeeperDeploymentState::gatekeeper_audit].
    pub fn set_gatekeeper_audit<T: std::convert::Into<crate::model::DeploymentState>>(
        mut self,
        v: T,
    ) -> Self {
        self.gatekeeper_audit = v.into();
        self
    }
}

impl wkt::message::Message for GatekeeperDeploymentState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkehub.configmanagement.v1.GatekeeperDeploymentState"
    }
}

/// Enum representing the state of an ACM's deployment on a cluster
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DeploymentState {
    /// Deployment's state cannot be determined
    Unspecified,
    /// Deployment is not installed
    NotInstalled,
    /// Deployment is installed
    Installed,
    /// Deployment was attempted to be installed, but has errors
    Error,
    /// Deployment is installing or terminating
    Pending,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DeploymentState::value] or
    /// [DeploymentState::name].
    UnknownValue(deployment_state::UnknownValue),
}

#[doc(hidden)]
pub mod deployment_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DeploymentState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NotInstalled => std::option::Option::Some(1),
            Self::Installed => std::option::Option::Some(2),
            Self::Error => std::option::Option::Some(3),
            Self::Pending => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DEPLOYMENT_STATE_UNSPECIFIED"),
            Self::NotInstalled => std::option::Option::Some("NOT_INSTALLED"),
            Self::Installed => std::option::Option::Some("INSTALLED"),
            Self::Error => std::option::Option::Some("ERROR"),
            Self::Pending => std::option::Option::Some("PENDING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DeploymentState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DeploymentState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DeploymentState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NotInstalled,
            2 => Self::Installed,
            3 => Self::Error,
            4 => Self::Pending,
            _ => Self::UnknownValue(deployment_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DeploymentState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DEPLOYMENT_STATE_UNSPECIFIED" => Self::Unspecified,
            "NOT_INSTALLED" => Self::NotInstalled,
            "INSTALLED" => Self::Installed,
            "ERROR" => Self::Error,
            "PENDING" => Self::Pending,
            _ => Self::UnknownValue(deployment_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DeploymentState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NotInstalled => serializer.serialize_i32(1),
            Self::Installed => serializer.serialize_i32(2),
            Self::Error => serializer.serialize_i32(3),
            Self::Pending => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DeploymentState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeploymentState>::new(
            ".google.cloud.gkehub.configmanagement.v1.DeploymentState",
        ))
    }
}
