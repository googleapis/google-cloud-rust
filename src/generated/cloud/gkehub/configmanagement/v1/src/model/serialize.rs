// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::MembershipState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if self.membership_spec.is_some() {
            state.serialize_entry("membershipSpec", &self.membership_spec)?;
        }
        if self.operator_state.is_some() {
            state.serialize_entry("operatorState", &self.operator_state)?;
        }
        if self.config_sync_state.is_some() {
            state.serialize_entry("configSyncState", &self.config_sync_state)?;
        }
        if self.policy_controller_state.is_some() {
            state.serialize_entry("policyControllerState", &self.policy_controller_state)?;
        }
        if self.hierarchy_controller_state.is_some() {
            state.serialize_entry("hierarchyControllerState", &self.hierarchy_controller_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MembershipSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config_sync.is_some() {
            state.serialize_entry("configSync", &self.config_sync)?;
        }
        if self.policy_controller.is_some() {
            state.serialize_entry("policyController", &self.policy_controller)?;
        }
        if self.hierarchy_controller.is_some() {
            state.serialize_entry("hierarchyController", &self.hierarchy_controller)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !wkt::internal::is_default(&self.management) {
            state.serialize_entry("management", &self.management)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ConfigSync {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.git.is_some() {
            state.serialize_entry("git", &self.git)?;
        }
        if !self.source_format.is_empty() {
            state.serialize_entry("sourceFormat", &self.source_format)?;
        }
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.prevent_drift) {
            state.serialize_entry("preventDrift", &self.prevent_drift)?;
        }
        if self.oci.is_some() {
            state.serialize_entry("oci", &self.oci)?;
        }
        if !self.metrics_gcp_service_account_email.is_empty() {
            state.serialize_entry(
                "metricsGcpServiceAccountEmail",
                &self.metrics_gcp_service_account_email,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GitConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sync_repo.is_empty() {
            state.serialize_entry("syncRepo", &self.sync_repo)?;
        }
        if !self.sync_branch.is_empty() {
            state.serialize_entry("syncBranch", &self.sync_branch)?;
        }
        if !self.policy_dir.is_empty() {
            state.serialize_entry("policyDir", &self.policy_dir)?;
        }
        if !wkt::internal::is_default(&self.sync_wait_secs) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("syncWaitSecs", &__With(&self.sync_wait_secs))?;
        }
        if !self.sync_rev.is_empty() {
            state.serialize_entry("syncRev", &self.sync_rev)?;
        }
        if !self.secret_type.is_empty() {
            state.serialize_entry("secretType", &self.secret_type)?;
        }
        if !self.https_proxy.is_empty() {
            state.serialize_entry("httpsProxy", &self.https_proxy)?;
        }
        if !self.gcp_service_account_email.is_empty() {
            state.serialize_entry("gcpServiceAccountEmail", &self.gcp_service_account_email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OciConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sync_repo.is_empty() {
            state.serialize_entry("syncRepo", &self.sync_repo)?;
        }
        if !self.policy_dir.is_empty() {
            state.serialize_entry("policyDir", &self.policy_dir)?;
        }
        if !wkt::internal::is_default(&self.sync_wait_secs) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("syncWaitSecs", &__With(&self.sync_wait_secs))?;
        }
        if !self.secret_type.is_empty() {
            state.serialize_entry("secretType", &self.secret_type)?;
        }
        if !self.gcp_service_account_email.is_empty() {
            state.serialize_entry("gcpServiceAccountEmail", &self.gcp_service_account_email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::PolicyController {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.template_library_installed.is_some() {
            state.serialize_entry("templateLibraryInstalled", &self.template_library_installed)?;
        }
        if self.audit_interval_seconds.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "auditIntervalSeconds",
                &__With(&self.audit_interval_seconds),
            )?;
        }
        if !self.exemptable_namespaces.is_empty() {
            state.serialize_entry("exemptableNamespaces", &self.exemptable_namespaces)?;
        }
        if !wkt::internal::is_default(&self.referential_rules_enabled) {
            state.serialize_entry("referentialRulesEnabled", &self.referential_rules_enabled)?;
        }
        if !wkt::internal::is_default(&self.log_denies_enabled) {
            state.serialize_entry("logDeniesEnabled", &self.log_denies_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HierarchyControllerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.enable_pod_tree_labels) {
            state.serialize_entry("enablePodTreeLabels", &self.enable_pod_tree_labels)?;
        }
        if !wkt::internal::is_default(&self.enable_hierarchical_resource_quota) {
            state.serialize_entry(
                "enableHierarchicalResourceQuota",
                &self.enable_hierarchical_resource_quota,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HierarchyControllerDeploymentState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.hnc) {
            state.serialize_entry("hnc", &self.hnc)?;
        }
        if !wkt::internal::is_default(&self.extension) {
            state.serialize_entry("extension", &self.extension)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HierarchyControllerVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hnc.is_empty() {
            state.serialize_entry("hnc", &self.hnc)?;
        }
        if !self.extension.is_empty() {
            state.serialize_entry("extension", &self.extension)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HierarchyControllerState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OperatorState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.deployment_state) {
            state.serialize_entry("deploymentState", &self.deployment_state)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::InstallError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ConfigSyncState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.deployment_state.is_some() {
            state.serialize_entry("deploymentState", &self.deployment_state)?;
        }
        if self.sync_state.is_some() {
            state.serialize_entry("syncState", &self.sync_state)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !wkt::internal::is_default(&self.rootsync_crd) {
            state.serialize_entry("rootsyncCrd", &self.rootsync_crd)?;
        }
        if !wkt::internal::is_default(&self.reposync_crd) {
            state.serialize_entry("reposyncCrd", &self.reposync_crd)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ConfigSyncError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ConfigSyncVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.importer.is_empty() {
            state.serialize_entry("importer", &self.importer)?;
        }
        if !self.syncer.is_empty() {
            state.serialize_entry("syncer", &self.syncer)?;
        }
        if !self.git_sync.is_empty() {
            state.serialize_entry("gitSync", &self.git_sync)?;
        }
        if !self.monitor.is_empty() {
            state.serialize_entry("monitor", &self.monitor)?;
        }
        if !self.reconciler_manager.is_empty() {
            state.serialize_entry("reconcilerManager", &self.reconciler_manager)?;
        }
        if !self.root_reconciler.is_empty() {
            state.serialize_entry("rootReconciler", &self.root_reconciler)?;
        }
        if !self.admission_webhook.is_empty() {
            state.serialize_entry("admissionWebhook", &self.admission_webhook)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ConfigSyncDeploymentState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.importer) {
            state.serialize_entry("importer", &self.importer)?;
        }
        if !wkt::internal::is_default(&self.syncer) {
            state.serialize_entry("syncer", &self.syncer)?;
        }
        if !wkt::internal::is_default(&self.git_sync) {
            state.serialize_entry("gitSync", &self.git_sync)?;
        }
        if !wkt::internal::is_default(&self.monitor) {
            state.serialize_entry("monitor", &self.monitor)?;
        }
        if !wkt::internal::is_default(&self.reconciler_manager) {
            state.serialize_entry("reconcilerManager", &self.reconciler_manager)?;
        }
        if !wkt::internal::is_default(&self.root_reconciler) {
            state.serialize_entry("rootReconciler", &self.root_reconciler)?;
        }
        if !wkt::internal::is_default(&self.admission_webhook) {
            state.serialize_entry("admissionWebhook", &self.admission_webhook)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SyncState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_token.is_empty() {
            state.serialize_entry("sourceToken", &self.source_token)?;
        }
        if !self.import_token.is_empty() {
            state.serialize_entry("importToken", &self.import_token)?;
        }
        if !self.sync_token.is_empty() {
            state.serialize_entry("syncToken", &self.sync_token)?;
        }
        if !self.last_sync.is_empty() {
            state.serialize_entry("lastSync", &self.last_sync)?;
        }
        if self.last_sync_time.is_some() {
            state.serialize_entry("lastSyncTime", &self.last_sync_time)?;
        }
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SyncError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self.error_resources.is_empty() {
            state.serialize_entry("errorResources", &self.error_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ErrorResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_path.is_empty() {
            state.serialize_entry("sourcePath", &self.source_path)?;
        }
        if !self.resource_name.is_empty() {
            state.serialize_entry("resourceName", &self.resource_name)?;
        }
        if !self.resource_namespace.is_empty() {
            state.serialize_entry("resourceNamespace", &self.resource_namespace)?;
        }
        if self.resource_gvk.is_some() {
            state.serialize_entry("resourceGvk", &self.resource_gvk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GroupVersionKind {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.kind.is_empty() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::PolicyControllerState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.deployment_state.is_some() {
            state.serialize_entry("deploymentState", &self.deployment_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::PolicyControllerVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GatekeeperDeploymentState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.gatekeeper_controller_manager_state) {
            state.serialize_entry(
                "gatekeeperControllerManagerState",
                &self.gatekeeper_controller_manager_state,
            )?;
        }
        if !wkt::internal::is_default(&self.gatekeeper_audit) {
            state.serialize_entry("gatekeeperAudit", &self.gatekeeper_audit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
