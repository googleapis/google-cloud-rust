// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MembershipState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_name,
            __membership_spec,
            __operator_state,
            __config_sync_state,
            __policy_controller_state,
            __hierarchy_controller_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MembershipState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "membershipSpec" => Ok(__FieldTag::__membership_spec),
                            "membership_spec" => Ok(__FieldTag::__membership_spec),
                            "operatorState" => Ok(__FieldTag::__operator_state),
                            "operator_state" => Ok(__FieldTag::__operator_state),
                            "configSyncState" => Ok(__FieldTag::__config_sync_state),
                            "config_sync_state" => Ok(__FieldTag::__config_sync_state),
                            "policyControllerState" => Ok(__FieldTag::__policy_controller_state),
                            "policy_controller_state" => Ok(__FieldTag::__policy_controller_state),
                            "hierarchyControllerState" => {
                                Ok(__FieldTag::__hierarchy_controller_state)
                            }
                            "hierarchy_controller_state" => {
                                Ok(__FieldTag::__hierarchy_controller_state)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MembershipState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MembershipState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__membership_spec => {
                            if !fields.insert(__FieldTag::__membership_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership_spec",
                                ));
                            }
                            result.membership_spec = map
                                .next_value::<std::option::Option<crate::model::MembershipSpec>>(
                                )?;
                        }
                        __FieldTag::__operator_state => {
                            if !fields.insert(__FieldTag::__operator_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operator_state",
                                ));
                            }
                            result.operator_state = map
                                .next_value::<std::option::Option<crate::model::OperatorState>>()?;
                        }
                        __FieldTag::__config_sync_state => {
                            if !fields.insert(__FieldTag::__config_sync_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_sync_state",
                                ));
                            }
                            result.config_sync_state = map
                                .next_value::<std::option::Option<crate::model::ConfigSyncState>>(
                                )?;
                        }
                        __FieldTag::__policy_controller_state => {
                            if !fields.insert(__FieldTag::__policy_controller_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_controller_state",
                                ));
                            }
                            result.policy_controller_state = map.next_value::<std::option::Option<crate::model::PolicyControllerState>>()?
                                ;
                        }
                        __FieldTag::__hierarchy_controller_state => {
                            if !fields.insert(__FieldTag::__hierarchy_controller_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hierarchy_controller_state",
                                ));
                            }
                            result.hierarchy_controller_state = map.next_value::<std::option::Option<crate::model::HierarchyControllerState>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MembershipSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config_sync,
            __policy_controller,
            __hierarchy_controller,
            __version,
            __cluster,
            __management,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MembershipSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "configSync" => Ok(__FieldTag::__config_sync),
                            "config_sync" => Ok(__FieldTag::__config_sync),
                            "policyController" => Ok(__FieldTag::__policy_controller),
                            "policy_controller" => Ok(__FieldTag::__policy_controller),
                            "hierarchyController" => Ok(__FieldTag::__hierarchy_controller),
                            "hierarchy_controller" => Ok(__FieldTag::__hierarchy_controller),
                            "version" => Ok(__FieldTag::__version),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "management" => Ok(__FieldTag::__management),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MembershipSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MembershipSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config_sync => {
                            if !fields.insert(__FieldTag::__config_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_sync",
                                ));
                            }
                            result.config_sync =
                                map.next_value::<std::option::Option<crate::model::ConfigSync>>()?;
                        }
                        __FieldTag::__policy_controller => {
                            if !fields.insert(__FieldTag::__policy_controller) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_controller",
                                ));
                            }
                            result.policy_controller = map
                                .next_value::<std::option::Option<crate::model::PolicyController>>(
                                )?;
                        }
                        __FieldTag::__hierarchy_controller => {
                            if !fields.insert(__FieldTag::__hierarchy_controller) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hierarchy_controller",
                                ));
                            }
                            result.hierarchy_controller = map.next_value::<std::option::Option<crate::model::HierarchyControllerConfig>>()?
                                ;
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map.next_value::<std::option::Option<crate::model::membership_spec::Management>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfigSync {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __git,
            __source_format,
            __enabled,
            __prevent_drift,
            __oci,
            __metrics_gcp_service_account_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigSync")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "git" => Ok(__FieldTag::__git),
                            "sourceFormat" => Ok(__FieldTag::__source_format),
                            "source_format" => Ok(__FieldTag::__source_format),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "preventDrift" => Ok(__FieldTag::__prevent_drift),
                            "prevent_drift" => Ok(__FieldTag::__prevent_drift),
                            "oci" => Ok(__FieldTag::__oci),
                            "metricsGcpServiceAccountEmail" => {
                                Ok(__FieldTag::__metrics_gcp_service_account_email)
                            }
                            "metrics_gcp_service_account_email" => {
                                Ok(__FieldTag::__metrics_gcp_service_account_email)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfigSync;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigSync")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__git => {
                            if !fields.insert(__FieldTag::__git) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git",
                                ));
                            }
                            result.git =
                                map.next_value::<std::option::Option<crate::model::GitConfig>>()?;
                        }
                        __FieldTag::__source_format => {
                            if !fields.insert(__FieldTag::__source_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_format",
                                ));
                            }
                            result.source_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__prevent_drift => {
                            if !fields.insert(__FieldTag::__prevent_drift) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prevent_drift",
                                ));
                            }
                            result.prevent_drift = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__oci => {
                            if !fields.insert(__FieldTag::__oci) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oci",
                                ));
                            }
                            result.oci =
                                map.next_value::<std::option::Option<crate::model::OciConfig>>()?;
                        }
                        __FieldTag::__metrics_gcp_service_account_email => {
                            if !fields.insert(__FieldTag::__metrics_gcp_service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics_gcp_service_account_email",
                                ));
                            }
                            result.metrics_gcp_service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GitConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sync_repo,
            __sync_branch,
            __policy_dir,
            __sync_wait_secs,
            __sync_rev,
            __secret_type,
            __https_proxy,
            __gcp_service_account_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GitConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "syncRepo" => Ok(__FieldTag::__sync_repo),
                            "sync_repo" => Ok(__FieldTag::__sync_repo),
                            "syncBranch" => Ok(__FieldTag::__sync_branch),
                            "sync_branch" => Ok(__FieldTag::__sync_branch),
                            "policyDir" => Ok(__FieldTag::__policy_dir),
                            "policy_dir" => Ok(__FieldTag::__policy_dir),
                            "syncWaitSecs" => Ok(__FieldTag::__sync_wait_secs),
                            "sync_wait_secs" => Ok(__FieldTag::__sync_wait_secs),
                            "syncRev" => Ok(__FieldTag::__sync_rev),
                            "sync_rev" => Ok(__FieldTag::__sync_rev),
                            "secretType" => Ok(__FieldTag::__secret_type),
                            "secret_type" => Ok(__FieldTag::__secret_type),
                            "httpsProxy" => Ok(__FieldTag::__https_proxy),
                            "https_proxy" => Ok(__FieldTag::__https_proxy),
                            "gcpServiceAccountEmail" => Ok(__FieldTag::__gcp_service_account_email),
                            "gcp_service_account_email" => {
                                Ok(__FieldTag::__gcp_service_account_email)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GitConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GitConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sync_repo => {
                            if !fields.insert(__FieldTag::__sync_repo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_repo",
                                ));
                            }
                            result.sync_repo = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sync_branch => {
                            if !fields.insert(__FieldTag::__sync_branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_branch",
                                ));
                            }
                            result.sync_branch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_dir => {
                            if !fields.insert(__FieldTag::__policy_dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_dir",
                                ));
                            }
                            result.policy_dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sync_wait_secs => {
                            if !fields.insert(__FieldTag::__sync_wait_secs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_wait_secs",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sync_wait_secs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sync_rev => {
                            if !fields.insert(__FieldTag::__sync_rev) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_rev",
                                ));
                            }
                            result.sync_rev = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secret_type => {
                            if !fields.insert(__FieldTag::__secret_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_type",
                                ));
                            }
                            result.secret_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__https_proxy => {
                            if !fields.insert(__FieldTag::__https_proxy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for https_proxy",
                                ));
                            }
                            result.https_proxy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_service_account_email => {
                            if !fields.insert(__FieldTag::__gcp_service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_service_account_email",
                                ));
                            }
                            result.gcp_service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OciConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sync_repo,
            __policy_dir,
            __sync_wait_secs,
            __secret_type,
            __gcp_service_account_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OciConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "syncRepo" => Ok(__FieldTag::__sync_repo),
                            "sync_repo" => Ok(__FieldTag::__sync_repo),
                            "policyDir" => Ok(__FieldTag::__policy_dir),
                            "policy_dir" => Ok(__FieldTag::__policy_dir),
                            "syncWaitSecs" => Ok(__FieldTag::__sync_wait_secs),
                            "sync_wait_secs" => Ok(__FieldTag::__sync_wait_secs),
                            "secretType" => Ok(__FieldTag::__secret_type),
                            "secret_type" => Ok(__FieldTag::__secret_type),
                            "gcpServiceAccountEmail" => Ok(__FieldTag::__gcp_service_account_email),
                            "gcp_service_account_email" => {
                                Ok(__FieldTag::__gcp_service_account_email)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OciConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OciConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sync_repo => {
                            if !fields.insert(__FieldTag::__sync_repo) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_repo",
                                ));
                            }
                            result.sync_repo = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_dir => {
                            if !fields.insert(__FieldTag::__policy_dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_dir",
                                ));
                            }
                            result.policy_dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sync_wait_secs => {
                            if !fields.insert(__FieldTag::__sync_wait_secs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_wait_secs",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sync_wait_secs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__secret_type => {
                            if !fields.insert(__FieldTag::__secret_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_type",
                                ));
                            }
                            result.secret_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_service_account_email => {
                            if !fields.insert(__FieldTag::__gcp_service_account_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_service_account_email",
                                ));
                            }
                            result.gcp_service_account_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyController {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __template_library_installed,
            __audit_interval_seconds,
            __exemptable_namespaces,
            __referential_rules_enabled,
            __log_denies_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyController")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "templateLibraryInstalled" => {
                                Ok(__FieldTag::__template_library_installed)
                            }
                            "template_library_installed" => {
                                Ok(__FieldTag::__template_library_installed)
                            }
                            "auditIntervalSeconds" => Ok(__FieldTag::__audit_interval_seconds),
                            "audit_interval_seconds" => Ok(__FieldTag::__audit_interval_seconds),
                            "exemptableNamespaces" => Ok(__FieldTag::__exemptable_namespaces),
                            "exemptable_namespaces" => Ok(__FieldTag::__exemptable_namespaces),
                            "referentialRulesEnabled" => {
                                Ok(__FieldTag::__referential_rules_enabled)
                            }
                            "referential_rules_enabled" => {
                                Ok(__FieldTag::__referential_rules_enabled)
                            }
                            "logDeniesEnabled" => Ok(__FieldTag::__log_denies_enabled),
                            "log_denies_enabled" => Ok(__FieldTag::__log_denies_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyController;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyController")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template_library_installed => {
                            if !fields.insert(__FieldTag::__template_library_installed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template_library_installed",
                                ));
                            }
                            result.template_library_installed =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__audit_interval_seconds => {
                            if !fields.insert(__FieldTag::__audit_interval_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_interval_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audit_interval_seconds = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__exemptable_namespaces => {
                            if !fields.insert(__FieldTag::__exemptable_namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exemptable_namespaces",
                                ));
                            }
                            result.exemptable_namespaces = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__referential_rules_enabled => {
                            if !fields.insert(__FieldTag::__referential_rules_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referential_rules_enabled",
                                ));
                            }
                            result.referential_rules_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_denies_enabled => {
                            if !fields.insert(__FieldTag::__log_denies_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_denies_enabled",
                                ));
                            }
                            result.log_denies_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HierarchyControllerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __enable_pod_tree_labels,
            __enable_hierarchical_resource_quota,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HierarchyControllerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "enablePodTreeLabels" => Ok(__FieldTag::__enable_pod_tree_labels),
                            "enable_pod_tree_labels" => Ok(__FieldTag::__enable_pod_tree_labels),
                            "enableHierarchicalResourceQuota" => {
                                Ok(__FieldTag::__enable_hierarchical_resource_quota)
                            }
                            "enable_hierarchical_resource_quota" => {
                                Ok(__FieldTag::__enable_hierarchical_resource_quota)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HierarchyControllerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HierarchyControllerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_pod_tree_labels => {
                            if !fields.insert(__FieldTag::__enable_pod_tree_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_pod_tree_labels",
                                ));
                            }
                            result.enable_pod_tree_labels = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_hierarchical_resource_quota => {
                            if !fields.insert(__FieldTag::__enable_hierarchical_resource_quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_hierarchical_resource_quota",
                                ));
                            }
                            result.enable_hierarchical_resource_quota = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HierarchyControllerDeploymentState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hnc,
            __extension,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HierarchyControllerDeploymentState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hnc" => Ok(__FieldTag::__hnc),
                            "extension" => Ok(__FieldTag::__extension),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HierarchyControllerDeploymentState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HierarchyControllerDeploymentState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hnc => {
                            if !fields.insert(__FieldTag::__hnc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hnc",
                                ));
                            }
                            result.hnc = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__extension => {
                            if !fields.insert(__FieldTag::__extension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extension",
                                ));
                            }
                            result.extension = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HierarchyControllerVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hnc,
            __extension,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HierarchyControllerVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hnc" => Ok(__FieldTag::__hnc),
                            "extension" => Ok(__FieldTag::__extension),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HierarchyControllerVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HierarchyControllerVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hnc => {
                            if !fields.insert(__FieldTag::__hnc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hnc",
                                ));
                            }
                            result.hnc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__extension => {
                            if !fields.insert(__FieldTag::__extension) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extension",
                                ));
                            }
                            result.extension = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HierarchyControllerState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HierarchyControllerState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HierarchyControllerState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HierarchyControllerState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map.next_value::<std::option::Option<crate::model::HierarchyControllerVersion>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<
                                crate::model::HierarchyControllerDeploymentState,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperatorState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __deployment_state,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperatorState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "deploymentState" => Ok(__FieldTag::__deployment_state),
                            "deployment_state" => Ok(__FieldTag::__deployment_state),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperatorState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperatorState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deployment_state => {
                            if !fields.insert(__FieldTag::__deployment_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_state",
                                ));
                            }
                            result.deployment_state = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InstallError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::InstallError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstallError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::InstallError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstallError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfigSyncState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __deployment_state,
            __sync_state,
            __errors,
            __rootsync_crd,
            __reposync_crd,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigSyncState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "deploymentState" => Ok(__FieldTag::__deployment_state),
                            "deployment_state" => Ok(__FieldTag::__deployment_state),
                            "syncState" => Ok(__FieldTag::__sync_state),
                            "sync_state" => Ok(__FieldTag::__sync_state),
                            "errors" => Ok(__FieldTag::__errors),
                            "rootsyncCrd" => Ok(__FieldTag::__rootsync_crd),
                            "rootsync_crd" => Ok(__FieldTag::__rootsync_crd),
                            "reposyncCrd" => Ok(__FieldTag::__reposync_crd),
                            "reposync_crd" => Ok(__FieldTag::__reposync_crd),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfigSyncState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigSyncState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<crate::model::ConfigSyncVersion>>(
                                )?;
                        }
                        __FieldTag::__deployment_state => {
                            if !fields.insert(__FieldTag::__deployment_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_state",
                                ));
                            }
                            result.deployment_state = map.next_value::<std::option::Option<crate::model::ConfigSyncDeploymentState>>()?
                                ;
                        }
                        __FieldTag::__sync_state => {
                            if !fields.insert(__FieldTag::__sync_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_state",
                                ));
                            }
                            result.sync_state =
                                map.next_value::<std::option::Option<crate::model::SyncState>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConfigSyncError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rootsync_crd => {
                            if !fields.insert(__FieldTag::__rootsync_crd) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rootsync_crd",
                                ));
                            }
                            result.rootsync_crd = map.next_value::<std::option::Option<crate::model::config_sync_state::CRDState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reposync_crd => {
                            if !fields.insert(__FieldTag::__reposync_crd) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reposync_crd",
                                ));
                            }
                            result.reposync_crd = map.next_value::<std::option::Option<crate::model::config_sync_state::CRDState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::config_sync_state::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfigSyncError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigSyncError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfigSyncError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigSyncError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfigSyncVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __importer,
            __syncer,
            __git_sync,
            __monitor,
            __reconciler_manager,
            __root_reconciler,
            __admission_webhook,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigSyncVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "importer" => Ok(__FieldTag::__importer),
                            "syncer" => Ok(__FieldTag::__syncer),
                            "gitSync" => Ok(__FieldTag::__git_sync),
                            "git_sync" => Ok(__FieldTag::__git_sync),
                            "monitor" => Ok(__FieldTag::__monitor),
                            "reconcilerManager" => Ok(__FieldTag::__reconciler_manager),
                            "reconciler_manager" => Ok(__FieldTag::__reconciler_manager),
                            "rootReconciler" => Ok(__FieldTag::__root_reconciler),
                            "root_reconciler" => Ok(__FieldTag::__root_reconciler),
                            "admissionWebhook" => Ok(__FieldTag::__admission_webhook),
                            "admission_webhook" => Ok(__FieldTag::__admission_webhook),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfigSyncVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigSyncVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__importer => {
                            if !fields.insert(__FieldTag::__importer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for importer",
                                ));
                            }
                            result.importer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__syncer => {
                            if !fields.insert(__FieldTag::__syncer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for syncer",
                                ));
                            }
                            result.syncer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_sync => {
                            if !fields.insert(__FieldTag::__git_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_sync",
                                ));
                            }
                            result.git_sync = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitor => {
                            if !fields.insert(__FieldTag::__monitor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitor",
                                ));
                            }
                            result.monitor = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciler_manager => {
                            if !fields.insert(__FieldTag::__reconciler_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciler_manager",
                                ));
                            }
                            result.reconciler_manager = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_reconciler => {
                            if !fields.insert(__FieldTag::__root_reconciler) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_reconciler",
                                ));
                            }
                            result.root_reconciler = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admission_webhook => {
                            if !fields.insert(__FieldTag::__admission_webhook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admission_webhook",
                                ));
                            }
                            result.admission_webhook = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfigSyncDeploymentState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __importer,
            __syncer,
            __git_sync,
            __monitor,
            __reconciler_manager,
            __root_reconciler,
            __admission_webhook,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigSyncDeploymentState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "importer" => Ok(__FieldTag::__importer),
                            "syncer" => Ok(__FieldTag::__syncer),
                            "gitSync" => Ok(__FieldTag::__git_sync),
                            "git_sync" => Ok(__FieldTag::__git_sync),
                            "monitor" => Ok(__FieldTag::__monitor),
                            "reconcilerManager" => Ok(__FieldTag::__reconciler_manager),
                            "reconciler_manager" => Ok(__FieldTag::__reconciler_manager),
                            "rootReconciler" => Ok(__FieldTag::__root_reconciler),
                            "root_reconciler" => Ok(__FieldTag::__root_reconciler),
                            "admissionWebhook" => Ok(__FieldTag::__admission_webhook),
                            "admission_webhook" => Ok(__FieldTag::__admission_webhook),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfigSyncDeploymentState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigSyncDeploymentState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__importer => {
                            if !fields.insert(__FieldTag::__importer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for importer",
                                ));
                            }
                            result.importer = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__syncer => {
                            if !fields.insert(__FieldTag::__syncer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for syncer",
                                ));
                            }
                            result.syncer = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_sync => {
                            if !fields.insert(__FieldTag::__git_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_sync",
                                ));
                            }
                            result.git_sync = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitor => {
                            if !fields.insert(__FieldTag::__monitor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitor",
                                ));
                            }
                            result.monitor = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciler_manager => {
                            if !fields.insert(__FieldTag::__reconciler_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciler_manager",
                                ));
                            }
                            result.reconciler_manager = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_reconciler => {
                            if !fields.insert(__FieldTag::__root_reconciler) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_reconciler",
                                ));
                            }
                            result.root_reconciler = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__admission_webhook => {
                            if !fields.insert(__FieldTag::__admission_webhook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admission_webhook",
                                ));
                            }
                            result.admission_webhook = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SyncState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_token,
            __import_token,
            __sync_token,
            __last_sync,
            __last_sync_time,
            __code,
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SyncState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceToken" => Ok(__FieldTag::__source_token),
                            "source_token" => Ok(__FieldTag::__source_token),
                            "importToken" => Ok(__FieldTag::__import_token),
                            "import_token" => Ok(__FieldTag::__import_token),
                            "syncToken" => Ok(__FieldTag::__sync_token),
                            "sync_token" => Ok(__FieldTag::__sync_token),
                            "lastSync" => Ok(__FieldTag::__last_sync),
                            "last_sync" => Ok(__FieldTag::__last_sync),
                            "lastSyncTime" => Ok(__FieldTag::__last_sync_time),
                            "last_sync_time" => Ok(__FieldTag::__last_sync_time),
                            "code" => Ok(__FieldTag::__code),
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SyncState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SyncState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_token => {
                            if !fields.insert(__FieldTag::__source_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_token",
                                ));
                            }
                            result.source_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_token => {
                            if !fields.insert(__FieldTag::__import_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_token",
                                ));
                            }
                            result.import_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sync_token => {
                            if !fields.insert(__FieldTag::__sync_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sync_token",
                                ));
                            }
                            result.sync_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_sync => {
                            if !fields.insert(__FieldTag::__last_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_sync",
                                ));
                            }
                            result.last_sync = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_sync_time => {
                            if !fields.insert(__FieldTag::__last_sync_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_sync_time",
                                ));
                            }
                            result.last_sync_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::sync_state::SyncCode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SyncError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SyncError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __error_message,
            __error_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SyncError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "errorResources" => Ok(__FieldTag::__error_resources),
                            "error_resources" => Ok(__FieldTag::__error_resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SyncError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SyncError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_resources => {
                            if !fields.insert(__FieldTag::__error_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_resources",
                                ));
                            }
                            result.error_resources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ErrorResource>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ErrorResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_path,
            __resource_name,
            __resource_namespace,
            __resource_gvk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourcePath" => Ok(__FieldTag::__source_path),
                            "source_path" => Ok(__FieldTag::__source_path),
                            "resourceName" => Ok(__FieldTag::__resource_name),
                            "resource_name" => Ok(__FieldTag::__resource_name),
                            "resourceNamespace" => Ok(__FieldTag::__resource_namespace),
                            "resource_namespace" => Ok(__FieldTag::__resource_namespace),
                            "resourceGvk" => Ok(__FieldTag::__resource_gvk),
                            "resource_gvk" => Ok(__FieldTag::__resource_gvk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ErrorResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_path => {
                            if !fields.insert(__FieldTag::__source_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_path",
                                ));
                            }
                            result.source_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_name => {
                            if !fields.insert(__FieldTag::__resource_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_name",
                                ));
                            }
                            result.resource_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_namespace => {
                            if !fields.insert(__FieldTag::__resource_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_namespace",
                                ));
                            }
                            result.resource_namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_gvk => {
                            if !fields.insert(__FieldTag::__resource_gvk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_gvk",
                                ));
                            }
                            result.resource_gvk = map
                                .next_value::<std::option::Option<crate::model::GroupVersionKind>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GroupVersionKind {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __version,
            __kind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GroupVersionKind")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "version" => Ok(__FieldTag::__version),
                            "kind" => Ok(__FieldTag::__kind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GroupVersionKind;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GroupVersionKind")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyControllerState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __deployment_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyControllerState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "deploymentState" => Ok(__FieldTag::__deployment_state),
                            "deployment_state" => Ok(__FieldTag::__deployment_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyControllerState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyControllerState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map.next_value::<std::option::Option<crate::model::PolicyControllerVersion>>()?
                                ;
                        }
                        __FieldTag::__deployment_state => {
                            if !fields.insert(__FieldTag::__deployment_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment_state",
                                ));
                            }
                            result.deployment_state = map.next_value::<std::option::Option<crate::model::GatekeeperDeploymentState>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyControllerVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyControllerVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyControllerVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyControllerVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GatekeeperDeploymentState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gatekeeper_controller_manager_state,
            __gatekeeper_audit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GatekeeperDeploymentState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gatekeeperControllerManagerState" => {
                                Ok(__FieldTag::__gatekeeper_controller_manager_state)
                            }
                            "gatekeeper_controller_manager_state" => {
                                Ok(__FieldTag::__gatekeeper_controller_manager_state)
                            }
                            "gatekeeperAudit" => Ok(__FieldTag::__gatekeeper_audit),
                            "gatekeeper_audit" => Ok(__FieldTag::__gatekeeper_audit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GatekeeperDeploymentState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GatekeeperDeploymentState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gatekeeper_controller_manager_state => {
                            if !fields.insert(__FieldTag::__gatekeeper_controller_manager_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gatekeeper_controller_manager_state",
                                ));
                            }
                            result.gatekeeper_controller_manager_state = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gatekeeper_audit => {
                            if !fields.insert(__FieldTag::__gatekeeper_audit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gatekeeper_audit",
                                ));
                            }
                            result.gatekeeper_audit = map
                                .next_value::<std::option::Option<crate::model::DeploymentState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
