// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for
/// [`ListReportConfigs`][google.cloud.storageinsights.v1.StorageInsights.ListReportConfigs]
///
/// [google.cloud.storageinsights.v1.StorageInsights.ListReportConfigs]: crate::client::StorageInsights::list_report_configs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportConfigsRequest {
    /// Required. Parent value for ListReportConfigsRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReportConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReportConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReportConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReportConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReportConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReportConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ListReportConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing ReportConfigs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportConfigsResponse {
    /// The list of ReportConfig
    pub report_configs: std::vec::Vec<crate::model::ReportConfig>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_configs][crate::model::ListReportConfigsResponse::report_configs].
    pub fn set_report_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReportConfig>,
    {
        use std::iter::Iterator;
        self.report_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReportConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReportConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReportConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ListReportConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReportConfigsResponse {
    type PageItem = crate::model::ReportConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.report_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __report_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reportConfigs" => Ok(__FieldTag::__report_configs),
                            "report_configs" => Ok(__FieldTag::__report_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__report_configs => {
                            if !fields.insert(__FieldTag::__report_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_configs",
                                ));
                            }
                            result.report_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ReportConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.report_configs.is_empty() {
            state.serialize_entry("reportConfigs", &self.report_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a ReportConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReportConfigRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReportConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.GetReportConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReportConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReportConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReportConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReportConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReportConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a ReportConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReportConfigRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. The resource being created
    pub report_config: std::option::Option<crate::model::ReportConfig>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReportConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [report_config][crate::model::CreateReportConfigRequest::report_config].
    pub fn set_report_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReportConfig>,
    {
        self.report_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report_config][crate::model::CreateReportConfigRequest::report_config].
    pub fn set_or_clear_report_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReportConfig>,
    {
        self.report_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateReportConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.CreateReportConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReportConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __report_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReportConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "reportConfig" => Ok(__FieldTag::__report_config),
                            "report_config" => Ok(__FieldTag::__report_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReportConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReportConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__report_config => {
                            if !fields.insert(__FieldTag::__report_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_config",
                                ));
                            }
                            result.report_config = map
                                .next_value::<std::option::Option<crate::model::ReportConfig>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReportConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.report_config.is_some() {
            state.serialize_entry("reportConfig", &self.report_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a ReportConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateReportConfigRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// ReportConfig resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub report_config: std::option::Option<crate::model::ReportConfig>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateReportConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateReportConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [report_config][crate::model::UpdateReportConfigRequest::report_config].
    pub fn set_report_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReportConfig>,
    {
        self.report_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report_config][crate::model::UpdateReportConfigRequest::report_config].
    pub fn set_or_clear_report_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReportConfig>,
    {
        self.report_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateReportConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.UpdateReportConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateReportConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __report_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateReportConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "reportConfig" => Ok(__FieldTag::__report_config),
                            "report_config" => Ok(__FieldTag::__report_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateReportConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateReportConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__report_config => {
                            if !fields.insert(__FieldTag::__report_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_config",
                                ));
                            }
                            result.report_config = map
                                .next_value::<std::option::Option<crate::model::ReportConfig>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateReportConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.report_config.is_some() {
            state.serialize_entry("reportConfig", &self.report_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a ReportConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteReportConfigRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. If set, all ReportDetails for this ReportConfig will be deleted.
    pub force: bool,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReportConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReportConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteReportConfigRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteReportConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReportConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.DeleteReportConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteReportConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteReportConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteReportConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteReportConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteReportConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing ReportDetail object. ReportDetail represents metadata of
/// generated reports for a ReportConfig.
/// Next ID: 10
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportDetail {
    /// Name of resource. It will be of form
    /// projects/\<project\>/locations/\<location\>/reportConfigs/\<report-config-id\>/reportDetails/\<report-detail-id\>.
    pub name: std::string::String,

    /// The snapshot time.
    /// All the report data is referenced at this point of time.
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    /// Prefix of the object name of each report's shard. This will have full
    /// prefix except the "extension" and "shard_id".
    /// For example, if the `destination_path` is
    /// `{{report-config-id}}/dt={{datetime}}`, the shard object name would be
    /// `gs://my-insights/1A34-F2E456-12B456-1C3D/dt=2022-05-20T06:35/1A34-F2E456-12B456-1C3D_2022-05-20T06:35_5.csv`
    /// and the value of `report_path_prefix` field would be
    /// `gs://my-insights/1A34-F2E456-12B456-1C3D/dt=2022-05-20T06:35/1A34-F2E456-12B456-1C3D_2022-05-20T06:35_`.
    pub report_path_prefix: std::string::String,

    /// Total shards generated for the report.
    pub shards_count: i64,

    /// Status of the ReportDetail.
    pub status: std::option::Option<rpc::model::Status>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The date for which report is generated. The time part of target_datetime
    /// will be zero till we support multiple reports per day.
    pub target_datetime: std::option::Option<gtype::model::DateTime>,

    /// Metrics of the report.
    pub report_metrics: std::option::Option<crate::model::report_detail::Metrics>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReportDetail::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::ReportDetail::snapshot_time].
    pub fn set_snapshot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_time][crate::model::ReportDetail::snapshot_time].
    pub fn set_or_clear_snapshot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [report_path_prefix][crate::model::ReportDetail::report_path_prefix].
    pub fn set_report_path_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.report_path_prefix = v.into();
        self
    }

    /// Sets the value of [shards_count][crate::model::ReportDetail::shards_count].
    pub fn set_shards_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shards_count = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ReportDetail::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::ReportDetail::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ReportDetail::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [target_datetime][crate::model::ReportDetail::target_datetime].
    pub fn set_target_datetime<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::DateTime>,
    {
        self.target_datetime = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_datetime][crate::model::ReportDetail::target_datetime].
    pub fn set_or_clear_target_datetime<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::DateTime>,
    {
        self.target_datetime = v.map(|x| x.into());
        self
    }

    /// Sets the value of [report_metrics][crate::model::ReportDetail::report_metrics].
    pub fn set_report_metrics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::report_detail::Metrics>,
    {
        self.report_metrics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report_metrics][crate::model::ReportDetail::report_metrics].
    pub fn set_or_clear_report_metrics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::report_detail::Metrics>,
    {
        self.report_metrics = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReportDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ReportDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __snapshot_time,
            __report_path_prefix,
            __shards_count,
            __status,
            __labels,
            __target_datetime,
            __report_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            "reportPathPrefix" => Ok(__FieldTag::__report_path_prefix),
                            "report_path_prefix" => Ok(__FieldTag::__report_path_prefix),
                            "shardsCount" => Ok(__FieldTag::__shards_count),
                            "shards_count" => Ok(__FieldTag::__shards_count),
                            "status" => Ok(__FieldTag::__status),
                            "labels" => Ok(__FieldTag::__labels),
                            "targetDatetime" => Ok(__FieldTag::__target_datetime),
                            "target_datetime" => Ok(__FieldTag::__target_datetime),
                            "reportMetrics" => Ok(__FieldTag::__report_metrics),
                            "report_metrics" => Ok(__FieldTag::__report_metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__report_path_prefix => {
                            if !fields.insert(__FieldTag::__report_path_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_path_prefix",
                                ));
                            }
                            result.report_path_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shards_count => {
                            if !fields.insert(__FieldTag::__shards_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shards_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shards_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_datetime => {
                            if !fields.insert(__FieldTag::__target_datetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_datetime",
                                ));
                            }
                            result.target_datetime =
                                map.next_value::<std::option::Option<gtype::model::DateTime>>()?;
                        }
                        __FieldTag::__report_metrics => {
                            if !fields.insert(__FieldTag::__report_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_metrics",
                                ));
                            }
                            result.report_metrics = map.next_value::<std::option::Option<crate::model::report_detail::Metrics>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.snapshot_time.is_some() {
            state.serialize_entry("snapshotTime", &self.snapshot_time)?;
        }
        if !self.report_path_prefix.is_empty() {
            state.serialize_entry("reportPathPrefix", &self.report_path_prefix)?;
        }
        if !wkt::internal::is_default(&self.shards_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shardsCount", &__With(&self.shards_count))?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.target_datetime.is_some() {
            state.serialize_entry("targetDatetime", &self.target_datetime)?;
        }
        if self.report_metrics.is_some() {
            state.serialize_entry("reportMetrics", &self.report_metrics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReportDetail].
pub mod report_detail {
    #[allow(unused_imports)]
    use super::*;

    /// Different metrics associated with the generated report.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Metrics {
        /// Count of Cloud Storage objects which are part of the report.
        pub processed_records_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [processed_records_count][crate::model::report_detail::Metrics::processed_records_count].
        pub fn set_processed_records_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.processed_records_count = v.into();
            self
        }
    }

    impl wkt::message::Message for Metrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.ReportDetail.Metrics"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Metrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __processed_records_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Metrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "processedRecordsCount" => {
                                    Ok(__FieldTag::__processed_records_count)
                                }
                                "processed_records_count" => {
                                    Ok(__FieldTag::__processed_records_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Metrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Metrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__processed_records_count => {
                                if !fields.insert(__FieldTag::__processed_records_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for processed_records_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.processed_records_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Metrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.processed_records_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "processedRecordsCount",
                    &__With(&self.processed_records_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Message for requesting list of ReportDetails
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportDetailsRequest {
    /// Required. Parent value for ListReportDetailsRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReportDetailsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReportDetailsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReportDetailsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReportDetailsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReportDetailsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReportDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ListReportDetailsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportDetailsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing ReportDetails
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReportDetailsResponse {
    /// The list of ReportDetail
    pub report_details: std::vec::Vec<crate::model::ReportDetail>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReportDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_details][crate::model::ListReportDetailsResponse::report_details].
    pub fn set_report_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReportDetail>,
    {
        use std::iter::Iterator;
        self.report_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReportDetailsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReportDetailsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReportDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ListReportDetailsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReportDetailsResponse {
    type PageItem = crate::model::ReportDetail;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.report_details
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReportDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __report_details,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReportDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reportDetails" => Ok(__FieldTag::__report_details),
                            "report_details" => Ok(__FieldTag::__report_details),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReportDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReportDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__report_details => {
                            if !fields.insert(__FieldTag::__report_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_details",
                                ));
                            }
                            result.report_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ReportDetail>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReportDetailsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.report_details.is_empty() {
            state.serialize_entry("reportDetails", &self.report_details)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a ReportDetail
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReportDetailRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReportDetailRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReportDetailRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReportDetailRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.GetReportDetailRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReportDetailRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReportDetailRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReportDetailRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReportDetailRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReportDetailRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ReportConfig Resource:
///
/// Options to setup frequency of report generation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FrequencyOptions {
    /// Frequency of report generation.
    pub frequency: crate::model::frequency_options::Frequency,

    /// The date from which report generation should start.
    /// UTC time zone.
    pub start_date: std::option::Option<gtype::model::Date>,

    /// The date on which report generation should stop (Inclusive).
    /// UTC time zone.
    pub end_date: std::option::Option<gtype::model::Date>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FrequencyOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [frequency][crate::model::FrequencyOptions::frequency].
    pub fn set_frequency<T: std::convert::Into<crate::model::frequency_options::Frequency>>(
        mut self,
        v: T,
    ) -> Self {
        self.frequency = v.into();
        self
    }

    /// Sets the value of [start_date][crate::model::FrequencyOptions::start_date].
    pub fn set_start_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.start_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_date][crate::model::FrequencyOptions::start_date].
    pub fn set_or_clear_start_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.start_date = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_date][crate::model::FrequencyOptions::end_date].
    pub fn set_end_date<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_date = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_date][crate::model::FrequencyOptions::end_date].
    pub fn set_or_clear_end_date<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Date>,
    {
        self.end_date = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FrequencyOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.FrequencyOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FrequencyOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __frequency,
            __start_date,
            __end_date,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FrequencyOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "frequency" => Ok(__FieldTag::__frequency),
                            "startDate" => Ok(__FieldTag::__start_date),
                            "start_date" => Ok(__FieldTag::__start_date),
                            "endDate" => Ok(__FieldTag::__end_date),
                            "end_date" => Ok(__FieldTag::__end_date),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FrequencyOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FrequencyOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            result.frequency = map.next_value::<std::option::Option<crate::model::frequency_options::Frequency>>()?.unwrap_or_default();
                        }
                        __FieldTag::__start_date => {
                            if !fields.insert(__FieldTag::__start_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_date",
                                ));
                            }
                            result.start_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::__end_date => {
                            if !fields.insert(__FieldTag::__end_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_date",
                                ));
                            }
                            result.end_date =
                                map.next_value::<std::option::Option<gtype::model::Date>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FrequencyOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.frequency) {
            state.serialize_entry("frequency", &self.frequency)?;
        }
        if self.start_date.is_some() {
            state.serialize_entry("startDate", &self.start_date)?;
        }
        if self.end_date.is_some() {
            state.serialize_entry("endDate", &self.end_date)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FrequencyOptions].
pub mod frequency_options {
    #[allow(unused_imports)]
    use super::*;

    /// This ENUM specifies possible frequencies of report generation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Frequency {
        /// Unspecified.
        Unspecified,
        /// Report will be generated daily.
        Daily,
        /// Report will be generated weekly.
        Weekly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Frequency::value] or
        /// [Frequency::name].
        UnknownValue(frequency::UnknownValue),
    }

    #[doc(hidden)]
    pub mod frequency {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Frequency {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Daily => std::option::Option::Some(1),
                Self::Weekly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FREQUENCY_UNSPECIFIED"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Frequency {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Frequency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Frequency {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Daily,
                2 => Self::Weekly,
                _ => Self::UnknownValue(frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Frequency {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FREQUENCY_UNSPECIFIED" => Self::Unspecified,
                "DAILY" => Self::Daily,
                "WEEKLY" => Self::Weekly,
                _ => Self::UnknownValue(frequency::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Frequency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Daily => serializer.serialize_i32(1),
                Self::Weekly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Frequency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Frequency>::new(
                ".google.cloud.storageinsights.v1.FrequencyOptions.Frequency",
            ))
        }
    }
}

/// Options to configure CSV formatted reports.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CSVOptions {
    /// Record separator characters in CSV.
    pub record_separator: std::string::String,

    /// Delimiter characters in CSV.
    pub delimiter: std::string::String,

    /// If set, will include a header row in the CSV report.
    pub header_required: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CSVOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [record_separator][crate::model::CSVOptions::record_separator].
    pub fn set_record_separator<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.record_separator = v.into();
        self
    }

    /// Sets the value of [delimiter][crate::model::CSVOptions::delimiter].
    pub fn set_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.delimiter = v.into();
        self
    }

    /// Sets the value of [header_required][crate::model::CSVOptions::header_required].
    pub fn set_header_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.header_required = v.into();
        self
    }
}

impl wkt::message::Message for CSVOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.CSVOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CSVOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __record_separator,
            __delimiter,
            __header_required,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CSVOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recordSeparator" => Ok(__FieldTag::__record_separator),
                            "record_separator" => Ok(__FieldTag::__record_separator),
                            "delimiter" => Ok(__FieldTag::__delimiter),
                            "headerRequired" => Ok(__FieldTag::__header_required),
                            "header_required" => Ok(__FieldTag::__header_required),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CSVOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CSVOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__record_separator => {
                            if !fields.insert(__FieldTag::__record_separator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for record_separator",
                                ));
                            }
                            result.record_separator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delimiter => {
                            if !fields.insert(__FieldTag::__delimiter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delimiter",
                                ));
                            }
                            result.delimiter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__header_required => {
                            if !fields.insert(__FieldTag::__header_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for header_required",
                                ));
                            }
                            result.header_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CSVOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.record_separator.is_empty() {
            state.serialize_entry("recordSeparator", &self.record_separator)?;
        }
        if !self.delimiter.is_empty() {
            state.serialize_entry("delimiter", &self.delimiter)?;
        }
        if !wkt::internal::is_default(&self.header_required) {
            state.serialize_entry("headerRequired", &self.header_required)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options to configure Parquet formatted reports.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ParquetOptions {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParquetOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ParquetOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ParquetOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ParquetOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParquetOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ParquetOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParquetOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ParquetOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options to filter data on storage systems.
/// Next ID: 2
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageFilters {
    /// Bucket for which the report will be generated.
    pub bucket: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageFilters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::CloudStorageFilters::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageFilters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.CloudStorageFilters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageFilters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageFilters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageFilters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageFilters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageFilters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Options to store reports in storage systems.
/// Next ID: 3
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageDestinationOptions {
    /// Destination bucket.
    pub bucket: std::string::String,

    /// Destination path is the path in the bucket where the report should be
    /// generated.
    pub destination_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageDestinationOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bucket][crate::model::CloudStorageDestinationOptions::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [destination_path][crate::model::CloudStorageDestinationOptions::destination_path].
    pub fn set_destination_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_path = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageDestinationOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.CloudStorageDestinationOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageDestinationOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bucket,
            __destination_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageDestinationOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bucket" => Ok(__FieldTag::__bucket),
                            "destinationPath" => Ok(__FieldTag::__destination_path),
                            "destination_path" => Ok(__FieldTag::__destination_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageDestinationOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageDestinationOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_path => {
                            if !fields.insert(__FieldTag::__destination_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_path",
                                ));
                            }
                            result.destination_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageDestinationOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !self.destination_path.is_empty() {
            state.serialize_entry("destinationPath", &self.destination_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Report specification for exporting object metadata.
/// Next ID: 4
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectMetadataReportOptions {
    /// Metadata fields to be included in the report.
    pub metadata_fields: std::vec::Vec<std::string::String>,

    /// Filter options for storage systems.
    pub filter: std::option::Option<crate::model::object_metadata_report_options::Filter>,

    /// Options on destination for storage systems.
    pub destination_options:
        std::option::Option<crate::model::object_metadata_report_options::DestinationOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectMetadataReportOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata_fields][crate::model::ObjectMetadataReportOptions::metadata_fields].
    pub fn set_metadata_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::ObjectMetadataReportOptions::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::object_metadata_report_options::Filter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::ObjectMetadataReportOptions::filter]
    /// if it holds a `StorageFilters`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_filters(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageFilters>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::object_metadata_report_options::Filter::StorageFilters(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ObjectMetadataReportOptions::filter]
    /// to hold a `StorageFilters`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_storage_filters<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageFilters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::object_metadata_report_options::Filter::StorageFilters(v.into()),
        );
        self
    }

    /// Sets the value of [destination_options][crate::model::ObjectMetadataReportOptions::destination_options].
    ///
    /// Note that all the setters affecting `destination_options` are mutually
    /// exclusive.
    pub fn set_destination_options<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::object_metadata_report_options::DestinationOptions,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_options = v.into();
        self
    }

    /// The value of [destination_options][crate::model::ObjectMetadataReportOptions::destination_options]
    /// if it holds a `StorageDestinationOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_destination_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageDestinationOptions>> {
        #[allow(unreachable_patterns)]
        self.destination_options.as_ref().and_then(|v| match v {
            crate::model::object_metadata_report_options::DestinationOptions::StorageDestinationOptions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination_options][crate::model::ObjectMetadataReportOptions::destination_options]
    /// to hold a `StorageDestinationOptions`.
    ///
    /// Note that all the setters affecting `destination_options` are
    /// mutually exclusive.
    pub fn set_storage_destination_options<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageDestinationOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_options = std::option::Option::Some(
            crate::model::object_metadata_report_options::DestinationOptions::StorageDestinationOptions(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for ObjectMetadataReportOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ObjectMetadataReportOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectMetadataReportOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metadata_fields,
            __storage_filters,
            __storage_destination_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectMetadataReportOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metadataFields" => Ok(__FieldTag::__metadata_fields),
                            "metadata_fields" => Ok(__FieldTag::__metadata_fields),
                            "storageFilters" => Ok(__FieldTag::__storage_filters),
                            "storage_filters" => Ok(__FieldTag::__storage_filters),
                            "storageDestinationOptions" => {
                                Ok(__FieldTag::__storage_destination_options)
                            }
                            "storage_destination_options" => {
                                Ok(__FieldTag::__storage_destination_options)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectMetadataReportOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectMetadataReportOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metadata_fields => {
                            if !fields.insert(__FieldTag::__metadata_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata_fields",
                                ));
                            }
                            result.metadata_fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__storage_filters => {
                            if !fields.insert(__FieldTag::__storage_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_filters",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.cloud.storageinsights.v1.ObjectMetadataReportOptions.storage_filters, latest field was storageFilters",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::object_metadata_report_options::Filter::StorageFilters(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudStorageFilters>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__storage_destination_options => {
                            if !fields.insert(__FieldTag::__storage_destination_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_destination_options",
                                ));
                            }
                            if result.destination_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination_options`, a oneof with full ID .google.cloud.storageinsights.v1.ObjectMetadataReportOptions.storage_destination_options, latest field was storageDestinationOptions",
                                ));
                            }
                            result.destination_options = std::option::Option::Some(
                                crate::model::object_metadata_report_options::DestinationOptions::StorageDestinationOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudStorageDestinationOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectMetadataReportOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metadata_fields.is_empty() {
            state.serialize_entry("metadataFields", &self.metadata_fields)?;
        }
        if let Some(value) = self.storage_filters() {
            state.serialize_entry("storageFilters", value)?;
        }
        if let Some(value) = self.storage_destination_options() {
            state.serialize_entry("storageDestinationOptions", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ObjectMetadataReportOptions].
pub mod object_metadata_report_options {
    #[allow(unused_imports)]
    use super::*;

    /// Filter options for storage systems.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// Cloud Storage as the storage system.
        StorageFilters(std::boxed::Box<crate::model::CloudStorageFilters>),
    }

    /// Options on destination for storage systems.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DestinationOptions {
        /// Cloud Storage as the storage system.
        StorageDestinationOptions(std::boxed::Box<crate::model::CloudStorageDestinationOptions>),
    }
}

/// Message describing ReportConfig object. ReportConfig is the configuration to
/// generate reports.
/// See
/// <https://cloud.google.com/storage/docs/insights/using-inventory-reports#create-config-rest>
/// for more details on how to set various fields.
/// Next ID: 12
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportConfig {
    /// name of resource. It will be of form
    /// projects/\<project\>/locations/\<location\>/reportConfigs/\<report-config-id\>.
    pub name: std::string::String,

    /// Output only. [Output only] Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update time stamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The frequency of report generation.
    pub frequency_options: std::option::Option<crate::model::FrequencyOptions>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User provided display name which can be empty and limited to 256 characters
    /// that is editable.
    pub display_name: std::string::String,

    /// Format in which report will be published.
    pub report_format: std::option::Option<crate::model::report_config::ReportFormat>,

    /// Configuration options for report contents.
    pub report_kind: std::option::Option<crate::model::report_config::ReportKind>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReportConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ReportConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ReportConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ReportConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ReportConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [frequency_options][crate::model::ReportConfig::frequency_options].
    pub fn set_frequency_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FrequencyOptions>,
    {
        self.frequency_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [frequency_options][crate::model::ReportConfig::frequency_options].
    pub fn set_or_clear_frequency_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FrequencyOptions>,
    {
        self.frequency_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ReportConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::ReportConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [report_format][crate::model::ReportConfig::report_format].
    ///
    /// Note that all the setters affecting `report_format` are mutually
    /// exclusive.
    pub fn set_report_format<
        T: std::convert::Into<std::option::Option<crate::model::report_config::ReportFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report_format = v.into();
        self
    }

    /// The value of [report_format][crate::model::ReportConfig::report_format]
    /// if it holds a `CsvOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_options(&self) -> std::option::Option<&std::boxed::Box<crate::model::CSVOptions>> {
        #[allow(unreachable_patterns)]
        self.report_format.as_ref().and_then(|v| match v {
            crate::model::report_config::ReportFormat::CsvOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [report_format][crate::model::ReportConfig::report_format]
    /// to hold a `CsvOptions`.
    ///
    /// Note that all the setters affecting `report_format` are
    /// mutually exclusive.
    pub fn set_csv_options<T: std::convert::Into<std::boxed::Box<crate::model::CSVOptions>>>(
        mut self,
        v: T,
    ) -> Self {
        self.report_format = std::option::Option::Some(
            crate::model::report_config::ReportFormat::CsvOptions(v.into()),
        );
        self
    }

    /// The value of [report_format][crate::model::ReportConfig::report_format]
    /// if it holds a `ParquetOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn parquet_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ParquetOptions>> {
        #[allow(unreachable_patterns)]
        self.report_format.as_ref().and_then(|v| match v {
            crate::model::report_config::ReportFormat::ParquetOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [report_format][crate::model::ReportConfig::report_format]
    /// to hold a `ParquetOptions`.
    ///
    /// Note that all the setters affecting `report_format` are
    /// mutually exclusive.
    pub fn set_parquet_options<
        T: std::convert::Into<std::boxed::Box<crate::model::ParquetOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report_format = std::option::Option::Some(
            crate::model::report_config::ReportFormat::ParquetOptions(v.into()),
        );
        self
    }

    /// Sets the value of [report_kind][crate::model::ReportConfig::report_kind].
    ///
    /// Note that all the setters affecting `report_kind` are mutually
    /// exclusive.
    pub fn set_report_kind<
        T: std::convert::Into<std::option::Option<crate::model::report_config::ReportKind>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report_kind = v.into();
        self
    }

    /// The value of [report_kind][crate::model::ReportConfig::report_kind]
    /// if it holds a `ObjectMetadataReportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn object_metadata_report_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ObjectMetadataReportOptions>> {
        #[allow(unreachable_patterns)]
        self.report_kind.as_ref().and_then(|v| match v {
            crate::model::report_config::ReportKind::ObjectMetadataReportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [report_kind][crate::model::ReportConfig::report_kind]
    /// to hold a `ObjectMetadataReportOptions`.
    ///
    /// Note that all the setters affecting `report_kind` are
    /// mutually exclusive.
    pub fn set_object_metadata_report_options<
        T: std::convert::Into<std::boxed::Box<crate::model::ObjectMetadataReportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.report_kind = std::option::Option::Some(
            crate::model::report_config::ReportKind::ObjectMetadataReportOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ReportConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ReportConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __frequency_options,
            __csv_options,
            __parquet_options,
            __object_metadata_report_options,
            __labels,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "frequencyOptions" => Ok(__FieldTag::__frequency_options),
                            "frequency_options" => Ok(__FieldTag::__frequency_options),
                            "csvOptions" => Ok(__FieldTag::__csv_options),
                            "csv_options" => Ok(__FieldTag::__csv_options),
                            "parquetOptions" => Ok(__FieldTag::__parquet_options),
                            "parquet_options" => Ok(__FieldTag::__parquet_options),
                            "objectMetadataReportOptions" => {
                                Ok(__FieldTag::__object_metadata_report_options)
                            }
                            "object_metadata_report_options" => {
                                Ok(__FieldTag::__object_metadata_report_options)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__frequency_options => {
                            if !fields.insert(__FieldTag::__frequency_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency_options",
                                ));
                            }
                            result.frequency_options = map
                                .next_value::<std::option::Option<crate::model::FrequencyOptions>>(
                                )?;
                        }
                        __FieldTag::__csv_options => {
                            if !fields.insert(__FieldTag::__csv_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_options",
                                ));
                            }
                            if result.report_format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `report_format`, a oneof with full ID .google.cloud.storageinsights.v1.ReportConfig.csv_options, latest field was csvOptions",
                                ));
                            }
                            result.report_format = std::option::Option::Some(
                                crate::model::report_config::ReportFormat::CsvOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CSVOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__parquet_options => {
                            if !fields.insert(__FieldTag::__parquet_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parquet_options",
                                ));
                            }
                            if result.report_format.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `report_format`, a oneof with full ID .google.cloud.storageinsights.v1.ReportConfig.parquet_options, latest field was parquetOptions",
                                ));
                            }
                            result.report_format = std::option::Option::Some(
                                crate::model::report_config::ReportFormat::ParquetOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ParquetOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__object_metadata_report_options => {
                            if !fields.insert(__FieldTag::__object_metadata_report_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_metadata_report_options",
                                ));
                            }
                            if result.report_kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `report_kind`, a oneof with full ID .google.cloud.storageinsights.v1.ReportConfig.object_metadata_report_options, latest field was objectMetadataReportOptions",
                                ));
                            }
                            result.report_kind = std::option::Option::Some(
                                crate::model::report_config::ReportKind::ObjectMetadataReportOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ObjectMetadataReportOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.frequency_options.is_some() {
            state.serialize_entry("frequencyOptions", &self.frequency_options)?;
        }
        if let Some(value) = self.csv_options() {
            state.serialize_entry("csvOptions", value)?;
        }
        if let Some(value) = self.parquet_options() {
            state.serialize_entry("parquetOptions", value)?;
        }
        if let Some(value) = self.object_metadata_report_options() {
            state.serialize_entry("objectMetadataReportOptions", value)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReportConfig].
pub mod report_config {
    #[allow(unused_imports)]
    use super::*;

    /// Format in which report will be published.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReportFormat {
        /// Options for CSV formatted reports.
        CsvOptions(std::boxed::Box<crate::model::CSVOptions>),
        /// Options for Parquet formatted reports.
        ParquetOptions(std::boxed::Box<crate::model::ParquetOptions>),
    }

    /// Configuration options for report contents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReportKind {
        /// Report for exporting object metadata.
        ObjectMetadataReportOptions(std::boxed::Box<crate::model::ObjectMetadataReportOptions>),
    }
}

/// Identity lets the user provide the type of identity to use, and outputs
/// the identity string that can be used for IAM policy changes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Identity {
    /// Output only. Name of the identity.
    pub name: std::string::String,

    /// Type of identity to use for the datasetConfig.
    pub r#type: crate::model::identity::IdentityType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Identity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Identity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Identity::type].
    pub fn set_type<T: std::convert::Into<crate::model::identity::IdentityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for Identity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.Identity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Identity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Identity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Identity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Identity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::identity::IdentityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Identity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Identity].
pub mod identity {
    #[allow(unused_imports)]
    use super::*;

    /// Type of service account to use for the dataset configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IdentityType {
        /// Default is unspecified and should not be used.
        Unspecified,
        /// Google managed service account per resource.
        PerConfig,
        /// Google managed service account per project.
        PerProject,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IdentityType::value] or
        /// [IdentityType::name].
        UnknownValue(identity_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod identity_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IdentityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PerConfig => std::option::Option::Some(1),
                Self::PerProject => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IDENTITY_TYPE_UNSPECIFIED"),
                Self::PerConfig => std::option::Option::Some("IDENTITY_TYPE_PER_CONFIG"),
                Self::PerProject => std::option::Option::Some("IDENTITY_TYPE_PER_PROJECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IdentityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IdentityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IdentityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PerConfig,
                2 => Self::PerProject,
                _ => Self::UnknownValue(identity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IdentityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IDENTITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IDENTITY_TYPE_PER_CONFIG" => Self::PerConfig,
                "IDENTITY_TYPE_PER_PROJECT" => Self::PerProject,
                _ => Self::UnknownValue(identity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IdentityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PerConfig => serializer.serialize_i32(1),
                Self::PerProject => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IdentityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IdentityType>::new(
                ".google.cloud.storageinsights.v1.Identity.IdentityType",
            ))
        }
    }
}

/// Message describing the dataset configuration properties. For more
/// information, see [Dataset configuration
/// properties](https://cloud.google.com/storage/docs/insights/datasets#dataset-config).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetConfig {
    /// Identifier. name of resource
    pub name: std::string::String,

    /// Output only. The UTC time at which the dataset configuration was created.
    /// This is auto-populated.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The UTC time at which the dataset configuration was last
    /// updated. This is auto-populated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. System generated unique identifier for the resource.
    pub uid: std::string::String,

    /// Optional. Organization resource ID that the source projects should belong
    /// to. Projects that do not belong to the provided organization are not
    /// considered when creating the dataset.
    pub organization_number: i64,

    /// If set to `true`, the request includes all the newly created buckets in the
    /// dataset that meet the inclusion and exclusion rules.
    pub include_newly_created_buckets: bool,

    /// Optional. If set to `false`, then all the permission checks must be
    /// successful before the system can start ingesting data. This field can only
    /// be updated before the system ingests data for the first time. Any attempt
    /// to modify the field after data ingestion starts results in an error.
    #[deprecated]
    pub skip_verification_and_ingest: bool,

    /// Number of days of history that must be retained.
    pub retention_period_days: i32,

    /// Details of the linked dataset.
    pub link: std::option::Option<crate::model::dataset_config::Link>,

    /// Identity used by this `datasetConfig`.
    pub identity: std::option::Option<crate::model::Identity>,

    /// Output only. Status of the `datasetConfig`.
    pub status: std::option::Option<rpc::model::Status>,

    /// Output only. State of the `datasetConfig`.
    pub dataset_config_state: crate::model::dataset_config::ConfigState,

    /// Optional. A user-provided description for the dataset configuration.
    ///
    /// Maximum length: 256 characters.
    pub description: std::string::String,

    /// Defines the options for providing source identifiers for the dataset.
    pub source_options: std::option::Option<crate::model::dataset_config::SourceOptions>,

    /// Cloud Storage locations to include or exclude.
    pub cloud_storage_locations:
        std::option::Option<crate::model::dataset_config::CloudStorageLocationsOneOf>,

    /// Cloud Storage buckets to include or exclude.
    pub cloud_storage_buckets:
        std::option::Option<crate::model::dataset_config::CloudStorageBucketsOneOf>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DatasetConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DatasetConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DatasetConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DatasetConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DatasetConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::DatasetConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uid][crate::model::DatasetConfig::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [organization_number][crate::model::DatasetConfig::organization_number].
    pub fn set_organization_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.organization_number = v.into();
        self
    }

    /// Sets the value of [include_newly_created_buckets][crate::model::DatasetConfig::include_newly_created_buckets].
    pub fn set_include_newly_created_buckets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_newly_created_buckets = v.into();
        self
    }

    /// Sets the value of [skip_verification_and_ingest][crate::model::DatasetConfig::skip_verification_and_ingest].
    #[deprecated]
    pub fn set_skip_verification_and_ingest<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_verification_and_ingest = v.into();
        self
    }

    /// Sets the value of [retention_period_days][crate::model::DatasetConfig::retention_period_days].
    pub fn set_retention_period_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retention_period_days = v.into();
        self
    }

    /// Sets the value of [link][crate::model::DatasetConfig::link].
    pub fn set_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::dataset_config::Link>,
    {
        self.link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [link][crate::model::DatasetConfig::link].
    pub fn set_or_clear_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::dataset_config::Link>,
    {
        self.link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [identity][crate::model::DatasetConfig::identity].
    pub fn set_identity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Identity>,
    {
        self.identity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity][crate::model::DatasetConfig::identity].
    pub fn set_or_clear_identity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Identity>,
    {
        self.identity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::DatasetConfig::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::DatasetConfig::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dataset_config_state][crate::model::DatasetConfig::dataset_config_state].
    pub fn set_dataset_config_state<
        T: std::convert::Into<crate::model::dataset_config::ConfigState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config_state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DatasetConfig::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [source_options][crate::model::DatasetConfig::source_options].
    ///
    /// Note that all the setters affecting `source_options` are mutually
    /// exclusive.
    pub fn set_source_options<
        T: std::convert::Into<std::option::Option<crate::model::dataset_config::SourceOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_options = v.into();
        self
    }

    /// The value of [source_options][crate::model::DatasetConfig::source_options]
    /// if it holds a `SourceProjects`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_projects(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dataset_config::SourceProjects>> {
        #[allow(unreachable_patterns)]
        self.source_options.as_ref().and_then(|v| match v {
            crate::model::dataset_config::SourceOptions::SourceProjects(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_options][crate::model::DatasetConfig::source_options]
    /// to hold a `SourceProjects`.
    ///
    /// Note that all the setters affecting `source_options` are
    /// mutually exclusive.
    pub fn set_source_projects<
        T: std::convert::Into<std::boxed::Box<crate::model::dataset_config::SourceProjects>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_options = std::option::Option::Some(
            crate::model::dataset_config::SourceOptions::SourceProjects(v.into()),
        );
        self
    }

    /// The value of [source_options][crate::model::DatasetConfig::source_options]
    /// if it holds a `SourceFolders`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_folders(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dataset_config::SourceFolders>> {
        #[allow(unreachable_patterns)]
        self.source_options.as_ref().and_then(|v| match v {
            crate::model::dataset_config::SourceOptions::SourceFolders(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_options][crate::model::DatasetConfig::source_options]
    /// to hold a `SourceFolders`.
    ///
    /// Note that all the setters affecting `source_options` are
    /// mutually exclusive.
    pub fn set_source_folders<
        T: std::convert::Into<std::boxed::Box<crate::model::dataset_config::SourceFolders>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_options = std::option::Option::Some(
            crate::model::dataset_config::SourceOptions::SourceFolders(v.into()),
        );
        self
    }

    /// The value of [source_options][crate::model::DatasetConfig::source_options]
    /// if it holds a `OrganizationScope`, `None` if the field is not set or
    /// holds a different branch.
    pub fn organization_scope(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.source_options.as_ref().and_then(|v| match v {
            crate::model::dataset_config::SourceOptions::OrganizationScope(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_options][crate::model::DatasetConfig::source_options]
    /// to hold a `OrganizationScope`.
    ///
    /// Note that all the setters affecting `source_options` are
    /// mutually exclusive.
    pub fn set_organization_scope<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.source_options = std::option::Option::Some(
            crate::model::dataset_config::SourceOptions::OrganizationScope(v.into()),
        );
        self
    }

    /// The value of [source_options][crate::model::DatasetConfig::source_options]
    /// if it holds a `CloudStorageObjectPath`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_object_path(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source_options.as_ref().and_then(|v| match v {
            crate::model::dataset_config::SourceOptions::CloudStorageObjectPath(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_options][crate::model::DatasetConfig::source_options]
    /// to hold a `CloudStorageObjectPath`.
    ///
    /// Note that all the setters affecting `source_options` are
    /// mutually exclusive.
    pub fn set_cloud_storage_object_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_options = std::option::Option::Some(
            crate::model::dataset_config::SourceOptions::CloudStorageObjectPath(v.into()),
        );
        self
    }

    /// Sets the value of [cloud_storage_locations][crate::model::DatasetConfig::cloud_storage_locations].
    ///
    /// Note that all the setters affecting `cloud_storage_locations` are mutually
    /// exclusive.
    pub fn set_cloud_storage_locations<
        T: std::convert::Into<
                std::option::Option<crate::model::dataset_config::CloudStorageLocationsOneOf>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_storage_locations = v.into();
        self
    }

    /// The value of [cloud_storage_locations][crate::model::DatasetConfig::cloud_storage_locations]
    /// if it holds a `IncludeCloudStorageLocations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_cloud_storage_locations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>>
    {
        #[allow(unreachable_patterns)]
        self.cloud_storage_locations.as_ref().and_then(|v| match v {
            crate::model::dataset_config::CloudStorageLocationsOneOf::IncludeCloudStorageLocations(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cloud_storage_locations][crate::model::DatasetConfig::cloud_storage_locations]
    /// to hold a `IncludeCloudStorageLocations`.
    ///
    /// Note that all the setters affecting `cloud_storage_locations` are
    /// mutually exclusive.
    pub fn set_include_cloud_storage_locations<
        T: std::convert::Into<std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_storage_locations = std::option::Option::Some(
            crate::model::dataset_config::CloudStorageLocationsOneOf::IncludeCloudStorageLocations(
                v.into(),
            ),
        );
        self
    }

    /// The value of [cloud_storage_locations][crate::model::DatasetConfig::cloud_storage_locations]
    /// if it holds a `ExcludeCloudStorageLocations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclude_cloud_storage_locations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>>
    {
        #[allow(unreachable_patterns)]
        self.cloud_storage_locations.as_ref().and_then(|v| match v {
            crate::model::dataset_config::CloudStorageLocationsOneOf::ExcludeCloudStorageLocations(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cloud_storage_locations][crate::model::DatasetConfig::cloud_storage_locations]
    /// to hold a `ExcludeCloudStorageLocations`.
    ///
    /// Note that all the setters affecting `cloud_storage_locations` are
    /// mutually exclusive.
    pub fn set_exclude_cloud_storage_locations<
        T: std::convert::Into<std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_storage_locations = std::option::Option::Some(
            crate::model::dataset_config::CloudStorageLocationsOneOf::ExcludeCloudStorageLocations(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [cloud_storage_buckets][crate::model::DatasetConfig::cloud_storage_buckets].
    ///
    /// Note that all the setters affecting `cloud_storage_buckets` are mutually
    /// exclusive.
    pub fn set_cloud_storage_buckets<
        T: std::convert::Into<
                std::option::Option<crate::model::dataset_config::CloudStorageBucketsOneOf>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_storage_buckets = v.into();
        self
    }

    /// The value of [cloud_storage_buckets][crate::model::DatasetConfig::cloud_storage_buckets]
    /// if it holds a `IncludeCloudStorageBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn include_cloud_storage_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>>
    {
        #[allow(unreachable_patterns)]
        self.cloud_storage_buckets.as_ref().and_then(|v| match v {
            crate::model::dataset_config::CloudStorageBucketsOneOf::IncludeCloudStorageBuckets(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cloud_storage_buckets][crate::model::DatasetConfig::cloud_storage_buckets]
    /// to hold a `IncludeCloudStorageBuckets`.
    ///
    /// Note that all the setters affecting `cloud_storage_buckets` are
    /// mutually exclusive.
    pub fn set_include_cloud_storage_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_storage_buckets = std::option::Option::Some(
            crate::model::dataset_config::CloudStorageBucketsOneOf::IncludeCloudStorageBuckets(
                v.into(),
            ),
        );
        self
    }

    /// The value of [cloud_storage_buckets][crate::model::DatasetConfig::cloud_storage_buckets]
    /// if it holds a `ExcludeCloudStorageBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclude_cloud_storage_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>>
    {
        #[allow(unreachable_patterns)]
        self.cloud_storage_buckets.as_ref().and_then(|v| match v {
            crate::model::dataset_config::CloudStorageBucketsOneOf::ExcludeCloudStorageBuckets(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [cloud_storage_buckets][crate::model::DatasetConfig::cloud_storage_buckets]
    /// to hold a `ExcludeCloudStorageBuckets`.
    ///
    /// Note that all the setters affecting `cloud_storage_buckets` are
    /// mutually exclusive.
    pub fn set_exclude_cloud_storage_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cloud_storage_buckets = std::option::Option::Some(
            crate::model::dataset_config::CloudStorageBucketsOneOf::ExcludeCloudStorageBuckets(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DatasetConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatasetConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __uid,
            __organization_number,
            __source_projects,
            __source_folders,
            __organization_scope,
            __cloud_storage_object_path,
            __include_cloud_storage_locations,
            __exclude_cloud_storage_locations,
            __include_cloud_storage_buckets,
            __exclude_cloud_storage_buckets,
            __include_newly_created_buckets,
            __skip_verification_and_ingest,
            __retention_period_days,
            __link,
            __identity,
            __status,
            __dataset_config_state,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "uid" => Ok(__FieldTag::__uid),
                            "organizationNumber" => Ok(__FieldTag::__organization_number),
                            "organization_number" => Ok(__FieldTag::__organization_number),
                            "sourceProjects" => Ok(__FieldTag::__source_projects),
                            "source_projects" => Ok(__FieldTag::__source_projects),
                            "sourceFolders" => Ok(__FieldTag::__source_folders),
                            "source_folders" => Ok(__FieldTag::__source_folders),
                            "organizationScope" => Ok(__FieldTag::__organization_scope),
                            "organization_scope" => Ok(__FieldTag::__organization_scope),
                            "cloudStorageObjectPath" => Ok(__FieldTag::__cloud_storage_object_path),
                            "cloud_storage_object_path" => {
                                Ok(__FieldTag::__cloud_storage_object_path)
                            }
                            "includeCloudStorageLocations" => {
                                Ok(__FieldTag::__include_cloud_storage_locations)
                            }
                            "include_cloud_storage_locations" => {
                                Ok(__FieldTag::__include_cloud_storage_locations)
                            }
                            "excludeCloudStorageLocations" => {
                                Ok(__FieldTag::__exclude_cloud_storage_locations)
                            }
                            "exclude_cloud_storage_locations" => {
                                Ok(__FieldTag::__exclude_cloud_storage_locations)
                            }
                            "includeCloudStorageBuckets" => {
                                Ok(__FieldTag::__include_cloud_storage_buckets)
                            }
                            "include_cloud_storage_buckets" => {
                                Ok(__FieldTag::__include_cloud_storage_buckets)
                            }
                            "excludeCloudStorageBuckets" => {
                                Ok(__FieldTag::__exclude_cloud_storage_buckets)
                            }
                            "exclude_cloud_storage_buckets" => {
                                Ok(__FieldTag::__exclude_cloud_storage_buckets)
                            }
                            "includeNewlyCreatedBuckets" => {
                                Ok(__FieldTag::__include_newly_created_buckets)
                            }
                            "include_newly_created_buckets" => {
                                Ok(__FieldTag::__include_newly_created_buckets)
                            }
                            "skipVerificationAndIngest" => {
                                Ok(__FieldTag::__skip_verification_and_ingest)
                            }
                            "skip_verification_and_ingest" => {
                                Ok(__FieldTag::__skip_verification_and_ingest)
                            }
                            "retentionPeriodDays" => Ok(__FieldTag::__retention_period_days),
                            "retention_period_days" => Ok(__FieldTag::__retention_period_days),
                            "link" => Ok(__FieldTag::__link),
                            "identity" => Ok(__FieldTag::__identity),
                            "status" => Ok(__FieldTag::__status),
                            "datasetConfigState" => Ok(__FieldTag::__dataset_config_state),
                            "dataset_config_state" => Ok(__FieldTag::__dataset_config_state),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatasetConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__organization_number => {
                            if !fields.insert(__FieldTag::__organization_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization_number",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.organization_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_projects => {
                            if !fields.insert(__FieldTag::__source_projects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_projects",
                                ));
                            }
                            if result.source_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_options`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.source_projects, latest field was sourceProjects",
                                ));
                            }
                            result.source_options = std::option::Option::Some(
                                crate::model::dataset_config::SourceOptions::SourceProjects(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::dataset_config::SourceProjects,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__source_folders => {
                            if !fields.insert(__FieldTag::__source_folders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_folders",
                                ));
                            }
                            if result.source_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_options`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.source_folders, latest field was sourceFolders",
                                ));
                            }
                            result.source_options = std::option::Option::Some(
                                crate::model::dataset_config::SourceOptions::SourceFolders(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::dataset_config::SourceFolders,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__organization_scope => {
                            if !fields.insert(__FieldTag::__organization_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization_scope",
                                ));
                            }
                            if result.source_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_options`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.organization_scope, latest field was organizationScope",
                                ));
                            }
                            result.source_options = std::option::Option::Some(
                                crate::model::dataset_config::SourceOptions::OrganizationScope(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloud_storage_object_path => {
                            if !fields.insert(__FieldTag::__cloud_storage_object_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_object_path",
                                ));
                            }
                            if result.source_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_options`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.cloud_storage_object_path, latest field was cloudStorageObjectPath",
                                ));
                            }
                            result.source_options = std::option::Option::Some(
                                crate::model::dataset_config::SourceOptions::CloudStorageObjectPath(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__include_cloud_storage_locations => {
                            if !fields.insert(__FieldTag::__include_cloud_storage_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_cloud_storage_locations",
                                ));
                            }
                            if result.cloud_storage_locations.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cloud_storage_locations`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.include_cloud_storage_locations, latest field was includeCloudStorageLocations",
                                ));
                            }
                            result.cloud_storage_locations = std::option::Option::Some(
                                crate::model::dataset_config::CloudStorageLocationsOneOf::IncludeCloudStorageLocations(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__exclude_cloud_storage_locations => {
                            if !fields.insert(__FieldTag::__exclude_cloud_storage_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_cloud_storage_locations",
                                ));
                            }
                            if result.cloud_storage_locations.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cloud_storage_locations`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.exclude_cloud_storage_locations, latest field was excludeCloudStorageLocations",
                                ));
                            }
                            result.cloud_storage_locations = std::option::Option::Some(
                                crate::model::dataset_config::CloudStorageLocationsOneOf::ExcludeCloudStorageLocations(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__include_cloud_storage_buckets => {
                            if !fields.insert(__FieldTag::__include_cloud_storage_buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_cloud_storage_buckets",
                                ));
                            }
                            if result.cloud_storage_buckets.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cloud_storage_buckets`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.include_cloud_storage_buckets, latest field was includeCloudStorageBuckets",
                                ));
                            }
                            result.cloud_storage_buckets = std::option::Option::Some(
                                crate::model::dataset_config::CloudStorageBucketsOneOf::IncludeCloudStorageBuckets(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__exclude_cloud_storage_buckets => {
                            if !fields.insert(__FieldTag::__exclude_cloud_storage_buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_cloud_storage_buckets",
                                ));
                            }
                            if result.cloud_storage_buckets.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `cloud_storage_buckets`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.exclude_cloud_storage_buckets, latest field was excludeCloudStorageBuckets",
                                ));
                            }
                            result.cloud_storage_buckets = std::option::Option::Some(
                                crate::model::dataset_config::CloudStorageBucketsOneOf::ExcludeCloudStorageBuckets(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__include_newly_created_buckets => {
                            if !fields.insert(__FieldTag::__include_newly_created_buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_newly_created_buckets",
                                ));
                            }
                            result.include_newly_created_buckets = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_verification_and_ingest => {
                            if !fields.insert(__FieldTag::__skip_verification_and_ingest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_verification_and_ingest",
                                ));
                            }
                            result.skip_verification_and_ingest = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention_period_days => {
                            if !fields.insert(__FieldTag::__retention_period_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_period_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retention_period_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__link => {
                            if !fields.insert(__FieldTag::__link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for link",
                                ));
                            }
                            result.link = map.next_value::<std::option::Option<crate::model::dataset_config::Link>>()?
                                ;
                        }
                        __FieldTag::__identity => {
                            if !fields.insert(__FieldTag::__identity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity",
                                ));
                            }
                            result.identity =
                                map.next_value::<std::option::Option<crate::model::Identity>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__dataset_config_state => {
                            if !fields.insert(__FieldTag::__dataset_config_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_config_state",
                                ));
                            }
                            result.dataset_config_state = map.next_value::<std::option::Option<crate::model::dataset_config::ConfigState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatasetConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.organization_number) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("organizationNumber", &__With(&self.organization_number))?;
        }
        if let Some(value) = self.source_projects() {
            state.serialize_entry("sourceProjects", value)?;
        }
        if let Some(value) = self.source_folders() {
            state.serialize_entry("sourceFolders", value)?;
        }
        if let Some(value) = self.organization_scope() {
            state.serialize_entry("organizationScope", value)?;
        }
        if let Some(value) = self.cloud_storage_object_path() {
            state.serialize_entry("cloudStorageObjectPath", value)?;
        }
        if let Some(value) = self.include_cloud_storage_locations() {
            state.serialize_entry("includeCloudStorageLocations", value)?;
        }
        if let Some(value) = self.exclude_cloud_storage_locations() {
            state.serialize_entry("excludeCloudStorageLocations", value)?;
        }
        if let Some(value) = self.include_cloud_storage_buckets() {
            state.serialize_entry("includeCloudStorageBuckets", value)?;
        }
        if let Some(value) = self.exclude_cloud_storage_buckets() {
            state.serialize_entry("excludeCloudStorageBuckets", value)?;
        }
        if !wkt::internal::is_default(&self.include_newly_created_buckets) {
            state.serialize_entry(
                "includeNewlyCreatedBuckets",
                &self.include_newly_created_buckets,
            )?;
        }
        if !wkt::internal::is_default(&self.skip_verification_and_ingest) {
            state.serialize_entry(
                "skipVerificationAndIngest",
                &self.skip_verification_and_ingest,
            )?;
        }
        if !wkt::internal::is_default(&self.retention_period_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retentionPeriodDays", &__With(&self.retention_period_days))?;
        }
        if self.link.is_some() {
            state.serialize_entry("link", &self.link)?;
        }
        if self.identity.is_some() {
            state.serialize_entry("identity", &self.identity)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !wkt::internal::is_default(&self.dataset_config_state) {
            state.serialize_entry("datasetConfigState", &self.dataset_config_state)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatasetConfig].
pub mod dataset_config {
    #[allow(unused_imports)]
    use super::*;

    /// Collection of project numbers
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SourceProjects {
        pub project_numbers: std::vec::Vec<i64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceProjects {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_numbers][crate::model::dataset_config::SourceProjects::project_numbers].
        pub fn set_project_numbers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.project_numbers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SourceProjects {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.SourceProjects"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SourceProjects {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __project_numbers,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SourceProjects")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "projectNumbers" => Ok(__FieldTag::__project_numbers),
                                "project_numbers" => Ok(__FieldTag::__project_numbers),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SourceProjects;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SourceProjects")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__project_numbers => {
                                if !fields.insert(__FieldTag::__project_numbers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_numbers",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i64>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.project_numbers =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SourceProjects {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.project_numbers.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("projectNumbers", &__With(&self.project_numbers))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Specifies a set of folders to include in the dataset
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SourceFolders {
        /// Optional. The list of folder numbers to include in the dataset.
        pub folder_numbers: std::vec::Vec<i64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SourceFolders {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [folder_numbers][crate::model::dataset_config::SourceFolders::folder_numbers].
        pub fn set_folder_numbers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.folder_numbers = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SourceFolders {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.SourceFolders"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SourceFolders {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __folder_numbers,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SourceFolders")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "folderNumbers" => Ok(__FieldTag::__folder_numbers),
                                "folder_numbers" => Ok(__FieldTag::__folder_numbers),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SourceFolders;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SourceFolders")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__folder_numbers => {
                                if !fields.insert(__FieldTag::__folder_numbers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for folder_numbers",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i64>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.folder_numbers =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SourceFolders {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.folder_numbers.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("folderNumbers", &__With(&self.folder_numbers))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Collection of Cloud Storage locations.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudStorageLocations {
        pub locations: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudStorageLocations {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [locations][crate::model::dataset_config::CloudStorageLocations::locations].
        pub fn set_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CloudStorageLocations {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.CloudStorageLocations"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudStorageLocations {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __locations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudStorageLocations")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "locations" => Ok(__FieldTag::__locations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudStorageLocations;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudStorageLocations")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__locations => {
                                if !fields.insert(__FieldTag::__locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for locations",
                                    ));
                                }
                                result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudStorageLocations {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.locations.is_empty() {
                state.serialize_entry("locations", &self.locations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Collection of Cloud Storage buckets.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CloudStorageBuckets {
        pub cloud_storage_buckets:
            std::vec::Vec<crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CloudStorageBuckets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cloud_storage_buckets][crate::model::dataset_config::CloudStorageBuckets::cloud_storage_buckets].
        pub fn set_cloud_storage_buckets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket,
                >,
        {
            use std::iter::Iterator;
            self.cloud_storage_buckets = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CloudStorageBuckets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.CloudStorageBuckets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CloudStorageBuckets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cloud_storage_buckets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CloudStorageBuckets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cloudStorageBuckets" => Ok(__FieldTag::__cloud_storage_buckets),
                                "cloud_storage_buckets" => Ok(__FieldTag::__cloud_storage_buckets),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CloudStorageBuckets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CloudStorageBuckets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cloud_storage_buckets => {
                                if !fields.insert(__FieldTag::__cloud_storage_buckets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_storage_buckets",
                                    ));
                                }
                                result.cloud_storage_buckets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CloudStorageBuckets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cloud_storage_buckets.is_empty() {
                state.serialize_entry("cloudStorageBuckets", &self.cloud_storage_buckets)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [CloudStorageBuckets].
    pub mod cloud_storage_buckets {
        #[allow(unused_imports)]
        use super::*;

        /// Defines the bucket by its name or a regex pattern to match buckets.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CloudStorageBucket {

            pub cloud_storage_bucket: std::option::Option<crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CloudStorageBucket {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cloud_storage_bucket][crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket::cloud_storage_bucket].
            ///
            /// Note that all the setters affecting `cloud_storage_bucket` are mutually
            /// exclusive.
            pub fn set_cloud_storage_bucket<T: std::convert::Into<std::option::Option<crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket>>>(mut self, v: T) -> Self
            {
                self.cloud_storage_bucket = v.into();
                self
            }

            /// The value of [cloud_storage_bucket][crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket::cloud_storage_bucket]
            /// if it holds a `BucketName`, `None` if the field is not set or
            /// holds a different branch.
            pub fn bucket_name(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.cloud_storage_bucket.as_ref().and_then(|v| match v {
                    crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket::BucketName(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [cloud_storage_bucket][crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket::cloud_storage_bucket]
            /// to hold a `BucketName`.
            ///
            /// Note that all the setters affecting `cloud_storage_bucket` are
            /// mutually exclusive.
            pub fn set_bucket_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.cloud_storage_bucket = std::option::Option::Some(
                    crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket::BucketName(
                        v.into()
                    )
                );
                self
            }

            /// The value of [cloud_storage_bucket][crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket::cloud_storage_bucket]
            /// if it holds a `BucketPrefixRegex`, `None` if the field is not set or
            /// holds a different branch.
            pub fn bucket_prefix_regex(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.cloud_storage_bucket.as_ref().and_then(|v| match v {
                    crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket::BucketPrefixRegex(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [cloud_storage_bucket][crate::model::dataset_config::cloud_storage_buckets::CloudStorageBucket::cloud_storage_bucket]
            /// to hold a `BucketPrefixRegex`.
            ///
            /// Note that all the setters affecting `cloud_storage_bucket` are
            /// mutually exclusive.
            pub fn set_bucket_prefix_regex<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.cloud_storage_bucket = std::option::Option::Some(
                    crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket::BucketPrefixRegex(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for CloudStorageBucket {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.CloudStorageBuckets.CloudStorageBucket"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CloudStorageBucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __bucket_name,
                    __bucket_prefix_regex,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CloudStorageBucket")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "bucketName" => Ok(__FieldTag::__bucket_name),
                                    "bucket_name" => Ok(__FieldTag::__bucket_name),
                                    "bucketPrefixRegex" => Ok(__FieldTag::__bucket_prefix_regex),
                                    "bucket_prefix_regex" => Ok(__FieldTag::__bucket_prefix_regex),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CloudStorageBucket;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CloudStorageBucket")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__bucket_name => {
                                    if !fields.insert(__FieldTag::__bucket_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_name",
                                            ),
                                        );
                                    }
                                    if result.cloud_storage_bucket.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `cloud_storage_bucket`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.CloudStorageBuckets.CloudStorageBucket.bucket_name, latest field was bucketName",
                                            ),
                                        );
                                    }
                                    result.cloud_storage_bucket = std::option::Option::Some(
                                        crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket::BucketName(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__bucket_prefix_regex => {
                                    if !fields.insert(__FieldTag::__bucket_prefix_regex) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for bucket_prefix_regex",
                                            ),
                                        );
                                    }
                                    if result.cloud_storage_bucket.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `cloud_storage_bucket`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.CloudStorageBuckets.CloudStorageBucket.bucket_prefix_regex, latest field was bucketPrefixRegex",
                                            ),
                                        );
                                    }
                                    result.cloud_storage_bucket = std::option::Option::Some(
                                        crate::model::dataset_config::cloud_storage_buckets::cloud_storage_bucket::CloudStorageBucket::BucketPrefixRegex(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CloudStorageBucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.bucket_name() {
                    state.serialize_entry("bucketName", value)?;
                }
                if let Some(value) = self.bucket_prefix_regex() {
                    state.serialize_entry("bucketPrefixRegex", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [CloudStorageBucket].
        pub mod cloud_storage_bucket {
            #[allow(unused_imports)]
            use super::*;

            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum CloudStorageBucket {
                /// Cloud Storage bucket name.
                BucketName(std::string::String),
                /// A regex pattern for bucket names matching the regex. Regex should
                /// follow the syntax specified in `google/re2` on GitHub.
                BucketPrefixRegex(std::string::String),
            }
        }
    }

    /// Defines the details about the linked dataset.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Link {
        /// Output only. Dataset name for linked dataset.
        pub dataset: std::string::String,

        /// Output only. State of the linked dataset.
        pub linked: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Link {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::dataset_config::Link::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [linked][crate::model::dataset_config::Link::linked].
        pub fn set_linked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.linked = v.into();
            self
        }
    }

    impl wkt::message::Message for Link {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.Link"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Link {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset,
                __linked,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Link")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dataset" => Ok(__FieldTag::__dataset),
                                "linked" => Ok(__FieldTag::__linked),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Link;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Link")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset => {
                                if !fields.insert(__FieldTag::__dataset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset",
                                    ));
                                }
                                result.dataset = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__linked => {
                                if !fields.insert(__FieldTag::__linked) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for linked",
                                    ));
                                }
                                result.linked = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Link {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dataset.is_empty() {
                state.serialize_entry("dataset", &self.dataset)?;
            }
            if !wkt::internal::is_default(&self.linked) {
                state.serialize_entry("linked", &self.linked)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Provides a summary of the bucket level error statistics.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BucketErrors {
        /// Optional. Count of successfully validated buckets.
        pub validated_count: i64,

        /// Optional. Count of buckets with permission denied errors.
        pub permission_denied_count: i64,

        /// Optional. Subset of bucket names that have permission denied.
        pub permission_denied_bucket_ids: std::vec::Vec<std::string::String>,

        /// Optional. Count of buckets that are not subscribed to Storage
        /// Intelligence.
        #[deprecated]
        pub non_management_hub_entitled_count: i64,

        /// Optional. Number of buckets that encountered internal errors during the
        /// validation process. These buckets are automatically retried in subsequent
        /// validation attempts.
        pub internal_error_count: i64,

        /// Optional. Count of buckets that are not subscribed to Storage
        /// Intelligence.
        pub non_storage_intelligence_entitled_count: i64,

        /// Optional. Subset of bucket names that are not subscribed to Storage
        /// Intelligence.
        pub non_storage_intelligence_entitled_bucket_ids: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BucketErrors {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [validated_count][crate::model::dataset_config::BucketErrors::validated_count].
        pub fn set_validated_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.validated_count = v.into();
            self
        }

        /// Sets the value of [permission_denied_count][crate::model::dataset_config::BucketErrors::permission_denied_count].
        pub fn set_permission_denied_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.permission_denied_count = v.into();
            self
        }

        /// Sets the value of [permission_denied_bucket_ids][crate::model::dataset_config::BucketErrors::permission_denied_bucket_ids].
        pub fn set_permission_denied_bucket_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.permission_denied_bucket_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [non_management_hub_entitled_count][crate::model::dataset_config::BucketErrors::non_management_hub_entitled_count].
        #[deprecated]
        pub fn set_non_management_hub_entitled_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.non_management_hub_entitled_count = v.into();
            self
        }

        /// Sets the value of [internal_error_count][crate::model::dataset_config::BucketErrors::internal_error_count].
        pub fn set_internal_error_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.internal_error_count = v.into();
            self
        }

        /// Sets the value of [non_storage_intelligence_entitled_count][crate::model::dataset_config::BucketErrors::non_storage_intelligence_entitled_count].
        pub fn set_non_storage_intelligence_entitled_count<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.non_storage_intelligence_entitled_count = v.into();
            self
        }

        /// Sets the value of [non_storage_intelligence_entitled_bucket_ids][crate::model::dataset_config::BucketErrors::non_storage_intelligence_entitled_bucket_ids].
        pub fn set_non_storage_intelligence_entitled_bucket_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.non_storage_intelligence_entitled_bucket_ids =
                v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BucketErrors {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.BucketErrors"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BucketErrors {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __validated_count,
                __permission_denied_count,
                __permission_denied_bucket_ids,
                __non_management_hub_entitled_count,
                __internal_error_count,
                __non_storage_intelligence_entitled_count,
                __non_storage_intelligence_entitled_bucket_ids,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BucketErrors")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "validatedCount" => Ok(__FieldTag::__validated_count),
                                "validated_count" => Ok(__FieldTag::__validated_count),
                                "permissionDeniedCount" => {
                                    Ok(__FieldTag::__permission_denied_count)
                                }
                                "permission_denied_count" => {
                                    Ok(__FieldTag::__permission_denied_count)
                                }
                                "permissionDeniedBucketIds" => {
                                    Ok(__FieldTag::__permission_denied_bucket_ids)
                                }
                                "permission_denied_bucket_ids" => {
                                    Ok(__FieldTag::__permission_denied_bucket_ids)
                                }
                                "nonManagementHubEntitledCount" => {
                                    Ok(__FieldTag::__non_management_hub_entitled_count)
                                }
                                "non_management_hub_entitled_count" => {
                                    Ok(__FieldTag::__non_management_hub_entitled_count)
                                }
                                "internalErrorCount" => Ok(__FieldTag::__internal_error_count),
                                "internal_error_count" => Ok(__FieldTag::__internal_error_count),
                                "nonStorageIntelligenceEntitledCount" => {
                                    Ok(__FieldTag::__non_storage_intelligence_entitled_count)
                                }
                                "non_storage_intelligence_entitled_count" => {
                                    Ok(__FieldTag::__non_storage_intelligence_entitled_count)
                                }
                                "nonStorageIntelligenceEntitledBucketIds" => {
                                    Ok(__FieldTag::__non_storage_intelligence_entitled_bucket_ids)
                                }
                                "non_storage_intelligence_entitled_bucket_ids" => {
                                    Ok(__FieldTag::__non_storage_intelligence_entitled_bucket_ids)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BucketErrors;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BucketErrors")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__validated_count => {
                                if !fields.insert(__FieldTag::__validated_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for validated_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.validated_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__permission_denied_count => {
                                if !fields.insert(__FieldTag::__permission_denied_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permission_denied_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.permission_denied_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__permission_denied_bucket_ids => {
                                if !fields.insert(__FieldTag::__permission_denied_bucket_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permission_denied_bucket_ids",
                                    ));
                                }
                                result.permission_denied_bucket_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__non_management_hub_entitled_count => {
                                if !fields.insert(__FieldTag::__non_management_hub_entitled_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_management_hub_entitled_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.non_management_hub_entitled_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__internal_error_count => {
                                if !fields.insert(__FieldTag::__internal_error_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for internal_error_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.internal_error_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__non_storage_intelligence_entitled_count => {
                                if !fields
                                    .insert(__FieldTag::__non_storage_intelligence_entitled_count)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_storage_intelligence_entitled_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.non_storage_intelligence_entitled_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__non_storage_intelligence_entitled_bucket_ids => {
                                if !fields.insert(
                                    __FieldTag::__non_storage_intelligence_entitled_bucket_ids,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_storage_intelligence_entitled_bucket_ids",
                                    ));
                                }
                                result.non_storage_intelligence_entitled_bucket_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BucketErrors {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.validated_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("validatedCount", &__With(&self.validated_count))?;
            }
            if !wkt::internal::is_default(&self.permission_denied_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "permissionDeniedCount",
                    &__With(&self.permission_denied_count),
                )?;
            }
            if !self.permission_denied_bucket_ids.is_empty() {
                state.serialize_entry(
                    "permissionDeniedBucketIds",
                    &self.permission_denied_bucket_ids,
                )?;
            }
            if !wkt::internal::is_default(&self.non_management_hub_entitled_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "nonManagementHubEntitledCount",
                    &__With(&self.non_management_hub_entitled_count),
                )?;
            }
            if !wkt::internal::is_default(&self.internal_error_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("internalErrorCount", &__With(&self.internal_error_count))?;
            }
            if !wkt::internal::is_default(&self.non_storage_intelligence_entitled_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "nonStorageIntelligenceEntitledCount",
                    &__With(&self.non_storage_intelligence_entitled_count),
                )?;
            }
            if !self.non_storage_intelligence_entitled_bucket_ids.is_empty() {
                state.serialize_entry(
                    "nonStorageIntelligenceEntitledBucketIds",
                    &self.non_storage_intelligence_entitled_bucket_ids,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Provides a summary of the project level error statistics.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProjectErrors {
        /// Optional. Count of successfully validated projects.
        pub validated_count: std::option::Option<i64>,

        /// Optional. Count of projects which are not in the same organization.
        pub outside_org_error_count: std::option::Option<i64>,

        /// Optional. Subset of project numbers which are not in the same
        /// organization.
        pub outside_org_project_numbers: std::vec::Vec<i64>,

        /// Optional. Count of projects that are not subscribed to Storage
        /// Intelligence.
        #[deprecated]
        pub non_management_hub_entitled_error_count: std::option::Option<i64>,

        /// Optional. Subset of project numbers that are not subscribed to Storage
        /// Intelligence.
        #[deprecated]
        pub non_management_hub_entitled_project_numbers: std::vec::Vec<i64>,

        /// Optional. Count of projects that are not subscribed to Storage
        /// Intelligence.
        pub non_storage_intelligence_entitled_error_count: std::option::Option<i64>,

        /// Optional. Subset of project numbers that are not subscribed to Storage
        /// Intelligence.
        pub non_storage_intelligence_entitled_project_numbers: std::vec::Vec<i64>,

        /// Optional. Number of projects that encountered internal errors during
        /// validation and are automatically retried.
        pub internal_error_count: std::option::Option<i64>,

        /// The destination project check result. It indicates whether the project
        /// is in the correct organization or if an internal error occurred during
        /// the check.
        pub destination_project_check_result: std::option::Option<
            crate::model::dataset_config::project_errors::DestinationProjectCheckResult,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProjectErrors {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [validated_count][crate::model::dataset_config::ProjectErrors::validated_count].
        pub fn set_validated_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.validated_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [validated_count][crate::model::dataset_config::ProjectErrors::validated_count].
        pub fn set_or_clear_validated_count<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.validated_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [outside_org_error_count][crate::model::dataset_config::ProjectErrors::outside_org_error_count].
        pub fn set_outside_org_error_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.outside_org_error_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [outside_org_error_count][crate::model::dataset_config::ProjectErrors::outside_org_error_count].
        pub fn set_or_clear_outside_org_error_count<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.outside_org_error_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [outside_org_project_numbers][crate::model::dataset_config::ProjectErrors::outside_org_project_numbers].
        pub fn set_outside_org_project_numbers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.outside_org_project_numbers = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [non_management_hub_entitled_error_count][crate::model::dataset_config::ProjectErrors::non_management_hub_entitled_error_count].
        #[deprecated]
        pub fn set_non_management_hub_entitled_error_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.non_management_hub_entitled_error_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [non_management_hub_entitled_error_count][crate::model::dataset_config::ProjectErrors::non_management_hub_entitled_error_count].
        #[deprecated]
        pub fn set_or_clear_non_management_hub_entitled_error_count<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.non_management_hub_entitled_error_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [non_management_hub_entitled_project_numbers][crate::model::dataset_config::ProjectErrors::non_management_hub_entitled_project_numbers].
        #[deprecated]
        pub fn set_non_management_hub_entitled_project_numbers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.non_management_hub_entitled_project_numbers =
                v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [non_storage_intelligence_entitled_error_count][crate::model::dataset_config::ProjectErrors::non_storage_intelligence_entitled_error_count].
        pub fn set_non_storage_intelligence_entitled_error_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.non_storage_intelligence_entitled_error_count =
                std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [non_storage_intelligence_entitled_error_count][crate::model::dataset_config::ProjectErrors::non_storage_intelligence_entitled_error_count].
        pub fn set_or_clear_non_storage_intelligence_entitled_error_count<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.non_storage_intelligence_entitled_error_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [non_storage_intelligence_entitled_project_numbers][crate::model::dataset_config::ProjectErrors::non_storage_intelligence_entitled_project_numbers].
        pub fn set_non_storage_intelligence_entitled_project_numbers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i64>,
        {
            use std::iter::Iterator;
            self.non_storage_intelligence_entitled_project_numbers =
                v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [internal_error_count][crate::model::dataset_config::ProjectErrors::internal_error_count].
        pub fn set_internal_error_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.internal_error_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [internal_error_count][crate::model::dataset_config::ProjectErrors::internal_error_count].
        pub fn set_or_clear_internal_error_count<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.internal_error_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [destination_project_check_result][crate::model::dataset_config::ProjectErrors::destination_project_check_result].
        ///
        /// Note that all the setters affecting `destination_project_check_result` are mutually
        /// exclusive.
        pub fn set_destination_project_check_result<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::dataset_config::project_errors::DestinationProjectCheckResult,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.destination_project_check_result = v.into();
            self
        }

        /// The value of [destination_project_check_result][crate::model::dataset_config::ProjectErrors::destination_project_check_result]
        /// if it holds a `DestinationProjectOrgError`, `None` if the field is not set or
        /// holds a different branch.
        pub fn destination_project_org_error(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.destination_project_check_result.as_ref().and_then(|v| match v {
                crate::model::dataset_config::project_errors::DestinationProjectCheckResult::DestinationProjectOrgError(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination_project_check_result][crate::model::dataset_config::ProjectErrors::destination_project_check_result]
        /// to hold a `DestinationProjectOrgError`.
        ///
        /// Note that all the setters affecting `destination_project_check_result` are
        /// mutually exclusive.
        pub fn set_destination_project_org_error<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.destination_project_check_result = std::option::Option::Some(
                crate::model::dataset_config::project_errors::DestinationProjectCheckResult::DestinationProjectOrgError(
                    v.into()
                )
            );
            self
        }

        /// The value of [destination_project_check_result][crate::model::dataset_config::ProjectErrors::destination_project_check_result]
        /// if it holds a `DestinationProjectCheckHasInternalError`, `None` if the field is not set or
        /// holds a different branch.
        pub fn destination_project_check_has_internal_error(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.destination_project_check_result.as_ref().and_then(|v| match v {
                crate::model::dataset_config::project_errors::DestinationProjectCheckResult::DestinationProjectCheckHasInternalError(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [destination_project_check_result][crate::model::dataset_config::ProjectErrors::destination_project_check_result]
        /// to hold a `DestinationProjectCheckHasInternalError`.
        ///
        /// Note that all the setters affecting `destination_project_check_result` are
        /// mutually exclusive.
        pub fn set_destination_project_check_has_internal_error<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.destination_project_check_result = std::option::Option::Some(
                crate::model::dataset_config::project_errors::DestinationProjectCheckResult::DestinationProjectCheckHasInternalError(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ProjectErrors {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.ProjectErrors"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ProjectErrors {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __validated_count,
                __outside_org_error_count,
                __outside_org_project_numbers,
                __non_management_hub_entitled_error_count,
                __non_management_hub_entitled_project_numbers,
                __non_storage_intelligence_entitled_error_count,
                __non_storage_intelligence_entitled_project_numbers,
                __internal_error_count,
                __destination_project_org_error,
                __destination_project_check_has_internal_error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ProjectErrors")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "validatedCount" => Ok(__FieldTag::__validated_count),
                                "validated_count" => Ok(__FieldTag::__validated_count),
                                "outsideOrgErrorCount" => Ok(__FieldTag::__outside_org_error_count),
                                "outside_org_error_count" => {
                                    Ok(__FieldTag::__outside_org_error_count)
                                }
                                "outsideOrgProjectNumbers" => {
                                    Ok(__FieldTag::__outside_org_project_numbers)
                                }
                                "outside_org_project_numbers" => {
                                    Ok(__FieldTag::__outside_org_project_numbers)
                                }
                                "nonManagementHubEntitledErrorCount" => {
                                    Ok(__FieldTag::__non_management_hub_entitled_error_count)
                                }
                                "non_management_hub_entitled_error_count" => {
                                    Ok(__FieldTag::__non_management_hub_entitled_error_count)
                                }
                                "nonManagementHubEntitledProjectNumbers" => {
                                    Ok(__FieldTag::__non_management_hub_entitled_project_numbers)
                                }
                                "non_management_hub_entitled_project_numbers" => {
                                    Ok(__FieldTag::__non_management_hub_entitled_project_numbers)
                                }
                                "nonStorageIntelligenceEntitledErrorCount" => {
                                    Ok(__FieldTag::__non_storage_intelligence_entitled_error_count)
                                }
                                "non_storage_intelligence_entitled_error_count" => {
                                    Ok(__FieldTag::__non_storage_intelligence_entitled_error_count)
                                }
                                "nonStorageIntelligenceEntitledProjectNumbers" => Ok(
                                    __FieldTag::__non_storage_intelligence_entitled_project_numbers,
                                ),
                                "non_storage_intelligence_entitled_project_numbers" => Ok(
                                    __FieldTag::__non_storage_intelligence_entitled_project_numbers,
                                ),
                                "internalErrorCount" => Ok(__FieldTag::__internal_error_count),
                                "internal_error_count" => Ok(__FieldTag::__internal_error_count),
                                "destinationProjectOrgError" => {
                                    Ok(__FieldTag::__destination_project_org_error)
                                }
                                "destination_project_org_error" => {
                                    Ok(__FieldTag::__destination_project_org_error)
                                }
                                "destinationProjectCheckHasInternalError" => {
                                    Ok(__FieldTag::__destination_project_check_has_internal_error)
                                }
                                "destination_project_check_has_internal_error" => {
                                    Ok(__FieldTag::__destination_project_check_has_internal_error)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ProjectErrors;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ProjectErrors")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__validated_count => {
                                if !fields.insert(__FieldTag::__validated_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for validated_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.validated_count = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__outside_org_error_count => {
                                if !fields.insert(__FieldTag::__outside_org_error_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for outside_org_error_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.outside_org_error_count = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__outside_org_project_numbers => {
                                if !fields.insert(__FieldTag::__outside_org_project_numbers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for outside_org_project_numbers",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i64>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.outside_org_project_numbers =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__non_management_hub_entitled_error_count => {
                                if !fields
                                    .insert(__FieldTag::__non_management_hub_entitled_error_count)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_management_hub_entitled_error_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.non_management_hub_entitled_error_count =
                                    map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__non_management_hub_entitled_project_numbers => {
                                if !fields.insert(
                                    __FieldTag::__non_management_hub_entitled_project_numbers,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_management_hub_entitled_project_numbers",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i64>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.non_management_hub_entitled_project_numbers =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__non_storage_intelligence_entitled_error_count => {
                                if !fields.insert(
                                    __FieldTag::__non_storage_intelligence_entitled_error_count,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_storage_intelligence_entitled_error_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.non_storage_intelligence_entitled_error_count =
                                    map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__non_storage_intelligence_entitled_project_numbers => {
                                if !fields.insert(
                                    __FieldTag::__non_storage_intelligence_entitled_project_numbers,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for non_storage_intelligence_entitled_project_numbers",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i64>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.non_storage_intelligence_entitled_project_numbers =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__internal_error_count => {
                                if !fields.insert(__FieldTag::__internal_error_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for internal_error_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.internal_error_count = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__destination_project_org_error => {
                                if !fields.insert(__FieldTag::__destination_project_org_error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for destination_project_org_error",
                                    ));
                                }
                                if result.destination_project_check_result.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `destination_project_check_result`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.ProjectErrors.destination_project_org_error, latest field was destinationProjectOrgError",
                                    ));
                                }
                                result.destination_project_check_result = std::option::Option::Some(
                                    crate::model::dataset_config::project_errors::DestinationProjectCheckResult::DestinationProjectOrgError(
                                        map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__destination_project_check_has_internal_error => {
                                if !fields.insert(
                                    __FieldTag::__destination_project_check_has_internal_error,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for destination_project_check_has_internal_error",
                                    ));
                                }
                                if result.destination_project_check_result.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `destination_project_check_result`, a oneof with full ID .google.cloud.storageinsights.v1.DatasetConfig.ProjectErrors.destination_project_check_has_internal_error, latest field was destinationProjectCheckHasInternalError",
                                    ));
                                }
                                result.destination_project_check_result = std::option::Option::Some(
                                    crate::model::dataset_config::project_errors::DestinationProjectCheckResult::DestinationProjectCheckHasInternalError(
                                        map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ProjectErrors {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.validated_count.is_some() {
                struct __With<'a>(&'a std::option::Option<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("validatedCount", &__With(&self.validated_count))?;
            }
            if self.outside_org_error_count.is_some() {
                struct __With<'a>(&'a std::option::Option<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "outsideOrgErrorCount",
                    &__With(&self.outside_org_error_count),
                )?;
            }
            if !self.outside_org_project_numbers.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "outsideOrgProjectNumbers",
                    &__With(&self.outside_org_project_numbers),
                )?;
            }
            if self.non_management_hub_entitled_error_count.is_some() {
                struct __With<'a>(&'a std::option::Option<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "nonManagementHubEntitledErrorCount",
                    &__With(&self.non_management_hub_entitled_error_count),
                )?;
            }
            if !self.non_management_hub_entitled_project_numbers.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "nonManagementHubEntitledProjectNumbers",
                    &__With(&self.non_management_hub_entitled_project_numbers),
                )?;
            }
            if self.non_storage_intelligence_entitled_error_count.is_some() {
                struct __With<'a>(&'a std::option::Option<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "nonStorageIntelligenceEntitledErrorCount",
                    &__With(&self.non_storage_intelligence_entitled_error_count),
                )?;
            }
            if !self
                .non_storage_intelligence_entitled_project_numbers
                .is_empty()
            {
                struct __With<'a>(&'a std::vec::Vec<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "nonStorageIntelligenceEntitledProjectNumbers",
                    &__With(&self.non_storage_intelligence_entitled_project_numbers),
                )?;
            }
            if self.internal_error_count.is_some() {
                struct __With<'a>(&'a std::option::Option<i64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("internalErrorCount", &__With(&self.internal_error_count))?;
            }
            if let Some(value) = self.destination_project_org_error() {
                state.serialize_entry("destinationProjectOrgError", value)?;
            }
            if let Some(value) = self.destination_project_check_has_internal_error() {
                state.serialize_entry("destinationProjectCheckHasInternalError", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ProjectErrors].
    pub mod project_errors {
        #[allow(unused_imports)]
        use super::*;

        /// The destination project check result. It indicates whether the project
        /// is in the correct organization or if an internal error occurred during
        /// the check.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DestinationProjectCheckResult {
            /// Optional. Indicates if the destination project resides within the same
            /// organization as the source project.
            DestinationProjectOrgError(bool),
            /// Optional. Indicates whether the destination project check failed due to
            /// an internal error. If `true`, the system automatically retries the
            /// check.
            DestinationProjectCheckHasInternalError(bool),
        }
    }

    /// Summary of validation errors that occurred during the verification phase.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ValidationErrorsBeforeIngestion {
        /// Optional. Provides a summary of the bucket level error stats.
        pub bucket_errors: std::option::Option<crate::model::dataset_config::BucketErrors>,

        /// Optional. Provides a summary of the project level error stats.
        pub project_errors: std::option::Option<crate::model::dataset_config::ProjectErrors>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ValidationErrorsBeforeIngestion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bucket_errors][crate::model::dataset_config::ValidationErrorsBeforeIngestion::bucket_errors].
        pub fn set_bucket_errors<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::dataset_config::BucketErrors>,
        {
            self.bucket_errors = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bucket_errors][crate::model::dataset_config::ValidationErrorsBeforeIngestion::bucket_errors].
        pub fn set_or_clear_bucket_errors<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::dataset_config::BucketErrors>,
        {
            self.bucket_errors = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project_errors][crate::model::dataset_config::ValidationErrorsBeforeIngestion::project_errors].
        pub fn set_project_errors<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::dataset_config::ProjectErrors>,
        {
            self.project_errors = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [project_errors][crate::model::dataset_config::ValidationErrorsBeforeIngestion::project_errors].
        pub fn set_or_clear_project_errors<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::dataset_config::ProjectErrors>,
        {
            self.project_errors = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ValidationErrorsBeforeIngestion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.storageinsights.v1.DatasetConfig.ValidationErrorsBeforeIngestion"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ValidationErrorsBeforeIngestion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bucket_errors,
                __project_errors,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ValidationErrorsBeforeIngestion")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bucketErrors" => Ok(__FieldTag::__bucket_errors),
                                "bucket_errors" => Ok(__FieldTag::__bucket_errors),
                                "projectErrors" => Ok(__FieldTag::__project_errors),
                                "project_errors" => Ok(__FieldTag::__project_errors),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ValidationErrorsBeforeIngestion;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ValidationErrorsBeforeIngestion")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bucket_errors => {
                                if !fields.insert(__FieldTag::__bucket_errors) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bucket_errors",
                                    ));
                                }
                                result.bucket_errors = map.next_value::<std::option::Option<
                                    crate::model::dataset_config::BucketErrors,
                                >>()?;
                            }
                            __FieldTag::__project_errors => {
                                if !fields.insert(__FieldTag::__project_errors) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_errors",
                                    ));
                                }
                                result.project_errors = map.next_value::<std::option::Option<
                                    crate::model::dataset_config::ProjectErrors,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ValidationErrorsBeforeIngestion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.bucket_errors.is_some() {
                state.serialize_entry("bucketErrors", &self.bucket_errors)?;
            }
            if self.project_errors.is_some() {
                state.serialize_entry("projectErrors", &self.project_errors)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// State of the configuration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConfigState {
        /// Unspecified state.
        Unspecified,
        /// Active configuration indicates that the configuration is
        /// actively ingesting data.
        Active,
        /// In this state, the configuration is being verified for various
        /// permissions.
        VerificationInProgress,
        /// Configuration is created and further processing needs to happen.
        Created,
        /// Configuration is under processing
        Processing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConfigState::value] or
        /// [ConfigState::name].
        UnknownValue(config_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod config_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConfigState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::VerificationInProgress => std::option::Option::Some(2),
                Self::Created => std::option::Option::Some(3),
                Self::Processing => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONFIG_STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("CONFIG_STATE_ACTIVE"),
                Self::VerificationInProgress => {
                    std::option::Option::Some("CONFIG_STATE_VERIFICATION_IN_PROGRESS")
                }
                Self::Created => std::option::Option::Some("CONFIG_STATE_CREATED"),
                Self::Processing => std::option::Option::Some("CONFIG_STATE_PROCESSING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConfigState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConfigState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConfigState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::VerificationInProgress,
                3 => Self::Created,
                4 => Self::Processing,
                _ => Self::UnknownValue(config_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConfigState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONFIG_STATE_UNSPECIFIED" => Self::Unspecified,
                "CONFIG_STATE_ACTIVE" => Self::Active,
                "CONFIG_STATE_VERIFICATION_IN_PROGRESS" => Self::VerificationInProgress,
                "CONFIG_STATE_CREATED" => Self::Created,
                "CONFIG_STATE_PROCESSING" => Self::Processing,
                _ => Self::UnknownValue(config_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConfigState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::VerificationInProgress => serializer.serialize_i32(2),
                Self::Created => serializer.serialize_i32(3),
                Self::Processing => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConfigState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConfigState>::new(
                ".google.cloud.storageinsights.v1.DatasetConfig.ConfigState",
            ))
        }
    }

    /// Defines the options for providing source identifiers for the dataset.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceOptions {
        /// Defines the options for providing source projects for the dataset.
        SourceProjects(std::boxed::Box<crate::model::dataset_config::SourceProjects>),
        /// Defines the options for providing source folders for the dataset.
        SourceFolders(std::boxed::Box<crate::model::dataset_config::SourceFolders>),
        /// Defines the options for providing a source organization for the dataset.
        OrganizationScope(bool),
        /// Input only. Cloud Storage object path containing a list of
        /// project or folder numbers to include in the dataset;
        /// it cannot contain a mix of project and folders.
        ///
        /// The object must be a text file where each line has one of the following
        /// entries:
        ///
        /// - Project number, formatted as `projects/{project_number}`, for example,
        ///   `projects/1234567890`.
        /// - Folder identifier, formatted as `folders/{folder_number}`, for example,
        ///   `folders/9876543210`.
        ///   Path must be in the format `gs://{bucket_name}/{object_name}`.
        CloudStorageObjectPath(std::string::String),
    }

    /// Cloud Storage locations to include or exclude.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudStorageLocationsOneOf {
        IncludeCloudStorageLocations(
            std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>,
        ),
        ExcludeCloudStorageLocations(
            std::boxed::Box<crate::model::dataset_config::CloudStorageLocations>,
        ),
    }

    /// Cloud Storage buckets to include or exclude.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CloudStorageBucketsOneOf {
        IncludeCloudStorageBuckets(
            std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>,
        ),
        ExcludeCloudStorageBuckets(
            std::boxed::Box<crate::model::dataset_config::CloudStorageBuckets>,
        ),
    }
}

/// Request message for
/// [`ListDatasetConfigs`][google.cloud.storageinsights.v1.StorageInsights.ListDatasetConfigs]
///
/// [google.cloud.storageinsights.v1.StorageInsights.ListDatasetConfigs]: crate::client::StorageInsights::list_dataset_configs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatasetConfigsRequest {
    /// Required. Parent value for ListDatasetConfigsRequest
    pub parent: std::string::String,

    /// Requested page size. Server might return fewer items than requested.
    /// If unspecified, server picks an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatasetConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatasetConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ListDatasetConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatasetConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatasetConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatasetConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatasetConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatasetConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [`ListDatasetConfigs`][google.cloud.storageinsights.v1.StorageInsights.ListDatasetConfigs]
///
/// [google.cloud.storageinsights.v1.StorageInsights.ListDatasetConfigs]: crate::client::StorageInsights::list_dataset_configs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatasetConfigsResponse {
    /// The list of `DatasetConfigs`
    pub dataset_configs: std::vec::Vec<crate::model::DatasetConfig>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatasetConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_configs][crate::model::ListDatasetConfigsResponse::dataset_configs].
    pub fn set_dataset_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatasetConfig>,
    {
        use std::iter::Iterator;
        self.dataset_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatasetConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatasetConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.ListDatasetConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatasetConfigsResponse {
    type PageItem = crate::model::DatasetConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.dataset_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatasetConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatasetConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetConfigs" => Ok(__FieldTag::__dataset_configs),
                            "dataset_configs" => Ok(__FieldTag::__dataset_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatasetConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatasetConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_configs => {
                            if !fields.insert(__FieldTag::__dataset_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_configs",
                                ));
                            }
                            result.dataset_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DatasetConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatasetConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset_configs.is_empty() {
            state.serialize_entry("datasetConfigs", &self.dataset_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [`GetDatasetConfig`][google.cloud.storageinsights.v1.StorageInsights.GetDatasetConfig]
///
/// [google.cloud.storageinsights.v1.StorageInsights.GetDatasetConfig]: crate::client::StorageInsights::get_dataset_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDatasetConfigRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatasetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.GetDatasetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDatasetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDatasetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDatasetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDatasetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDatasetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [`CreateDatasetConfig`][google.cloud.storageinsights.v1.StorageInsights.CreateDatasetConfig]
///
/// [google.cloud.storageinsights.v1.StorageInsights.CreateDatasetConfig]: crate::client::StorageInsights::create_dataset_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDatasetConfigRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    /// If auto-generating ID is enabled on the server-side, remove this field and
    /// `dataset_config_id` from the method_signature of Create RPC
    /// Note: The value should not contain any hyphens.
    pub dataset_config_id: std::string::String,

    /// Required. The resource being created
    pub dataset_config: std::option::Option<crate::model::DatasetConfig>,

    /// Optional. A unique identifier for your request.
    /// Specify the request ID if you need to retry the request.
    /// If you retry the request with the same ID within 60 minutes, the server
    /// ignores the request if it has already completed the original request.
    ///
    /// For example, if your initial request times out and you retry the request
    /// using the same request ID, the server recognizes the original request and
    /// does not process the new request.
    ///
    /// The request ID must be a valid UUID and cannot be a zero UUID
    /// (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatasetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset_config_id][crate::model::CreateDatasetConfigRequest::dataset_config_id].
    pub fn set_dataset_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset_config_id = v.into();
        self
    }

    /// Sets the value of [dataset_config][crate::model::CreateDatasetConfigRequest::dataset_config].
    pub fn set_dataset_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetConfig>,
    {
        self.dataset_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset_config][crate::model::CreateDatasetConfigRequest::dataset_config].
    pub fn set_or_clear_dataset_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetConfig>,
    {
        self.dataset_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDatasetConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.CreateDatasetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDatasetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dataset_config_id,
            __dataset_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDatasetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "datasetConfigId" => Ok(__FieldTag::__dataset_config_id),
                            "dataset_config_id" => Ok(__FieldTag::__dataset_config_id),
                            "datasetConfig" => Ok(__FieldTag::__dataset_config),
                            "dataset_config" => Ok(__FieldTag::__dataset_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDatasetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDatasetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_config_id => {
                            if !fields.insert(__FieldTag::__dataset_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_config_id",
                                ));
                            }
                            result.dataset_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_config => {
                            if !fields.insert(__FieldTag::__dataset_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_config",
                                ));
                            }
                            result.dataset_config = map
                                .next_value::<std::option::Option<crate::model::DatasetConfig>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDatasetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.dataset_config_id.is_empty() {
            state.serialize_entry("datasetConfigId", &self.dataset_config_id)?;
        }
        if self.dataset_config.is_some() {
            state.serialize_entry("datasetConfig", &self.dataset_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [`UpdateDatasetConfig`][google.cloud.storageinsights.v1.StorageInsights.UpdateDatasetConfig]
///
/// [google.cloud.storageinsights.v1.StorageInsights.UpdateDatasetConfig]: crate::client::StorageInsights::update_dataset_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDatasetConfigRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// `DatasetConfig` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field is overwritten if it is in the mask. If the
    /// user does not provide a mask then it returns an "Invalid Argument" error.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub dataset_config: std::option::Option<crate::model::DatasetConfig>,

    /// Optional. A unique identifier for your request.
    /// Specify the request ID if you need to retry the request.
    /// If you retry the request with the same ID within 60 minutes, the server
    /// ignores the request if it has already completed the original request.
    ///
    /// For example, if your initial request times out and you retry the request
    /// using the same request ID, the server recognizes the original request and
    /// does not process the new request.
    ///
    /// The request ID must be a valid UUID and cannot be a zero UUID
    /// (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDatasetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatasetConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDatasetConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dataset_config][crate::model::UpdateDatasetConfigRequest::dataset_config].
    pub fn set_dataset_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetConfig>,
    {
        self.dataset_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset_config][crate::model::UpdateDatasetConfigRequest::dataset_config].
    pub fn set_or_clear_dataset_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetConfig>,
    {
        self.dataset_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDatasetConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDatasetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.UpdateDatasetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDatasetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __dataset_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDatasetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "datasetConfig" => Ok(__FieldTag::__dataset_config),
                            "dataset_config" => Ok(__FieldTag::__dataset_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDatasetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDatasetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__dataset_config => {
                            if !fields.insert(__FieldTag::__dataset_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_config",
                                ));
                            }
                            result.dataset_config = map
                                .next_value::<std::option::Option<crate::model::DatasetConfig>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDatasetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.dataset_config.is_some() {
            state.serialize_entry("datasetConfig", &self.dataset_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [`DeleteDatasetConfig`][google.cloud.storageinsights.v1.StorageInsights.DeleteDatasetConfig]
///
/// [google.cloud.storageinsights.v1.StorageInsights.DeleteDatasetConfig]: crate::client::StorageInsights::delete_dataset_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatasetConfigRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    /// Optional. A unique identifier for your request.
    /// Specify the request ID if you need to retry the request.
    /// If you retry the request with the same ID within 60 minutes, the server
    /// ignores the request if it has already completed the original request.
    ///
    /// For example, if your initial request times out and you retry the request
    /// using the same request ID, the server recognizes the original request and
    /// does not process the new request.
    ///
    /// The request ID must be a valid UUID and cannot be a zero UUID
    /// (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatasetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDatasetConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.DeleteDatasetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatasetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatasetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatasetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatasetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatasetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [`LinkDataset`][google.cloud.storageinsights.v1.StorageInsights.LinkDataset]
///
/// [google.cloud.storageinsights.v1.StorageInsights.LinkDataset]: crate::client::StorageInsights::link_dataset
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LinkDatasetRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LinkDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for LinkDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.LinkDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LinkDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LinkDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LinkDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [`LinkDataset`][google.cloud.storageinsights.v1.StorageInsights.LinkDataset]
///
/// [google.cloud.storageinsights.v1.StorageInsights.LinkDataset]: crate::client::StorageInsights::link_dataset
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LinkDatasetResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkDatasetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for LinkDatasetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.LinkDatasetResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LinkDatasetResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinkDatasetResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LinkDatasetResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinkDatasetResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LinkDatasetResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [`UnlinkDataset`][google.cloud.storageinsights.v1.StorageInsights.UnlinkDataset]
///
/// [google.cloud.storageinsights.v1.StorageInsights.UnlinkDataset]: crate::client::StorageInsights::unlink_dataset
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UnlinkDatasetRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnlinkDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UnlinkDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UnlinkDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.UnlinkDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UnlinkDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnlinkDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UnlinkDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnlinkDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UnlinkDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata that helps discover which resources are available in a location.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// If true, `storageinsights.googleapis.com/ReportConfig` resource is
    /// available at the location.
    pub report_config_available: bool,

    /// If true, `storageinsights.googleapis.com/DatasetConfig` resource is
    /// available at the location.
    pub dataset_config_available: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_config_available][crate::model::LocationMetadata::report_config_available].
    pub fn set_report_config_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.report_config_available = v.into();
        self
    }

    /// Sets the value of [dataset_config_available][crate::model::LocationMetadata::dataset_config_available].
    pub fn set_dataset_config_available<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dataset_config_available = v.into();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.storageinsights.v1.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __report_config_available,
            __dataset_config_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reportConfigAvailable" => Ok(__FieldTag::__report_config_available),
                            "report_config_available" => Ok(__FieldTag::__report_config_available),
                            "datasetConfigAvailable" => Ok(__FieldTag::__dataset_config_available),
                            "dataset_config_available" => {
                                Ok(__FieldTag::__dataset_config_available)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__report_config_available => {
                            if !fields.insert(__FieldTag::__report_config_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_config_available",
                                ));
                            }
                            result.report_config_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_config_available => {
                            if !fields.insert(__FieldTag::__dataset_config_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_config_available",
                                ));
                            }
                            result.dataset_config_available = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.report_config_available) {
            state.serialize_entry("reportConfigAvailable", &self.report_config_available)?;
        }
        if !wkt::internal::is_default(&self.dataset_config_available) {
            state.serialize_entry("datasetConfigAvailable", &self.dataset_config_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
