// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gclient;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An Adaptive MT Dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdaptiveMtDataset {
    /// Required. The resource name of the dataset, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the dataset to show in the interface. The name can be
    /// up to 32 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z, underscores (_), and ASCII digits 0-9.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The BCP-47 language code of the source language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,

    /// The BCP-47 language code of the target language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language_code: std::string::String,

    /// The number of examples in the dataset.
    pub example_count: i32,

    /// Output only. Timestamp when this dataset was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this dataset was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl AdaptiveMtDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdaptiveMtDataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AdaptiveMtDataset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::AdaptiveMtDataset::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::AdaptiveMtDataset::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [example_count][crate::model::AdaptiveMtDataset::example_count].
    pub fn set_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.example_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AdaptiveMtDataset::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AdaptiveMtDataset::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for AdaptiveMtDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtDataset"
    }
}

/// Â Request message for creating an AdaptiveMtDataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAdaptiveMtDatasetRequest {
    /// Required. Name of the parent project. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The AdaptiveMtDataset to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub adaptive_mt_dataset: std::option::Option<crate::model::AdaptiveMtDataset>,
}

impl CreateAdaptiveMtDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAdaptiveMtDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [adaptive_mt_dataset][crate::model::CreateAdaptiveMtDatasetRequest::adaptive_mt_dataset].
    pub fn set_adaptive_mt_dataset<
        T: std::convert::Into<std::option::Option<crate::model::AdaptiveMtDataset>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.adaptive_mt_dataset = v.into();
        self
    }
}

impl wkt::message::Message for CreateAdaptiveMtDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateAdaptiveMtDatasetRequest"
    }
}

/// Request message for deleting an AdaptiveMtDataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAdaptiveMtDatasetRequest {
    /// Required. Name of the dataset. In the form of
    /// `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteAdaptiveMtDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAdaptiveMtDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAdaptiveMtDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteAdaptiveMtDatasetRequest"
    }
}

/// Request message for getting an Adaptive MT dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAdaptiveMtDatasetRequest {
    /// Required. Name of the dataset. In the form of
    /// `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAdaptiveMtDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAdaptiveMtDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAdaptiveMtDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetAdaptiveMtDatasetRequest"
    }
}

/// Request message for listing all Adaptive MT datasets that the requestor has
/// access to.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAdaptiveMtDatasetsRequest {
    /// Required. The resource name of the project from which to list the Adaptive
    /// MT datasets. `projects/{project-number-or-id}/locations/{location-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer results than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// ListAdaptiveMtDatasetsResponse.next_page_token returned from the
    /// previous call to `ListAdaptiveMtDatasets` method. The first page is
    /// returned if `page_token`is empty or missing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    /// Filter is not supported yet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListAdaptiveMtDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAdaptiveMtDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAdaptiveMtDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAdaptiveMtDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAdaptiveMtDatasetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtDatasetsRequest"
    }
}

/// A list of AdaptiveMtDatasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAdaptiveMtDatasetsResponse {
    /// Output only. A list of Adaptive MT datasets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub adaptive_mt_datasets: std::vec::Vec<crate::model::AdaptiveMtDataset>,

    /// Optional. A token to retrieve a page of results. Pass this value in the
    /// [ListAdaptiveMtDatasetsRequest.page_token] field in the subsequent call to
    /// `ListAdaptiveMtDatasets` method to retrieve the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAdaptiveMtDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAdaptiveMtDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [adaptive_mt_datasets][crate::model::ListAdaptiveMtDatasetsResponse::adaptive_mt_datasets].
    pub fn set_adaptive_mt_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtDataset>,
    {
        use std::iter::Iterator;
        self.adaptive_mt_datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtDatasetsResponse"
    }
}

impl gax::paginator::PageableResponse for ListAdaptiveMtDatasetsResponse {
    type PageItem = crate::model::AdaptiveMtDataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.adaptive_mt_datasets
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for sending an AdaptiveMt translation query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdaptiveMtTranslateRequest {
    /// Required. Location to make a regional call.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource name for the dataset to use for adaptive MT.
    /// `projects/{project}/locations/{location-id}/adaptiveMtDatasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Required. The content of the input in string format.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content: std::vec::Vec<std::string::String>,

    /// Configuration for caller provided reference sentences.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference_sentence_config:
        std::option::Option<crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig>,

    /// Optional. Glossary to be applied. The glossary must be
    /// within the same region (have the same location-id) as the model, otherwise
    /// an INVALID_ARGUMENT (400) error is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_config:
        std::option::Option<crate::model::adaptive_mt_translate_request::GlossaryConfig>,
}

impl AdaptiveMtTranslateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AdaptiveMtTranslateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::AdaptiveMtTranslateRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [reference_sentence_config][crate::model::AdaptiveMtTranslateRequest::reference_sentence_config].
    pub fn set_reference_sentence_config<
        T: std::convert::Into<
            std::option::Option<
                crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reference_sentence_config = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::AdaptiveMtTranslateRequest::glossary_config].
    pub fn set_glossary_config<
        T: std::convert::Into<
            std::option::Option<crate::model::adaptive_mt_translate_request::GlossaryConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_config = v.into();
        self
    }

    /// Sets the value of [content][crate::model::AdaptiveMtTranslateRequest::content].
    pub fn set_content<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.content = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdaptiveMtTranslateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest"
    }
}

/// Defines additional types related to AdaptiveMtTranslateRequest
pub mod adaptive_mt_translate_request {
    #[allow(unused_imports)]
    use super::*;

    /// A pair of sentences used as reference in source and target languages.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReferenceSentencePair {
        /// Source sentence in the sentence pair.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_sentence: std::string::String,

        /// Target sentence in the sentence pair.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub target_sentence: std::string::String,
    }

    impl ReferenceSentencePair {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_sentence][crate::model::adaptive_mt_translate_request::ReferenceSentencePair::source_sentence].
        pub fn set_source_sentence<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_sentence = v.into();
            self
        }

        /// Sets the value of [target_sentence][crate::model::adaptive_mt_translate_request::ReferenceSentencePair::target_sentence].
        pub fn set_target_sentence<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_sentence = v.into();
            self
        }
    }

    impl wkt::message::Message for ReferenceSentencePair {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.ReferenceSentencePair"
        }
    }

    /// A list of reference sentence pairs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReferenceSentencePairList {
        /// Reference sentence pairs.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub reference_sentence_pairs:
            std::vec::Vec<crate::model::adaptive_mt_translate_request::ReferenceSentencePair>,
    }

    impl ReferenceSentencePairList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reference_sentence_pairs][crate::model::adaptive_mt_translate_request::ReferenceSentencePairList::reference_sentence_pairs].
        pub fn set_reference_sentence_pairs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::adaptive_mt_translate_request::ReferenceSentencePair,
            >,
        {
            use std::iter::Iterator;
            self.reference_sentence_pairs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ReferenceSentencePairList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.ReferenceSentencePairList"
        }
    }

    /// Message of caller-provided reference configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReferenceSentenceConfig {
        /// Reference sentences pair lists. Each list will be used as the references
        /// to translate the sentence under "content" field at the corresponding
        /// index. Length of the list is required to be equal to the length of
        /// "content" field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub reference_sentence_pair_lists:
            std::vec::Vec<crate::model::adaptive_mt_translate_request::ReferenceSentencePairList>,

        /// Source language code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_language_code: std::string::String,

        /// Target language code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub target_language_code: std::string::String,
    }

    impl ReferenceSentenceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_language_code][crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig::source_language_code].
        pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_language_code = v.into();
            self
        }

        /// Sets the value of [target_language_code][crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig::target_language_code].
        pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_language_code = v.into();
            self
        }

        /// Sets the value of [reference_sentence_pair_lists][crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig::reference_sentence_pair_lists].
        pub fn set_reference_sentence_pair_lists<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::adaptive_mt_translate_request::ReferenceSentencePairList,
            >,
        {
            use std::iter::Iterator;
            self.reference_sentence_pair_lists = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ReferenceSentenceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.ReferenceSentenceConfig"
        }
    }

    /// Configures which glossary is used for a specific target language and
    /// defines
    /// options for applying that glossary.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GlossaryConfig {
        /// Required. The `glossary` to be applied for this translation.
        ///
        /// The format depends on the glossary:
        ///
        /// - User-provided custom glossary:
        ///   `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub glossary: std::string::String,

        /// Optional. Indicates match is case insensitive. The default value is
        /// `false` if missing.
        pub ignore_case: bool,

        /// Optional. If set to true, the glossary will be used for contextual
        /// translation.
        pub contextual_translation_enabled: bool,
    }

    impl GlossaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [glossary][crate::model::adaptive_mt_translate_request::GlossaryConfig::glossary].
        pub fn set_glossary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.glossary = v.into();
            self
        }

        /// Sets the value of [ignore_case][crate::model::adaptive_mt_translate_request::GlossaryConfig::ignore_case].
        pub fn set_ignore_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.ignore_case = v.into();
            self
        }

        /// Sets the value of [contextual_translation_enabled][crate::model::adaptive_mt_translate_request::GlossaryConfig::contextual_translation_enabled].
        pub fn set_contextual_translation_enabled<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.contextual_translation_enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for GlossaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.GlossaryConfig"
        }
    }
}

/// An AdaptiveMt translation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdaptiveMtTranslation {
    /// Output only. The translated text.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub translated_text: std::string::String,
}

impl AdaptiveMtTranslation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translated_text][crate::model::AdaptiveMtTranslation::translated_text].
    pub fn set_translated_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.translated_text = v.into();
        self
    }
}

impl wkt::message::Message for AdaptiveMtTranslation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslation"
    }
}

/// An AdaptiveMtTranslate response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdaptiveMtTranslateResponse {
    /// Output only. The translation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub translations: std::vec::Vec<crate::model::AdaptiveMtTranslation>,

    /// Output only. The translation's language code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Text translation response if a glossary is provided in the request. This
    /// could be the same as 'translation' above if no terms apply.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub glossary_translations: std::vec::Vec<crate::model::AdaptiveMtTranslation>,
}

impl AdaptiveMtTranslateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::AdaptiveMtTranslateResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [translations][crate::model::AdaptiveMtTranslateResponse::translations].
    pub fn set_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtTranslation>,
    {
        use std::iter::Iterator;
        self.translations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [glossary_translations][crate::model::AdaptiveMtTranslateResponse::glossary_translations].
    pub fn set_glossary_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtTranslation>,
    {
        use std::iter::Iterator;
        self.glossary_translations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdaptiveMtTranslateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateResponse"
    }
}

/// An AdaptiveMtFile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdaptiveMtFile {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The file's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The number of entries that the file contains.
    pub entry_count: i32,

    /// Output only. Timestamp when this file was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this file was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl AdaptiveMtFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdaptiveMtFile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AdaptiveMtFile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::AdaptiveMtFile::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AdaptiveMtFile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AdaptiveMtFile::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for AdaptiveMtFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtFile"
    }
}

/// The request for getting an AdaptiveMtFile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAdaptiveMtFileRequest {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAdaptiveMtFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAdaptiveMtFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAdaptiveMtFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetAdaptiveMtFileRequest"
    }
}

/// The request for deleting an AdaptiveMt file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAdaptiveMtFileRequest {
    /// Required. The resource name of the file to delete, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteAdaptiveMtFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAdaptiveMtFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAdaptiveMtFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteAdaptiveMtFileRequest"
    }
}

/// The request for importing an AdaptiveMt file along with its sentences.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAdaptiveMtFileRequest {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The source for the document.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_adaptive_mt_file_request::Source>,
}

impl ImportAdaptiveMtFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportAdaptiveMtFileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<
            std::option::Option<crate::model::import_adaptive_mt_file_request::Source>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// if it holds a `FileInputSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_file_input_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileInputSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_adaptive_mt_file_request::Source::FileInputSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// if it holds a `GcsInputSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_input_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsInputSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_adaptive_mt_file_request::Source::GcsInputSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// to hold a `FileInputSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_file_input_source<
        T: std::convert::Into<std::boxed::Box<crate::model::FileInputSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_adaptive_mt_file_request::Source::FileInputSource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// to hold a `GcsInputSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_input_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsInputSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_adaptive_mt_file_request::Source::GcsInputSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportAdaptiveMtFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportAdaptiveMtFileRequest"
    }
}

/// Defines additional types related to ImportAdaptiveMtFileRequest
pub mod import_adaptive_mt_file_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source for the document.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Inline file source.
        FileInputSource(std::boxed::Box<crate::model::FileInputSource>),
        /// Google Cloud Storage file source.
        GcsInputSource(std::boxed::Box<crate::model::GcsInputSource>),
    }
}

/// The response for importing an AdaptiveMtFile
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportAdaptiveMtFileResponse {
    /// Output only. The Adaptive MT file that was imported.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub adaptive_mt_file: std::option::Option<crate::model::AdaptiveMtFile>,
}

impl ImportAdaptiveMtFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adaptive_mt_file][crate::model::ImportAdaptiveMtFileResponse::adaptive_mt_file].
    pub fn set_adaptive_mt_file<
        T: std::convert::Into<std::option::Option<crate::model::AdaptiveMtFile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.adaptive_mt_file = v.into();
        self
    }
}

impl wkt::message::Message for ImportAdaptiveMtFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportAdaptiveMtFileResponse"
    }
}

/// The request to list all AdaptiveMt files under a given dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAdaptiveMtFilesRequest {
    /// Required. The resource name of the project from which to list the Adaptive
    /// MT files.
    /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// ListAdaptiveMtFilesResponse.next_page_token returned from the
    /// previous call to `ListAdaptiveMtFiles` method. The first page is
    /// returned if `page_token`is empty or missing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAdaptiveMtFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAdaptiveMtFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAdaptiveMtFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAdaptiveMtFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtFilesRequest"
    }
}

/// The response for listing all AdaptiveMt files under a given dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAdaptiveMtFilesResponse {
    /// Output only. The Adaptive MT files.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub adaptive_mt_files: std::vec::Vec<crate::model::AdaptiveMtFile>,

    /// Optional. A token to retrieve a page of results. Pass this value in the
    /// ListAdaptiveMtFilesRequest.page_token field in the subsequent call to
    /// `ListAdaptiveMtFiles` method to retrieve the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAdaptiveMtFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAdaptiveMtFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [adaptive_mt_files][crate::model::ListAdaptiveMtFilesResponse::adaptive_mt_files].
    pub fn set_adaptive_mt_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtFile>,
    {
        use std::iter::Iterator;
        self.adaptive_mt_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtFilesResponse"
    }
}

impl gax::paginator::PageableResponse for ListAdaptiveMtFilesResponse {
    type PageItem = crate::model::AdaptiveMtFile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.adaptive_mt_files
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// An AdaptiveMt sentence entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdaptiveMtSentence {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}/adaptiveMtSentences/{sentence}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The source sentence.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_sentence: std::string::String,

    /// Required. The target sentence.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_sentence: std::string::String,

    /// Output only. Timestamp when this sentence was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this sentence was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl AdaptiveMtSentence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdaptiveMtSentence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_sentence][crate::model::AdaptiveMtSentence::source_sentence].
    pub fn set_source_sentence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_sentence = v.into();
        self
    }

    /// Sets the value of [target_sentence][crate::model::AdaptiveMtSentence::target_sentence].
    pub fn set_target_sentence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_sentence = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AdaptiveMtSentence::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AdaptiveMtSentence::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for AdaptiveMtSentence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtSentence"
    }
}

/// The request for listing Adaptive MT sentences from a Dataset/File.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAdaptiveMtSentencesRequest {
    /// Required. The resource name of the project from which to list the Adaptive
    /// MT files. The following format lists all sentences under a file.
    /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    /// The following format lists all sentences within a dataset.
    /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// ListAdaptiveMtSentencesRequest.next_page_token returned from the
    /// previous call to `ListTranslationMemories` method. The first page is
    /// returned if `page_token` is empty or missing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAdaptiveMtSentencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAdaptiveMtSentencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAdaptiveMtSentencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAdaptiveMtSentencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtSentencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtSentencesRequest"
    }
}

/// List AdaptiveMt sentences response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAdaptiveMtSentencesResponse {
    /// Output only. The list of AdaptiveMtSentences.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub adaptive_mt_sentences: std::vec::Vec<crate::model::AdaptiveMtSentence>,

    /// Optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAdaptiveMtSentencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListAdaptiveMtSentencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [adaptive_mt_sentences][crate::model::ListAdaptiveMtSentencesResponse::adaptive_mt_sentences].
    pub fn set_adaptive_mt_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtSentence>,
    {
        use std::iter::Iterator;
        self.adaptive_mt_sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtSentencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtSentencesResponse"
    }
}

impl gax::paginator::PageableResponse for ListAdaptiveMtSentencesResponse {
    type PageItem = crate::model::AdaptiveMtSentence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.adaptive_mt_sentences
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for ImportData.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataRequest {
    /// Required. Name of the dataset. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Required. The config for the input content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::DatasetInputConfig>,
}

impl ImportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::ImportDataRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportDataRequest::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::DatasetInputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }
}

impl wkt::message::Message for ImportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportDataRequest"
    }
}

/// Input configuration for datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetInputConfig {
    /// Files containing the sentence pairs to be imported to the dataset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub input_files: std::vec::Vec<crate::model::dataset_input_config::InputFile>,
}

impl DatasetInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_files][crate::model::DatasetInputConfig::input_files].
    pub fn set_input_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dataset_input_config::InputFile>,
    {
        use std::iter::Iterator;
        self.input_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatasetInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DatasetInputConfig"
    }
}

/// Defines additional types related to DatasetInputConfig
pub mod dataset_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// An input file.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InputFile {
        /// Optional. Usage of the file contents. Options are TRAIN|VALIDATION|TEST,
        /// or UNASSIGNED (by default) for auto split.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub usage: std::string::String,

        /// Source of the file containing sentence pairs.
        /// Supported formats are tab-separated values (.tsv) and Translation Memory
        /// eXchange (.tmx) .
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<crate::model::dataset_input_config::input_file::Source>,
    }

    impl InputFile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [usage][crate::model::dataset_input_config::InputFile::usage].
        pub fn set_usage<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.usage = v.into();
            self
        }

        /// Sets the value of `source`.
        pub fn set_source<
            T: std::convert::Into<
                std::option::Option<crate::model::dataset_input_config::input_file::Source>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::dataset_input_config::InputFile::source]
        /// if it holds a `GcsSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_gcs_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GcsInputSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::dataset_input_config::input_file::Source::GcsSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::dataset_input_config::InputFile::source]
        /// to hold a `GcsSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_gcs_source<
            T: std::convert::Into<std::boxed::Box<crate::model::GcsInputSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::dataset_input_config::input_file::Source::GcsSource(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for InputFile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.DatasetInputConfig.InputFile"
        }
    }

    /// Defines additional types related to InputFile
    pub mod input_file {
        #[allow(unused_imports)]
        use super::*;

        /// Source of the file containing sentence pairs.
        /// Supported formats are tab-separated values (.tsv) and Translation Memory
        /// eXchange (.tmx) .
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// Google Cloud Storage file source.
            GcsSource(std::boxed::Box<crate::model::GcsInputSource>),
        }
    }
}

/// Metadata of import data operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDataMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,
}

impl ImportDataMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ImportDataMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportDataMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ImportDataMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ImportDataMetadata::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for ImportDataMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportDataMetadata"
    }
}

/// Request message for ExportData.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataRequest {
    /// Required. Name of the dataset. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Required. The config for the output content.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::DatasetOutputConfig>,
}

impl ExportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::ExportDataRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::ExportDataRequest::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::DatasetOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }
}

impl wkt::message::Message for ExportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ExportDataRequest"
    }
}

/// Output configuration for datasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatasetOutputConfig {
    /// Required. Specify the output.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::dataset_output_config::Destination>,
}

impl DatasetOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::dataset_output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::DatasetOutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsOutputDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::dataset_output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::DatasetOutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsOutputDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::dataset_output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatasetOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DatasetOutputConfig"
    }
}

/// Defines additional types related to DatasetOutputConfig
pub mod dataset_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify the output.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage destination to write the output.
        GcsDestination(std::boxed::Box<crate::model::GcsOutputDestination>),
    }
}

/// Metadata of export data operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportDataMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,
}

impl ExportDataMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ExportDataMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ExportDataMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ExportDataMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ExportDataMetadata::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for ExportDataMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ExportDataMetadata"
    }
}

/// Request message for DeleteDataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetRequest {
    /// Required. The name of the dataset to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteDatasetRequest"
    }
}

/// Metadata of delete dataset operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,
}

impl DeleteDatasetMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::DeleteDatasetMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteDatasetMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteDatasetMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::DeleteDatasetMetadata::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteDatasetMetadata"
    }
}

/// Request message for GetDataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatasetRequest {
    /// Required. The resource name of the dataset to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetDatasetRequest"
    }
}

/// Request message for ListDatasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsRequest {
    /// Required. Name of the parent project. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. The server can return fewer results than
    /// requested.
    pub page_size: i32,

    /// Optional. A token identifying a page of results for the server to return.
    /// Typically obtained from next_page_token field in the response of a
    /// ListDatasets call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListDatasetsRequest"
    }
}

/// Response message for ListDatasets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsResponse {
    /// The datasets read.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<crate::model::Dataset>,

    /// A token to retrieve next page of results.
    /// Pass this token to the page_token field in the ListDatasetsRequest to
    /// obtain the corresponding page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::ListDatasetsResponse::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListDatasetsResponse"
    }
}

impl gax::paginator::PageableResponse for ListDatasetsResponse {
    type PageItem = crate::model::Dataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for CreateDataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetRequest {
    /// Required. The project name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Dataset to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,
}

impl CreateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateDatasetRequest"
    }
}

/// Metadata of create dataset operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,
}

impl CreateDatasetMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::CreateDatasetMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateDatasetMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CreateDatasetMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::CreateDatasetMetadata::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateDatasetMetadata"
    }
}

/// Request message for ListExamples.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExamplesRequest {
    /// Required. Name of the parent dataset. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the examples that will be returned.
    /// Example filter:
    ///
    /// * `usage=TRAIN`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Requested page size. The server can return fewer results than
    /// requested.
    pub page_size: i32,

    /// Optional. A token identifying a page of results for the server to return.
    /// Typically obtained from next_page_token field in the response of a
    /// ListExamples call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListExamplesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExamplesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExamplesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExamplesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExamplesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExamplesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListExamplesRequest"
    }
}

/// Response message for ListExamples.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListExamplesResponse {
    /// The sentence pairs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub examples: std::vec::Vec<crate::model::Example>,

    /// A token to retrieve next page of results.
    /// Pass this token to the page_token field in the ListExamplesRequest to
    /// obtain the corresponding page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListExamplesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListExamplesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [examples][crate::model::ListExamplesResponse::examples].
    pub fn set_examples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Example>,
    {
        use std::iter::Iterator;
        self.examples = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListExamplesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListExamplesResponse"
    }
}

impl gax::paginator::PageableResponse for ListExamplesResponse {
    type PageItem = crate::model::Example;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.examples
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// A sentence pair.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Example {
    /// Output only. The resource name of the example, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}/examples/{example_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Sentence in source language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_text: std::string::String,

    /// Sentence in target language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_text: std::string::String,

    /// Output only. Usage of the sentence pair. Options are TRAIN|VALIDATION|TEST.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub usage: std::string::String,
}

impl Example {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Example::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_text][crate::model::Example::source_text].
    pub fn set_source_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_text = v.into();
        self
    }

    /// Sets the value of [target_text][crate::model::Example::target_text].
    pub fn set_target_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_text = v.into();
        self
    }

    /// Sets the value of [usage][crate::model::Example::usage].
    pub fn set_usage<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.usage = v.into();
        self
    }
}

impl wkt::message::Message for Example {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Example"
    }
}

/// Response message for BatchTransferResources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchTransferResourcesResponse {
    /// Responses of the transfer for individual resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses:
        std::vec::Vec<crate::model::batch_transfer_resources_response::TransferResourceResponse>,
}

impl BatchTransferResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::BatchTransferResourcesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
            crate::model::batch_transfer_resources_response::TransferResourceResponse,
        >,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchTransferResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTransferResourcesResponse"
    }
}

/// Defines additional types related to BatchTransferResourcesResponse
pub mod batch_transfer_resources_response {
    #[allow(unused_imports)]
    use super::*;

    /// Transfer response for a single resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TransferResourceResponse {
        /// Full name of the resource to transfer as specified in the request.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source: std::string::String,

        /// Full name of the new resource successfully transferred from the source
        /// hosted by Translation API. Target will be empty if the transfer failed.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub target: std::string::String,

        /// The error result in case of failure.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub error: std::option::Option<rpc::model::Status>,
    }

    impl TransferResourceResponse {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::batch_transfer_resources_response::TransferResourceResponse::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [target][crate::model::batch_transfer_resources_response::TransferResourceResponse::target].
        pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.target = v.into();
            self
        }

        /// Sets the value of [error][crate::model::batch_transfer_resources_response::TransferResourceResponse::error].
        pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for TransferResourceResponse {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.BatchTransferResourcesResponse.TransferResourceResponse"
        }
    }
}

/// A dataset that hosts the examples (sentence pairs) used for translation
/// models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dataset {
    /// The resource name of the dataset, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the dataset to show in the interface. The name can be
    /// up to 32 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z, underscores (_), and ASCII digits 0-9.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The BCP-47 language code of the source language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,

    /// The BCP-47 language code of the target language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language_code: std::string::String,

    /// Output only. The number of examples in the dataset.
    pub example_count: i32,

    /// Output only. Number of training examples (sentence pairs).
    pub train_example_count: i32,

    /// Output only. Number of validation examples (sentence pairs).
    pub validate_example_count: i32,

    /// Output only. Number of test examples (sentence pairs).
    pub test_example_count: i32,

    /// Output only. Timestamp when this dataset was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this dataset was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl Dataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Dataset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::Dataset::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::Dataset::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [example_count][crate::model::Dataset::example_count].
    pub fn set_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.example_count = v.into();
        self
    }

    /// Sets the value of [train_example_count][crate::model::Dataset::train_example_count].
    pub fn set_train_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.train_example_count = v.into();
        self
    }

    /// Sets the value of [validate_example_count][crate::model::Dataset::validate_example_count].
    pub fn set_validate_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.validate_example_count = v.into();
        self
    }

    /// Sets the value of [test_example_count][crate::model::Dataset::test_example_count].
    pub fn set_test_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.test_example_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Dataset::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Dataset::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for Dataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Dataset"
    }
}

/// Request message for CreateModel.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateModelRequest {
    /// Required. The project name, in form of
    /// `projects/{project}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Model to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,
}

impl CreateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CreateModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for CreateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateModelRequest"
    }
}

/// Metadata of create model operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateModelMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,
}

impl CreateModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::CreateModelMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CreateModelMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::CreateModelMetadata::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for CreateModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateModelMetadata"
    }
}

/// Request message for ListModels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. Name of the parent project. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An expression for filtering the models that will be returned.
    /// Supported filter:
    /// `dataset_id=${dataset_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Requested page size. The server can return fewer results than
    /// requested.
    pub page_size: i32,

    /// Optional. A token identifying a page of results for the server to return.
    /// Typically obtained from next_page_token field in the response of a
    /// ListModels call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListModelsRequest"
    }
}

/// Response message for ListModels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// The models read.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to retrieve next page of results.
    /// Pass this token to the page_token field in the ListModelsRequest to
    /// obtain the corresponding page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListModelsResponse"
    }
}

impl gax::paginator::PageableResponse for ListModelsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for GetModel.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. The resource name of the model to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetModelRequest"
    }
}

/// Request message for DeleteModel.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. The name of the model to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteModelRequest"
    }
}

/// Metadata of delete model operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,
}

impl DeleteModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::DeleteModelMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteModelMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteModelMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [error][crate::model::DeleteModelMetadata::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteModelMetadata"
    }
}

/// A trained translation model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Model {
    /// The resource name of the model, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/models/{model_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the model to show in the interface. The name can be
    /// up to 32 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z, underscores (_), and ASCII digits 0-9.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The dataset from which the model is trained, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Output only. The BCP-47 language code of the source language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,

    /// Output only. The BCP-47 language code of the target language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language_code: std::string::String,

    /// Output only. Number of examples (sentence pairs) used to train the model.
    pub train_example_count: i32,

    /// Output only. Number of examples (sentence pairs) used to validate the
    /// model.
    pub validate_example_count: i32,

    /// Output only. Number of examples (sentence pairs) used to test the model.
    pub test_example_count: i32,

    /// Output only. Timestamp when the model resource was created, which is also
    /// when the training started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this model was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,
}

impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Model::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Model::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::Model::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::Model::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::Model::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [train_example_count][crate::model::Model::train_example_count].
    pub fn set_train_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.train_example_count = v.into();
        self
    }

    /// Sets the value of [validate_example_count][crate::model::Model::validate_example_count].
    pub fn set_validate_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.validate_example_count = v.into();
        self
    }

    /// Sets the value of [test_example_count][crate::model::Model::test_example_count].
    pub fn set_test_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.test_example_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Model::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Model::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Model"
    }
}

/// The Google Cloud Storage location for the input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsInputSource {
    /// Required. Source data URI. For example, `gs://my_bucket/my_object`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri: std::string::String,
}

impl GcsInputSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uri][crate::model::GcsInputSource::input_uri].
    pub fn set_input_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsInputSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsInputSource"
    }
}

/// An inlined file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FileInputSource {
    /// Required. The file's mime type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Required. The file's byte contents.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub content: ::bytes::Bytes,

    /// Required. The file's display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,
}

impl FileInputSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::FileInputSource::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [content][crate::model::FileInputSource::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::FileInputSource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for FileInputSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.FileInputSource"
    }
}

/// The Google Cloud Storage location for the output content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsOutputDestination {
    /// Required. Google Cloud Storage URI to output directory. For example,
    /// `gs://bucket/directory`. The requesting user must have write permission to
    /// the bucket. The directory will be created if it doesn't exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,
}

impl GcsOutputDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::GcsOutputDestination::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for GcsOutputDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsOutputDestination"
    }
}

/// Represents a single entry in a glossary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GlossaryEntry {
    /// Identifier. The resource name of the entry.
    /// Format:
    /// `projects/*/locations/*/glossaries/*/glossaryEntries/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Describes the glossary entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The different data for the glossary types (Unidirectional, Equivalent term
    /// sets).
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::glossary_entry::Data>,
}

impl GlossaryEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GlossaryEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::GlossaryEntry::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of `data`.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::glossary_entry::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::GlossaryEntry::data]
    /// if it holds a `TermsPair`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_terms_pair(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary_entry::GlossaryTermsPair>>
    {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::glossary_entry::Data::TermsPair(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [data][crate::model::GlossaryEntry::data]
    /// if it holds a `TermsSet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_terms_set(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary_entry::GlossaryTermsSet>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::glossary_entry::Data::TermsSet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::GlossaryEntry::data]
    /// to hold a `TermsPair`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_terms_pair<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary_entry::GlossaryTermsPair>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::glossary_entry::Data::TermsPair(v.into()));
        self
    }

    /// Sets the value of [data][crate::model::GlossaryEntry::data]
    /// to hold a `TermsSet`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_terms_set<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary_entry::GlossaryTermsSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::glossary_entry::Data::TermsSet(v.into()));
        self
    }
}

impl wkt::message::Message for GlossaryEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GlossaryEntry"
    }
}

/// Defines additional types related to GlossaryEntry
pub mod glossary_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a single entry for an unidirectional glossary.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GlossaryTermsPair {
        /// The source term is the term that will get match in the text,
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub source_term: std::option::Option<crate::model::GlossaryTerm>,

        /// The term that will replace the match source term.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub target_term: std::option::Option<crate::model::GlossaryTerm>,
    }

    impl GlossaryTermsPair {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_term][crate::model::glossary_entry::GlossaryTermsPair::source_term].
        pub fn set_source_term<
            T: std::convert::Into<std::option::Option<crate::model::GlossaryTerm>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_term = v.into();
            self
        }

        /// Sets the value of [target_term][crate::model::glossary_entry::GlossaryTermsPair::target_term].
        pub fn set_target_term<
            T: std::convert::Into<std::option::Option<crate::model::GlossaryTerm>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.target_term = v.into();
            self
        }
    }

    impl wkt::message::Message for GlossaryTermsPair {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.GlossaryEntry.GlossaryTermsPair"
        }
    }

    /// Represents a single entry for an equivalent term set glossary. This is used
    /// for equivalent term sets where each term can be replaced by the other terms
    /// in the set.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GlossaryTermsSet {
        /// Each term in the set represents a term that can be replaced by the other
        /// terms.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub terms: std::vec::Vec<crate::model::GlossaryTerm>,
    }

    impl GlossaryTermsSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [terms][crate::model::glossary_entry::GlossaryTermsSet::terms].
        pub fn set_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::GlossaryTerm>,
        {
            use std::iter::Iterator;
            self.terms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GlossaryTermsSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.GlossaryEntry.GlossaryTermsSet"
        }
    }

    /// The different data for the glossary types (Unidirectional, Equivalent term
    /// sets).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// Used for an unidirectional glossary.
        TermsPair(std::boxed::Box<crate::model::glossary_entry::GlossaryTermsPair>),
        /// Used for an equivalent term sets glossary.
        TermsSet(std::boxed::Box<crate::model::glossary_entry::GlossaryTermsSet>),
    }
}

/// Represents a single glossary term
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GlossaryTerm {
    /// The language for this glossary term.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// The text for the glossary term.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub text: std::string::String,
}

impl GlossaryTerm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::GlossaryTerm::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [text][crate::model::GlossaryTerm::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

impl wkt::message::Message for GlossaryTerm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GlossaryTerm"
    }
}

/// Configures transliteration feature on top of translation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransliterationConfig {
    /// If true, source text in romanized form can be translated to the target
    /// language.
    pub enable_transliteration: bool,
}

impl TransliterationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_transliteration][crate::model::TransliterationConfig::enable_transliteration].
    pub fn set_enable_transliteration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_transliteration = v.into();
        self
    }
}

impl wkt::message::Message for TransliterationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TransliterationConfig"
    }
}

/// The request message for synchronous translation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslateTextRequest {
    /// Required. The content of the input in string format.
    /// We recommend the total content be less than 30,000 codepoints. The max
    /// length of this field is 1024. Use BatchTranslateText for larger text.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<std::string::String>,

    /// Optional. The format of the source text, for example, "text/html",
    /// "text/plain". If left blank, the MIME type defaults to "text/html".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Optional. The ISO-639 language code of the input text if
    /// known, for example, "en-US" or "sr-Latn". Supported language codes are
    /// listed in Language Support. If the source language isn't specified, the API
    /// attempts to identify the source language automatically and returns the
    /// source language within the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,

    /// Required. The ISO-639 language code to use for translation of the input
    /// text, set to one of the language codes listed in Language Support.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language_code: std::string::String,

    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}` or
    /// `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Non-global location is required for requests using AutoML models or
    /// custom glossaries.
    ///
    /// Models and glossaries must be within the same region (have same
    /// location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The `model` type requested for this translation.
    ///
    /// The format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    /// - Translation LLM models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/translation-llm`,
    ///
    ///
    /// For global (non-regionalized) requests, use `location-id` `global`.
    /// For example,
    /// `projects/{project-number-or-id}/locations/global/models/general/nmt`.
    ///
    /// If not provided, the default Google model (NMT) will be used
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. Glossary to be applied. The glossary must be
    /// within the same region (have the same location-id) as the model, otherwise
    /// an INVALID_ARGUMENT (400) error is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,

    /// Optional. Transliteration to be applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transliteration_config: std::option::Option<crate::model::TransliterationConfig>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl TranslateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::TranslateTextRequest::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::TranslateTextRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::TranslateTextRequest::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::TranslateTextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::TranslateTextRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::TranslateTextRequest::glossary_config].
    pub fn set_glossary_config<
        T: std::convert::Into<std::option::Option<crate::model::TranslateTextGlossaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_config = v.into();
        self
    }

    /// Sets the value of [transliteration_config][crate::model::TranslateTextRequest::transliteration_config].
    pub fn set_transliteration_config<
        T: std::convert::Into<std::option::Option<crate::model::TransliterationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transliteration_config = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::TranslateTextRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::TranslateTextRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TranslateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateTextRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslateTextResponse {
    /// Text translation responses with no glossary applied.
    /// This field has the same length as
    /// [`contents`][google.cloud.translation.v3.TranslateTextRequest.contents].
    ///
    /// [google.cloud.translation.v3.TranslateTextRequest.contents]: crate::model::TranslateTextRequest::contents
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub translations: std::vec::Vec<crate::model::Translation>,

    /// Text translation responses if a glossary is provided in the request.
    /// This can be the same as
    /// [`translations`][google.cloud.translation.v3.TranslateTextResponse.translations]
    /// if no terms apply. This field has the same length as
    /// [`contents`][google.cloud.translation.v3.TranslateTextRequest.contents].
    ///
    /// [google.cloud.translation.v3.TranslateTextRequest.contents]: crate::model::TranslateTextRequest::contents
    /// [google.cloud.translation.v3.TranslateTextResponse.translations]: crate::model::TranslateTextResponse::translations
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub glossary_translations: std::vec::Vec<crate::model::Translation>,
}

impl TranslateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translations][crate::model::TranslateTextResponse::translations].
    pub fn set_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Translation>,
    {
        use std::iter::Iterator;
        self.translations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [glossary_translations][crate::model::TranslateTextResponse::glossary_translations].
    pub fn set_glossary_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Translation>,
    {
        use std::iter::Iterator;
        self.glossary_translations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranslateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateTextResponse"
    }
}

/// A single translation response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Translation {
    /// Text translated into the target language.
    /// If an error occurs during translation, this field might be excluded from
    /// the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub translated_text: std::string::String,

    /// Only present when `model` is present in the request.
    /// `model` here is normalized to have project number.
    ///
    /// For example:
    /// If the `model` requested in TranslationTextRequest is
    /// `projects/{project-id}/locations/{location-id}/models/general/nmt` then
    /// `model` here would be normalized to
    /// `projects/{project-number}/locations/{location-id}/models/general/nmt`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// The ISO-639 language code of source text in the initial request, detected
    /// automatically, if no source language was passed within the initial
    /// request. If the source language was passed, auto-detection of the language
    /// does not occur and this field is empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detected_language_code: std::string::String,

    /// The `glossary_config` used for this translation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,
}

impl Translation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translated_text][crate::model::Translation::translated_text].
    pub fn set_translated_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.translated_text = v.into();
        self
    }

    /// Sets the value of [model][crate::model::Translation::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [detected_language_code][crate::model::Translation::detected_language_code].
    pub fn set_detected_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.detected_language_code = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::Translation::glossary_config].
    pub fn set_glossary_config<
        T: std::convert::Into<std::option::Option<crate::model::TranslateTextGlossaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_config = v.into();
        self
    }
}

impl wkt::message::Message for Translation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Translation"
    }
}

/// The request message for synchronous romanization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RomanizeTextRequest {
    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}` or
    /// `projects/{project-number-or-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The content of the input in string format.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<std::string::String>,

    /// Optional. The ISO-639 language code of the input text if
    /// known, for example, "hi" or "zh". If the source language isn't specified,
    /// the API attempts to identify the source language automatically and returns
    /// the source language for each content in the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,
}

impl RomanizeTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RomanizeTextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::RomanizeTextRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::RomanizeTextRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RomanizeTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.RomanizeTextRequest"
    }
}

/// A single romanization response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Romanization {
    /// Romanized text.
    /// If an error occurs during romanization, this field might be excluded from
    /// the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub romanized_text: std::string::String,

    /// The ISO-639 language code of source text in the initial request, detected
    /// automatically, if no source language was passed within the initial
    /// request. If the source language was passed, auto-detection of the language
    /// does not occur and this field is empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detected_language_code: std::string::String,
}

impl Romanization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [romanized_text][crate::model::Romanization::romanized_text].
    pub fn set_romanized_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.romanized_text = v.into();
        self
    }

    /// Sets the value of [detected_language_code][crate::model::Romanization::detected_language_code].
    pub fn set_detected_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.detected_language_code = v.into();
        self
    }
}

impl wkt::message::Message for Romanization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Romanization"
    }
}

/// The response message for synchronous romanization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RomanizeTextResponse {
    /// Text romanization responses.
    /// This field has the same length as
    /// [`contents`][google.cloud.translation.v3.RomanizeTextRequest.contents].
    ///
    /// [google.cloud.translation.v3.RomanizeTextRequest.contents]: crate::model::RomanizeTextRequest::contents
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub romanizations: std::vec::Vec<crate::model::Romanization>,
}

impl RomanizeTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [romanizations][crate::model::RomanizeTextResponse::romanizations].
    pub fn set_romanizations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Romanization>,
    {
        use std::iter::Iterator;
        self.romanizations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RomanizeTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.RomanizeTextResponse"
    }
}

/// The request message for language detection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DetectLanguageRequest {
    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}` or
    /// `projects/{project-number-or-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Only models within the same region (has same location-id) can be used.
    /// Otherwise an INVALID_ARGUMENT (400) error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The language detection model to be used.
    ///
    /// Format:
    /// `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/{model-id}`
    ///
    /// Only one language detection model is currently supported:
    /// `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/default`.
    ///
    /// If not specified, the default model is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. The format of the source text, for example, "text/html",
    /// "text/plain". If left blank, the MIME type defaults to "text/html".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The source of the document from which to detect the language.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::detect_language_request::Source>,
}

impl DetectLanguageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DetectLanguageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::DetectLanguageRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::DetectLanguageRequest::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DetectLanguageRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::detect_language_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::DetectLanguageRequest::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_content(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::detect_language_request::Source::Content(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DetectLanguageRequest::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::detect_language_request::Source::Content(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DetectLanguageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DetectLanguageRequest"
    }
}

/// Defines additional types related to DetectLanguageRequest
pub mod detect_language_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The source of the document from which to detect the language.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The content of the input stored as a string.
        Content(std::string::String),
    }
}

/// The response message for language detection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DetectedLanguage {
    /// The ISO-639 language code of the source content in the request, detected
    /// automatically.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// The confidence of the detection result for this language.
    pub confidence: f32,
}

impl DetectedLanguage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::DetectedLanguage::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::DetectedLanguage::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for DetectedLanguage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DetectedLanguage"
    }
}

/// The response message for language detection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DetectLanguageResponse {
    /// The most probable language detected by the Translation API. For each
    /// request, the Translation API will always return only one result.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub languages: std::vec::Vec<crate::model::DetectedLanguage>,
}

impl DetectLanguageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [languages][crate::model::DetectLanguageResponse::languages].
    pub fn set_languages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DetectedLanguage>,
    {
        use std::iter::Iterator;
        self.languages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DetectLanguageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DetectLanguageResponse"
    }
}

/// The request message for discovering supported languages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSupportedLanguagesRequest {
    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}` or
    /// `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Non-global location is required for AutoML models.
    ///
    /// Only models within the same region (have same location-id) can be used,
    /// otherwise an INVALID_ARGUMENT (400) error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The language to use to return localized, human readable names
    /// of supported languages. If missing, then display names are not returned
    /// in a response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_language_code: std::string::String,

    /// Optional. Get supported languages of this model.
    ///
    /// The format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// Returns languages supported by the specified model.
    /// If missing, we get supported languages of Google general NMT model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,
}

impl GetSupportedLanguagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetSupportedLanguagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [display_language_code][crate::model::GetSupportedLanguagesRequest::display_language_code].
    pub fn set_display_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.display_language_code = v.into();
        self
    }

    /// Sets the value of [model][crate::model::GetSupportedLanguagesRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for GetSupportedLanguagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetSupportedLanguagesRequest"
    }
}

/// The response message for discovering supported languages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupportedLanguages {
    /// A list of supported language responses. This list contains an entry
    /// for each language the Translation API supports.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub languages: std::vec::Vec<crate::model::SupportedLanguage>,
}

impl SupportedLanguages {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [languages][crate::model::SupportedLanguages::languages].
    pub fn set_languages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SupportedLanguage>,
    {
        use std::iter::Iterator;
        self.languages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SupportedLanguages {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.SupportedLanguages"
    }
}

/// A single supported language response corresponds to information related
/// to one supported language.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupportedLanguage {
    /// Supported language code, generally consisting of its ISO 639-1
    /// identifier, for example, 'en', 'ja'. In certain cases, ISO-639 codes
    /// including language and region identifiers are returned (for example,
    /// 'zh-TW' and 'zh-CN').
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Human-readable name of the language localized in the display language
    /// specified in the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Can be used as a source language.
    pub support_source: bool,

    /// Can be used as a target language.
    pub support_target: bool,
}

impl SupportedLanguage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::SupportedLanguage::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SupportedLanguage::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [support_source][crate::model::SupportedLanguage::support_source].
    pub fn set_support_source<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.support_source = v.into();
        self
    }

    /// Sets the value of [support_target][crate::model::SupportedLanguage::support_target].
    pub fn set_support_target<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.support_target = v.into();
        self
    }
}

impl wkt::message::Message for SupportedLanguage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.SupportedLanguage"
    }
}

/// The Google Cloud Storage location for the input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsSource {
    /// Required. Source data URI. For example, `gs://my_bucket/my_object`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input_uri: std::string::String,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uri][crate::model::GcsSource::input_uri].
    pub fn set_input_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsSource"
    }
}

/// Input configuration for BatchTranslateText request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InputConfig {
    /// Optional. Can be "text/plain" or "text/html".
    /// For `.tsv`, "text/html" is used if mime_type is missing.
    /// For `.html`, this field must be "text/html" or empty.
    /// For `.txt`, this field must be "text/plain" or empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Required. Specify the input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::input_config::Source>,
}

impl InputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::InputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::InputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::input_config::Source::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::InputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::input_config::Source::GcsSource(v.into()));
        self
    }
}

impl wkt::message::Message for InputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.InputConfig"
    }
}

/// Defines additional types related to InputConfig
pub mod input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify the input.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Required. Google Cloud Storage location for the source input.
        /// This can be a single file (for example,
        /// `gs://translation-test/input.tsv`) or a wildcard (for example,
        /// `gs://translation-test/*`). If a file extension is `.tsv`, it can
        /// contain either one or two columns. The first column (optional) is the id
        /// of the text request. If the first column is missing, we use the row
        /// number (0-based) from the input file as the ID in the output file. The
        /// second column is the actual text to be
        /// translated. We recommend each row be <= 10K Unicode codepoints,
        /// otherwise an error might be returned.
        /// Note that the input tsv must be RFC 4180 compliant.
        ///
        /// You could use <https://github.com/Clever/csvlint> to check potential
        /// formatting errors in your tsv file.
        /// csvlint --delimiter='\t' your_input_file.tsv
        ///
        /// The other supported file extensions are `.txt` or `.html`, which is
        /// treated as a single large chunk of text.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// The Google Cloud Storage location for the output content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required. The bucket used in 'output_uri_prefix' must exist and there must
    /// be no files under 'output_uri_prefix'. 'output_uri_prefix' must end with
    /// "/" and start with "gs://". One 'output_uri_prefix' can only be used by one
    /// batch translation job at a time. Otherwise an INVALID_ARGUMENT (400) error
    /// is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri_prefix: std::string::String,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::GcsDestination::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsDestination"
    }
}

/// Output configuration for BatchTranslateText request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OutputConfig {
    /// Required. The destination of output.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::output_config::Destination>,
}

impl OutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::OutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.OutputConfig"
    }
}

/// Defines additional types related to OutputConfig
pub mod output_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The destination of output.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage destination for output content.
        /// For every single input file (for example, gs://a/b/c.[extension]), we
        /// generate at most 2 * n output files. (n is the # of target_language_codes
        /// in the BatchTranslateTextRequest).
        ///
        /// Output files (tsv) generated are compliant with RFC 4180 except that
        /// record delimiters are '\n' instead of '\r\n'. We don't provide any way to
        /// change record delimiters.
        ///
        /// While the input files are being processed, we write/update an index file
        /// 'index.csv'  under 'output_uri_prefix' (for example,
        /// gs://translation-test/index.csv) The index file is generated/updated as
        /// new files are being translated. The format is:
        ///
        /// input_file,target_language_code,translations_file,errors_file,
        /// glossary_translations_file,glossary_errors_file
        ///
        /// input_file is one file we matched using gcs_source.input_uri.
        /// target_language_code is provided in the request.
        /// translations_file contains the translations. (details provided below)
        /// errors_file contains the errors during processing of the file. (details
        /// below). Both translations_file and errors_file could be empty
        /// strings if we have no content to output.
        /// glossary_translations_file and glossary_errors_file are always empty
        /// strings if the input_file is tsv. They could also be empty if we have no
        /// content to output.
        ///
        /// Once a row is present in index.csv, the input/output matching never
        /// changes. Callers should also expect all the content in input_file are
        /// processed and ready to be consumed (that is, no partial output file is
        /// written).
        ///
        /// Since index.csv will be keeping updated during the process, please make
        /// sure there is no custom retention policy applied on the output bucket
        /// that may avoid file updating.
        /// (<https://cloud.google.com/storage/docs/bucket-lock#retention-policy>)
        ///
        /// The format of translations_file (for target language code 'trg') is:
        /// `gs://translation_test/a_b_c_'trg'_translations.[extension]`
        ///
        /// If the input file extension is tsv, the output has the following
        /// columns:
        /// Column 1: ID of the request provided in the input, if it's not
        /// provided in the input, then the input row number is used (0-based).
        /// Column 2: source sentence.
        /// Column 3: translation without applying a glossary. Empty string if there
        /// is an error.
        /// Column 4 (only present if a glossary is provided in the request):
        /// translation after applying the glossary. Empty string if there is an
        /// error applying the glossary. Could be same string as column 3 if there is
        /// no glossary applied.
        ///
        /// If input file extension is a txt or html, the translation is directly
        /// written to the output file. If glossary is requested, a separate
        /// glossary_translations_file has format of
        /// `gs://translation_test/a_b_c_'trg'_glossary_translations.[extension]`
        ///
        /// The format of errors file (for target language code 'trg') is:
        /// `gs://translation_test/a_b_c_'trg'_errors.[extension]`
        ///
        /// If the input file extension is tsv, errors_file contains the following:
        /// Column 1: ID of the request provided in the input, if it's not
        /// provided in the input, then the input row number is used (0-based).
        /// Column 2: source sentence.
        /// Column 3: Error detail for the translation. Could be empty.
        /// Column 4 (only present if a glossary is provided in the request):
        /// Error when applying the glossary.
        ///
        /// If the input file extension is txt or html, glossary_error_file will be
        /// generated that contains error details. glossary_error_file has format of
        /// `gs://translation_test/a_b_c_'trg'_glossary_errors.[extension]`
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// A document translation request input config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DocumentInputConfig {
    /// Specifies the input document's mime_type.
    ///
    /// If not specified it will be determined using the file extension for
    /// gcs_source provided files. For a file provided through bytes content the
    /// mime_type must be provided.
    /// Currently supported mime types are:
    ///
    /// - application/pdf
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Specifies the source for the document's content.
    /// The input file size should be <= 20MB for
    ///
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    ///   The input file size should be <= 20MB and the maximum page limit is 20 for
    /// - application/pdf
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::document_input_config::Source>,
}

impl DocumentInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::DocumentInputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::DocumentInputConfig::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document_input_config::Source::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::DocumentInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DocumentInputConfig::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::document_input_config::Source::Content(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::DocumentInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::document_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DocumentInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DocumentInputConfig"
    }
}

/// Defines additional types related to DocumentInputConfig
pub mod document_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the source for the document's content.
    /// The input file size should be <= 20MB for
    ///
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    ///   The input file size should be <= 20MB and the maximum page limit is 20 for
    /// - application/pdf
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Document's content represented as a stream of bytes.
        Content(::bytes::Bytes),
        /// Google Cloud Storage location. This must be a single file.
        /// For example: gs://example_bucket/example_file.pdf
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// A document translation request output config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DocumentOutputConfig {
    /// Optional. Specifies the translated document's mime_type.
    /// If not specified, the translated file's mime type will be the same as the
    /// input file's mime type.
    /// Currently only support the output mime type to be the same as input mime
    /// type.
    ///
    /// - application/pdf
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// A URI destination for the translated document.
    /// It is optional to provide a destination. If provided the results from
    /// TranslateDocument will be stored in the destination.
    /// Whether a destination is provided or not, the translated documents will be
    /// returned within TranslateDocumentResponse.document_translation and
    /// TranslateDocumentResponse.glossary_document_translation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::document_output_config::Destination>,
}

impl DocumentOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::DocumentOutputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::document_output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::DocumentOutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::document_output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::DocumentOutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::document_output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DocumentOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DocumentOutputConfig"
    }
}

/// Defines additional types related to DocumentOutputConfig
pub mod document_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// A URI destination for the translated document.
    /// It is optional to provide a destination. If provided the results from
    /// TranslateDocument will be stored in the destination.
    /// Whether a destination is provided or not, the translated documents will be
    /// returned within TranslateDocumentResponse.document_translation and
    /// TranslateDocumentResponse.glossary_document_translation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Optional. Google Cloud Storage destination for the translation output,
        /// e.g., `gs://my_bucket/my_directory/`.
        ///
        /// The destination directory provided does not have to be empty, but the
        /// bucket must exist. If a file with the same name as the output file
        /// already exists in the destination an error will be returned.
        ///
        /// For a DocumentInputConfig.contents provided document, the output file
        /// will have the name "output_[trg]_translations.[ext]", where
        ///
        /// - [trg] corresponds to the translated file's language code,
        /// - [ext] corresponds to the translated file's extension according to its
        ///   mime type.
        ///
        /// For a DocumentInputConfig.gcs_uri provided document, the output file will
        /// have a name according to its URI. For example: an input file with URI:
        /// `gs://a/b/c.[extension]` stored in a gcs_destination bucket with name
        /// "my_bucket" will have an output URI:
        /// `gs://my_bucket/a_b_c_[trg]_translations.[ext]`, where
        ///
        /// - [trg] corresponds to the translated file's language code,
        /// - [ext] corresponds to the translated file's extension according to its
        ///   mime type.
        ///
        /// If the document was directly provided through the request, then the
        /// output document will have the format:
        /// `gs://my_bucket/translated_document_[trg]_translations.[ext]`, where
        ///
        /// - [trg] corresponds to the translated file's language code,
        /// - [ext] corresponds to the translated file's extension according to its
        ///   mime type.
        ///
        /// If a glossary was provided, then the output URI for the glossary
        /// translation will be equal to the default output URI but have
        /// `glossary_translations` instead of `translations`. For the previous
        /// example, its glossary URI would be:
        /// `gs://my_bucket/a_b_c_[trg]_glossary_translations.[ext]`.
        ///
        /// Thus the max number of output files will be 2 (Translated document,
        /// Glossary translated document).
        ///
        /// Callers should expect no partial outputs. If there is any error during
        /// document translation, no output will be stored in the Cloud Storage
        /// bucket.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// A document translation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslateDocumentRequest {
    /// Required. Location to make a regional call.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Non-global location is required for requests using AutoML models or custom
    /// glossaries.
    ///
    /// Models and glossaries must be within the same region (have the same
    /// location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The ISO-639 language code of the input document if known, for
    /// example, "en-US" or "sr-Latn". Supported language codes are listed in
    /// Language Support. If the source language isn't specified, the API attempts
    /// to identify the source language automatically and returns the source
    /// language within the response. Source language must be specified if the
    /// request contains a glossary or a custom model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,

    /// Required. The ISO-639 language code to use for translation of the input
    /// document, set to one of the language codes listed in Language Support.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language_code: std::string::String,

    /// Required. Input configurations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_input_config: std::option::Option<crate::model::DocumentInputConfig>,

    /// Optional. Output configurations.
    /// Defines if the output file should be stored within Cloud Storage as well
    /// as the desired output format. If not provided the translated file will
    /// only be returned through a byte-stream and its output mime type will be
    /// the same as the input file's mime type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_output_config: std::option::Option<crate::model::DocumentOutputConfig>,

    /// Optional. The `model` type requested for this translation.
    ///
    /// The format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// If not provided, the default Google model (NMT) will be used for
    /// translation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. Glossary to be applied. The glossary must be within the same
    /// region (have the same location-id) as the model, otherwise an
    /// INVALID_ARGUMENT (400) error is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters (Unicode
    /// codepoints), can only contain lowercase letters, numeric characters,
    /// underscores and dashes. International characters are allowed. Label values
    /// are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This flag is to support user customized attribution.
    /// If not provided, the default is `Machine Translated by Google`.
    /// Customized attribution should follow rules in
    /// <https://cloud.google.com/translate/attribution#attribution_and_logos>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub customized_attribution: std::string::String,

    /// Optional. is_translate_native_pdf_only field for external customers.
    /// If true, the page limit of online native pdf translation is 300 and only
    /// native pdf pages will be translated.
    pub is_translate_native_pdf_only: bool,

    /// Optional. If true, use the text removal server to remove the shadow text on
    /// background image for native pdf translation.
    /// Shadow removal feature can only be enabled when
    /// is_translate_native_pdf_only: false && pdf_native_only: false
    pub enable_shadow_removal_native_pdf: bool,

    /// Optional. If true, enable auto rotation correction in DVS.
    pub enable_rotation_correction: bool,
}

impl TranslateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::TranslateDocumentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::TranslateDocumentRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::TranslateDocumentRequest::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [document_input_config][crate::model::TranslateDocumentRequest::document_input_config].
    pub fn set_document_input_config<
        T: std::convert::Into<std::option::Option<crate::model::DocumentInputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_input_config = v.into();
        self
    }

    /// Sets the value of [document_output_config][crate::model::TranslateDocumentRequest::document_output_config].
    pub fn set_document_output_config<
        T: std::convert::Into<std::option::Option<crate::model::DocumentOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_output_config = v.into();
        self
    }

    /// Sets the value of [model][crate::model::TranslateDocumentRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::TranslateDocumentRequest::glossary_config].
    pub fn set_glossary_config<
        T: std::convert::Into<std::option::Option<crate::model::TranslateTextGlossaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_config = v.into();
        self
    }

    /// Sets the value of [customized_attribution][crate::model::TranslateDocumentRequest::customized_attribution].
    pub fn set_customized_attribution<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.customized_attribution = v.into();
        self
    }

    /// Sets the value of [is_translate_native_pdf_only][crate::model::TranslateDocumentRequest::is_translate_native_pdf_only].
    pub fn set_is_translate_native_pdf_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_translate_native_pdf_only = v.into();
        self
    }

    /// Sets the value of [enable_shadow_removal_native_pdf][crate::model::TranslateDocumentRequest::enable_shadow_removal_native_pdf].
    pub fn set_enable_shadow_removal_native_pdf<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_shadow_removal_native_pdf = v.into();
        self
    }

    /// Sets the value of [enable_rotation_correction][crate::model::TranslateDocumentRequest::enable_rotation_correction].
    pub fn set_enable_rotation_correction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_rotation_correction = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::TranslateDocumentRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TranslateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateDocumentRequest"
    }
}

/// A translated document message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DocumentTranslation {
    /// The array of translated documents. It is expected to be size 1 for now. We
    /// may produce multiple translated documents in the future for other type of
    /// file formats.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub byte_stream_outputs: std::vec::Vec<::bytes::Bytes>,

    /// The translated document's mime type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// The detected language for the input document.
    /// If the user did not provide the source language for the input document,
    /// this field will have the language code automatically detected. If the
    /// source language was passed, auto-detection of the language does not occur
    /// and this field is empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detected_language_code: std::string::String,
}

impl DocumentTranslation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::DocumentTranslation::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [detected_language_code][crate::model::DocumentTranslation::detected_language_code].
    pub fn set_detected_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.detected_language_code = v.into();
        self
    }

    /// Sets the value of [byte_stream_outputs][crate::model::DocumentTranslation::byte_stream_outputs].
    pub fn set_byte_stream_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.byte_stream_outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DocumentTranslation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DocumentTranslation"
    }
}

/// A translated document response message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslateDocumentResponse {
    /// Translated document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_translation: std::option::Option<crate::model::DocumentTranslation>,

    /// The document's translation output if a glossary is provided in the request.
    /// This can be the same as [TranslateDocumentResponse.document_translation]
    /// if no glossary terms apply.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_document_translation: std::option::Option<crate::model::DocumentTranslation>,

    /// Only present when 'model' is present in the request.
    /// 'model' is normalized to have a project number.
    ///
    /// For example:
    /// If the 'model' field in TranslateDocumentRequest is:
    /// `projects/{project-id}/locations/{location-id}/models/general/nmt` then
    /// `model` here would be normalized to
    /// `projects/{project-number}/locations/{location-id}/models/general/nmt`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// The `glossary_config` used for this translation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,
}

impl TranslateDocumentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document_translation][crate::model::TranslateDocumentResponse::document_translation].
    pub fn set_document_translation<
        T: std::convert::Into<std::option::Option<crate::model::DocumentTranslation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_translation = v.into();
        self
    }

    /// Sets the value of [glossary_document_translation][crate::model::TranslateDocumentResponse::glossary_document_translation].
    pub fn set_glossary_document_translation<
        T: std::convert::Into<std::option::Option<crate::model::DocumentTranslation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_document_translation = v.into();
        self
    }

    /// Sets the value of [model][crate::model::TranslateDocumentResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::TranslateDocumentResponse::glossary_config].
    pub fn set_glossary_config<
        T: std::convert::Into<std::option::Option<crate::model::TranslateTextGlossaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_config = v.into();
        self
    }
}

impl wkt::message::Message for TranslateDocumentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateDocumentResponse"
    }
}

/// The batch translation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchTranslateTextRequest {
    /// Required. Location to make a call. Must refer to a caller's project.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// The `global` location is not supported for batch translation.
    ///
    /// Only AutoML Translation models or glossaries within the same region (have
    /// the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
    /// error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Source language code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,

    /// Required. Specify up to 10 language codes here.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_language_codes: std::vec::Vec<std::string::String>,

    /// Optional. The models to use for translation. Map's key is target language
    /// code. Map's value is model name. Value can be a built-in general model,
    /// or an AutoML Translation model.
    ///
    /// The value format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// If the map is empty or a specific model is
    /// not requested for a language pair, then default google model (nmt) is used.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub models: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Input configurations.
    /// The total number of files matched should be <= 100.
    /// The total content size should be <= 100M Unicode codepoints.
    /// The files must use UTF-8 encoding.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub input_configs: std::vec::Vec<crate::model::InputConfig>,

    /// Required. Output configuration.
    /// If 2 input configs match to the same file (that is, same input path),
    /// we don't generate output for duplicate inputs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    /// Optional. Glossaries to be applied for translation.
    /// It's keyed by target language code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub glossaries:
        std::collections::HashMap<std::string::String, crate::model::TranslateTextGlossaryConfig>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,
}

impl BatchTranslateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchTranslateTextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::BatchTranslateTextRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::BatchTranslateTextRequest::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }

    /// Sets the value of [target_language_codes][crate::model::BatchTranslateTextRequest::target_language_codes].
    pub fn set_target_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_configs][crate::model::BatchTranslateTextRequest::input_configs].
    pub fn set_input_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InputConfig>,
    {
        use std::iter::Iterator;
        self.input_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [models][crate::model::BatchTranslateTextRequest::models].
    pub fn set_models<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [glossaries][crate::model::BatchTranslateTextRequest::glossaries].
    pub fn set_glossaries<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        use std::iter::Iterator;
        self.glossaries = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::BatchTranslateTextRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchTranslateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateTextRequest"
    }
}

/// State metadata for the batch translation operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchTranslateMetadata {
    /// The state of the operation.
    pub state: crate::model::batch_translate_metadata::State,

    /// Number of successfully translated characters so far (Unicode codepoints).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub translated_characters: i64,

    /// Number of characters that have failed to process so far (Unicode
    /// codepoints).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_characters: i64,

    /// Total number of characters (Unicode codepoints).
    /// This is the total number of codepoints from input files times the number of
    /// target languages and appears here shortly after the call is submitted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_characters: i64,

    /// Time when the operation was submitted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,
}

impl BatchTranslateMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchTranslateMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_translate_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateMetadata::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateMetadata::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateMetadata::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateMetadata::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }
}

impl wkt::message::Message for BatchTranslateMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateMetadata"
    }
}

/// Defines additional types related to BatchTranslateMetadata
pub mod batch_translate_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of the job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Invalid.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Request is being processed.
        pub const RUNNING: State = State::new(1);

        /// The batch is processed, and at least one item was successfully
        /// processed.
        pub const SUCCEEDED: State = State::new(2);

        /// The batch is done and no item was successfully processed.
        pub const FAILED: State = State::new(3);

        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        pub const CANCELLING: State = State::new(4);

        /// The batch is done after the user has called the
        /// longrunning.Operations.CancelOperation. Any records processed before the
        /// cancel command are output as specified in the request.
        pub const CANCELLED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                3 => std::borrow::Cow::Borrowed("FAILED"),
                4 => std::borrow::Cow::Borrowed("CANCELLING"),
                5 => std::borrow::Cow::Borrowed("CANCELLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "CANCELLING" => std::option::Option::Some(Self::CANCELLING),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by BatchTranslateText if at least one sentence is translated
/// successfully.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchTranslateResponse {
    /// Total number of characters (Unicode codepoints).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_characters: i64,

    /// Number of successfully translated characters (Unicode codepoints).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub translated_characters: i64,

    /// Number of characters that have failed to process (Unicode codepoints).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_characters: i64,

    /// Time when the operation was submitted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl BatchTranslateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateResponse::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateResponse::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateResponse::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateResponse::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BatchTranslateResponse::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for BatchTranslateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateResponse"
    }
}

/// Input configuration for glossaries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GlossaryInputConfig {
    /// Required. Specify the input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::glossary_input_config::Source>,
}

impl GlossaryInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::glossary_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GlossaryInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::glossary_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GlossaryInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::glossary_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GlossaryInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GlossaryInputConfig"
    }
}

/// Defines additional types related to GlossaryInputConfig
pub mod glossary_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify the input.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Required. Google Cloud Storage location of glossary data.
        /// File format is determined based on the filename extension. API returns
        /// [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file
        /// formats. Wildcards are not allowed. This must be a single file in one of
        /// the following formats:
        ///
        /// For unidirectional glossaries:
        ///
        /// - TSV/CSV (`.tsv`/`.csv`): Two column file, tab- or comma-separated.
        ///   The first column is source text. The second column is target text.
        ///   No headers in this file. The first row contains data and not column
        ///   names.
        ///
        /// - TMX (`.tmx`): TMX file with parallel data defining source/target term
        ///   pairs.
        ///
        ///
        /// For equivalent term sets glossaries:
        ///
        /// - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms
        ///   in multiple languages. See documentation for more information -
        ///   [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// Represents a glossary built from user-provided data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Glossary {
    /// Required. The resource name of the glossary. Glossary names have the form
    /// `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Provides examples to build the glossary from.
    /// Total glossary must not exceed 10M Unicode codepoints.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::GlossaryInputConfig>,

    /// Output only. The number of entries defined in the glossary.
    pub entry_count: i32,

    /// Output only. When CreateGlossary was called.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// Output only. When the glossary creation was finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The display name of the glossary.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Languages supported by the glossary.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub languages: std::option::Option<crate::model::glossary::Languages>,
}

impl Glossary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Glossary::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::Glossary::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::GlossaryInputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::Glossary::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::Glossary::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Glossary::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Glossary::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of `languages`.
    pub fn set_languages<
        T: std::convert::Into<std::option::Option<crate::model::glossary::Languages>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.languages = v.into();
        self
    }

    /// The value of [languages][crate::model::Glossary::languages]
    /// if it holds a `LanguagePair`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_language_pair(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary::LanguageCodePair>> {
        #[allow(unreachable_patterns)]
        self.languages.as_ref().and_then(|v| match v {
            crate::model::glossary::Languages::LanguagePair(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [languages][crate::model::Glossary::languages]
    /// if it holds a `LanguageCodesSet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_language_codes_set(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary::LanguageCodesSet>> {
        #[allow(unreachable_patterns)]
        self.languages.as_ref().and_then(|v| match v {
            crate::model::glossary::Languages::LanguageCodesSet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [languages][crate::model::Glossary::languages]
    /// to hold a `LanguagePair`.
    ///
    /// Note that all the setters affecting `languages` are
    /// mutually exclusive.
    pub fn set_language_pair<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary::LanguageCodePair>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.languages =
            std::option::Option::Some(crate::model::glossary::Languages::LanguagePair(v.into()));
        self
    }

    /// Sets the value of [languages][crate::model::Glossary::languages]
    /// to hold a `LanguageCodesSet`.
    ///
    /// Note that all the setters affecting `languages` are
    /// mutually exclusive.
    pub fn set_language_codes_set<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary::LanguageCodesSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.languages = std::option::Option::Some(
            crate::model::glossary::Languages::LanguageCodesSet(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Glossary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Glossary"
    }
}

/// Defines additional types related to Glossary
pub mod glossary {
    #[allow(unused_imports)]
    use super::*;

    /// Used with unidirectional glossaries.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LanguageCodePair {
        /// Required. The ISO-639 language code of the input text, for example,
        /// "en-US". Expected to be an exact match for GlossaryTerm.language_code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_language_code: std::string::String,

        /// Required. The ISO-639 language code for translation output, for example,
        /// "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub target_language_code: std::string::String,
    }

    impl LanguageCodePair {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_language_code][crate::model::glossary::LanguageCodePair::source_language_code].
        pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_language_code = v.into();
            self
        }

        /// Sets the value of [target_language_code][crate::model::glossary::LanguageCodePair::target_language_code].
        pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_language_code = v.into();
            self
        }
    }

    impl wkt::message::Message for LanguageCodePair {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.Glossary.LanguageCodePair"
        }
    }

    /// Used with equivalent term set glossaries.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LanguageCodesSet {
        /// The ISO-639 language code(s) for terms defined in the glossary.
        /// All entries are unique. The list contains at least two entries.
        /// Expected to be an exact match for GlossaryTerm.language_code.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub language_codes: std::vec::Vec<std::string::String>,
    }

    impl LanguageCodesSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [language_codes][crate::model::glossary::LanguageCodesSet::language_codes].
        pub fn set_language_codes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.language_codes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for LanguageCodesSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.Glossary.LanguageCodesSet"
        }
    }

    /// Languages supported by the glossary.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Languages {
        /// Used with unidirectional glossaries.
        LanguagePair(std::boxed::Box<crate::model::glossary::LanguageCodePair>),
        /// Used with equivalent term set glossaries.
        LanguageCodesSet(std::boxed::Box<crate::model::glossary::LanguageCodesSet>),
    }
}

/// Request message for CreateGlossary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGlossaryRequest {
    /// Required. The project name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The glossary to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary: std::option::Option<crate::model::Glossary>,
}

impl CreateGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGlossaryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [glossary][crate::model::CreateGlossaryRequest::glossary].
    pub fn set_glossary<T: std::convert::Into<std::option::Option<crate::model::Glossary>>>(
        mut self,
        v: T,
    ) -> Self {
        self.glossary = v.into();
        self
    }
}

impl wkt::message::Message for CreateGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateGlossaryRequest"
    }
}

/// Request message for the update glossary flow
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGlossaryRequest {
    /// Required. The glossary entry to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary: std::option::Option<crate::model::Glossary>,

    /// The list of fields to be updated. Currently only `display_name` and
    /// 'input_config'
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary][crate::model::UpdateGlossaryRequest::glossary].
    pub fn set_glossary<T: std::convert::Into<std::option::Option<crate::model::Glossary>>>(
        mut self,
        v: T,
    ) -> Self {
        self.glossary = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGlossaryRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.UpdateGlossaryRequest"
    }
}

/// Request message for GetGlossary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGlossaryRequest {
    /// Required. The name of the glossary to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGlossaryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetGlossaryRequest"
    }
}

/// Request message for DeleteGlossary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGlossaryRequest {
    /// Required. The name of the glossary to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryRequest"
    }
}

/// Request message for ListGlossaries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGlossariesRequest {
    /// Required. The name of the project from which to list all of the glossaries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer glossaries than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of [ListGlossariesResponse.next_page_token]
    /// returned from the previous call to `ListGlossaries` method.
    /// The first page is returned if `page_token`is empty or missing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter specifying constraints of a list operation.
    /// Specify the constraint by the format of "key=value", where key must be
    /// "src" or "tgt", and the value must be a valid language code.
    /// For multiple restrictions, concatenate them by "AND" (uppercase only),
    /// such as: "src=en-US AND tgt=zh-CN". Notice that the exact match is used
    /// here, which means using 'en-US' and 'en' can lead to different results,
    /// which depends on the language code you used when you create the glossary.
    /// For the unidirectional glossaries, the "src" and "tgt" add restrictions
    /// on the source and target language code separately.
    /// For the equivalent term set glossaries, the "src" and/or "tgt" add
    /// restrictions on the term set.
    /// For example: "src=en-US AND tgt=zh-CN" will only pick the unidirectional
    /// glossaries which exactly match the source language code as "en-US" and the
    /// target language code "zh-CN", but all equivalent term set glossaries which
    /// contain "en-US" and "zh-CN" in their language set will be picked.
    /// If missing, no filtering is performed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListGlossariesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGlossariesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGlossariesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGlossariesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGlossariesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListGlossariesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossariesRequest"
    }
}

/// Response message for ListGlossaries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGlossariesResponse {
    /// The list of glossaries for a project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub glossaries: std::vec::Vec<crate::model::Glossary>,

    /// A token to retrieve a page of results. Pass this value in the
    /// [ListGlossariesRequest.page_token] field in the subsequent call to
    /// `ListGlossaries` method to retrieve the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListGlossariesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListGlossariesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [glossaries][crate::model::ListGlossariesResponse::glossaries].
    pub fn set_glossaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Glossary>,
    {
        use std::iter::Iterator;
        self.glossaries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGlossariesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossariesResponse"
    }
}

impl gax::paginator::PageableResponse for ListGlossariesResponse {
    type PageItem = crate::model::Glossary;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.glossaries
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for the Get Glossary Entry Api
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGlossaryEntryRequest {
    /// Required. The resource name of the glossary entry to get
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGlossaryEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetGlossaryEntryRequest"
    }
}

/// Request message for Delete Glossary Entry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGlossaryEntryRequest {
    /// Required. The resource name of the glossary entry to delete
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryEntryRequest"
    }
}

/// Request message for ListGlossaryEntries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGlossaryEntriesRequest {
    /// Required. The parent glossary resource name for listing the glossary's
    /// entries.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer glossary entries
    /// than requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// [ListGlossaryEntriesResponse.next_page_token] returned from the previous
    /// call. The first page is returned if `page_token`is empty or missing.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListGlossaryEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGlossaryEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGlossaryEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGlossaryEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGlossaryEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossaryEntriesRequest"
    }
}

/// Response message for ListGlossaryEntries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGlossaryEntriesResponse {
    /// Optional. The Glossary Entries
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub glossary_entries: std::vec::Vec<crate::model::GlossaryEntry>,

    /// Optional. A token to retrieve a page of results. Pass this value in the
    /// [ListGLossaryEntriesRequest.page_token] field in the subsequent calls.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListGlossaryEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListGlossaryEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [glossary_entries][crate::model::ListGlossaryEntriesResponse::glossary_entries].
    pub fn set_glossary_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GlossaryEntry>,
    {
        use std::iter::Iterator;
        self.glossary_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGlossaryEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossaryEntriesResponse"
    }
}

impl gax::paginator::PageableResponse for ListGlossaryEntriesResponse {
    type PageItem = crate::model::GlossaryEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.glossary_entries
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for CreateGlossaryEntry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGlossaryEntryRequest {
    /// Required. The resource name of the glossary to create the entry under.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The glossary entry to create
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_entry: std::option::Option<crate::model::GlossaryEntry>,
}

impl CreateGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGlossaryEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [glossary_entry][crate::model::CreateGlossaryEntryRequest::glossary_entry].
    pub fn set_glossary_entry<
        T: std::convert::Into<std::option::Option<crate::model::GlossaryEntry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_entry = v.into();
        self
    }
}

impl wkt::message::Message for CreateGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateGlossaryEntryRequest"
    }
}

/// Request message for UpdateGlossaryEntry
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGlossaryEntryRequest {
    /// Required. The glossary entry to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary_entry: std::option::Option<crate::model::GlossaryEntry>,
}

impl UpdateGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary_entry][crate::model::UpdateGlossaryEntryRequest::glossary_entry].
    pub fn set_glossary_entry<
        T: std::convert::Into<std::option::Option<crate::model::GlossaryEntry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.glossary_entry = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.UpdateGlossaryEntryRequest"
    }
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by CreateGlossary.
///
/// [google.longrunning.Operation.metadata]: longrunning::model::Operation::metadata
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGlossaryMetadata {
    /// The name of the glossary that is being created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current state of the glossary creation operation.
    pub state: crate::model::create_glossary_metadata::State,

    /// The time when the operation was submitted to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,
}

impl CreateGlossaryMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateGlossaryMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CreateGlossaryMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::create_glossary_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::CreateGlossaryMetadata::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateGlossaryMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateGlossaryMetadata"
    }
}

/// Defines additional types related to CreateGlossaryMetadata
pub mod create_glossary_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the creation request can be in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Invalid.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Request is being processed.
        pub const RUNNING: State = State::new(1);

        /// The glossary was successfully created.
        pub const SUCCEEDED: State = State::new(2);

        /// Failed to create the glossary.
        pub const FAILED: State = State::new(3);

        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        pub const CANCELLING: State = State::new(4);

        /// The glossary creation request was successfully canceled.
        pub const CANCELLED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                3 => std::borrow::Cow::Borrowed("FAILED"),
                4 => std::borrow::Cow::Borrowed("CANCELLING"),
                5 => std::borrow::Cow::Borrowed("CANCELLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "CANCELLING" => std::option::Option::Some(Self::CANCELLING),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by UpdateGlossary.
///
/// [google.longrunning.Operation.metadata]: longrunning::model::Operation::metadata
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGlossaryMetadata {
    /// The updated glossary object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub glossary: std::option::Option<crate::model::Glossary>,

    /// The current state of the glossary update operation. If the glossary input
    /// file was not updated this will be completed immediately
    pub state: crate::model::update_glossary_metadata::State,

    /// The time when the operation was submitted to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,
}

impl UpdateGlossaryMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary][crate::model::UpdateGlossaryMetadata::glossary].
    pub fn set_glossary<T: std::convert::Into<std::option::Option<crate::model::Glossary>>>(
        mut self,
        v: T,
    ) -> Self {
        self.glossary = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpdateGlossaryMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::update_glossary_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::UpdateGlossaryMetadata::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGlossaryMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.UpdateGlossaryMetadata"
    }
}

/// Defines additional types related to UpdateGlossaryMetadata
pub mod update_glossary_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the update request can be in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Invalid.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Request is being processed.
        pub const RUNNING: State = State::new(1);

        /// The glossary was successfully updated.
        pub const SUCCEEDED: State = State::new(2);

        /// Failed to update the glossary.
        pub const FAILED: State = State::new(3);

        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        pub const CANCELLING: State = State::new(4);

        /// The glossary update request was successfully canceled.
        pub const CANCELLED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                3 => std::borrow::Cow::Borrowed("FAILED"),
                4 => std::borrow::Cow::Borrowed("CANCELLING"),
                5 => std::borrow::Cow::Borrowed("CANCELLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "CANCELLING" => std::option::Option::Some(Self::CANCELLING),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by DeleteGlossary.
///
/// [google.longrunning.Operation.metadata]: longrunning::model::Operation::metadata
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGlossaryMetadata {
    /// The name of the glossary that is being deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The current state of the glossary deletion operation.
    pub state: crate::model::delete_glossary_metadata::State,

    /// The time when the operation was submitted to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,
}

impl DeleteGlossaryMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DeleteGlossaryMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::delete_glossary_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::DeleteGlossaryMetadata::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGlossaryMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryMetadata"
    }
}

/// Defines additional types related to DeleteGlossaryMetadata
pub mod delete_glossary_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the creation request can be in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Invalid.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Request is being processed.
        pub const RUNNING: State = State::new(1);

        /// The glossary was successfully deleted.
        pub const SUCCEEDED: State = State::new(2);

        /// Failed to delete the glossary.
        pub const FAILED: State = State::new(3);

        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        pub const CANCELLING: State = State::new(4);

        /// The glossary deletion request was successfully canceled.
        pub const CANCELLED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                3 => std::borrow::Cow::Borrowed("FAILED"),
                4 => std::borrow::Cow::Borrowed("CANCELLING"),
                5 => std::borrow::Cow::Borrowed("CANCELLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "CANCELLING" => std::option::Option::Some(Self::CANCELLING),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by DeleteGlossary.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGlossaryResponse {
    /// The name of the deleted glossary.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time when the operation was submitted to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the glossary deletion is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl DeleteGlossaryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::DeleteGlossaryResponse::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::DeleteGlossaryResponse::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGlossaryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryResponse"
    }
}

/// The BatchTranslateDocument request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchTranslateDocumentRequest {
    /// Required. Location to make a regional call.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// The `global` location is not supported for batch translation.
    ///
    /// Only AutoML Translation models or glossaries within the same region (have
    /// the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
    /// error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ISO-639 language code of the input document if known, for
    /// example, "en-US" or "sr-Latn". Supported language codes are listed in
    /// [Language Support](https://cloud.google.com/translate/docs/languages).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_language_code: std::string::String,

    /// Required. The ISO-639 language code to use for translation of the input
    /// document. Specify up to 10 language codes here.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_language_codes: std::vec::Vec<std::string::String>,

    /// Required. Input configurations.
    /// The total number of files matched should be <= 100.
    /// The total content size to translate should be <= 100M Unicode codepoints.
    /// The files must use UTF-8 encoding.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub input_configs: std::vec::Vec<crate::model::BatchDocumentInputConfig>,

    /// Required. Output configuration.
    /// If 2 input configs match to the same file (that is, same input path),
    /// we don't generate output for duplicate inputs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::BatchDocumentOutputConfig>,

    /// Optional. The models to use for translation. Map's key is target language
    /// code. Map's value is the model name. Value can be a built-in general model,
    /// or an AutoML Translation model.
    ///
    /// The value format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// If the map is empty or a specific model is
    /// not requested for a language pair, then default google model (nmt) is used.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub models: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Glossaries to be applied. It's keyed by target language code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub glossaries:
        std::collections::HashMap<std::string::String, crate::model::TranslateTextGlossaryConfig>,

    /// Optional. The file format conversion map that is applied to all input
    /// files. The map key is the original mime_type. The map value is the target
    /// mime_type of translated documents.
    ///
    /// Supported file format conversion includes:
    ///
    /// - `application/pdf` to
    ///   `application/vnd.openxmlformats-officedocument.wordprocessingml.document`
    ///
    /// If nothing specified, output files will be in the same format as the
    /// original file.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub format_conversions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This flag is to support user customized attribution.
    /// If not provided, the default is `Machine Translated by Google`.
    /// Customized attribution should follow rules in
    /// <https://cloud.google.com/translate/attribution#attribution_and_logos>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub customized_attribution: std::string::String,

    /// Optional. If true, use the text removal server to remove the shadow text on
    /// background image for native pdf translation.
    /// Shadow removal feature can only be enabled when
    /// is_translate_native_pdf_only: false && pdf_native_only: false
    pub enable_shadow_removal_native_pdf: bool,

    /// Optional. If true, enable auto rotation correction in DVS.
    pub enable_rotation_correction: bool,
}

impl BatchTranslateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchTranslateDocumentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::BatchTranslateDocumentRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::BatchTranslateDocumentRequest::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::BatchDocumentOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }

    /// Sets the value of [customized_attribution][crate::model::BatchTranslateDocumentRequest::customized_attribution].
    pub fn set_customized_attribution<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.customized_attribution = v.into();
        self
    }

    /// Sets the value of [enable_shadow_removal_native_pdf][crate::model::BatchTranslateDocumentRequest::enable_shadow_removal_native_pdf].
    pub fn set_enable_shadow_removal_native_pdf<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_shadow_removal_native_pdf = v.into();
        self
    }

    /// Sets the value of [enable_rotation_correction][crate::model::BatchTranslateDocumentRequest::enable_rotation_correction].
    pub fn set_enable_rotation_correction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_rotation_correction = v.into();
        self
    }

    /// Sets the value of [target_language_codes][crate::model::BatchTranslateDocumentRequest::target_language_codes].
    pub fn set_target_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_configs][crate::model::BatchTranslateDocumentRequest::input_configs].
    pub fn set_input_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BatchDocumentInputConfig>,
    {
        use std::iter::Iterator;
        self.input_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [models][crate::model::BatchTranslateDocumentRequest::models].
    pub fn set_models<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [glossaries][crate::model::BatchTranslateDocumentRequest::glossaries].
    pub fn set_glossaries<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        use std::iter::Iterator;
        self.glossaries = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [format_conversions][crate::model::BatchTranslateDocumentRequest::format_conversions].
    pub fn set_format_conversions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.format_conversions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchTranslateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateDocumentRequest"
    }
}

/// Input configuration for BatchTranslateDocument request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDocumentInputConfig {
    /// Specify the input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::batch_document_input_config::Source>,
}

impl BatchDocumentInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::batch_document_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::BatchDocumentInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::batch_document_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::BatchDocumentInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::batch_document_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchDocumentInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchDocumentInputConfig"
    }
}

/// Defines additional types related to BatchDocumentInputConfig
pub mod batch_document_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specify the input.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location for the source input.
        /// This can be a single file (for example,
        /// `gs://translation-test/input.docx`) or a wildcard (for example,
        /// `gs://translation-test/*`).
        ///
        /// File mime type is determined based on extension. Supported mime type
        /// includes:
        ///
        /// - `pdf`, application/pdf
        /// - `docx`,
        ///   application/vnd.openxmlformats-officedocument.wordprocessingml.document
        /// - `pptx`,
        ///   application/vnd.openxmlformats-officedocument.presentationml.presentation
        /// - `xlsx`,
        ///   application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
        ///
        /// The max file size to support for `.docx`, `.pptx` and `.xlsx` is 100MB.
        /// The max file size to support for `.pdf` is 1GB and the max page limit is
        /// 1000 pages.
        /// The max file size to support for all input documents is 1GB.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// Output configuration for BatchTranslateDocument request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchDocumentOutputConfig {
    /// The destination of output. The destination directory provided must exist
    /// and be empty.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::batch_document_output_config::Destination>,
}

impl BatchDocumentOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<
            std::option::Option<crate::model::batch_document_output_config::Destination>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::BatchDocumentOutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::batch_document_output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::BatchDocumentOutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::batch_document_output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchDocumentOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchDocumentOutputConfig"
    }
}

/// Defines additional types related to BatchDocumentOutputConfig
pub mod batch_document_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// The destination of output. The destination directory provided must exist
    /// and be empty.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage destination for output content.
        /// For every single input document (for example, gs://a/b/c.[extension]), we
        /// generate at most 2 * n output files. (n is the # of target_language_codes
        /// in the BatchTranslateDocumentRequest).
        ///
        /// While the input documents are being processed, we write/update an index
        /// file `index.csv` under `gcs_destination.output_uri_prefix` (for example,
        /// gs://translation_output/index.csv) The index file is generated/updated as
        /// new files are being translated. The format is:
        ///
        /// input_document,target_language_code,translation_output,error_output,
        /// glossary_translation_output,glossary_error_output
        ///
        /// `input_document` is one file we matched using gcs_source.input_uri.
        /// `target_language_code` is provided in the request.
        /// `translation_output` contains the translations. (details provided below)
        /// `error_output` contains the error message during processing of the file.
        /// Both translations_file and errors_file could be empty strings if we have
        /// no content to output.
        /// `glossary_translation_output` and `glossary_error_output` are the
        /// translated output/error when we apply glossaries. They could also be
        /// empty if we have no content to output.
        ///
        /// Once a row is present in index.csv, the input/output matching never
        /// changes. Callers should also expect all the content in input_file are
        /// processed and ready to be consumed (that is, no partial output file is
        /// written).
        ///
        /// Since index.csv will be keeping updated during the process, please make
        /// sure there is no custom retention policy applied on the output bucket
        /// that may avoid file updating.
        /// (<https://cloud.google.com/storage/docs/bucket-lock#retention-policy>)
        ///
        /// The naming format of translation output files follows (for target
        /// language code [trg]): `translation_output`:
        /// `gs://translation_output/a_b_c_[trg]_translation.[extension]`
        /// `glossary_translation_output`:
        /// `gs://translation_test/a_b_c_[trg]_glossary_translation.[extension]`. The
        /// output document will maintain the same file format as the input document.
        ///
        /// The naming format of error output files follows (for target language code
        /// [trg]): `error_output`: `gs://translation_test/a_b_c_[trg]_errors.txt`
        /// `glossary_error_output`:
        /// `gs://translation_test/a_b_c_[trg]_glossary_translation.txt`. The error
        /// output is a txt file containing error details.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by BatchTranslateDocument if at least one document is
/// translated successfully.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchTranslateDocumentResponse {
    /// Total number of pages to translate in all documents. Documents without
    /// clear page definition (such as XLSX) are not counted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_pages: i64,

    /// Number of successfully translated pages in all documents. Documents without
    /// clear page definition (such as XLSX) are not counted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub translated_pages: i64,

    /// Number of pages that failed to process in all documents. Documents without
    /// clear page definition (such as XLSX) are not counted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_pages: i64,

    /// Number of billable pages in documents with clear page definition (such as
    /// PDF, DOCX, PPTX)
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_billable_pages: i64,

    /// Total number of characters (Unicode codepoints) in all documents.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_characters: i64,

    /// Number of successfully translated characters (Unicode codepoints) in all
    /// documents.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub translated_characters: i64,

    /// Number of characters that have failed to process (Unicode codepoints) in
    /// all documents.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_characters: i64,

    /// Number of billable characters (Unicode codepoints) in documents without
    /// clear page definition, such as XLSX.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_billable_characters: i64,

    /// Time when the operation was submitted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl BatchTranslateDocumentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_pages][crate::model::BatchTranslateDocumentResponse::total_pages].
    pub fn set_total_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_pages = v.into();
        self
    }

    /// Sets the value of [translated_pages][crate::model::BatchTranslateDocumentResponse::translated_pages].
    pub fn set_translated_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_pages = v.into();
        self
    }

    /// Sets the value of [failed_pages][crate::model::BatchTranslateDocumentResponse::failed_pages].
    pub fn set_failed_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_pages = v.into();
        self
    }

    /// Sets the value of [total_billable_pages][crate::model::BatchTranslateDocumentResponse::total_billable_pages].
    pub fn set_total_billable_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_pages = v.into();
        self
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateDocumentResponse::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateDocumentResponse::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateDocumentResponse::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [total_billable_characters][crate::model::BatchTranslateDocumentResponse::total_billable_characters].
    pub fn set_total_billable_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateDocumentResponse::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BatchTranslateDocumentResponse::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for BatchTranslateDocumentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateDocumentResponse"
    }
}

/// State metadata for the batch translation operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchTranslateDocumentMetadata {
    /// The state of the operation.
    pub state: crate::model::batch_translate_document_metadata::State,

    /// Total number of pages to translate in all documents so far. Documents
    /// without clear page definition (such as XLSX) are not counted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_pages: i64,

    /// Number of successfully translated pages in all documents so far. Documents
    /// without clear page definition (such as XLSX) are not counted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub translated_pages: i64,

    /// Number of pages that failed to process in all documents so far. Documents
    /// without clear page definition (such as XLSX) are not counted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_pages: i64,

    /// Number of billable pages in documents with clear page definition (such as
    /// PDF, DOCX, PPTX) so far.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_billable_pages: i64,

    /// Total number of characters (Unicode codepoints) in all documents so far.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_characters: i64,

    /// Number of successfully translated characters (Unicode codepoints) in all
    /// documents so far.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub translated_characters: i64,

    /// Number of characters that have failed to process (Unicode codepoints) in
    /// all documents so far.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub failed_characters: i64,

    /// Number of billable characters (Unicode codepoints) in documents without
    /// clear page definition (such as XLSX) so far.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_billable_characters: i64,

    /// Time when the operation was submitted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,
}

impl BatchTranslateDocumentMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchTranslateDocumentMetadata::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::batch_translate_document_metadata::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [total_pages][crate::model::BatchTranslateDocumentMetadata::total_pages].
    pub fn set_total_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_pages = v.into();
        self
    }

    /// Sets the value of [translated_pages][crate::model::BatchTranslateDocumentMetadata::translated_pages].
    pub fn set_translated_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_pages = v.into();
        self
    }

    /// Sets the value of [failed_pages][crate::model::BatchTranslateDocumentMetadata::failed_pages].
    pub fn set_failed_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_pages = v.into();
        self
    }

    /// Sets the value of [total_billable_pages][crate::model::BatchTranslateDocumentMetadata::total_billable_pages].
    pub fn set_total_billable_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_pages = v.into();
        self
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateDocumentMetadata::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateDocumentMetadata::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateDocumentMetadata::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [total_billable_characters][crate::model::BatchTranslateDocumentMetadata::total_billable_characters].
    pub fn set_total_billable_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateDocumentMetadata::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }
}

impl wkt::message::Message for BatchTranslateDocumentMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateDocumentMetadata"
    }
}

/// Defines additional types related to BatchTranslateDocumentMetadata
pub mod batch_translate_document_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of the job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Invalid.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Request is being processed.
        pub const RUNNING: State = State::new(1);

        /// The batch is processed, and at least one item was successfully processed.
        pub const SUCCEEDED: State = State::new(2);

        /// The batch is done and no item was successfully processed.
        pub const FAILED: State = State::new(3);

        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        pub const CANCELLING: State = State::new(4);

        /// The batch is done after the user has called the
        /// longrunning.Operations.CancelOperation. Any records processed before the
        /// cancel command are output as specified in the request.
        pub const CANCELLED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RUNNING"),
                2 => std::borrow::Cow::Borrowed("SUCCEEDED"),
                3 => std::borrow::Cow::Borrowed("FAILED"),
                4 => std::borrow::Cow::Borrowed("CANCELLING"),
                5 => std::borrow::Cow::Borrowed("CANCELLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "RUNNING" => std::option::Option::Some(Self::RUNNING),
                "SUCCEEDED" => std::option::Option::Some(Self::SUCCEEDED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "CANCELLING" => std::option::Option::Some(Self::CANCELLING),
                "CANCELLED" => std::option::Option::Some(Self::CANCELLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configures which glossary is used for a specific target language and defines
/// options for applying that glossary.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslateTextGlossaryConfig {
    /// Required. The `glossary` to be applied for this translation.
    ///
    /// The format depends on the glossary:
    ///
    /// - User-provided custom glossary:
    ///   `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub glossary: std::string::String,

    /// Optional. Indicates match is case insensitive. The default value is `false`
    /// if missing.
    pub ignore_case: bool,

    /// Optional. If set to true, the glossary will be used for contextual
    /// translation.
    pub contextual_translation_enabled: bool,
}

impl TranslateTextGlossaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary][crate::model::TranslateTextGlossaryConfig::glossary].
    pub fn set_glossary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.glossary = v.into();
        self
    }

    /// Sets the value of [ignore_case][crate::model::TranslateTextGlossaryConfig::ignore_case].
    pub fn set_ignore_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_case = v.into();
        self
    }

    /// Sets the value of [contextual_translation_enabled][crate::model::TranslateTextGlossaryConfig::contextual_translation_enabled].
    pub fn set_contextual_translation_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.contextual_translation_enabled = v.into();
        self
    }
}

impl wkt::message::Message for TranslateTextGlossaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateTextGlossaryConfig"
    }
}

/// Possible states of long running operations.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct OperationState(i32);

impl OperationState {
    /// Invalid.
    pub const OPERATION_STATE_UNSPECIFIED: OperationState = OperationState::new(0);

    /// Request is being processed.
    pub const OPERATION_STATE_RUNNING: OperationState = OperationState::new(1);

    /// The operation was successful.
    pub const OPERATION_STATE_SUCCEEDED: OperationState = OperationState::new(2);

    /// Failed to process operation.
    pub const OPERATION_STATE_FAILED: OperationState = OperationState::new(3);

    /// Request is in the process of being canceled after caller invoked
    /// longrunning.Operations.CancelOperation on the request id.
    pub const OPERATION_STATE_CANCELLING: OperationState = OperationState::new(4);

    /// The operation request was successfully canceled.
    pub const OPERATION_STATE_CANCELLED: OperationState = OperationState::new(5);

    /// Creates a new OperationState instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("OPERATION_STATE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("OPERATION_STATE_RUNNING"),
            2 => std::borrow::Cow::Borrowed("OPERATION_STATE_SUCCEEDED"),
            3 => std::borrow::Cow::Borrowed("OPERATION_STATE_FAILED"),
            4 => std::borrow::Cow::Borrowed("OPERATION_STATE_CANCELLING"),
            5 => std::borrow::Cow::Borrowed("OPERATION_STATE_CANCELLED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "OPERATION_STATE_UNSPECIFIED" => {
                std::option::Option::Some(Self::OPERATION_STATE_UNSPECIFIED)
            }
            "OPERATION_STATE_RUNNING" => std::option::Option::Some(Self::OPERATION_STATE_RUNNING),
            "OPERATION_STATE_SUCCEEDED" => {
                std::option::Option::Some(Self::OPERATION_STATE_SUCCEEDED)
            }
            "OPERATION_STATE_FAILED" => std::option::Option::Some(Self::OPERATION_STATE_FAILED),
            "OPERATION_STATE_CANCELLING" => {
                std::option::Option::Some(Self::OPERATION_STATE_CANCELLING)
            }
            "OPERATION_STATE_CANCELLED" => {
                std::option::Option::Some(Self::OPERATION_STATE_CANCELLED)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for OperationState {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for OperationState {
    fn default() -> Self {
        Self::new(0)
    }
}
